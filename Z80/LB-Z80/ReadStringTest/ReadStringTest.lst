0001   0000             ; ReadStringTest.asm
0002   0000             ; Read in a string
0003   0000             
0004   0000             CR          .EQU     0DH
0005   0000             LF          .EQU     0AH
0006   0000             
0007   0000             ; Define the ACIA control and data register addresses
0008   0000             ACIA_CTRL   .EQU 80H  ; Control register address
0009   0000             ACIA_DATA   .EQU 81H  ; Data register address
0010   0000             
0011   0000             ; Define the initialization values
0012   0000             ACIA_RESET  .EQU 03H	; Master reset
0013   0000             ACIA_INIT   .EQU 15H	; Disable receive interrupt
0014   0000             						; Set RTS low and transmit interrupt disabled
0015   0000             						; 8 data bits
0016   0000             						; No parity
0017   0000             						; 1 stop bit;
0018   0000             						; /1 clock (115200 baud with 1.8432 MHz clock)
0019   0000             
0020   0000             ; Define the reset vector address
0021   0000             RESET_VECTOR .EQU 0000H
0022   0000             
0023   0000             ; Start of the program
0024   0000             	.ORG RESET_VECTOR
0025   0000 C3 03 00    	JP START          ; Jump to the start of the program
0026   0003             
0027   0003             START:
0028   0003 F3          	DI                	; Disable interrupts
0029   0004             
0030   0004 31 FF FF    	LD SP, 0FFFFH        ; Load the Stack Pointer with the top address of RAM (64K)
0031   0007             	
0032   0007 3E 03       	LD A, ACIA_RESET	; Reset ACIA command
0033   0009 D3 80       	OUT (ACIA_CTRL), A	; Write to the control register
0034   000B             
0035   000B 3E 15       	LD A, ACIA_INIT		; Load the initialization value into register A
0036   000D D3 80       	OUT (ACIA_CTRL), A	; Write to the control register
0037   000F             
0038   000F 21 9A 00    	LD HL, MESSAGE		; Load the address of the message into HL
0039   0012 CD 7C 00    	CALL PRINT			; Call the print subroutine
0040   0015             	
0041   0015             INTERP_LP:
0042   0015 11 00 80        LD DE, IN_BUFF      ; Load the address of the buffer into DE
0043   0018 CD 67 00        CALL READ_STRING    ; Call the routine to read the string	
0044   001B 21 F3 00    	LD HL, CRLF_MSG		; Pass the pointer to the CRLF message in HL register
0045   001E CD 7C 00    	CALL PRINT			; Call the print subroutine
0046   0021 11 00 80        LD DE, IN_BUFF      ; Load the address of the buffer into DE
0047   0024 1A          	LD A, (DE)
0048   0025 FE 44       	CP 'D'				; Dump Command Routine
0049   0027 28 26       	JR Z, DUMP_RTN
0050   0029 FE 4C       	CP 'L'				; LED Control Routine
0051   002B 28 18       	JR Z, LED_RTN
0052   002D FE 58       	CP 'X'				; X Command
0053   002F 28 26       	JR Z, X_RTN
0054   0031 FE 3F       	CP '?'				; Help Command
0055   0033 28 2A       	JR Z, HLP_RTN
0056   0035 21 BC 00    	LD HL, UNK_MSG		; Load the address of the message into HL
0057   0038 CD 7C 00    	CALL PRINT			; Call the print subroutine
0058   003B 18 D8       	JR	INTERP_LP
0059   003D             		
0060   003D             ; Loop forever to read and write characters
0061   003D             MAIN_LOOP:
0062   003D CD 91 00    	CALL READ_CHAR		; Read a character
0063   0040 CD 86 00    	CALL WRITE_CHAR		; Write the character that was read
0064   0043 18 D0       	JR INTERP_LP		; Repeat the loop
0065   0045             
0066   0045             LED_RTN:
0067   0045 11 01 80        LD DE, IN_BUFF+1    ; Load the address of the buffer into DE
0068   0048 1A          	LD A, (DE)			; GET THE 2ND CHAR IN THE INPUT STRING
0069   0049 21 00 00    	LD HL, 00000H		; STORE THE CHAR TO THE LED
0070   004C 77          	LD (HL), A
0071   004D 18 C6       	JR	INTERP_LP
0072   004F             
0073   004F             
0074   004F             DUMP_RTN:
0075   004F 21 A6 00    	LD HL, DUMP_MSG		; Load the address of the message into HL
0076   0052 CD 7C 00    	CALL PRINT			; Call the print subroutine
0077   0055 18 BE       	JR	INTERP_LP
0078   0057             
0079   0057             X_RTN:
0080   0057 21 B1 00    	LD HL, XRTN_MSG		; Load the address of the message into HL
0081   005A CD 7C 00    	CALL PRINT			; Call the print subroutine
0082   005D 18 B6       	JR	INTERP_LP
0083   005F             
0084   005F             HLP_RTN:
0085   005F 21 CA 00    	LD HL, HELP_MSG		; Load the address of the message into HL
0086   0062 CD 7C 00    	CALL PRINT			; Call the print subroutine
0087   0065 18 AE       	JR	INTERP_LP
0088   0067             
0089   0067             ; Routine to read a string into buffer
0090   0067             READ_STRING:
0091   0067 06 00           LD B, 00H          	; Initialize B as the string length counter
0092   0069             READ_CHARLP:
0093   0069 CD 91 00    	CALL	READ_CHAR
0094   006C CD 86 00    	CALL	WRITE_CHAR
0095   006F FE 0D           CP CR             	; Compare with carriage return (Enter key)
0096   0071 28 05           JR Z, END_READ      ; If Enter is pressed, end reading
0097   0073 12              LD (DE), A          ; Store the character in the buffer
0098   0074 13              INC DE              ; Increment the buffer pointer
0099   0075 04              INC B               ; Increment the counter
0100   0076 18 F1           JR READ_CHARLP      ; Repeat until Enter is pressed
0101   0078             
0102   0078             END_READ:
0103   0078 3E 00           LD	A, 00H			; Null-terminate the string
0104   007A 12          	LD (DE), A
0105   007B C9              RET                 ; Return from subroutine
0106   007C             
0107   007C             ; Subroutine to print a string
0108   007C             PRINT:
0109   007C 7E          	LD A, (HL)			; Load the character pointed to by HL into A
0110   007D FE 00       	CP 0          		; Compare A with 0 (end of string)
0111   007F C8          	RET Z         		; Return if zero (end of string)
0112   0080 CD 86 00    	CALL WRITE_CHAR		; Write out the character
0113   0083 23          	INC HL				; Increment HL to point to the next character
0114   0084 18 F6       	JR PRINT			; Repeat
0115   0086             
0116   0086             ; Routine to write a character to the ACIA
0117   0086             WRITE_CHAR:
0118   0086 F5          	PUSH AF				; Preserve the A register
0119   0087             WAIT_TX_READY:
0120   0087 DB 80       	IN A, (ACIA_CTRL)	; Read the status register
0121   0089 CB 4F       	BIT 1, A			; Check if the transmitter is ready
0122   008B 28 FA       	JR Z, WAIT_TX_READY	; Wait until the transmitter is ready
0123   008D F1          	POP AF				; Restore the A register
0124   008E D3 81       	OUT (ACIA_DATA), A	; Write the character in register A to the data register
0125   0090 C9          	RET
0126   0091             
0127   0091             ; Routine to read a character from the ACIA
0128   0091             READ_CHAR:
0129   0091 DB 80       	IN A, (ACIA_CTRL) 	; Read the status register
0130   0093 CB 47       	BIT 0, A			; Check if data is available
0131   0095 28 FA       	JR Z, READ_CHAR		; Wait until data is available
0132   0097 DB 81       	IN A, (ACIA_DATA)	; Read the character from the data register
0133   0099 C9          	RET
0134   009A             
0135   009A             ; ROM data section
0136   009A             MESSAGE:
0137   009A 4C 42 2D 5A     .BYTE	"LB-Z80-01",CR,LF,0
0137   009E 38 30 2D 30 
0137   00A2 31 0D 0A 00 
0138   00A6             DUMP_MSG:
0139   00A6 44 55 4D 50     .BYTE	"DUMP CMD",CR,LF,0
0139   00AA 20 43 4D 44 
0139   00AE 0D 0A 00 
0140   00B1             XRTN_MSG:
0141   00B1 58 52 54 4E     .BYTE	"XRTN CMD",CR,LF,0
0141   00B5 20 43 4D 44 
0141   00B9 0D 0A 00 
0142   00BC             UNK_MSG:
0143   00BC 55 4E 4B 4E     .BYTE	"UNKNOWN CMD",CR,LF,0
0143   00C0 4F 57 4E 20 
0143   00C4 43 4D 44 0D 
0143   00C8 0A 00 
0144   00CA             HELP_MSG:
0145   00CA 44 2D 44 75     .BYTE	"D-Dump, X-X_routine, L#-SetLED, ?-Help",CR,LF,0
0145   00CE 6D 70 2C 20 
0145   00D2 58 2D 58 5F 
0145   00D6 72 6F 75 74 
0145   00DA 69 6E 65 2C 
0145   00DE 20 4C 23 2D 
0145   00E2 53 65 74 4C 
0145   00E6 45 44 2C 20 
0145   00EA 3F 2D 48 65 
0145   00EE 6C 70 0D 0A 
0145   00F2 00 
0146   00F3             CRLF_MSG:
0147   00F3 0D 0A 00        .BYTE	CR,LF,0
0148   00F6             
0149   8000             	.ORG 8000H		; 8KB
0150   8000             ; Data section
0151   8000             IN_BUFF: .DS 256          ; Allocate 256 bytes for the buffer
0152   8100             
0153   8100             ; End of the program
0154   8100                         .END START
tasm: Number of errors = 0
