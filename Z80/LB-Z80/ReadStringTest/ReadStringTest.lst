0001   0000             ; ReadStringTest.asm
0002   0000             ; Minimal monitor program used for hardware testing
0003   0000             
0004   0000             ; Define the ACIA control and data register addresses
0005   0000             ACIA_CTRL   .EQU 80H  ; Control register address
0006   0000             ACIA_DATA   .EQU 81H  ; Data register address
0007   0000             
0008   0000             ; Define the initialization values
0009   0000             ACIA_RESET  .EQU 03H	; Master reset
0010   0000             ACIA_INIT   .EQU 15H	; Disable receive interrupt
0011   0000             						; Set RTS low and transmit interrupt disabled
0012   0000             						; 8 data bits
0013   0000             						; No parity
0014   0000             						; 1 stop bit;
0015   0000             						; /1 clock (115200 baud with 1.8432 MHz clock)
0016   0000             
0017   0000             ; Define the reset vector address
0018   0000             RESET_VECTOR .EQU 0000H
0019   0000             
0020   0000             CR          .EQU     0DH
0021   0000             LF          .EQU     0AH
0022   0000             
0023   0000             ; RESET VECTOR GOES TO JUMP TO START
0024   0000             	.ORG RESET_VECTOR
0025   0000 C3 03 00    	JP START          ; Jump to the start of the program
0026   0003             
0027   0003             ; START OF THE CODE
0028   0003             START:
0029   0003 F3          	DI                	; Disable interrupts
0030   0004             
0031   0004 31 FF FF    	LD SP, 0FFFFH        ; Load the Stack Pointer with the top address of RAM (64K)
0032   0007             	
0033   0007 3E 03       	LD A, ACIA_RESET	; Reset ACIA command
0034   0009 D3 80       	OUT (ACIA_CTRL), A	; Write to the control register
0035   000B             
0036   000B 3E 15       	LD A, ACIA_INIT		; Load the initialization value into register A
0037   000D D3 80       	OUT (ACIA_CTRL), A	; Write to the control register
0038   000F             
0039   000F             ; Print the banner/prompt
0040   000F 21 F6 00    	LD HL, MESSAGE		; Load the address of the message into HL
0041   0012 CD D8 00    	CALL PRINT			; Call the print subroutine
0042   0015             
0043   0015             ; Interpreter loop
0044   0015             INTERP_LP:
0045   0015 11 00 80        LD DE, IN_BUFF      ; Load the address of the buffer into DE
0046   0018 CD C3 00        CALL READ_STRING    ; Call the routine to read the string	
0047   001B 21 4F 01    	LD HL, CRLF_MSG		; Pass the pointer to the CRLF message in HL register
0048   001E CD D8 00    	CALL PRINT			; Call the print subroutine
0049   0021 11 00 80        LD DE, IN_BUFF      ; Load the address of the buffer into DE
0050   0024 1A          	LD A, (DE)
0051   0025 FE 44       	CP 'D'				; Dump Command Routine
0052   0027 28 1E       	JR Z, DUMP_RTN
0053   0029 FE 4C       	CP 'L'				; LED Control Routine
0054   002B 28 10       	JR Z, LED_RTN
0055   002D FE 58       	CP 'X'				; X Command
0056   002F 28 21       	JR Z, X_RTN
0057   0031 FE 3F       	CP '?'				; Help Command
0058   0033 28 3A       	JR Z, HLP_RTN
0059   0035 21 18 01    	LD HL, UNK_MSG		; Load the address of the message into HL
0060   0038 CD D8 00    	CALL PRINT			; Call the print subroutine
0061   003B 18 D8       	JR	INTERP_LP
0062   003D             	
0063   003D             ; Turn LED On/Off Command
0064   003D             ;	L0 - Turn off LED
0065   003D             ;	L1 - Turn on LED
0066   003D             LED_RTN:
0067   003D 11 01 80        LD DE, IN_BUFF+1    ; Load the address of the buffer into DE
0068   0040 1A          	LD A, (DE)			; GET THE 2ND CHAR IN THE INPUT STRING
0069   0041 21 00 00    	LD HL, 00000H		; STORE THE CHAR TO THE LED
0070   0044 77          	LD (HL), A
0071   0045 18 CE       	JR	INTERP_LP
0072   0047             
0073   0047             ; Dump memory block
0074   0047             ; D PP - Dump page PP to the serial port
0075   0047             DUMP_RTN:
0076   0047 21 02 01    	LD HL, DUMP_MSG		; Load the address of the message into HL
0077   004A CD D8 00    	CALL PRINT			; Call the print subroutine
0078   004D CD 77 00    	CALL GET_DUMP_ADDR
0079   0050 18 C3       	JR	INTERP_LP
0080   0052             
0081   0052             ; X Example function
0082   0052             X_RTN:
0083   0052 21 0D 01    	LD HL, XRTN_MSG		; Load the address of the message into HL
0084   0055 CD D8 00    	CALL PRINT			; Call the print subroutine
0085   0058 3E 5A       	LD A, 05AH
0086   005A CD A1 00    	CALL PRINT_HEX
0087   005D 3E 20       	LD A, ' '
0088   005F CD E2 00    	CALL WRITE_CHAR
0089   0062 3E A5       	LD A, 0A5H
0090   0064 CD A1 00    	CALL PRINT_HEX
0091   0067 21 4F 01    	LD HL, CRLF_MSG		; Load the address of the message into HL
0092   006A CD D8 00    	CALL PRINT			; Call the print subroutine
0093   006D 18 A6       	JR	INTERP_LP
0094   006F             
0095   006F             ; Print the commands
0096   006F             HLP_RTN:
0097   006F 21 26 01    	LD HL, HELP_MSG		; Load the address of the message into HL
0098   0072 CD D8 00    	CALL PRINT			; Call the print subroutine
0099   0075 18 9E       	JR	INTERP_LP
0100   0077             
0101   0077             ; Pull the two ascii hex digits from the input buffer
0102   0077             GET_DUMP_ADDR:
0103   0077 21 02 80    	LD	HL, IN_BUFF+2
0104   007A 7E          	LD A, (HL)
0105   007B CD 88 00    	CALL CONVERT_CHAR
0106   007E 47          	LD B, A
0107   007F 21 03 80    	LD	HL, IN_BUFF+3
0108   0082 7E          	LD A, (HL)
0109   0083 CD 88 00    	CALL CONVERT_CHAR
0110   0086 4F          	LD C, A
0111   0087 C9          	RET
0112   0088             
0113   0088             ; CONVERT_CHAR - Convert an ASCII character (0-9,A-F) into a nibble value
0114   0088             CONVERT_CHAR:
0115   0088 FE 30           CP '0'               ; Compare with '0'
0116   008A 38 12           JR C, INVALID_CHAR   ; Jump if less than '0'
0117   008C FE 3A           CP '9' + 1           ; Compare with '9' + 1
0118   008E 30 03           JR NC, CHECK_A_F     ; Jump if not less than '9' + 1
0119   0090 D6 30           SUB '0'              ; Convert '0'-'9' to 0-9
0120   0092 C9              RET
0121   0093             CHECK_A_F:
0122   0093 FE 41           CP 'A'               ; Compare with 'A'
0123   0095 38 07           JR C, INVALID_CHAR   ; Jump if less than 'A'
0124   0097 FE 47           CP 'F' + 1           ; Compare with 'F' + 1
0125   0099 30 03           JR NC, INVALID_CHAR  ; Jump if not less than 'F' + 1
0126   009B D6 37           SUB 'A' - 10         ; Convert 'A'-'F' to 10-15
0127   009D C9              RET
0128   009E             INVALID_CHAR:
0129   009E 3E 00           LD A, 0              ; Invalid character, set A to 0
0130   00A0 C9              RET
0131   00A1             
0132   00A1             ; Print a byte as two hexadecimal ASCII digits
0133   00A1             PRINT_HEX:
0134   00A1 57              LD D, A             ; Save the byte in D
0135   00A2 CB 3F           SRL A               ; Shift right 4 times to get the high nibble
0136   00A4 CB 3F           SRL A
0137   00A6 CB 3F           SRL A
0138   00A8 CB 3F           SRL A
0139   00AA CD BA 00        CALL NIBBLE_TO_HEX  ; Convert high nibble to ASCII
0140   00AD CD E2 00        CALL WRITE_CHAR     ; Print the high nibble
0141   00B0             
0142   00B0 7A              LD A, D             ; Restore the byte
0143   00B1 E6 0F           AND 00FH            ; Mask out the high nibble to get the low nibble
0144   00B3 CD BA 00        CALL NIBBLE_TO_HEX  ; Convert low nibble to ASCII
0145   00B6 CD E2 00        CALL WRITE_CHAR     ; Print the low nibble
0146   00B9             
0147   00B9 C9              RET
0148   00BA             
0149   00BA             NIBBLE_TO_HEX:
0150   00BA C6 30           ADD A, '0'          ; Convert 0-9 to ASCII
0151   00BC FE 3A           CP '9' + 1          ; If greater than '9'
0152   00BE 38 02           JR C, DONE          ; If less than or equal to '9', done
0153   00C0 C6 07           ADD A, 7            ; Convert A-F to ASCII
0154   00C2             DONE:
0155   00C2 C9              RET
0156   00C3             
0157   00C3             ; Routine to read a string into buffer
0158   00C3             READ_STRING:
0159   00C3 06 00           LD B, 00H          	; Initialize B as the string length counter
0160   00C5             READ_CHARLP:
0161   00C5 CD ED 00    	CALL	READ_CHAR
0162   00C8 CD E2 00    	CALL	WRITE_CHAR
0163   00CB FE 0D           CP CR             	; Compare with carriage return (Enter key)
0164   00CD 28 05           JR Z, END_READ      ; If Enter is pressed, end reading
0165   00CF 12              LD (DE), A          ; Store the character in the buffer
0166   00D0 13              INC DE              ; Increment the buffer pointer
0167   00D1 04              INC B               ; Increment the counter
0168   00D2 18 F1           JR READ_CHARLP      ; Repeat until Enter is pressed
0169   00D4             
0170   00D4             END_READ:
0171   00D4 3E 00           LD	A, 00H			; Null-terminate the string
0172   00D6 12          	LD (DE), A
0173   00D7 C9              RET                 ; Return from subroutine
0174   00D8             
0175   00D8             ; Subroutine to print a string
0176   00D8             PRINT:
0177   00D8 7E          	LD A, (HL)			; Load the character pointed to by HL into A
0178   00D9 FE 00       	CP 0          		; Compare A with 0 (end of string)
0179   00DB C8          	RET Z         		; Return if zero (end of string)
0180   00DC CD E2 00    	CALL WRITE_CHAR		; Write out the character
0181   00DF 23          	INC HL				; Increment HL to point to the next character
0182   00E0 18 F6       	JR PRINT			; Repeat
0183   00E2             
0184   00E2             ; Routine to write a character to the ACIA
0185   00E2             WRITE_CHAR:
0186   00E2 F5          	PUSH AF				; Preserve the A register
0187   00E3             WAIT_TX_READY:
0188   00E3 DB 80       	IN A, (ACIA_CTRL)	; Read the status register
0189   00E5 CB 4F       	BIT 1, A			; Check if the transmitter is ready
0190   00E7 28 FA       	JR Z, WAIT_TX_READY	; Wait until the transmitter is ready
0191   00E9 F1          	POP AF				; Restore the A register
0192   00EA D3 81       	OUT (ACIA_DATA), A	; Write the character in register A to the data register
0193   00EC C9          	RET
0194   00ED             
0195   00ED             ; Routine to read a character from the ACIA
0196   00ED             READ_CHAR:
0197   00ED DB 80       	IN A, (ACIA_CTRL) 	; Read the status register
0198   00EF CB 47       	BIT 0, A			; Check if data is available
0199   00F1 28 FA       	JR Z, READ_CHAR		; Wait until data is available
0200   00F3 DB 81       	IN A, (ACIA_DATA)	; Read the character from the data register
0201   00F5 C9          	RET
0202   00F6             
0203   00F6             ; ROM data section
0204   00F6             MESSAGE:
0205   00F6 4C 42 2D 5A     .BYTE	"LB-Z80-01",CR,LF,0
0205   00FA 38 30 2D 30 
0205   00FE 31 0D 0A 00 
0206   0102             DUMP_MSG:
0207   0102 44 55 4D 50     .BYTE	"DUMP CMD",CR,LF,0
0207   0106 20 43 4D 44 
0207   010A 0D 0A 00 
0208   010D             XRTN_MSG:
0209   010D 58 52 54 4E     .BYTE	"XRTN CMD",CR,LF,0
0209   0111 20 43 4D 44 
0209   0115 0D 0A 00 
0210   0118             UNK_MSG:
0211   0118 55 4E 4B 4E     .BYTE	"UNKNOWN CMD",CR,LF,0
0211   011C 4F 57 4E 20 
0211   0120 43 4D 44 0D 
0211   0124 0A 00 
0212   0126             HELP_MSG:
0213   0126 44 2D 44 75     .BYTE	"D-Dump, X-X_routine, L#-SetLED, ?-Help",CR,LF,0
0213   012A 6D 70 2C 20 
0213   012E 58 2D 58 5F 
0213   0132 72 6F 75 74 
0213   0136 69 6E 65 2C 
0213   013A 20 4C 23 2D 
0213   013E 53 65 74 4C 
0213   0142 45 44 2C 20 
0213   0146 3F 2D 48 65 
0213   014A 6C 70 0D 0A 
0213   014E 00 
0214   014F             CRLF_MSG:
0215   014F 0D 0A 00        .BYTE	CR,LF,0
0216   0152             
0217   8000             	.ORG 8000H		; 8KB
0218   8000             ; Data section
0219   8000             IN_BUFF: .DS 256          ; Allocate 256 bytes for the buffer
0220   8100             
0221   8100             ; End of the program
0222   8100                         .END START
tasm: Number of errors = 0
