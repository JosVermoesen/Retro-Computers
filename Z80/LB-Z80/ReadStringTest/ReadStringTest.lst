0001   0000             ; ReadStringTest.asm
0002   0000             ; Read in a string
0003   0000             
0004   0000             CR          .EQU     0DH
0005   0000             LF          .EQU     0AH
0006   0000             
0007   0000             ; Define the ACIA control and data register addresses
0008   0000             ACIA_CTRL   .EQU 80H  ; Control register address
0009   0000             ACIA_DATA   .EQU 81H  ; Data register address
0010   0000             
0011   0000             ; Define the initialization values
0012   0000             ACIA_RESET  .EQU 03H	; Master reset
0013   0000             ACIA_INIT   .EQU 15H	; Disable receive interrupt
0014   0000             						; Set RTS low and transmit interrupt disabled
0015   0000             						; 8 data bits
0016   0000             						; No parity
0017   0000             						; 1 stop bit;
0018   0000             						; /1 clock (115200 baud with 1.8432 MHz clock)
0019   0000             
0020   0000             ; Define the reset vector address
0021   0000             RESET_VECTOR .EQU 0000H
0022   0000             
0023   0000             ; Start of the program
0024   0000             	.ORG RESET_VECTOR
0025   0000 C3 03 00    	JP START          ; Jump to the start of the program
0026   0003             
0027   0003             START:
0028   0003 F3          	DI                	; Disable interrupts
0029   0004             
0030   0004 31 FF FF    	LD SP, 0FFFFH        ; Load the Stack Pointer with the top address of RAM (64K)
0031   0007             	
0032   0007 3E 03       	LD A, ACIA_RESET	; Reset ACIA command
0033   0009 D3 80       	OUT (ACIA_CTRL), A	; Write to the control register
0034   000B             
0035   000B 3E 15       	LD A, ACIA_INIT		; Load the initialization value into register A
0036   000D D3 80       	OUT (ACIA_CTRL), A	; Write to the control register
0037   000F             
0038   000F 21 8C 00    	LD HL, MESSAGE		; Load the address of the message into HL
0039   0012 CD 6E 00    	CALL PRINT			; Call the print subroutine
0040   0015             	
0041   0015             INTERP_LP:
0042   0015 11 00 80        LD DE, IN_BUFF      ; Load the address of the buffer into DE
0043   0018 CD 59 00        CALL READ_STRING    ; Call the routine to read the string	
0044   001B 21 DA 00    	LD HL, CRLF_MSG		; Pass the pointer to the CRLF message in HL register
0045   001E CD 6E 00    	CALL PRINT			; Call the print subroutine
0046   0021 11 00 80        LD DE, IN_BUFF      ; Load the address of the buffer into DE
0047   0024 1A          	LD A, (DE)
0048   0025 FE 44       	CP 'D'				; Dump Command Routine
0049   0027 28 18       	JR Z, DUMP_RTN
0050   0029 FE 58       	CP 'X'				; X Command
0051   002B 28 1C       	JR Z, X_RTN
0052   002D FE 3F       	CP '?'				; Help Command
0053   002F 28 20       	JR Z, HLP_RTN
0054   0031 21 AE 00    	LD HL, UNK_MSG		; Load the address of the message into HL
0055   0034 CD 6E 00    	CALL PRINT			; Call the print subroutine
0056   0037 18 DC       	JR	INTERP_LP
0057   0039             		
0058   0039             ; Loop forever to read and write characters
0059   0039             MAIN_LOOP:
0060   0039 CD 83 00    	CALL READ_CHAR		; Read a character
0061   003C CD 78 00    	CALL WRITE_CHAR		; Write the character that was read
0062   003F 18 D4       	JR INTERP_LP		; Repeat the loop
0063   0041             
0064   0041             DUMP_RTN:
0065   0041 21 98 00    	LD HL, DUMP_MSG		; Load the address of the message into HL
0066   0044 CD 6E 00    	CALL PRINT			; Call the print subroutine
0067   0047 18 CC       	JR	INTERP_LP
0068   0049             
0069   0049             X_RTN:
0070   0049 21 A3 00    	LD HL, XRTN_MSG		; Load the address of the message into HL
0071   004C CD 6E 00    	CALL PRINT			; Call the print subroutine
0072   004F 18 E8       	JR	MAIN_LOOP
0073   0051             
0074   0051             HLP_RTN:
0075   0051 21 BC 00    	LD HL, HELP_MSG		; Load the address of the message into HL
0076   0054 CD 6E 00    	CALL PRINT			; Call the print subroutine
0077   0057 18 E0       	JR	MAIN_LOOP
0078   0059             
0079   0059             ; Routine to read a string into buffer
0080   0059             READ_STRING:
0081   0059 06 00           LD B, 00H          	; Initialize B as the string length counter
0082   005B             READ_CHARLP:
0083   005B CD 83 00    	CALL	READ_CHAR
0084   005E CD 78 00    	CALL	WRITE_CHAR
0085   0061 FE 0D           CP CR             	; Compare with carriage return (Enter key)
0086   0063 28 05           JR Z, END_READ      ; If Enter is pressed, end reading
0087   0065 12              LD (DE), A          ; Store the character in the buffer
0088   0066 13              INC DE              ; Increment the buffer pointer
0089   0067 04              INC B               ; Increment the counter
0090   0068 18 F1           JR READ_CHARLP      ; Repeat until Enter is pressed
0091   006A             
0092   006A             END_READ:
0093   006A 3E 00           LD	A, 00H			; Null-terminate the string
0094   006C 12          	LD (DE), A
0095   006D C9              RET                 ; Return from subroutine
0096   006E             
0097   006E             ; Subroutine to print a string
0098   006E             PRINT:
0099   006E 7E          	LD A, (HL)			; Load the character pointed to by HL into A
0100   006F FE 00       	CP 0          		; Compare A with 0 (end of string)
0101   0071 C8          	RET Z         		; Return if zero (end of string)
0102   0072 CD 78 00    	CALL WRITE_CHAR		; Write out the character
0103   0075 23          	INC HL				; Increment HL to point to the next character
0104   0076 18 F6       	JR PRINT			; Repeat
0105   0078             
0106   0078             ; Routine to write a character to the ACIA
0107   0078             WRITE_CHAR:
0108   0078 F5          	PUSH AF				; Preserve the A register
0109   0079             WAIT_TX_READY:
0110   0079 DB 80       	IN A, (ACIA_CTRL)	; Read the status register
0111   007B CB 4F       	BIT 1, A			; Check if the transmitter is ready
0112   007D 28 FA       	JR Z, WAIT_TX_READY	; Wait until the transmitter is ready
0113   007F F1          	POP AF				; Restore the A register
0114   0080 D3 81       	OUT (ACIA_DATA), A	; Write the character in register A to the data register
0115   0082 C9          	RET
0116   0083             
0117   0083             ; Routine to read a character from the ACIA
0118   0083             READ_CHAR:
0119   0083 DB 80       	IN A, (ACIA_CTRL) 	; Read the status register
0120   0085 CB 47       	BIT 0, A			; Check if data is available
0121   0087 28 FA       	JR Z, READ_CHAR		; Wait until data is available
0122   0089 DB 81       	IN A, (ACIA_DATA)	; Read the character from the data register
0123   008B C9          	RET
0124   008C             
0125   008C             ; ROM data section
0126   008C             MESSAGE:
0127   008C 4C 42 2D 5A     .BYTE	"LB-Z80-01",CR,LF,0
0127   0090 38 30 2D 30 
0127   0094 31 0D 0A 00 
0128   0098             DUMP_MSG:
0129   0098 44 55 4D 50     .BYTE	"DUMP CMD",CR,LF,0
0129   009C 20 43 4D 44 
0129   00A0 0D 0A 00 
0130   00A3             XRTN_MSG:
0131   00A3 58 52 54 4E     .BYTE	"XRTN CMD",CR,LF,0
0131   00A7 20 43 4D 44 
0131   00AB 0D 0A 00 
0132   00AE             UNK_MSG:
0133   00AE 55 4E 4B 4E     .BYTE	"UNKNOWN CMD",CR,LF,0
0133   00B2 4F 57 4E 20 
0133   00B6 43 4D 44 0D 
0133   00BA 0A 00 
0134   00BC             HELP_MSG:
0135   00BC 44 2D 44 75     .BYTE	"D-Dump, X-X_routine, ?-Help",CR,LF,0
0135   00C0 6D 70 2C 20 
0135   00C4 58 2D 58 5F 
0135   00C8 72 6F 75 74 
0135   00CC 69 6E 65 2C 
0135   00D0 20 3F 2D 48 
0135   00D4 65 6C 70 0D 
0135   00D8 0A 00 
0136   00DA             CRLF_MSG:
0137   00DA 0D 0A 00        .BYTE	CR,LF,0
0138   00DD             
0139   8000             	.ORG 8000H		; 8KB
0140   8000             ; Data section
0141   8000             IN_BUFF: .DS 256          ; Allocate 256 bytes for the buffer
0142   8100             
0143   8100             ; End of the program
0144   8100                         .END START
tasm: Number of errors = 0
