//
// cpmcbfs.cpp - CP/M Callback Filesystem
//
// A Callback Filesystem, much in the same style as cpmfuse.
//
// Although we might want to use a SectorSize and ClusterSize of 128,
// this isn't allowed by CbFs and would confuse Windows programs.
//
// The volume ID is supposed to be unique within the system.
// We do this by associating it with the mount point drive letter.
// It is also supposed to tie back to the specific media.
// Some applications associate settings with volume IDs.
// Unfortunately we have no way of doing this.
// 

/*...sincludes:0:*/
#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <unistd.h>
#include <windows.h>
#include <tchar.h>
#include "cbfs.h"

extern "C" {
#include "config.h"
#include "cpmfs.h"
}

/*...vconfig\46\h:0:*/
/*...vcpmfs\46\h:0:*/
/*...e*/

/*...svars:0:*/
extern "C" {
const char cmd[] = "cpmcbfs"; // meeded by cpmfs.c
}

// A value generated by me specifically for this project
static char guid[] = "AEDF6510-1C7C-44E7-B271-A5791F348405";

// static char regkey[] = "long hex string from EldoS";
#include "regkey.h"
/*...vregkey\46\h:0:*/

static struct cpmSuperBlock drive;
static struct cpmInode      root;
static int user = 0;
static BOOLEAN invert = FALSE;
static char driveLetter = 'Z';
static BOOLEAN readOnly = FALSE;
static BOOLEAN debugEnabled = FALSE;

typedef struct
	{
	char fn[2+8+1+3+1];
	struct cpmInode ino;
	} FIUC;

typedef struct
	{
	cpmFile file;
	} EIUC;
/*...e*/

/*...sfatal:0:*/
static void fatal(const char *fmt, ...)
	{
	va_list	vars;
	char s[256+1];
	va_start(vars, fmt);
	vsprintf(s, fmt, vars);
	va_end(vars);
	fprintf(stderr, "%s: %s\n", cmd, s);
	exit(1);
	}
/*...e*/
/*...susage:0:*/
static void usage()
	{
	fprintf(stderr, "usage: %s [flags]\n", cmd);
	fprintf(stderr, "flags: -f,--format format  format (default %%CPMTOOLSFMT%% or %s)\n", FORMAT);
	fprintf(stderr, "       -i,--image image    image (must be specified)\n");
	fprintf(stderr, "       -u,--user user      CP/M user (default 0)\n");
	fprintf(stderr, "       -v,--invert-case    toggle case to match what CP/M uses\n");
	fprintf(stderr, "       -d,--drive d:       mount as drive d: (default Z:)\n");
	fprintf(stderr, "       -r,--read-only      read only access\n");
	fprintf(stderr, "       --install           install cbfs driver\n");
	fprintf(stderr, "       --uninstall         uninstall cbfs driver\n");
	fprintf(stderr, "       --status            is the driver installed and running\n");
	exit(1);
	}
/*...e*/
/*...semalloc:0:*/
static void *emalloc(size_t size)
	{
	void *p;
	if ( (p = malloc(size+1)) == NULL )
		throw ECBFSError(ERROR_NOT_ENOUGH_MEMORY);
	return p;
	}
/*...e*/
/*...sdebug:0:*/
static void debug(const char *fmt, ...)
	{
	if ( debugEnabled )
		{
		va_list	vars;
		char s[256+1];
		va_start(vars, fmt);
		vsprintf(s, fmt, vars);
		va_end(vars);
		fprintf(stderr, "%s\n", s);
		fflush(stderr);
		}
	}
/*...e*/

/*...scpmXxxxSafe:0:*/
// I have observed that cpmtools cpmcp only copies in 4096 byte blocks,
// and when I try to write larger blocks in one go, the file size wraps
// modulo 16384 bytes. So these wrappers avoid this problem.

static int cpmReadSafe(struct cpmFile *file, char *buffer, int count)
	{
	int total = 0;
	while ( count > 0 )
		{
		int thisgo = ( count < 4096 ) ? count : 4096;
		int n = cpmRead(file, buffer, thisgo);
		total += n;
		if ( n < thisgo )
			break;
		buffer += n;
		count -= n;
		}
	return total;
	}

static int cpmWriteSafe(struct cpmFile *file, const char *buffer, int count)
	{
	int total = 0;
	while ( count > 0 )
		{
		int thisgo = ( count < 4096 ) ? count : 4096;
		int n = cpmWrite(file, buffer, thisgo);
		total += n;
		if ( n < thisgo )
			break;
		buffer += n;
		count -= n;
		}
	return total;
	}
/*...e*/

/*...sinvert_char:0:*/
static char invert_char(char ch)
	{
	if ( invert )
		{
		if ( islower(ch) )
			return toupper(ch);
		if ( isupper(ch) )
			return tolower(ch);
		}
	return ch;
	}
/*...e*/
/*...slower_TCHAR:0:*/
static TCHAR lower_TCHAR(TCHAR ch)
	{
	if ( _istupper(ch) )
		return _totlower(ch);
	return ch;
	}
/*...e*/
/*...scpm2windows:0:*/
static BOOLEAN cpm2windows(const char *c, TCHAR *w)
	{
	for ( ; *c != '\0'; c++, w++ )
		{
		if ( *c == '/' || *c == '\\' )
			return FALSE;
		*w = invert_char(*c);
		}
	*w = _T('\0');
	return TRUE;
	}
/*...e*/
/*...swindows2cpm:0:*/
/* Valid filenames on the Windows side, include "FILE" and "FILE.EXT".
   "", ".EXT" or "FILE." are not valid. */

/*...svalid_filename_TCHAR:0:*/
/* cpmtools considers the files to be in lower case.
   Of course, in reality, they're not, thats the game it plays. */

static BOOLEAN valid_filename_TCHAR(TCHAR ch)
	{
	if ( ch >= _T('0') && ch <= _T('9') ) return TRUE;
	if ( ch >= _T('a') && ch <= _T('z') ) return TRUE;
	if ( ch >= _T('A') && ch <= _T('Z') ) return FALSE;
	if ( ch <= _T(' ') || ch >  _T('~') ) return FALSE;
	if ( ch == _T('<') ||
	     ch == _T('>') ||
	     ch == _T('.') ||
	     ch == _T(',') ||
	     ch == _T(';') ||
	     ch == _T(':') ||
	     ch == _T('=') ||
	     ch == _T('[') ||
	     ch == _T(']') ||
	     ch == _T('%') ||
	     ch == _T('|') ||
	     ch == _T('(') ||
	     ch == _T(')') ||
	     ch == _T('/') ||
	     ch == _T('\\') ||
	     ch == _T('?') ||
	     ch == _T('*') )
		return FALSE;
	/* Assuming its some ASCII punctuation we allow */
	return TRUE;
	}
/*...e*/

static BOOLEAN windows2cpm(const TCHAR *w, char *c)
	{
	int n = 0;
	for ( ; *w != _T('\0'); w++, c++ )
		{
		TCHAR w2 = lower_TCHAR(*w);
		BOOLEAN w2v = valid_filename_TCHAR(w2);
		if ( n < 8 && w2v )
			{
			*c = (char) w2;
			++n;
			}
		else if ( n >=1 && n <= 8 && w2 == _T('.') )
			{
			*c = '.';
			n = 9;
			}
		else if ( n >= 9 && n < 12 && w2v )
			{
			*c = (char) w2;
			++n;
			}
		else
			return FALSE;
		}
	if ( n == 0 || n == 9 )
		return FALSE;
	*c = '\0';
	return TRUE;
	}
/*...e*/

/*...sFileTime:0:*/
// time_t is seconds since 1700
// FILETIME is 100ns units since 1601
// horrible use of magic numbers, per MSDN site

static void TimeToFileTime(time_t t, FILETIME *ft)
	{
	__int64 hns = t * 10000000 + 116444736000000000ULL;
	ft->dwHighDateTime = (DWORD) ( hns >> 32           ); 
	ft->dwLowDateTime  = (DWORD) ( hns & 0xffffffffULL );
	}

static time_t FileTimeToTime(FILETIME *ft)
	{
	__int64 hns = ( (__int64)ft->dwHighDateTime<<32) | ft->dwLowDateTime;
	return (time_t) ( ( hns - 116444736000000000ULL ) / 10000000 );
	}
/*...e*/

/*...scpmcbfs_Mount                     \45\ noop:0:*/
static void cpmcbfs_Mount(
	CallbackFileSystem *cbfs
	)
	{
	}
/*...e*/
/*...scpmcbfs_Unmount                   \45\ noop:0:*/
static void cpmcbfs_Unmount(
	CallbackFileSystem *cbfs
	)
	{
	}
/*...e*/
/*...scpmcbfs_GetVolumeSize             \45\ cpmStatFS:0:*/
// Bear in mind we must pretend sectors are 512 bytes in size for Windows.

static void cpmcbfs_GetVolumeSize(
	CallbackFileSystem *cbfs,
	__int64 *TotalNumberOfSectors,
	__int64 *NumberOfFreeSectors
	)
	{
	struct cpmStatFS cs;
	cpmStatFS(&root, &cs);
	*TotalNumberOfSectors = ( cs.f_blocks * cs.f_bsize ) / 512;
	*NumberOfFreeSectors  = ( cs.f_bfree  * cs.f_bsize ) / 512;
	debug("GetVolumeSize returns TotalNumberOfSectors=%d NumberOfFreeSectors=%d",
		(int) (*TotalNumberOfSectors),
		(int) (*NumberOfFreeSectors));
	}
/*...e*/
/*...scpmcbfs_GetVolumeLabel            \45\ return CbFS CP\47\M filesystem:0:*/
static void cpmcbfs_GetVolumeLabel(
	CallbackFileSystem *cbfs,
	LPTSTR VolumeLabel
	)
	{
	_tcscpy(VolumeLabel, _T("CbFS CP/M filesystem"));
	}
/*...e*/
/*...scpmcbfs_SetVolumeLabel            \45\ noop:0:*/
static void cpmcbfs_SetVolumeLabel(
	CallbackFileSystem *cbfs,
	LPCTSTR label
	)
	{
	}
/*...e*/
/*...scpmcbfs_GetVolumeId               \45\ \39\CPM\39\ \43\ drive letter:0:*/
// volumeId is supposed to be unique for all CbFs volumes

static void cpmcbfs_GetVolumeId(
	CallbackFileSystem *cbfs,
	DWORD *volumeId
	)
	{
	*volumeId = 0x43504d00+driveLetter; // 'CPM' plus letter
	}
/*...e*/
/*...scpmcbfs_CreateFile                \45\ cpmCreat:0:*/
static void cpmcbfs_CreateFile(
	CallbackFileSystem *cbfs,
	LPCTSTR FileName,
	ACCESS_MASK DesiredAccess, // GENERIC_READ, _WRITE, ...
	DWORD FileAttributes, // FILE_ATTRIBUTE_READONLY, ...
	DWORD ShareMode, // FILE_SHARE_READ, _WRITE
	CbFsFileInfo *FileInfo,
	CbFsHandleInfo *HandleInfo
	)
	{
	debug("CreateFile DesiredAccess=%08x FileAttributes=%08x",
		DesiredAccess, FileAttributes);
	if ( FileAttributes & FILE_ATTRIBUTE_DIRECTORY )
		// This is CP/M, we don't support directories
		{
		debug("  ERROR_ACCESS_DENIED directory");
		throw ECBFSError(ERROR_ACCESS_DENIED);
		}
	if ( readOnly )
		{
		debug("  ERROR_ACCESS_DENIED r/o media");
		throw ECBFSError(ERROR_ACCESS_DENIED);
		}
	while ( *FileName == _T('\\') )
		++FileName;

	char dirent[2+8+1+3+1];
	dirent[0] = (user/10)+'0';
	dirent[1] = (user%10)+'0';
	if ( ! windows2cpm(FileName, dirent+2) )
		{
		debug("  ERROR_INVALID_NAME");
		throw ECBFSError(ERROR_INVALID_NAME);
		}
	mode_t mode = ( FileAttributes & FILE_ATTRIBUTE_READONLY ) ? 0444 : 0666;
	debug("  dirent=%s mode=0%o", dirent, mode);
	FIUC *fiuc = (FIUC *) emalloc(sizeof(FIUC));
	strcpy(fiuc->fn, dirent);
	if ( cpmCreat(&root, dirent, &(fiuc->ino), mode) != 0 )
		{
		debug("  ERROR_CANNOT_MAKE");
		free(fiuc);
		throw ECBFSError(ERROR_CANNOT_MAKE);
		}
	FileInfo->set_UserContext(fiuc);
		// context retained for as long as open
	}
/*...e*/
/*...scpmcbfs_OpenFile                  \45\ cpmNamei:0:*/
static void cpmcbfs_OpenFile(
	CallbackFileSystem *cbfs,
	LPCTSTR FileName,
	ACCESS_MASK DesiredAccess, // GENERIC_READ, _WRITE, ...
	DWORD FileAttributes, // FILE_ATTRIBUTE_READONLY, ...
	DWORD ShareMode,
	CbFsFileInfo *FileInfo,
	CbFsHandleInfo *HandleInfo
	)
	{
	debug("OpenFile DesiredAccess=%08x FileAttributes=%08x",
		DesiredAccess, FileAttributes);
	if ( FileAttributes & FILE_ATTRIBUTE_DIRECTORY )
		// This is CP/M so there shouldn't be any directories to open
		// Behave like VMounter, which also doesn't support directories
	        FileInfo->set_UserContext(NULL);
	else if ( FileInfo->get_UserContext() == NULL )
		{
	        while ( *FileName == _T('\\') )
	        	++FileName;

		char dirent[2+8+1+3+1];
		dirent[0] = (user/10)+'0';
		dirent[1] = (user%10)+'0';
		if ( ! windows2cpm(FileName, dirent+2) )
			throw ECBFSError(ERROR_INVALID_NAME);
		debug("  dirent=%s", dirent);
		FIUC *fiuc = (FIUC *) emalloc(sizeof(FIUC));
		strcpy(fiuc->fn, dirent);
		if ( cpmNamei(&root, dirent, &(fiuc->ino)) != 0 )
			{
			debug("  ERROR_FILE_NOT_FOUND");
			free(fiuc);
			throw ECBFSError(ERROR_FILE_NOT_FOUND);
			}
		struct cpmStat cstbuf;
		cpmStat(&(fiuc->ino), &cstbuf);
		if ( DesiredAccess & GENERIC_WRITE )
			{
			if ( readOnly )
				{
				debug("  ERROR_ACCESS_DENIED r/o media");
				free(fiuc);
				throw ECBFSError(ERROR_ACCESS_DENIED);
				}
			if ( (cstbuf.mode & 0200) == 0 )
			     	{
			     	debug("  ERROR_FILE_READ_ONLY");
			     	free(fiuc);
				throw ECBFSError(ERROR_FILE_READ_ONLY);
				}
			}
		FileInfo->set_UserContext(fiuc);
			// context retained for as long as open
		}
	}
/*...e*/
/*...scpmcbfs_CloseFile                 \45\ free FIUC:0:*/
static void cpmcbfs_CloseFile(
	CallbackFileSystem *cbfs,
	CbFsFileInfo *FileInfo,
	CbFsHandleInfo *HandleInfo
	)
	{
	debug("CloseFile");
	FIUC *fiuc;
	if ( (fiuc = (FIUC *) FileInfo->get_UserContext()) != NULL )
		{
		free(fiuc);
		FileInfo->set_UserContext(NULL);
		}

	debug("cpmSync");
	cpmSync(&drive);
	}
/*...e*/
/*...scpmcbfs_GetFileInfo               \45\ cpmStat:0:*/
static void cpmcbfs_GetFileInfo(
	CallbackFileSystem *cbfs,
	LPCTSTR FileName,
	BOOL *FileExists,
	FILETIME *CreationTime,
	FILETIME *LastAccessTime,
	FILETIME *LastWriteTime,
	__int64 *EndOfFile,
	__int64 *AllocationSize,
	__int64 *FileId,
	DWORD *FileAttributes,
	LPTSTR ShortFileName      OPTIONAL,
	WORD  *SortFileNameLength OPTIONAL,
	LPTSTR RealFileName       OPTIONAL,
	WORD  *RealFileNameLength OPTIONAL
	)
	{
	while( *FileName == _T('\\') )
		++FileName;

	char dirent[2+8+1+3+1];
	dirent[0] = (user/10)+'0';
	dirent[1] = (user%10)+'0';
	if ( ! windows2cpm(FileName, dirent+2) )
		*FileExists = FALSE;
	else
		{
		struct cpmInode ino;
		if ( cpmNamei(&root, dirent, &ino) != 0 )
			*FileExists = FALSE;
		else
			{
			struct cpmStat cstbuf;
			cpmStat(&ino, &cstbuf);
			TimeToFileTime(cstbuf.ctime, CreationTime  );
			TimeToFileTime(cstbuf.atime, LastAccessTime);
			TimeToFileTime(cstbuf.mtime, LastWriteTime );
			*EndOfFile      = cstbuf.size;
			*AllocationSize = cstbuf.size;
			*FileId         = 0;
			if ( readOnly )
				*FileAttributes = FILE_ATTRIBUTE_READONLY;
			else if ( cstbuf.mode & 0222 )
				*FileAttributes = 0;
			else
				*FileAttributes = FILE_ATTRIBUTE_READONLY;
			*FileExists = TRUE;
			}
		}
	}
/*...e*/
/*...scpmcbfs_EnumerateDirectory        \45\ cpmReaddir etc\46\\46\:0:*/
// CP/M directories can never have many entries in them.
// We always scan them all, even when the mask doesn't contain any wildcards,
// and we've previously had a match.

/*...sFileNameMatchesMask:0:*/
// Mask     matches FileName(s)
// --------         -----------
// File.Ext         File.Ext, FILE.ext
// a?b              apb, aqb, a.b
// *.c              a.c, b.c
// x*y              xy, xAy, xAAy
// File.            File

static BOOLEAN FileNameMatchesMask2(
	const char *FileName,
	LPCTSTR Mask,
	int MaskLength
	)
	{
	if ( MaskLength == 0 )
		return *FileName == 0;
	else if ( *Mask == _T('?') )
		return *FileName != 0 &&
		       FileNameMatchesMask2(FileName+1, Mask+1, MaskLength-1);
	else if ( *Mask == _T('*') )
		return ( *FileName != 0 &&
		         FileNameMatchesMask2(FileName+1, Mask, MaskLength) ) ||
		       FileNameMatchesMask2(FileName, Mask+1, MaskLength-1);
	else
		return _totupper(*Mask) == toupper(*FileName) &&
		       FileNameMatchesMask2(FileName+1, Mask+1, MaskLength-1);
	}

static BOOLEAN FileNameMatchesMask(
	const char *FileName,
	LPCTSTR Mask
	)
	{
	int MaskLength = _tcslen(Mask);
	if ( MaskLength >= 1 && Mask[MaskLength-1] == _T('.') )
		--MaskLength;
	return FileNameMatchesMask2(FileName, Mask, MaskLength);
	}
/*...e*/

static void cpmcbfs_EnumerateDirectory(
	CallbackFileSystem *cbfs,
	CbFsFileInfo *DirectoryInfo,
	CbFsHandleInfo *HandleInfo,
	CbFsDirectoryEnumerationInfo *EnumerationInfo,
	LPCTSTR Mask,
	INT Index,			// passed as -1 in modern OS
	BOOL Restart,
	BOOL *FileFound,
	LPTSTR FileName,
	DWORD *FileNameLength,
	LPTSTR ShortFileName OPTIONAL,
	UCHAR *ShortFileNameLength OPTIONAL,
	FILETIME *CreationTime,
	FILETIME *LastAccessTime,
	FILETIME *LastWriteTime,
	__int64 *EndOfFile,
	__int64 *AllocationSize,
	__int64 *FileId,		// currently unused
	DWORD *FileAttributes
	)
	{
	EIUC *eiuc;
	if ( (eiuc = (EIUC *) EnumerationInfo->get_UserContext()) == NULL )
		{
		eiuc = (EIUC *) emalloc(sizeof(EIUC));
		EnumerationInfo->set_UserContext(eiuc);
		// set to start
		cpmOpendir(&root, &(eiuc->file));
		}
	else if ( Restart )
		// reset to start
		cpmOpendir(&root, &(eiuc->file));
	cpmDirent dirent;
	while ( cpmReaddir(&(eiuc->file), &dirent) )
		{
		const char *p = dirent.name;
		if ( p[0] == (user/10)+'0' &&
		     p[1] == (user%10)+'0' &&
		     FileNameMatchesMask(p+2, Mask) )
			{
			if ( cpm2windows(p+2, FileName) )
				{
				*FileNameLength = _tcslen(FileName);
				struct cpmInode ino;
				cpmNamei(&root, p, &ino);
				struct cpmStat cstbuf;
				cpmStat(&ino, &cstbuf);
				TimeToFileTime(cstbuf.ctime, CreationTime  );
				TimeToFileTime(cstbuf.atime, LastAccessTime);
				TimeToFileTime(cstbuf.mtime, LastWriteTime );
				*EndOfFile      = cstbuf.size;
				*AllocationSize = cstbuf.size;
				*FileId         = 0;
				if ( readOnly )
					*FileAttributes = FILE_ATTRIBUTE_READONLY;
				else if ( cstbuf.mode & 0222 )
					*FileAttributes = 0;
				else
					*FileAttributes = FILE_ATTRIBUTE_READONLY;
				*FileFound      = TRUE;
				return;
				} 
			}
		}
	*FileFound = FALSE;
	}
/*...e*/
/*...scpmcbfs_CloseDirectoryEnumeration \45\ free EIUC:0:*/
static void cpmcbfs_CloseDirectoryEnumeration(
	CallbackFileSystem *cbfs,
	CbFsFileInfo *DirectoryInfo,
	CbFsDirectoryEnumerationInfo *EnumerationInfo
	)
	{
	EIUC *eiuc;
	if ( (eiuc = (EIUC *) EnumerationInfo->get_UserContext()) != NULL )
		{
		free(eiuc);
		EnumerationInfo->set_UserContext(NULL);
		}
	}
/*...e*/
/*...scpmcbfs_SetAllocationSize         \45\ noop:0:*/
static void cpmcbfs_SetAllocationSize(
	CallbackFileSystem *cbfs,
	CbFsFileInfo *FileInfo,
	__int64 AllocationSize
	)
	{
	debug("SetAllocationSize %d", (int) AllocationSize);
	// Like the Mapper sample, we'll ignore this, and when asked
	// what the AllocationSize is later, we'll reply with the file size
	}
/*...e*/
/*...scpmcbfs_SetEndOfFile              \45\ cpmRead\44\ cpmUnlink\44\ cpmWrite:0:*/
static void cpmcbfs_SetEndOfFile(
	CallbackFileSystem *cbfs,
	CbFsFileInfo *FileInfo,
	__int64 EndOfFile
	)
	{
	debug("SetEndOfFile %d", (int) EndOfFile);
	FIUC *fiuc = (FIUC *) FileInfo->get_UserContext();
	// CP/M doesn't support filesystems beyond 8MB,
	// so we can catch silly arguments like this.
	if ( EndOfFile > 8 * 1024 * 1024 )
		{
		debug("  ERROR_IO_DEVICE over 8MB");
		throw ECBFSError(ERROR_IO_DEVICE);
		}
	if ( readOnly )
		{
		debug("  ERROR_ACCESS_DENIED r/o media");
		throw ECBFSError(ERROR_ACCESS_DENIED);
		}
	struct cpmStat cstbuf;
	cpmStat(&(fiuc->ino), &cstbuf);
	if ( EndOfFile > cstbuf.size )
		{
		char *buf = (char *) emalloc((size_t) EndOfFile);
		struct cpmFile file;
		cpmOpen(&(fiuc->ino), &file, O_RDONLY);
		cpmReadSafe(&file, buf, (int) cstbuf.size);
		memset(buf+cstbuf.size, 0, (size_t) (EndOfFile-cstbuf.size));
		if ( cpmWrite(&file, buf+cstbuf.size, (int) (EndOfFile-cstbuf.size)) != (int) (EndOfFile-cstbuf.size) )
			{
			debug("  ERROR_IO_DEVICE writing");
			free(buf);
			throw ECBFSError(ERROR_IO_DEVICE);
			}
		cpmClose(&file);
		free(buf);
		}
	else if ( EndOfFile < cstbuf.size )
		{
		char *buf = (char *) emalloc((size_t) EndOfFile);
		struct cpmFile file;
		cpmOpen(&(fiuc->ino), &file, O_RDONLY);
		cpmReadSafe(&file, buf, (int) EndOfFile);
		cpmClose(&file);
		if ( cpmUnlink(&root, fiuc->fn) != 0 )
			{
			debug("  ERROR_IO_DEVICE unlinking");
			free(buf);
			throw ECBFSError(ERROR_IO_DEVICE);
			}
		// cpmCreat works because the cpmUnlink left a directory space
		cpmCreat(&root, fiuc->fn, &(fiuc->ino), cstbuf.mode);
		cpmOpen(&(fiuc->ino), &file, O_WRONLY);
		// cpmWrite works because new size <= old size
		cpmWriteSafe(&file, buf, (int) EndOfFile);
		cpmClose(&file);
		free(buf);
		}
	}
/*...e*/
/*...scpmcbfs_SetFileAttributes         \45\ cpmChmod\44\ cpmUtime:0:*/
static void cpmcbfs_SetFileAttributes(
	CallbackFileSystem *cbfs,
	CbFsFileInfo *FileInfo,
	CbFsHandleInfo *HandleInfo,
	FILETIME *CreationTime,
	FILETIME *LastAccessTime,
	FILETIME *LastWriteTime,
	DWORD FileAttributes
	)
	{
	debug("SetFileAttributes");
	if ( readOnly )
		{
		debug("  ERROR_ACCESS_DENIED r/o media");
		throw ECBFSError(ERROR_ACCESS_DENIED);
		}
	FIUC *fiuc = (FIUC *) FileInfo->get_UserContext();
	if ( FileAttributes != 0 )
		// Indicates a change, not the new value == 0
		{
		mode_t mode = ( FileAttributes & FILE_ATTRIBUTE_READONLY ) ? 0444 : 0666;
		debug("  mode=0%o", mode);
		cpmChmod(&(fiuc->ino), mode);
		}
	struct cpmStat cstbuf;
	cpmStat(&(fiuc->ino), &cstbuf); 
	struct utimbuf times;
	times.actime = ( LastAccessTime != NULL )
		? FileTimeToTime(LastAccessTime)
		: cstbuf.atime;
	times.modtime = ( LastWriteTime != NULL )
		? FileTimeToTime(LastWriteTime)
		: cstbuf.mtime;
	cpmUtime(&(fiuc->ino), &times);
	}
/*...e*/
/*...scpmcbfs_CanFileBeDeleted          \45\ return TRUE:0:*/
// If this function returns TRUE, then cpmcbfs_DeleteFile MUST succeed

static void cpmcbfs_CanFileBeDeleted(
	CallbackFileSystem *cbfs,
	CbFsFileInfo *FileInfo,
	CbFsHandleInfo *HandleInfo,
	BOOL *CanBeDeleted
	)
	{
/*
	DWORD FileNameLength = FileInfo->get_FileName(NULL);
	TCHAR *FileName = (TCHAR *) malloc((FileNameLength+1)*sizeof(TCHAR));
	FileInfo->get_FileName(FileName);
	TCHAR *FileNamePtr = FileName;
	while ( *FileNamePtr == _T('\\') )
		++FileNamePtr;

	free(FileName);
*/

	// The documentation gives no hint that file permissions or the
	// existence of open handles on the file should influence the result
	*CanBeDeleted = ! readOnly;
	debug("CanFileBeDeleted returns %d", *CanBeDeleted);
	}
/*...e*/
/*...scpmcbfs_DeleteFile                \45\ cpmUnlink:0:*/
// cpmcbfs_CanFileBeDeleted must have returned TRUE
// This function therefore MUST succeed

static void cpmcbfs_DeleteFile(
	CallbackFileSystem *cbfs,
	CbFsFileInfo *FileInfo
	)
	{
	debug("DeleteFile");
	if ( readOnly )
		{
		debug("  ERROR_ACCESS_DENIED r/o media");
		throw ECBFSError(ERROR_ACCESS_DENIED);
		}
	DWORD FileNameLength = FileInfo->get_FileName(NULL);
	TCHAR *FileName = (TCHAR *) malloc((FileNameLength+1)*sizeof(TCHAR));
	FileInfo->get_FileName(FileName);
	TCHAR *FileNamePtr = FileName;
	while ( *FileNamePtr == _T('\\') )
		++FileNamePtr;

	char dirent[2+8+1+3+1];
	dirent[0] = (user/10)+'0';
	dirent[1] = (user%10)+'0';
	windows2cpm(FileNamePtr, dirent+2);
	debug("  dirent=%s", dirent);
	cpmUnlink(&root, dirent);
	free(FileName);
	debug("cpmSync");
	cpmSync(&drive);
	}
/*...e*/
/*...scpmcbfs_RenameOrMoveFile          \45\ cpmRename:0:*/
static void cpmcbfs_RenameOrMoveFile(
	CallbackFileSystem *cbfs,
	CbFsFileInfo *FileInfo,
	LPCTSTR NewFileName
	)
	{
	debug("RenameOrMoveFile");
	if ( readOnly )
		{
		debug("  ERROR_ACCESS_DENIED r/o media");
		throw ECBFSError(ERROR_ACCESS_DENIED);
		}
	DWORD FileNameLength = FileInfo->get_FileName(NULL);
	TCHAR *FileName = (TCHAR *) malloc(FileNameLength+1);
	FileInfo->get_FileName(FileName);
	TCHAR *FileNamePtr = FileName;
	while ( *FileNamePtr == _T('\\') )
		++FileNamePtr;
	while ( *NewFileName == _T('\\') )
		++NewFileName;

	char dirent_old[2+8+1+3+1];
	char dirent_new[2+8+1+3+1];
	dirent_old[0] = (user/10)+'0';
	dirent_old[1] = (user%10)+'0';
	dirent_new[0] = (user/10)+'0';
	dirent_new[1] = (user%10)+'0';
	if ( ! windows2cpm(FileNamePtr, dirent_old+2) )
		{
		debug("  ERROR_INVALID_NAME old name");
		free(FileName);
		throw ECBFSError(ERROR_INVALID_NAME);
		}
	debug("  dirent_old=%s", dirent_old);
	if ( ! windows2cpm(NewFileName, dirent_new+2) )
		{
		debug("  ERROR_INVALID_NAME new name");
		free(FileName);
		throw ECBFSError(ERROR_INVALID_NAME);
		}
	debug("  dirent_new=%s", dirent_new);
	if ( cpmRename(&root, dirent_old, dirent_new) != 0 )
		{
		debug("  ERROR_IO_DEVICE");
		free(FileName);
		throw ECBFSError(ERROR_IO_DEVICE);
		}
	free(FileName);
	}
/*...e*/
/*...scpmcbfs_ReadFile                  \45\ cpmRead:0:*/
static void cpmcbfs_ReadFile(
	CallbackFileSystem *cbfs,
	CbFsFileInfo *FileInfo,
	__int64 Position,
	VOID *Buffer,
	DWORD BytesToRead,
	DWORD *BytesRead
	)
	{
	debug("ReadFile Position=%d BytesToRead=%d",
		(int) Position, (int) BytesToRead);
	FIUC *fiuc = (FIUC *) FileInfo->get_UserContext();
	struct cpmStat cstbuf;
	cpmStat(&(fiuc->ino), &cstbuf);
	if ( Position > cstbuf.size )
		BytesToRead = 0;
	else if ( Position + BytesToRead > cstbuf.size )
		BytesToRead = (DWORD) ( cstbuf.size - Position );
	struct cpmFile file;
	cpmOpen(&(fiuc->ino), &file, O_RDONLY);
	while ( Position > 0 )
		{
		char dump_buf[4096];
		off_t thisgo = (off_t) ( ( Position<sizeof(dump_buf) ) ? Position : sizeof(dump_buf) );
		cpmReadSafe(&file, dump_buf, thisgo);
		Position -= thisgo;
		}
	*BytesRead = cpmReadSafe(&file, (char *) Buffer, (int) BytesToRead);
	cpmClose(&file);
	debug("  BytesRead=%d", (int) *BytesRead);
	}
/*...e*/
/*...scpmcbfs_WriteFile                 \45\ cpmWrite:0:*/
static void cpmcbfs_WriteFile(
	CallbackFileSystem *cbfs,
	CbFsFileInfo *FileInfo,
	__int64 Position,
	VOID *Buffer,			// const?
	DWORD BytesToWrite,
	DWORD *BytesWritten
	)
	{
	debug("WriteFile Position=%d BytesToWrite=%d",
		(int) Position, (int) BytesToWrite);
	FIUC *fiuc = (FIUC *) FileInfo->get_UserContext();
	struct cpmStat cstbuf;
	cpmStat(&(fiuc->ino), &cstbuf);
	if ( Position > cstbuf.size )
		{
		debug("  ERROR_IO_DEVICE");
		throw ECBFSError(ERROR_IO_DEVICE);
		}
	cpmFile file;
	cpmOpen(&(fiuc->ino), &file, O_RDWR);
	while ( Position > 0 )
		{
		char dump_buf[4096];
		off_t thisgo = (off_t) ( ( Position<sizeof(dump_buf) ) ? Position : sizeof(dump_buf) );
		cpmReadSafe(&file, dump_buf, thisgo);
		Position -= thisgo;
		}
	*BytesWritten = cpmWriteSafe(&file, (const char *) Buffer, (int) BytesToWrite);
	cpmClose(&file);
	debug("  BytesWritten=%d", (int) *BytesWritten);
	}
/*...e*/
/*...scpmcbfs_IsDirectoryEmpty          \45\ if no files in any user area:0:*/
// Here I am ignoring the user
// So I only say the directory is empty if there are no files
// including files you cannot currently see in other user areas.
// I think this test is done prior to deleting directories,
// which doesn't make a lot of sense on CP/M anyway.

static void cpmcbfs_IsDirectoryEmpty(
	CallbackFileSystem *cbfs,
	CbFsFileInfo *FileInfo,
	LPCWSTR FileName,
	BOOL *IsEmpty
	)
	{
	cpmFile file;
	cpmOpendir(&root, &file);
	cpmDirent dirent;
	*IsEmpty = ! cpmReaddir(&file, &dirent);
	}
/*...e*/

/*...sinstall:0:*/
static void install()
	{
	try
		{
		TCHAR installdir[MAX_PATH];
		GetSystemDirectory(installdir, MAX_PATH);
		DWORD reboot = 0;
		CallbackFileSystem::Install(
			_T("cbfs.cab"),
			guid,
			installdir,
			true,
			CBFS_MODULE_NET_REDIRECTOR_DLL |
			CBFS_MODULE_MOUNT_NOTIFIER_DLL,
			&reboot
			);
		if ( reboot )
			fprintf(stderr, "Reboot the computer to complete the installation\n");
		}
	catch ( ECBFSError e )
		{
		if ( e.ErrorCode() == ERROR_ACCESS_DENIED )
			fprintf(stderr, "Installation requires administrator rights\n");
		else
			fwprintf(stderr, _T("Installation error: %s\n"), e.Message());
		}
	}
/*...e*/
/*...suninstall:0:*/
static void uninstall()
	{
	try
		{
		DWORD reboot = 0;
		CallbackFileSystem::Uninstall(
			_T("cbfs.cab"),
			guid,
			NULL,
			&reboot
			);
		if ( reboot )
			fprintf(stderr, "Reboot the computer to complete the uninstallation\n");
		}
	catch ( ECBFSError e )
		{
		if ( e.ErrorCode() == ERROR_ACCESS_DENIED )
			fprintf(stderr, "Uninstallation requires administrator rights\n");
		else
			fwprintf(stderr, _T("Uninstallation error: %s\n"), e.Message());
		}
	}
/*...e*/
/*...sstatus:0:*/
static void status()
	{
	BOOL installed = FALSE;
	int vh = 0, vl = 0;
	SERVICE_STATUS status;
	CallbackFileSystem::GetModuleStatus(guid, CBFS_MODULE_DRIVER, &installed, &vh, &vl, &status);
	if ( installed )
		{
		const char *s;
		switch ( status.dwCurrentState )
			{
			case SERVICE_CONTINUE_PENDING:
				s = "continue is pending";
				break;
			case SERVICE_PAUSE_PENDING:
				s = "pause is pending";
				break;
			case SERVICE_PAUSED:
				s = "is paused";
				break;
			case SERVICE_RUNNING:
				s = "is running";
				break;
			case SERVICE_START_PENDING:
				s = "is starting";
				break;
			case SERVICE_STOP_PENDING:
				s = "is stopping";
				break;
			case SERVICE_STOPPED:
				s = "is stopped";
				break;
			default:
				s = "is in an undefined state";
				break;
			}
		fprintf(stderr, "Driver (%d.%d.%d.%d) installed, service %s\n",
			(vh>>16),(vh&0xfff),(vl>>16),(vl&0xffff), s);
		}
	else
		fprintf(stderr, "Driver is not installed\n");
	}
/*...e*/

/*...smain:0:*/
int main(int argc, char *argv[])
	{
	if ( argc == 2 && !strcmp(argv[1], "--install") )
		install();
	else if ( argc == 2 && !strcmp(argv[1], "--uninstall") )
		uninstall();
	else if ( argc == 2 && !strcmp(argv[1], "--status") )
		status();
	else
		try
			{
			const char *format = FORMAT;
			const char *image  = NULL;

			for ( int i = 1; i < argc; i++ )
				if ( !strcmp(argv[i], "-f"      ) ||
				     !strcmp(argv[i], "--format") )
					{
					if ( ++i == argc )
						usage();
					format = argv[i];
					}
				else if ( !strcmp(argv[i], "-i"     ) ||
					  !strcmp(argv[i], "--image") )
					{
					if ( ++i == argc )
						usage();
					image = argv[i];
					}
				else if ( !strcmp(argv[i], "-u")     ||
					  !strcmp(argv[i], "--user") )
					{
					if ( ++i == argc )
						usage();
					sscanf(argv[i], "%d", &user);
					if ( user < 0 || user > 31 )
						fatal("user must be between 0 and 31");
					}
				else if ( !strcmp(argv[i], "-v")            ||
					  !strcmp(argv[i], "--invert-case") )
					invert = TRUE;
				else if ( !strcmp(argv[i], "-r")          ||
					  !strcmp(argv[i], "--read-only") )
					readOnly = TRUE;
				else if ( !strcmp(argv[i], "-d"     ) ||
					  !strcmp(argv[i], "--drive") )
					{
					if ( ++i == argc )
						usage();
					if ( isalpha(argv[i][0]) &&
					     argv[i][1] == ':' &&
					     argv[i][2] == '\0' )
						;
					else
						fatal("drive must be of the form X:");
					driveLetter = toupper(argv[i][0]);
					}
				else if ( !strcmp(argv[i], "-D") )
					debugEnabled = TRUE;
				else
					usage();

			if ( image == NULL )
				fatal("CP/M filesystem image must be specified with -i");

			const char *err;
			int mode = readOnly ? O_RDONLY : O_RDWR;
			if ( (err = Device_open(&drive.dev, image, mode|O_BINARY, NULL)) != NULL )
				fatal("can't open %s (%s)", image, err);

			if ( cpmReadSuper(&drive,&root,format) != 0 )
				fatal("can't read super block on %s of format %s\n", image, format);

			CallbackFileSystem cbfs;

			// media type information
			cbfs.SetStorageType(CallbackFileSystem::stDisk);
			cbfs.SetStorageCharacteristics(CallbackFileSystem::scRemovableMedia);

			// basic properties of files on a CP/M filesystem.
			// note that we don't do all that Windows 8.3 long and short
			// filename malarky, even though, on CP/M files are 8.3.
			cbfs.SetCaseSensitiveFileNames(FALSE);
			cbfs.SetShortFileNameSupport(FALSE);
			cbfs.SetSectorSize(512);
			cbfs.SetClusterSize(512);
			cbfs.SetMaxReadWriteBlockSize(8*1024*1024);

			// cpmfs library is single threaded
			cbfs.SetSerializeCallbacks(FALSE);
			cbfs.SetParalleledProcessingAllowed(FALSE);
			cbfs.SetMinWorkerThreadCount(1);
			cbfs.SetMaxWorkerThreadCount(1);

			// don't cache anything, at least not yet
			cbfs.SetNonexistentFilesCacheEnabled(FALSE);
			cbfs.SetFileCacheEnabled(FALSE);
			cbfs.SetMetaDataCacheEnabled(FALSE);

			cbfs.SetUseFileCreationFlags(TRUE);

			cbfs.SetOnMount(cpmcbfs_Mount);
			cbfs.SetOnUnmount(cpmcbfs_Unmount);
			cbfs.SetOnGetVolumeSize(cpmcbfs_GetVolumeSize);
			cbfs.SetOnGetVolumeLabel(cpmcbfs_GetVolumeLabel);
			cbfs.SetOnSetVolumeLabel(cpmcbfs_SetVolumeLabel);
			cbfs.SetOnGetVolumeId(cpmcbfs_GetVolumeId);
			cbfs.SetOnCreateFile(cpmcbfs_CreateFile);
			cbfs.SetOnOpenFile(cpmcbfs_OpenFile);
			cbfs.SetOnCloseFile(cpmcbfs_CloseFile);
			cbfs.SetOnGetFileInfo(cpmcbfs_GetFileInfo);
			cbfs.SetOnEnumerateDirectory(cpmcbfs_EnumerateDirectory);
			cbfs.SetOnCloseDirectoryEnumeration(cpmcbfs_CloseDirectoryEnumeration);
			cbfs.SetOnSetAllocationSize(cpmcbfs_SetAllocationSize);
			cbfs.SetOnSetEndOfFile(cpmcbfs_SetEndOfFile);
			cbfs.SetOnSetFileAttributes(cpmcbfs_SetFileAttributes);
			cbfs.SetOnCanFileBeDeleted(cpmcbfs_CanFileBeDeleted);
			cbfs.SetOnDeleteFile(cpmcbfs_DeleteFile);
			cbfs.SetOnRenameOrMoveFile(cpmcbfs_RenameOrMoveFile);
			cbfs.SetOnReadFile(cpmcbfs_ReadFile);
			cbfs.SetOnWriteFile(cpmcbfs_WriteFile);
			cbfs.SetOnIsDirectoryEmpty(cpmcbfs_IsDirectoryEmpty);

			cbfs.SetRegistrationKey(regkey);
			cbfs.Initialize(guid);

			cbfs.SetFileSystemName(_T("CP/M")); // upto 10 characters

			cbfs.CreateStorage();

			TCHAR mountPoint[2+1];
			mountPoint[0] = driveLetter;
			mountPoint[1] = _T(':');
			mountPoint[2] = _T('\0');

			cbfs.AddMountingPoint(mountPoint);
			cbfs.MountMedia(30000); // in ms

			fprintf(stderr, "Drive %c: should exist until you press Enter ", driveLetter);
			fflush(stderr);
			char buf[100+1];
			fgets(buf, 100, stdin);

			if ( cbfs.Active() )
				for ( int i = cbfs.GetMountingPointCount()-1; i >= 0; i-- )
					cbfs.DeleteMountingPoint(i);
			if ( cbfs.Active() )
				cbfs.UnmountMedia(TRUE);
			if ( cbfs.StoragePresent() )
				try
					{
					cbfs.DeleteStorage(TRUE);
					}
				catch ( ... )
					{
					}

			cpmSync(&drive);
			cpmUmount(&drive);
			Device_close(&drive.dev);
			}
		catch ( ECBFSError e )
			{
			fwprintf(stderr, _T("Exception: %s"), e.Message());
			return 1;
			}

	return 0;
	}
/*...e*/
