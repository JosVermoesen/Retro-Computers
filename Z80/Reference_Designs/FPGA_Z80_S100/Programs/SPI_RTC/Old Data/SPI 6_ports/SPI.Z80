;Test program for SPI interface of S100Computers.com FPGA Prototype board.
;Will Read or Write to a AT25128 EEPROM
;
;	John Monahan	S100Computers.com	1/5/2019
;
;
;V1.0		1/5/2019	;First version. It is "rough & ready" with little menu etc. error checking etc.

;	PORT ASSIGNMENTS
;
SPI_BASE_PORT	EQU	068H			; Base I/O port fot SPI module
SPI_OUT_DATA_7_0	EQU	SPI_BASE_PORT+5		; 6D, Data In/Out port to SPI module (6 Bytes wide)
SPI_OUT_DATA_15_8	EQU	SPI_BASE_PORT+4		; 6C, Data In/Out port to SPI module
SPI_OUT_DATA_23_16	EQU	SPI_BASE_PORT+3		; 6B, Data In/Out port to SPI module
SPI_OUT_DATA_31_24	EQU	SPI_BASE_PORT+2		; 6A, Data In/Out port to SPI module
SPI_OUT_DATA_39_22	EQU	SPI_BASE_PORT+1		; 69, Data In/Out port to SPI module
SPI_OUT_DATA_47_40	EQU	SPI_BASE_PORT		; 68, Data In/Out port to SPI module
SPI_OUT_PARMS_PORT	EQU	SPI_BASE_PORT+6		; 6E, Port for module Byte Count & Slave number etc.

SPI_RW_PORT		EQU	SPI_BASE_PORT+7		; 6F, Port begin Read/Write process. 
SPI_IN_STATUS_PORT	EQU	SPI_BASE_PORT		; 68, Input status port, Bit 0H contains SPI_BUSY_FLAG

EEPROM_CS_LOW		EQU	00H			; Bit 7 has CS*, BITS 2,1,0 LOW so Byte Count (000 = 8 bit SPI)
EEPROM_CS_HIGH		EQU	80H			

SPI_8_BITS		EQU	00000000B		; Send/Recieve 1 Byte SPI info (Default)
SPI_16_BITS		EQU	00000001B		; Send/Recieve 2 Byte SPI info
SPI_24_BITS		EQU	00000010B		; Send/Recieve 3 Byte SPI info
SPI_32_BITS		EQU	00000100B		; Send/Recieve 4 Byte SPI info
SPI_48_BITS		EQU	00001000B		; Send/Recieve 6 Byte SPI info

SET_WRITE_ENABLE	EQU	00000110B		; Set EEPROM Write Enable Latch
RESET_WRITE_ENABLE	EQU	00000100B		; Reset EEPROM Write Enable Latch
READ_STATUS		EQU	00000101B		; Read Status Register
WRITE_STATUS		EQU	00000001B		; Write Status Register
READ_MEMORY		EQU	00000011B		; Read Memory
WRITE_MEMORY		EQU	00000010B		; Write Memory

CONSTAT			EQU	0H		; Console Status Port
CONIN			EQU	1H		; Console IN Port
CONOUT			EQU	1H		; Console OUT Port

MONITOR			EQU	0F000H		;Location of Z80 ROM monitor when done.

SPACE			EQU	20H
BELL			EQU	07H
ESC			EQU	1BH
CR			EQU	0DH
LF			EQU	0AH

	ORG	100H
START:
	LD	SP,STACK
	LD	HL,SIGNON
	CALL	PMSG
	LD	A,EEPROM_CS_HIGH	;Deselect EEPROM, Default to 6 bytes
	OUT	(SPI_OUT_PARMS_PORT),A
	JP	START2
	
START1:	LD	HL,SIGNON1
	CALL	PMSG
START2:	CALL	CRLF			;Normal start within menu
	LD	C,'>'	   
	CALL	CO
	CALL	CI
	CP	A,ESC
	JP	NZ,START3
	JP	MONITOR
	
START3:	CP	A,'0'
	JP	Z,READ_BYTE_EEPROM
	CP	A,'1'
	JP	Z,FILL_EEPROM
	CP	A,'2'
	JP	Z,WRITE_EEPROM
	CP	A,'3'
	JP	Z,READ_EEPROM
	CP	A,'4'
	JP	Z,MOVE_EEPROM
	CP	A,'5'
	JP	Z,COPY_EEPROM
	CALL	MENU_ERROR
	JP	START1

MENU_ERROR:
	LD	HL,MENU_MSG		; "Menu error"
	CALL	PMSG
	RET
	
;-------------------------------------------------------------------------------------------------

READ_BYTE_EEPROM:
	LD	HL,MSG0			; "Enter EEPROM Address (000-1FFH)"
	CALL	PMSG
	CALL	GET_HEX4		; Put 16 Bit Paramater in HL
	JP	C,DATA_READ_ERROR	; Carry set, there was a problem
	LD	(START_STORE),HL
	
					; >>>> Display what will be done <<<<
	LD	HL,READ_MSG2A		; "Will Read byte from EEPROM at "
	CALL	PMSG
	LD	HL,(START_STORE)	; Print the value in HL
	CALL	PRINT_HL		; <--- START
	LD	HL,READ_MSG3		; "H,/n Press any keyboard character to display. ESC to return to the main menu.'"
	CALL	PMSG
	CALL	CHECK_ESC
	JP	NZ,BEGIN_BYTE_READ
	JP	START1

BEGIN_BYTE_READ:			;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
	LD	A,EEPROM_CS_LOW		; Select EEPROM and 32 bits
	OR	A,SPI_24_BITS
	OUT	(SPI_OUT_PARMS_PORT),A
	CALL	ZBITS
	CALL	CRLF
	
	LD	A,READ_MEMORY
	OUT	(SPI_OUT_DATA_47_40),A  ; Send read CMD
	LD	HL,(START_STORE)
	LD	A,H
	OUT	(SPI_OUT_DATA_39_22),A	; Send High Byte
	LD	A,L
	OUT	(SPI_OUT_DATA_31_24),A	; Send Low Byte

	OUT	(SPI_RW_PORT),A		; <--- Trigger WRITE 3 bytes
	
	CALL	CI
	
	LD	A,EEPROM_CS_LOW		; Keep EEPROM selected 
	OR	A,SPI_8_BITS		; Will send 1 bytes
	OUT	(SPI_OUT_PARMS_PORT),A

	CALL	CI

;	CALL	DELAY	
	
	IN	A,(SPI_RW_PORT)		; <--- Trigger READ 1 Byte
	LD	B,A			; store in B
	
	LD	A,EEPROM_CS_HIGH	; Deselect EEPROM, back to default 6 bytes
	OUT	(SPI_OUT_PARMS_PORT),A

	LD	HL,READ_MSG2B		; "Byte = "
	CALL	PMSG
	LD	A,B
	CALL	PRINT_A			; Print hex value on CRT
	LD	HL,READ_MSG3A		; "H. CRLF"
	CALL	PMSG
	JP	START1


;-----------------------------------------------------------------------------
FILL_EEPROM:
	LD	HL,FILL_MSG		; "Enter EEPROM Fill Start Address (000-1FFH)"
	CALL	PMSG
	CALL	GET_HEX4		; Put 16 Bit Paramater in HL
	JP	C,DATA_FILL_ERROR	; Carry set, there was a problem
	LD	A,H
	AND	A,01H			; Range is 000-1FFH for 512 Byre EEPROM
	LD	H,A 
	LD	(START_STORE),HL

	LD	HL,FILL_MSG1		; "Enter Number of Fill Bytes (00-7FH)"
	CALL	PMSG
	CALL	GET_HEX			; Get number of bytes to send in [A]
	JP	C,DATA_FILL_ERROR
	AND	A,7FH			; Range must be 00-7FH only (1 page)
	LD	(RANGE_STORE),A		; <<< Save range in B >>
	
	LD	HL,FILL_MSG2		; "Enter Fill Value (00-FFH)"
	CALL	PMSG
	CALL	GET_HEX			; Get fill value in [A]
	JP	C,DATA_FILL_ERROR
	LD	(DATA_STORE),A		; <<< Save fill value in [C] >>>
	


					; >>>> Display what will be done <<<<
	LD	HL,FILL_MSG3		; "Will fill EEPROM starting at "
	CALL	PMSG
	LD	HL,(START_STORE)	; Print the value in HL
	CALL	PRINT_HL		; <--- START
	LD	HL,FILL_MSG4		; "H for "
	CALL	PMSG
	
	LD	A,(RANGE_STORE)
	CALL	PRINT_A			; <--- RANGE
	LD	HL,FILL_MSG5		; "H Bytes with a Fill Value of "
	CALL	PMSG
	LD	A,(DATA_STORE)
	CALL	PRINT_A			; <--- VALUE
	LD	HL,FILL_MSG6		; "H. Press any character to continue. Press ESC to return to the main menu.."
	CALL	PMSG
	CALL	CHECK_ESC
	JP	NZ,BEGIN_FILL
	JP	START1
	
BEGIN_FILL:
	LD	HL,(START_STORE)	; Get Start
	LD	A,H
;;;;	OUT	(I2C_DATA),A	
	LD	A,L			; Send to FIFO High byte address
;;;;	OUT	(I2C_DATA),A	
	
	LD	A,(RANGE_STORE)		; 1 up to 7F Bytes
	INC	A			; 0,1,2,3,4 to 1,2,3,4
	LD	B,A			; Store in B

FILL_LOOP:
;;;;	IN	A,(I2C_STATUS)		; Check if FIFO is full
	BIT	4,A
	JP	NZ,FIFO_FILL_FULL
	LD	A,(DATA_STORE)		; Send to FIFO Fill Data byte
;;;;	OUT	(I2C_DATA),A
	DJNZ	FILL_LOOP		; Count down B

	CALL	CRLF
	XOR	A,A	
;;;;	OUT	(I2C_STROBE),A		; Set FIFO for Read

;;;;	OUT	(I2C_RW),A		; Pulse Write to transfer FIFO data to I2C Module
					; Note, no need to test busy flag as the FIFO is controlled by this signal
;;;;	IN	A,(I2C_STATUS)		; Check if FIFO is full
	BIT	5,A
	JP	NZ,FILL_ERROR

	LD	HL,FILL_MSG7		; "EEPROM Filled!"
	CALL	PMSG
	JP	START2

DATA_FILL_ERROR:
	LD	HL,ERROR_MSG		; "Data format error"
	CALL	PMSG
	JP	START1
	
FIFO_FILL_FULL:	
	LD	HL,FILL_MSG8		; "ERROR FIFO is Full!"
	CALL	PMSG
	JP	START1
	
FILL_ERROR:	
	LD	HL,FILL_MSG9		; "ERROR writing to I2C Port"
	CALL	PMSG
	JP	START1
	
;-----------------------------------------------------------------------	

WRITE_EEPROM:
	LD	HL,WRITE_MSG		; "Enter EEPROM Write Start Address (000-1FFH)"
	CALL	PMSG
	CALL	GET_HEX4		; Put 16 Bit Paramater in HL
	JP	C,DATA_WRITE_ERROR	; Carry set, there was a problem
	LD	A,H
	AND	A,01H			; Range is 000-1FFH for 512 Byre EEPROM
	LD	H,A 
	LD	(START_STORE),HL

	LD	HL,WRITE_MSG1		; "Enter bytes in form:- xx,xx,xx..., CR to stop"
	CALL	PMSG
	LD	HL,BYTE_STRING		; Setup pointer
	LD	A,1			; Count from 1,2,3,4...
	LD	(RANGE_STORE),A

WRITE_LOAD:
	CALL	GET_HEX			; Get Bytes to write
	JP	C,DATA_WRITE_ERROR
	LD	(HL),A			; <<< Save value in [HL++] >>>
	INC	HL
	CALL	CHECK_CR
	JP	Z,WRITE2
	LD	C,','
	CALL	CO
	LD	A,(RANGE_STORE)
	INC	A
	CP	A,81H
	JP	Z,RANGE_WRITE_ERROR
	LD	(RANGE_STORE),A
	JP	WRITE_LOAD
	
WRITE2:					; >>>> Display what will be done <<<<
	LD	HL,WRITE_MSG2		; "Will write to EEPROM starting at "
	CALL	PMSG
	LD	HL,(START_STORE)	; Print the value in HL
	CALL	PRINT_HL		; <--- START
	LD	HL,WRITE_MSG3		; "H for "
	CALL	PMSG
	LD	A,(RANGE_STORE)		;Numbering is 0,1,2...
	CALL	PRINT_A			; <--- RANGE
	LD	HL,WRITE_MSG4		; "H Bytes."
	CALL	PMSG
	LD	HL,WRITE_MSG5		; "Press any character to continue. Press ESC to return to the main menu."
	CALL	PMSG
	CALL	CHECK_ESC
	JP	NZ,BEGIN_WRITE
	JP	START1
	
BEGIN_WRITE:
	LD	HL,(START_STORE)
	LD	A,H			; Send to FIFO Low byte address
;;;	OUT	(I2C_DATA),A	
	LD	A,L			; Send to FIFO High byte address
;;;;	OUT	(I2C_DATA),A	

	LD	A,(RANGE_STORE)		; 1 up to 7F Bytes
	LD	B,A			; Store in B
	LD	HL,BYTE_STRING		; Get back pointer to byte string
	

WRITE_LOOP:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
;;;;;	IN	A,(I2C_STATUS)		; Check if FIFO is full
	BIT	4,A
	JP	NZ,FIFO_WRITE_FULL
	LD	A,(HL)			; Send to FIFO Fill Data byte
	INC	HL			; Next data byte
;;;;;;	OUT	(I2C_DATA),A
	DJNZ	WRITE_LOOP		; <<<<<<<<<<<<< Count down B

	CALL	CRLF
	XOR	A,A	
;;;;;;	OUT	(I2C_STROBE),A		; Set FIFO for Read
   					; Note the hardware will make sure all data is sent before Enable in lowered

;;;;;	OUT	(I2C_RW),A		; Pulse Write to transfer FIFO data to I2C Module
					; Note, no need to test busy flag as the FIFO is controlled by this signal

;;;;;	IN	A,(I2C_STATUS)		; Check if FIFO is full
	BIT	5,A
	JP	NZ,FIFO_WRITE_FULL

	LD	HL,WRITE_MSG7		; "EEPROM Filled!"
	CALL	PMSG
	JP	START2


DATA_WRITE_ERROR:
	LD	HL,ERROR_MSG		; "Data format error"
	CALL	PMSG
	JP	START1

RANGE_WRITE_ERROR:
	LD	HL,ERROR_MSG2		; "Data range error"
	CALL	PMSG
	JP	START1
	
FIFO_WRITE_FULL:	
	LD	HL,FILL_MSG8		; "ERROR FIFO is Full!"
	CALL	PMSG
	JP	START1
	
WRITE_ERROR:	
	LD	HL,FILL_MSG9		; "ERROR writing to I2C Port"
	CALL	PMSG
	JP	START1

;----------------------------------------------------------------------
	
READ_EEPROM:
	LD	HL,READ_MSG		; "Enter EEPROM Write Start Address (000-1FFH)"
	CALL	PMSG
	CALL	GET_HEX4		; Put 16 Bit Paramater in HL
	JP	C,DATA_READ_ERROR	; Carry set, there was a problem
	LD	A,H
	AND	A,01H			; Range is 000-1FFH for 512 Byre EEPROM
	LD	H,A 
	LD	(START_STORE),HL
	
	LD	HL,READ_MSG1		; "Enter Number of Fill Bytes (00-7FH)"
	CALL	PMSG
	CALL	GET_HEX			; Get number of bytes to send in [A]
	JP	C,DATA_FILL_ERROR
	AND	A,7FH			; Range must be 00-7FH only (1 page)
	LD	(RANGE_STORE),A		; <<< Save range in B >>

					; >>>> Display what will be done <<<<
	LD	HL,READ_MSG2		; "Will Read bytes from EEPROM starting at "
	CALL	PMSG
	LD	HL,(START_STORE)	; Print the value in HL
	CALL	PRINT_HL		; <--- START
	LD	HL,READ_MSG3		; "H,/n Press any keyboard character to display. ESC to return to the main menu.'"
	CALL	PMSG
	LD	A,(RANGE_STORE)		; <<< Range in B >>
	LD	B,A
	CALL	CHECK_ESC
	JP	NZ,BEGIN_READ
	JP	START1

BEGIN_READ:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
	LD	HL,(START_STORE)
	LD	A,H			; 68 Send to FIFO High byte address
;;;;;	OUT	(I2C_DATA),A	
	LD	A,L			; 68 Send to FIFO Low byte address
;;;;	OUT	(I2C_DATA),A	
	
;;;;	OUT	(I2C_STROBE),A		; (Port 69) Set FIFO for Read
	
;;;;	OUT	(I2C_RW),A		; (Port 6B) Pulse I2C device to set the "current address"
	CALL	DELAY	

BEGIN_READ1:
;;;;	IN	A,(I2C_RW)		; 
	CALL	DELAY
;
;;;;;	IN	A,(I2C_DATA)		; Get a byte from I2C EEPROM at its current address
	CALL	PRINT_A			; Print hex value on CRT
	
	DJNZ	BEGIN_READ1		;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
	JP	START2
	
	
DELAY:	PUSH	AF
	PUSH	BC
	LD	BC,08FFH
DELAY2:	DEC	BC
	LD	A,C
	OR	A,B
	JP	NZ,DELAY2
	POP	BC
	POP	AF
	RET
	
NEXT_READ:	
	LD	C,','
	CALL	CO
	JP	BEGIN_READ

DATA_READ_ERROR:
	LD	HL,ERROR_MSG		; "Data format error"
	CALL	PMSG
	JP	START1
	
FIFO_READ_ERROR:	
	LD	HL,FILL_MSG4		; "ERROR. FIFO is not empty after loading start address!"
	CALL	PMSG
	JP	START1
	
READ_ERROR:	
	LD	HL,FILL_MSG5		; "FIFO I2C Read error"
	CALL	PMSG
	JP	START1


;----------------------------------------------------------------------
	
MOVE_EEPROM:
	LD	HL,MOVE_MSG		; "Enter S100 Bus RAM Read Start Address (0000-FFFH):"
	CALL	PMSG
	CALL	GET_HEX4		; Put 16 Bit Paramater in HL
	JP	C,DATA_MOVE_ERROR	; Carry set, there was a problem
	LD	(S100_STORE),HL
	
	LD	HL,MOVE_MSG0		; "Enter EEPROM Read Start Address (0000-01FFH):"
	CALL	PMSG
	CALL	GET_HEX4		; Put 16 Bit Paramater in HL
	JP	C,DATA_MOVE_ERROR	; Carry set, there was a problem
	LD	(START_STORE),HL

	LD	HL,READ_MSG1		; "Enter Number of Bytes to Move (00-7FH): "
	CALL	PMSG
	CALL	GET_HEX			; Get number of bytes to send in [A]
	JP	C,DATA_MOVE_ERROR
	AND	A,7FH			; Range must be 00-7FH only (1 page)
	LD	(RANGE_STORE),A		; <<< Save range in B >>

					; >>>> Display what will be done <<<<
	LD	HL,MOVE_MSG2		; "Will Move bytes from S100 Bus RAM starting at "
	CALL	PMSG
	LD	HL,(S100_STORE)		; Print the value in HL
	CALL	PRINT_HL		; <--- START RAM
	LD	HL,MOVE_MSG2B		; "H. \n To the EEPROM starting at "
	CALL	PMSG
	LD	HL,(START_STORE)	; Print the value in HL
	CALL	PRINT_HL		; <--- START EEPROM

	LD	HL,MOVE_MSG3		; "H,/n Press any keyboard character to display. ESC to return to the main menu.'"
	CALL	PMSG
	LD	A,(RANGE_STORE)		; <<< Range in B >>
	LD	B,A
	CALL	CHECK_ESC
	JP	NZ,BEGIN_MOVE
	JP	START1

BEGIN_MOVE:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
	LD	HL,(S100_STORE)		; Pointer to S100 RAM
	LD	DE,(START_STORE)
	LD	A,D			; 68 Send to FIFO High byte address
;;;;	OUT	(I2C_DATA),A	
	LD	A,E			; 68 Send to FIFO Low byte address
;;;;;	OUT	(I2C_DATA),A	
	
;;;;;	OUT	(I2C_STROBE),A		; (Port 69) Set FIFO for Read
	
;;;;	OUT	(I2C_RW),A		; (Port 6B) Pulse I2C device to set the "current address"
	CALL	DELAY	

BEGIN_MOVE1:				; <----------- READ EEPROM
;;;;	IN	A,(I2C_RW)		;  
	CALL	DELAY

;;;;	IN	A,(I2C_DATA)		; Get a byte from I2C EEPROM at its current address
	LD	(HL),A			; Put data in S100 bus RAM
	INC	HL
	DJNZ	BEGIN_MOVE1		;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

	JP	START2

DATA_MOVE_ERROR:
	LD	HL,ERROR_MSG		; "Data format error"
	CALL	PMSG
	JP	START1
	
;-----------------------------------------------------------------------------------------------	
	
COPY_EEPROM:
	LD	HL,COPY_MSG		; "Enter S100 Bus RAM Read Start Address (0000-FFFH):"
	CALL	PMSG
	CALL	GET_HEX4		; Put 16 Bit Paramater in HL
	JP	C,DATA_COPY_ERROR	; Carry set, there was a problem
	LD	(S100_STORE),HL
	
	LD	HL,COPY_MSG0		; "Enter EEPROM Read Start Address (0000-01FFH):"
	CALL	PMSG
	CALL	GET_HEX4		; Put 16 Bit Paramater in HL
	JP	C,DATA_COPY_ERROR	; Carry set, there was a problem
	LD	(START_STORE),HL

	LD	HL,COPY_MSG1		; "Enter Number of Bytes to Move (00-7FH): "
	CALL	PMSG
	CALL	GET_HEX			; Get number of bytes to send in [A]
	JP	C,DATA_COPY_ERROR
	AND	A,7FH			; Range must be 00-7FH only (1 page)
	LD	(RANGE_STORE),A		; <<< Save range in B >>

					; >>>> Display what will be done <<<<
	LD	HL,COPY_MSG2		; "Will Copy bytes from S100 Bus starting at"
	CALL	PMSG
	LD	HL,(S100_STORE)		; Print the value in HL
	CALL	PRINT_HL		; <--- START RAM
	LD	HL,MOVE_MSG2B		; "H. \n To the EEPROM starting at "
	CALL	PMSG
	LD	HL,(START_STORE)	; Print the value in HL
	CALL	PRINT_HL		; <--- START EEPROM

	LD	HL,MOVE_MSG3		; "H,/n Press any keyboard character to start. ESC to return to the main menu.'"
	CALL	PMSG
	LD	A,(RANGE_STORE)		; <<< Range in B >>
	LD	B,A
		
BEGIN_COPY:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
	LD	HL,(START_STORE)
	LD	A,H			; Send to FIFO Low byte address
;;;;	OUT	(I2C_DATA),A	
	LD	A,L			; Send to FIFO High byte address
;;;;	OUT	(I2C_DATA),A	

	LD	A,(RANGE_STORE)		; 1 up to 7F Bytes
	LD	B,A			; Store in B
	LD	HL,(S100_STORE)		; Get back pointer to S100 bus RAM
	

COPY_LOOP:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
;;;;	IN	A,(I2C_STATUS)		; Check if FIFO is full
	BIT	4,A
	JP	NZ,FIFO_COPY_FULL
	LD	A,(HL)			; Send to FIFO Fill Data byte
	INC	HL			; Next data byte
;;;;;	OUT	(I2C_DATA),A
	DJNZ	COPY_LOOP		; <<<<<<<<<<<<< Count down B

	CALL	CRLF
	XOR	A,A	
;;;;;	OUT	(I2C_STROBE),A		; Set FIFO for Read
   					; Note the hardware will make sure all data is sent before Enable in lowered

;;;;	OUT	(I2C_RW),A		; Pulse Write to transfer FIFO data to I2C Module
					; Note, no need to test busy flag as the FIFO is controlled by this signal

;;;;	IN	A,(I2C_STATUS)		; Check if FIFO is full
	BIT	5,A
	JP	NZ,FIFO_COPY_FULL

	LD	HL,COPY_MSG7		; "EEPROM Filled!"
	CALL	PMSG
	JP	START2

DATA_COPY_ERROR:
	LD	HL,ERROR_MSG		; "Data format error"
	CALL	PMSG
	JP	START1

	
FIFO_COPY_FULL:	
	LD	HL,FILL_MSG8		; "ERROR FIFO is Full!"
	CALL	PMSG
	JP	START1
	

;<<<<<<<<<<<<<<<<<<<<<<<<< SUPPORT ROUTINES >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

PMSG:	PUSH	BC		; Only [A] and [HL] is changed
PMSG1:	LD	A,(HL)		; A ROUTINE TO PRINT OUT A STRING @ [HL]
	INC	HL		; UP TO THE FIRST 0.
	OR	A,A
	JP	Z,PMSG_DONE
	LD	C,A
	CALL	CO
	JP	PMSG1
PMSG_DONE:
	POP	BC
	RET

CRLF:	PUSH	BC
	LD	C,CR
	CALL	CO
	LD	C,LF
	CALL	CO
	POP	BC
	RET

; GET A CHARACTER, convert to UC, ECHO it
GETCMD:	CALL	CI		
	CALL	UCASE
	CP	A,ESC
	RET	Z		;Don't echo an ESC
	PUSH	AF		;Save it
	PUSH	BC
	LD	C,A
	CALL	CO		;Echo it
	POP	BC
	POP	AF		;get it back
	RET
;				;Convert LC to UC
UCASE:	CP	A,'a'		;must be >= lowercase a
	RET	C		; else go back...
	CP	A,'z'+1		;must be <= lowercase z
	RET	NC		; else go back...
	SUB	A,'a'-'A'	;subtract lowercase bias
	RET

; Check if next character is a ESC
CHECK_ESC:
	CALL	CI
	CP	A,ESC
	RET			; Return Z if ESC character.
	
; Check if next character is a CR
CHECK_CR:
	CALL	CI
	CP	A,CR
	RET			; Return Z if ESC character.
	
; Return with 2 HEX digits in [A]. If abort, Carry flag set + ESC in [A]
GET_HEX:
	PUSH	BC			
	CALL	GETCMD		;Get a character from keyboard & ECHO
	CP	A,ESC
	JR	Z,HEX_ABORT
	CP	'/'		;check 0-9, A-F
	JR	C,HEX_ABORT
	CP	'F'+1
	JR	NC,HEX_ABORT
	CALL	ASBIN		;Convert to binary
	SLA	A
	SLA	A
	SLA	A
	SLA	A		;Shift to high nibble	
	LD	B,A		;Store it
	CALL	GETCMD		;Get 2nd character from keyboard & ECHO
	CP	A,ESC
	JR	Z,HEX_ABORT
	CP	'/'		;check 0-9, A-F
	JR	C,HEX_ABORT
	CP	'F'+1
	JR	NC,HEX_ABORT
	CALL	ASBIN		;Convert to binary
	OR	A,B		;add in the first digit
	OR	A,A		;To return NC
	POP	BC
	RET
	
HEX_ABORT:
	SCF			;Set Carry flag 
	LD	A,ESC
	POP	BC
	RET
;
;
; Put 4 HEX characters in [HL] 
GET_HEX4:	
	LD      H,0000H
	CALL	GET_HEX		;get 2 HEX digits
	JR	C,SCAN_ABORT
	LD	H,A
	CALL	GET_HEX		;get 2 more HEX digits
	JR	C,SCAN_ABORT
	LD	L,A
	OR	A,A		;To return NC
	RET
	
SCAN_ABORT:
	SCF			;Set Carry flag 
	RET

; ASCII TO BINARY CONVERSION ROUTINE
ASBIN:	SUB	30H 
	CP	0AH 
	RET	M
	SUB	07H 
	RET
;	
;
; PRINT [HL] ON CONSOL
PRINT_HL:
	LD	A,H
	CALL	PRINT_A
	LD	A,L
PRINT_A:
	PUSH	AF
	RRCA
	RRCA
	RRCA
	RRCA
	CALL	SF598
	POP	AF
SF598:	CALL	CONV
	JP	CO

; CONVERT HEX TO ASCII
CONV:	AND	0FH
	ADD	A,90H
	DAA 
	ADC	A,40H
	DAA 
	LD	C,A
	RET
	
; DISPLAY 8 BITS OF [A] (No registers changed)
; DISPLAY BIT PATTERN IN [A]
ZBITS:	PUSH	AF
	PUSH	BC
	PUSH	DE
	LD	E,A		
	LD	B,8
BQ2:	SLA	E	
	LD	A,18H
	ADC	A,A
	LD	C,A
	CALL	CO
	DJNZ	BQ2
	POP	DE
	POP	BC
	POP	AF
	RET

;<<<<<<<<<<<<<<<<<<<<<< MAIN CONSOL OUTPUT ROUTINE >>>>>>>>>>>>>>>>>>>>>>>>>
;
CO:	IN	A,(CONSTAT)	; SD SYSTEMS or PROPELLER VIDIO BOARD PORT
	AND	4H
	JP	Z,CO
	LD	A,C
	OUT	(CONOUT),A
	RET			; RETURN CHARACTER SENT IN [A]
 
;<<<<<<<<<<<<<<<<<<< MAIN CONSOL STATUS ROUTINE >>>>>>>>>>>>>>>>>>>>>>
;
CSTS:	IN	A,(CONSTAT)
	AND	02H
	RET	Z
	XOR	A
	DEC	A		; RETURN WITH 0FFH IN [A] IF SOMETHING
	RET

;<<<<<<<<<<<<<<<<<<<< MAIN CONSOL INPUT ROUTINE >>>>>>>>>>>>>>>>>>>>
;
CI:	IN 	A,(CONSTAT)	; NEED CONSTAT TO CLEAN UP SHIFT KEYS ETC
	AND	02H
	JR	Z,CI
	IN	A,(CONIN)
	AND	7FH
	RET

;---------------------------------------------------------------------------------------
SIGNON:		DB	CR,LF
		DB	CR,LF,'Test program for SPI_8 interface of S100Computers.com FPGA Prototype board'
		DB	CR,LF,'By John Monahan S100Computers.COM  (V1.0)  1/5/2019'
		DB	CR,LF,'Note: 1. The test is with an SPI ATS5128 EEPROM'
		
SIGNON1:	DB	CR,LF,LF,'---------- Main Menu ---------------------------------------'
		DB	CR,LF,'0.   Read a single byte from a location in the SPI EEPROM.'
		DB	CR,LF,'1.   Fill up to a page of the SPI EEPROM with a Byte value.'
		DB	CR,LF,'2.   Write bytes to the EEPROM.'
		DB	CR,LF,'3.   Read bytes from the EEPROM.'
		DB	CR,LF,'4.   Move up to a page of the EEPROM to S100 bus RAM.'
		DB	CR,LF,'5.   Copy up to a page of S100 bus RAM to the EEPROM.'
		DB	CR,LF,'ESC  To abort program.',CR,LF,0H

MENU_MSG:	DB	BELL,BELL,CR,LF,'Menu error.',0


;-----		
FILL_MSG:	DB	CR,LF,'Enter EEPROM Fill Start Address (0000-01FFH): ',0H		
MSG0:		DB	CR,LF,'Enter EEPROM Address (0000-01FFH): ',0H		
FILL_MSG1:	DB	CR,LF,'Enter Number of Fill Bytes (00-7FH): ',0H		
FILL_MSG2:	DB	CR,LF,'Enter Fill Value (00-FFH): ',0H		

FILL_MSG3:	DB	CR,LF,LF,'Fill EEPROM starting at ',0H		
FILL_MSG4:	DB	'H for ',0H		
FILL_MSG5:	DB	'H bytes with a fill value of ',0H	
FILL_MSG6:	DB	'H.'
		DB	CR,LF,'Press any character to continue. ESC to return to the main menu.',0H	
FILL_MSG7:	DB	CR,LF,'EEPROM Filled.',CR,LF,0H
FILL_MSG8:	DB	CR,LF,BELL,'ERROR, FIFO is Full!',CR,LF,0H
FILL_MSG9:	DB	CR,LF,BELL,'ERROR writing to I2C Port!',CR,LF,0H
	
ERROR_MSG:	DB	BELL,BELL,CR,LF,'Data format error',0
ERROR_MSG2:	DB	BELL,BELL,CR,LF,'Data range error',0


WRITE_MSG:	DB	CR,LF,'Enter EEPROM Write Start Address (0000-01FFH): ',0H		
WRITE_MSG1:	DB	CR,LF,'Enter bytes in form:- xx,xx,xx..., CR to stop',CR,LF,0H		
WRITE_MSG2:	DB	CR,LF,LF,'Will write to EEPROM starting at ',0H		
WRITE_MSG3:	DB	'H with ',0H
WRITE_MSG4:	DB	'H Bytes of data.',0H		
WRITE_MSG5:	DB	CR,LF,'Press any character to continue. ESC to return to the main menu.',0H	
WRITE_MSG6:	DB	'H bytes with a fill value of ',0H	
WRITE_MSG7:	DB	'Bytes written to EEPROM OK',0H	

READ_MSG:	DB	CR,LF,'Enter EEPROM Read Start Address (0000-01FFH): ',0H		
READ_MSG1:	DB	CR,LF,'Enter Number of Bytes to Display (00-7FH): ',0H		
READ_MSG2:	DB	CR,LF,LF,'Will Read bytes from EEPROM starting at ',0H		
READ_MSG2A:	DB	CR,LF,LF,'Will Read Byte from EEPROM at ',0H		
READ_MSG2B:	DB	CR,LF,LF,'Byte = ',0H		
READ_MSG3:	DB	'H',CR,LF
		DB	'Press any keyboard to display. Press ESC to return to the main menu.',CR,LF,LF,0H	
READ_MSG3A:	DB	'H',CR,LF,0H
READ_MSG4:	DB	CR,LF,BELL,'ERROR. FIFO is not empty after loading start address!',CR,LF,0H
READ_MSG5:	DB	CR,LF,BELL,'FIFO I2C Read error!',CR,LF,0H


MOVE_MSG:	DB	CR,LF,'Enter S100 Bus RAM Read Start Address (0000-FFFH): ',0H		
MOVE_MSG0:	DB	CR,LF,'Enter EEPROM Read Start Address (0000-01FFH): ',0H
MOVE_MSG1:	DB	CR,LF,'Enter Number of Bytes to Move (00-7FH): ',0H		
MOVE_MSG2:	DB	CR,LF,LF,'Will Move bytes from S100 Bus RAM starting at ',0H		
MOVE_MSG2B:	DB	'H',
		DB	CR,LF,'To the EEPROM starting at ',0H		
MOVE_MSG3:	DB	'H',CR,LF
		DB	'Press any keyboard to start. Press ESC to return to the main menu.',CR,LF,LF,0H

COPY_MSG:	DB	CR,LF,'Enter S100 Bus RAM Read Start Address (0000-FFFH): ',0H		
COPY_MSG0:	DB	CR,LF,'Enter EEPROM Read Start Address (0000-01FFH): ',0H
COPY_MSG1:	DB	CR,LF,'Enter Number of Bytes to Move (00-7FH): ',0H		
COPY_MSG2:	DB	CR,LF,LF,'Will Copy bytes from S100 Bus starting at ',0H		
COPY_MSG2B:	DB	'H',
		DB	CR,LF,'To the EEPROM starting at ',0H		
COPY_MSG3:	DB	'H',CR,LF
		DB	'Press any keyboard to start. Press ESC to return to the main menu.',CR,LF,LF,0H
COPY_MSG7:	DB	'Bytes written to EEPROM OK',0H	


START_OF_STORE:	DB	'>>>>>>>>>>>>>>>>>>>>>>>>>'		
START_STORE:	DW	0H   ;<--- Note:- Low Byte,High Byte
RANGE_STORE:	DB	0H
DATA_STORE:	DB	0H
S100_STORE:	DW	0H
END_OF_STORE:	DB	'<<<<<<<<<<<<<<<<<<<<<<<<<'
		
BYTE_STRING:	DS	80H
;
	DS	40H
STACK:	DB	0H
; END
	



