;Program for SPI interface to the RTC (U2) on the S100Computers.com Z80_FPGA Board.
;Will Read or Write to an DS1305 RTC chip 
;
;	John Monahan	S100Computers.com	8/2/2019
;
;
;V1.0		7/30/2019	;First version. It is "rough & ready" with little menu etc. error checking etc.
;				;Note address input Hex values must be 4 digits. Data (byte) values 2 digits
;	PORT ASSIGNMENTS
;
SPI_BASE_PORT	EQU	068H			; Base I/O port fot SPI module
SPI_ADDRESS_OUT	EQU	SPI_BASE_PORT		; 68H, Data OUT port from SPI module to RTC
SPI_DATA_OUT	EQU	SPI_BASE_PORT+1		; 69H, Data OUT port from SPI module to RTC
SPI_DATA_IN	EQU	SPI_BASE_PORT+1		; 69H, Data IN from EEPROM
SPI_CS		EQU	SPI_BASE_PORT+2		; 6AH, CS Data OUT port to SPI/EEPROM module
SPI_STATUS	EQU	SPI_BASE_PORT+2		; 6AH, Busy Flag IN port from SPI/EEPROM

SPI_READ	EQU	SPI_BASE_PORT+3		; 6B, Read pulse to SPI module
SPI_WRITE	EQU	SPI_BASE_PORT+3		; 6B, Write pulse to SPI module

RTC_CS_LOW		EQU	00H		; Bit 0 has CS  (Note, HIGH to select chip)
RTC_CS_HIGH		EQU	01H			

RTC_SECONDS	EQU	0H			;All registers OR 80H for WRITE Address
RTC_MINUTES	EQU	1H
RTC_HOURS	EQU	2H
RTC_DAY		EQU	3H
RTC_DATE	EQU	4H
RTC_MONTH	EQU	5H
RTC_YEAR	EQU	6H

RTC_CTL_REG	EQU	0FH
RTC_STATUS_REG	EQU	10H
RTC_RAM		EQU	20H			;20H -- 7FH

ENABLE_OSC	EQU	80H			;Bit to enable/start the RTC chip (0=start, 1=stop)
WP		EQU	40H			;Write Protect. Bit must be 0 to alter any other register. 
						;Note alarms etc are not implemented in this simple example.
						
CONSTAT			EQU	0H		; Console Status Port
CONIN			EQU	1H		; Console IN Port
CONOUT			EQU	1H		; Console OUT Port

MONITOR			EQU	0F000H		; Location of Z80 ROM monitor when done.

BELL			EQU	07H
ESC			EQU	1BH
CR			EQU	0DH
LF			EQU	0AH

;------------------------------------------------------------------------------------------

	ORG	100H
	
START:	LD	SP,STACK
	LD	HL,SIGNON
	CALL	PMSG

START2:	LD	A,RTC_CS_LOW			;Deselect RTC chip SPI interface (Note HIGH for CS)
	OUT	(SPI_CS),A
	
	LD	HL,SIGNON1
	CALL	PMSG
	CALL	CRLF				;Normal start within menu
	LD	C,'>'	   
	CALL	CO
	CALL	CI
	CP	A,ESC
	JP	NZ,START3
	JP	MONITOR
	
START3:	CP	A,'0'
	JP	Z,ACTIVATE_RTC
	CP	A,'1'
	JP	Z,READ_SECONDS
	CP	A,'2'
	JP	Z,WRITE_RAM
	CP	A,'3'
	JP	Z,READ_RAM
	CP	A,'4'
	JP	Z,SET_TIME
	CP	A,'5'
	JP	Z,READ_TIME
	CP	A,'6'
	JP	Z,DISPLAY_RGS
	CALL	MENU_ERROR
	JP	START2

MENU_ERROR:
	LD	HL,MENU_MSG		; "Menu error"
	CALL	PMSG
	RET
 
 DATA_ERROR:
	LD	HL,FORMAT_ERR_MSG	; "DATA  error"
	CALL	PMSG
	JP	START2
	
;-------------------------------------------------------------------------------------------------
ACTIVATE_RTC:
	LD	HL,MSG0			; "Activate RTC Chip"
	CALL	PMSG
	
	LD	B,RTC_CTL_REG OR 80H	; RTC Register address + Write
	LD	C,00000000B		; ENABLE_OSC, Bit 7 to enable/start the RTC chip (0=start, 1=stop)
	CALL	WRITE_SPI		; <<<< Send Write pulse (Address + DATA)
	JP	START2
	
READ_SECONDS:
	LD	HL,MSG1			; "1 = Read Seconds Register from RTC Chip"
	CALL	PMSG
	
	LD	B,RTC_SECONDS		; Seconds Register address + READ
	CALL	READ_SPI		; <<< Send Read pulse (Address, get DATA), return result in [A]

	PUSH	AF			; Save it
	LD	HL,MSG2			; "RTC Seconds Register = "
	CALL	PMSG
	POP	AF
	CALL	PRINT_A			; Display Returned SPI PROM Byte
	CALL	CRLF
	JP	START2

WRITE_RAM:
	LD	HL,MSG3			; "2",CR,LF,Enter RAM location (20H-7FH) "
	CALL	PMSG
	
	CALL	GET_HEX
	JP	C,DATA_ERROR
	OR	A,80H			; Add write bit
	LD	D,A			; RAM Location to D (with Write bit)
	LD	HL,MSG4			; 'Enter Byte value " 
	CALL	PMSG
	CALL	GET_HEX
	JP	C,DATA_ERROR
	LD	E,A			; Save above values in DE

	LD	C,A			; Value to write to RAM
	LD	B,D			; Get the above saved address			
	CALL	WRITE_SPI		; <<<  Send Write pulse (Address in B, data in C)

	LD	HL,MSG5			; "Wrote" 
	CALL	PMSG
	LD	A,E
	CALL	PRINT_A
	LD	HL,MSG6			; " to RAM location 	
	CALL	PMSG
	LD	A,D
	AND	A,7FH			; Strip Write bit
	CALL	PRINT_A
	LD	HL,MSG7			; "  in RTC"	
	CALL	PMSG
	CALL	CRLF
	JP	START2
	
READ_RAM:
	LD	HL,MSG8			; "3 CR,LF,Enter RAM location (20H-7FH) "
	CALL	PMSG

	CALL	GET_HEX
	JP	C,DATA_ERROR
	LD	D,A			; Save RAM Location to D

	LD	B,A			; RAM Location to B
	CALL	READ_SPI		; <<< Send Read pulse (Address, get DATA), return result in [A]

	PUSH	AF			; Save data
	LD	HL,MSG9			; "RAM location "
	CALL	PMSG
	LD	A,D
	CALL	PRINT_A
	LD	HL,MSG10		; " H = "	
	CALL	PMSG
	POP	AF
	CALL	PRINT_A
	LD	HL,MSG11		; "  in RTC"	
	CALL	PMSG
	CALL	CRLF
	JP	START2
	
SET_TIME:
	LD	HL,MSG12		; "4",CR,LF,'Enter Year (00-99) '
	CALL	PMSG
	CALL	GET_HEX
	JP	C,DATA_ERROR
	LD	(YEAR),A	
	LD	B,RTC_YEAR OR 80H	; RTC Register address + Write
	LD	C,A		
	CALL	WRITE_SPI		; <<<< Send Write pulse (Address + DATA)

	LD	HL,MSG13		; CR,LF,'Enter Month (01-12) '
	CALL	PMSG
	CALL	GET_HEX
	JP	C,DATA_ERROR
	LD	(MONTH),A
	LD	B,RTC_MONTH OR 80H	; RTC Register address + Write
	LD	C,A		
	CALL	WRITE_SPI		; <<<< Send Write pulse (Address + DATA)

	LD	HL,MSG14		; CR,LF,'Enter Date (01-31) '
	CALL	PMSG
	CALL	GET_HEX
	JP	C,DATA_ERROR
	LD	(DATE),A
	LD	B,RTC_DATE OR 80H	; RTC Register address + Write
	LD	C,A		
	CALL	WRITE_SPI		; <<<< Send Write pulse (Address + DATA)
	
	LD	HL,MSG15		; CR,LF,'Enter Hours (00-23) '
	CALL	PMSG
	CALL	GET_HEX
	JP	C,DATA_ERROR
	LD	(HOURS),A
	LD	B,RTC_HOURS OR 80H	; RTC Register address + Write
	LD	C,A		
	CALL	WRITE_SPI		; <<<< Send Write pulse (Address + DATA)

	LD	HL,MSG16		; CR,LF,'Enter Minutes (00-59) '
	CALL	PMSG
	CALL	GET_HEX
	JP	C,DATA_ERROR
	LD	(MINUTES),A
	LD	B,RTC_MINUTES OR 80H	; RTC Register address + Write
	LD	C,A		
	CALL	WRITE_SPI		; <<<< Send Write pulse (Address + DATA)
	
	LD	HL,MSG17		; CR,LF,'Enter Seconds (00-59) '
	CALL	PMSG
	CALL	GET_HEX
	JP	C,DATA_ERROR
	LD	(SECONDS),A
	LD	B,RTC_SECONDS OR 80H	; RTC Register address + Write
	LD	C,A		
	CALL	WRITE_SPI		; <<<< Send Write pulse (Address + DATA)
	
	LD	HL,MSG18		; CR,LF,'Entered:- 20'
	CALL	PMSG
	LD	A,(YEAR)
	CALL	PRINT_A
	LD	C,'/'
	CALL	CO
	LD	A,(MONTH)
	CALL	PRINT_A
	LD	C,'/'
	CALL	CO
	LD	A,(DATE)
	CALL	PRINT_A
	LD	HL,MSG19		; '  Time= '
	CALL	PMSG
	LD	A,(HOURS)
	CALL	PRINT_A
	LD	C,'/'
	CALL	CO
	LD	A,(MINUTES)
	CALL	PRINT_A
	LD	C,'/'
	CALL	CO
	LD	A,(SECONDS)
	CALL	PRINT_A
	CALL	CRLF
	JP	START2
	
	
READ_TIME:
	LD	HL,MSG20		; "5",CR,LF,'Date = '
	CALL	PMSG

	LD	B,RTC_YEAR		; Year Register address + READ
	CALL	READ_SPI		; <<< Send Read pulse (Address, get DATA), return result in [A]
	CALL	PRINT_A
	LD	C,'/'
	CALL	CO

	LD	B,RTC_MONTH		; Month Register address + READ
	CALL	READ_SPI		; <<< Send Read pulse (Address, get DATA), return result in [A]
	CALL	PRINT_A
	LD	C,'/'
	CALL	CO

	LD	B,RTC_DATE		; Date Register address + READ
	CALL	READ_SPI		; <<< Send Read pulse (Address, get DATA), return result in [A]
	CALL	PRINT_A

	LD	HL,MSG19		; '  Time= '
	CALL	PMSG

	LD	B,RTC_HOURS		; Hours Register address + READ
	CALL	READ_SPI		; <<< Send Read pulse (Address, get DATA), return result in [A]
	CALL	PRINT_A
	LD	C,'/'
	CALL	CO

	LD	B,RTC_MINUTES		; Minutes Register address + READ
	CALL	READ_SPI		; <<< Send Read pulse (Address, get DATA), return result in [A]
	CALL	PRINT_A
	LD	C,'/'
	CALL	CO

	LD	B,RTC_SECONDS		; Seconds Register address + READ
	CALL	READ_SPI		; <<< Send Read pulse (Address, get DATA), return result in [A]
	CALL	PRINT_A

	CALL	CRLF
	JP	START2


DISPLAY_RGS:
	LD	HL,MSG21		; "6",CR,LF,'Register Dump:-'
	CALL	PMSG
	LD	HL,MSG22		; 'Register (00H - 06H)  '
	CALL	PMSG

	LD	D,07H			;Count
	LD	B,00H			;Register pointer
REGS_1:	CALL	READ_SPI		; <<< Send Read pulse (Address, get DATA), return result in [A]
	CALL	PRINT_A
	LD	C,' '
	CALL	CO
	INC	B																				
	DEC	D
	LD	A,D
	OR	A,A
	JP	NZ,REGS_1

	LD	HL,MSG23		; 'Register (07H - 0EH)  '
	CALL	PMSG

	LD	D,08H			;Count
	LD	B,09H			;Register pointer
REGS_2:	CALL	READ_SPI		; <<< Send Read pulse (Address, get DATA), return result in [A]
	CALL	PRINT_A
	LD	C,' '
	CALL	CO
	INC	B																				
	DEC	D
	LD	A,D
	OR	A,A
	JP	NZ,REGS_2

	LD	HL,MSG24		; 'Register (0FH - 11H)  '
	CALL	PMSG

	LD	D,03H			;Count
	LD	B,0FH			;Register pointer
REGS_3:	CALL	READ_SPI		; <<< Send Read pulse (Address, get DATA), return result in [A]
	CALL	PRINT_A
	LD	C,' '
	CALL	CO
	INC	B																				
	DEC	D
	LD	A,D
	OR	A,A
	JP	NZ,REGS_3
	CALL	CRLF
	JP	START2





;------------------------ SPI CORE ROUTINES ---------------------------------------------------------

WRITE_SPI:				; [C] contains DATA, [B] contains Register address
	LD	A,RTC_CS_HIGH		; Select RTC
	OUT	(SPI_CS),A
		
	LD	A,C			; <<<---- Send data first
	OUT	(SPI_ADDRESS_OUT),A
	LD	A,B			; <<<---- Then send address  (the two are flipped in the module)
	OUT	(SPI_DATA_OUT),A
	OUT	(SPI_WRITE),A		; (Port 6B) Send Write pulse 
	CALL	DELAY
	
	LD	A,RTC_CS_LOW		; De-select RTC
	OUT	(SPI_CS),A
	RET



READ_SPI:
	LD	A,RTC_CS_HIGH		; Select RTC
	OUT	(SPI_CS),A
READ_SPI1:
	LD	A,B			; <<<---- Send address (only)
	OUT	(SPI_DATA_OUT),A
	IN	A,(SPI_READ)		; Send Read pulse (Port 6B)
	CALL	DELAY
	
	IN	A,(SPI_DATA_IN)		; <<< Get SPI data returned in [A]
	PUSH	AF
	CALL	DELAY

	LD	A,RTC_CS_LOW		; De-select RTC
	OUT	(SPI_CS),A
	POP	AF
	RET				;Return with value in [A]


DELAY:	PUSH	HL
	LD	HL,40H			;Extra time required for RTC to write multiple data bytes
DELAY1:	DEC	HL			;before Status is valid	
	LD	A,H
	OR	A,L
	JR	NZ,DELAY1
	POP	HL
DELAY2:	IN	A,(SPI_STATUS)		; Wait until busy is low
	OR	A,A
	JR	NZ,DELAY2
	RET

;<<<<<<<<<<<<<<<<<<<<<<<<< SUPPORT ROUTINES >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

PMSG:	PUSH	BC		; Only [A] and [HL] is changed
PMSG1:	LD	A,(HL)		; A ROUTINE TO PRINT OUT A STRING @ [HL]
	INC	HL		; UP TO THE FIRST 0.
	OR	A,A
	JP	Z,PMSG_DONE
	LD	C,A
	CALL	CO
	JP	PMSG1
PMSG_DONE:
	POP	BC
	RET

CRLF:	PUSH	BC
	LD	C,CR
	CALL	CO
	LD	C,LF
	CALL	CO
	POP	BC
	RET

SPACE:  PUSH	BC
	LD	C,20H
	CALL	CO
	POP	BC
	RET


; GET A CHARACTER, convert to UC, ECHO it
GETCMD:	CALL	CI		
	CALL	UCASE
	CP	A,ESC
	RET	Z		;Don't echo an ESC
	PUSH	AF		;Save it
	PUSH	BC
	LD	C,A
	CALL	CO		;Echo it
	POP	BC
	POP	AF		;get it back
	RET
;				;Convert LC to UC
UCASE:	CP	A,'a'		;must be >= lowercase a
	RET	C		; else go back...
	CP	A,'z'+1		;must be <= lowercase z
	RET	NC		; else go back...
	SUB	A,'a'-'A'	;subtract lowercase bias
	RET

; Check if next character is a ESC
CHECK_ESC:
	CALL	CI
	CP	A,ESC
	RET			; Return Z if ESC character.
	
; Check if next character is a CR
CHECK_CR:
	CALL	CI
	CP	A,CR
	RET			; Return Z if ESC character.
	
; Return with 2 HEX digits in [A]. If abort, Carry flag set + ESC in [A]
GET_HEX:
	PUSH	BC			
	CALL	GETCMD		;Get a character from keyboard & ECHO
	CP	A,ESC
	JR	Z,HEX_ABORT
	CP	'/'		;check 0-9, A-F
	JR	C,HEX_ABORT
	CP	'F'+1
	JR	NC,HEX_ABORT
	CALL	ASBIN		;Convert to binary
	SLA	A
	SLA	A
	SLA	A
	SLA	A		;Shift to high nibble	
	LD	B,A		;Store it
	CALL	GETCMD		;Get 2nd character from keyboard & ECHO
	CP	A,ESC
	JR	Z,HEX_ABORT
	CP	'/'		;check 0-9, A-F
	JR	C,HEX_ABORT
	CP	'F'+1
	JR	NC,HEX_ABORT
	CALL	ASBIN		;Convert to binary
	OR	A,B		;add in the first digit
	OR	A,A		;To return NC
	POP	BC
	RET
	
HEX_ABORT:
	SCF			;Set Carry flag 
	LD	A,ESC
	POP	BC
	RET
;
;
; Put 4 HEX characters in [HL] 
GET_HEX4:	
	LD      H,0000H
	CALL	GET_HEX		;get 2 HEX digits
	JR	C,SCAN_ABORT
	LD	H,A
	CALL	GET_HEX		;get 2 more HEX digits
	JR	C,SCAN_ABORT
	LD	L,A
	OR	A,A		;To return NC
	RET
	
SCAN_ABORT:
	SCF			;Set Carry flag 
	RET

; ASCII TO BINARY CONVERSION ROUTINE
ASBIN:	SUB	30H 
	CP	0AH 
	RET	M
	SUB	07H 
	RET
;	
;
; PRINT [HL] ON CONSOL
PRINT_HL:
	LD	A,H
	CALL	PRINT_A
	LD	A,L
PRINT_A:
	PUSH	AF
	RRCA
	RRCA
	RRCA
	RRCA
	CALL	SF598
	POP	AF
SF598:	CALL	CONV
	JP	CO

; CONVERT HEX TO ASCII
CONV:	AND	0FH
	ADD	A,90H
	DAA 
	ADC	A,40H
	DAA 
	LD	C,A
	RET
	
; DISPLAY 8 BITS OF [A] (No registers changed)
; DISPLAY BIT PATTERN IN [A]
ZBITS:	PUSH	AF
	PUSH	BC
	PUSH	DE
	LD	E,A		
	LD	B,8
BQ2:	SLA	E	
	LD	A,18H
	ADC	A,A
	LD	C,A
	CALL	CO
	DJNZ	BQ2
	POP	DE
	POP	BC
	POP	AF
	RET

;<<<<<<<<<<<<<<<<<<<<<< MAIN CONSOL OUTPUT ROUTINE >>>>>>>>>>>>>>>>>>>>>>>>>
;
CO:	IN	A,(CONSTAT)	; SD SYSTEMS or PROPELLER VIDIO BOARD PORT
	AND	4H
	JP	Z,CO
	LD	A,C
	OUT	(CONOUT),A
	RET			; RETURN CHARACTER SENT IN [A]
 
;<<<<<<<<<<<<<<<<<<< MAIN CONSOL STATUS ROUTINE >>>>>>>>>>>>>>>>>>>>>>
;
CSTS:	IN	A,(CONSTAT)
	AND	02H
	RET	Z
	XOR	A
	DEC	A		; RETURN WITH 0FFH IN [A] IF SOMETHING
	RET

;<<<<<<<<<<<<<<<<<<<< MAIN CONSOL INPUT ROUTINE >>>>>>>>>>>>>>>>>>>>
;
CI:	IN 	A,(CONSTAT)	; NEED CONSTAT TO CLEAN UP SHIFT KEYS ETC
	AND	02H
	JR	Z,CI
	IN	A,(CONIN)
	AND	7FH
	RET

;---------------------------------------------------------------------------------------
SIGNON:		DB	CR,LF
		DB	CR,LF,'SPI interface to the RTC (U2) on Z80_FPGA Board.'
		DB	CR,LF,'By John Monahan S100Computers.COM  (V1.0)  8/3/2019'
		DB	CR,LF,'Note: This test is with a Maxim DS1305 RTC chip only.',0
		
SIGNON1:	DB	CR,LF,LF,'---------- Main Menu ---------------'
		DB	CR,LF,'0.   Activate Maxim DS1305 RTC chip.'
		DB	CR,LF,'1.   Read Seconds Register from RTC Chip.'
		DB	CR,LF,'2.   Write byte to RAM at a specified location in RTC.'
		DB	CR,LF,'3.   Read byte from RAM at a specified location in RTC.'
		DB	CR,LF,'4.   Set Time & Date.'
		DB	CR,LF,'5.   Read Time & Date.'
		DB	CR,LF,'6.   Display all RTC Registers.'
		DB	CR,LF,'ESC  To abort program.',CR,LF,0H

MENU_MSG:	DB	BELL,BELL,CR,LF,'Menu error.',0
FORMAT_ERR_MSG: DB	BELL,BELL,CR,LF,'Data Format error.',0
CMD_DONE:	DB	CR,LF,'Command Done.',CR,LF,LF,0


MSG0:		DB	'0 = Activate RTC Chip.',0	
MSG1:		DB	'1 = Read Seconds Register from RTC Chip.'0
MSG2:		DB	CR,LF,'RTC Seconds Register = ',0	
MSG3:		DB	'2',CR,LF,'Enter RAM location (20H-7FH) ',0
MSG4:		DB	CR,LF,'Enter Byte value ',0
MSG5:		DB	CR,LF,'Wrote ',0 
MSG6:		DB	'H to RAM location ',0
MSG7:		DB	'H in RTC',0
MSG8:		DB	'3',CR,LF,'Enter RAM location (20H-7FH) ',0
MSG9:		DB	CR,LF,'RAM location ',0
MSG10:		DB	'H = ',0
MSG11:		DB	'H in RTC',0
MSG12:		DB	'4',CR,LF,'Enter Year (00-99) ',0
MSG13:		DB	CR,LF,'Enter Month (01-12) ',0
MSG14:		DB	CR,LF,'Enter Date (01-31) ',0
MSG15:		DB	CR,LF,'Enter Hours (00-23) ',0
MSG16:		DB	CR,LF,'Enter Minutes (00-59) ',0
MSG17:		DB	CR,LF,'Enter Seconds (00-59) ',0
MSG18:		DB	CR,LF,LF,'Entered:- 20',0
MSG19:		DB	'  Time = ',0
MSG20:		DB	'5',CR,LF,'Date = 20',0
MSG21		DB	'6',CR,LF,'Register Dump:-',0
MSG22		DB	CR,LF,'Registers (00H - 06H)  ',0
MSG23		DB	CR,LF,'Registers (07H - 0EH)  ',0
MSG24		DB	CR,LF,'Registers (0FH - 11H)  ',0

YEAR:	DB	00H
MONTH:	DB	00H
DATE:	DB	00H
HOURS:	DB	00H
MINUTES: DB	00H
SECONDS: DB	00H


	DS	40H
STACK:	DB	0H

; END
	



