;Test program for SD_CARD interface of S100Computers.com FPGA Prototype board.
;
;	John Monahan	S100Computers.com	12/20/2018
;
;
;V1.0		8/9/2019	;First version. It is "rough & ready" with little menu etc. error checking etc.

;	PORT ASSIGNMENTS
;
SD_CARD_BASE	EQU	06CH

DISK_DATA_OUT   EQU	SD_CARD_BASE	; (6CH) Data TO port to SD CONTRROLLER
DISK_DATA_IN    EQU	SD_CARD_BASE	; (6CH) Data TO port to SD CONTRROLLER
DISK_CONTINUE	EQU	SD_CARD_BASE+1	; (6DH) HIGH FOR SPI MULTIPLE BYTES
DISK_CS		EQU	SD_CARD_BASE+2	; (6EH) Disk Select 
DISK_STATUS	EQU	SD_CARD_BASE+2	; (6EH) Disk Status
DISK_RW		EQU	SD_CARD_BASE+3	; (6FH) Port to pulse SPI Read/Write
					
CONSTAT		EQU	0H		; Console Status Port
CONIN		EQU	1H		; Console IN Port
CONOUT		EQU	1H		; Console OUT Port

MONITOR		EQU	0F000H		;Location of Z80 ROM monitor when done.

SPACE		EQU	20H
BELL		EQU	07H
ESC		EQU	1BH
CR		EQU	0DH
LF		EQU	0AH

;SD CARD Interface Status:-
RST		EQU	0;
INIT		EQU	1;
CMD0		EQU	2;
CMD55		EQU	3;
CMD41		EQU	4;
POLL_CMD	EQU	5;
    
IDLE		EQU	6;   <<<<<

READ_BLOCK	EQU	7;
READ_BLOCK_WAIT EQU	8;
READ_BLOCK_DATA EQU	9;
READ_BLOCK_CRC	EQU	10;
SEND_CMD	EQU	11;
RECEIVE_BYTE_WAIT EQU	12;
RECEIVE_BYTE	 EQU	13;
WRITE_BLOCK_CMD  EQU	14;
WRITE_BLOCK_INIT EQU	15;
WRITE_BLOCK_DATA EQU	16;
WRITE_BLOCK_BYTE EQU	17;
WRITE_BLOCK_WAIT EQU	18;

DISK_READY		EQU	7;
READY_FOR_NEXT_BYTE	EQU	6;
BYTE_AVAILABLE		EQU	5;

	ORG	100H
START:
	LD	SP,STACK
	LD	HL,SIGNON
	CALL	PMSG
	
START1:	LD	HL,SIGNON1
	CALL	PMSG
START2:	CALL	CRLF
	LD	C,'>'	   
	CALL	CO
	CALL	CI
	CP	A,ESC
	JP	NZ,START3
	JP	MONITOR
START3:	CP	A,'0'
	JP	Z,RESET
	CP	A,'1'
	JP	Z,FILL_SECTOR
	CP	A,'2'
	JP	Z,READ_SECTOR
	CP	A,'3'
	JP	Z,GET_S100_SECTOR_DATA
	CP	A,'4'
	JP	Z,PUT_S100_SECTOR_DATA
	CALL	MENU_ERROR
	JP	START1

MENU_ERROR:
	LD	HL,MENU_MSG		; "Menu error"
	CALL	PMSG
	RET
	
SD_CARD_STATUS:


;-----------------------------------------------------------------------------
RESET:	OUT	(RAISE_RESET),A		; Reset Interface
	OUT	(LOWER_RESET),A	
	LD	HL,RESET_MSG		; "SD_CARD Interface was reset. (Status = "
	CALL	PMSG
	LD	A,(DISK_STATUS)
	CALL	ZBITS
	LD	HL,RESET_MSG1		; "B) "
	JP	START1

;-----------------------------------------------------------------------------
FILL_SECTOR:
	LD	HL,FILL_MSG1		; "Enter Fill Value (00-FFH)"
	CALL	PMSG
	CALL	GET_HEX			; Get fill value in [A]
	JP	C,DATA_FILL_ERROR
	LD	(DATA_STORE),A		; <<< Save fill value in [C] >>>

					; >>>> Display what will be done <<<<
	LD	HL,FILL_MSG2		; "Will fill SD Card Sector: "
	CALL	PMSG
	LD	HL,(START_STORE)	; Print the value in HL
	CALL	PRINT_HL		; <--- START
	LD	HL,FILL_MSG3		; "H with a fill value of "
	CALL	PMSG
	LD	A,(DATA_STORE)
	CALL	PRINT_A			; <--- VALUE
	LD	HL,FILL_MSG4		; "H.\n Press any character to continue. Press ESC to return to the main menu.."
	CALL	PMSG
	CALL	CHECK_ESC
	JP	NZ,BEGIN_FILL
	JP	START1
	
BEGIN_FILL:				; <<<<<<<<<<<<<<<<<<<<<<
;	IN	A,(DISK_STATUS)		; Is Disk Ready
;	BIT	DISK_READY,A
;	JP	Z,NR_WR_ERROR

	LD	HL,(START_STORE)	; Get Sector Address (32 bits)
	LD	A,0
	OUT	(DISK_ADDRESS_0),A	; Load up sector address
	LD	A,0			 
	OUT	(DISK_ADDRESS_1),A	
	XOR	A,A
	OUT	(DISK_ADDRESS_2),A	; For this diagnostic test program we will use only 0-FFFFH sectors	
	OUT	(DISK_ADDRESS_3),A	
	
	LD	A,(DATA_STORE)		; Get fill Data byte
	LD	C,A	; Store Fill Data in C
	LD	B,0			; We need 2X255 bytes
	
	OUT	(DISK_WRITE_PULSE),A	; Send a Byte over the SPI line

FILL_LOOP:
	LD	A,C
	OUT	(DISK_DATA_OUT),A	; Send a Byte over the SPI line
FILL_LOOP1:
	IN	A,(DISK_STATUS)		; get WRITE status
	BIT	READY_FOR_NEXT_BYTE,A	; Is the SD_CONTROLLER ready to WRITE the next byte
	JR	NZ,FILL_LOOP1
	DJNZ	FILL_LOOP		; Do 256 times
FILL_LOOP2:
	LD	A,C
	OUT	(DISK_DATA_OUT),A	; Send a Byte over the SPI line
;	OUT	(DISK_WRITE_PULSE),A	; Send a Byte over the SPI line
FILL_LOOP3:
	IN	A,(DISK_STATUS)		; get WRITE status
	BIT	READY_FOR_NEXT_BYTE,A	; Is the SD_CONTROLLER ready to WRITE the next byte
	JR	NZ,FILL_LOOP3
	DJNZ	FILL_LOOP2		; We need 512 Bytes (256 x 2)

;	IN	A,(DISK_STATUS)		
;	BIT	DISK_READY,A
;	JP	Z,NR_WR_ERROR2
	LD	HL,FILL_MSG5		; "SD Card Sector filled OK."
	CALL	PMSG
	JP	START1
	

DATA_FILL_ERROR:
	LD	HL,ERROR_MSG		; "Data format error"
	CALL	PMSG
	JP	START1

FILL_DONE:
	LD	HL,FILL_MSG5		; "SD Card Sector filled OK."
	CALL	PMSG
	JP	START2

NR_WR_ERROR:
	LD	HL,NR_WR_MSG		; "Disk is not ready (Before Sector Write)"
	CALL	PMSG
	JP	START1
	
NR_WR_ERROR2:
	LD	HL,NR_WR_MSG2		; "Disk is not ready (After Sector Write)"
	CALL	PMSG
	JP	START1
	
	
;-----------------------------------------------------------------------	
READ_SECTOR:                            ;  ========================== READ ============================
	LD	HL,READ_MSG		; "Enter the Sector address (0000-FFFFH): "
	CALL	PMSG
	CALL	GET_HEX4		; Put 16 Bit Paramater in HL
	JP	C,DATA_READ_ERROR	; Carry set,there was a problem
	LD	(START_STORE),HL

					; >>>> Display what will be done <<<<
	LD	HL,READ_MSG2		; "Will Read SD Card Sector: "
	CALL	PMSG
	LD	HL,(START_STORE)	; Print the value in HL
	CALL	PRINT_HL		; <--- START
	LD	HL,READ_MSG4		; "H.\n Press any character to continue. Press ESC to return to the main menu.."
	CALL	PMSG
	CALL	CHECK_ESC
	JP	NZ,BEGIN_READ
	JP	START1
	
BEGIN_READ:				; <<<<<<<<<<<<<<<<<<<<<<
	LD	HL,(START_STORE)	; Get Sector Address (32 bits)
	LD	A,L
	OUT	(DISK_ADDRESS_0),A	; Load up sector address
	LD	A,H			 
	OUT	(DISK_ADDRESS_1),A	
	XOR	A,A
	OUT	(DISK_ADDRESS_2),A	; For this diagnostic test program we will use only 0-FFFFH sectors	
	OUT	(DISK_ADDRESS_3),A	
	
	LD	B,0			; We need 2X255 bytes
	LD	HL,SECTOR_DATA_STORE	; <----- Pointer to where we will store the data
	IN	A,(DISK_STATUS)		; Is Drive Initilized/ready
	
	BIT	DISK_READY,A
;	JR	NZ,READ_LOOP
;	JP	NR_RD_ERROR
	
READ_LOOP:
	IN	A,(DISK_STATUS)		; Is the SD_CONTROLLER ready to WRITE the next byte
	BIT	BYTE_AVAILABLE,A
	JR	Z,READ_LOOP
	IN	A,(DISK_DATA_IN)	; Get a Byte over the SPI line
	LD	(HL),A
	INC	HL

	PUSH	AF
	PUSH	BC
	LD	C,A
	CALL	CO
	POP	BC
	POP	AF
	
	DJNZ	READ_LOOP		; Do 256 times
READ_LOOP2:
	IN	A,(DISK_STATUS)		; Is the SD_CONTROLLER ready to WRITE the next byte
	BIT	BYTE_AVAILABLE,A
	JR	Z,READ_LOOP2
	IN	A,(DISK_DATA_IN)	; Get a Byte over the SPI line
	LD	(HL),A
	INC	HL

	PUSH	AF
	PUSH	BC
	LD	C,A
	CALL	CO
	POP	BC
	POP	AF
	
	DJNZ	READ_LOOP2		; Do 256 times

	BIT	DISK_READY,A
	JR	NZ,READ_DONE
	JP	NR_RD_ERROR2
	
READ_DONE:
	LD	HL,FILL_MSG5		; "SD Card Sector filled OK."
	CALL	PMSG
	JP	START2

DATA_READ_ERROR:
	LD	HL,ERROR_MSG		; "Data format error"
	CALL	PMSG
	JP	START1

NR_RD_ERROR:
	LD	HL,NR_RD_MSG		; "Disk is not ready (Before Sector Read)"
	CALL	PMSG
	JP	START1
	
NR_RD_ERROR2:
	LD	HL,NR_RD_MSG2		; "Disk is not ready (After Sector Read)"
	CALL	PMSG
	JP	START1
	
GET_S100_SECTOR_DATA:
PUT_S100_SECTOR_DATA:
	CALL	MENU_ERROR
	JP	START1


;<<<<<<<<<<<<<<<<<<<<<<<<< SUPPORT ROUTINES >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

PMSG:	PUSH	BC		; Only [A] and [HL] is changed
PMSG1:	LD	A,(HL)		; A ROUTINE TO PRINT OUT A STRING @ [HL]
	INC	HL		; UP TO THE FIRST 0.
	OR	A,A
	JP	Z,PMSG_DONE
	LD	C,A
	CALL	CO
	JP	PMSG1
PMSG_DONE:
	POP	BC
	RET

CRLF:	PUSH	AF
	PUSH	BC
	LD	C,CR
	CALL	CO
	LD	C,LF
	CALL	CO
	POP	BC
	POP	AF
	RET

; GET A CHARACTER, convert to UC, ECHO it
GETCMD:	CALL	CI		
	CALL	UCASE
	CP	A,ESC
	RET	Z		;Don't echo an ESC
	PUSH	AF		;Save it
	PUSH	BC
	LD	C,A
	CALL	CO		;Echo it
	POP	BC
	POP	AF		;get it back
	RET
;				;Convert LC to UC
UCASE:	CP	A,'a'		;must be >= lowercase a
	RET	C		; else go back...
	CP	A,'z'+1		;must be <= lowercase z
	RET	NC		; else go back...
	SUB	A,'a'-'A'	;subtract lowercase bias
	RET

; Check if next character is a ESC
CHECK_ESC:
	CALL	CI
	CP	A,ESC
	RET			; Return Z if ESC character.
	
; Check if next character is a CR
CHECK_CR:
	CALL	CI
	CP	A,CR
	RET			; Return Z if ESC character.
	
; Return with 2 HEX digits in [A]. If abort, Carry flag set + ESC in [A]
GET_HEX:
	PUSH	BC			
	CALL	GETCMD		;Get a character from keyboard & ECHO
	CP	A,ESC
	JR	Z,HEX_ABORT
	CP	'/'		;check 0-9, A-F
	JR	C,HEX_ABORT
	CP	'F'+1
	JR	NC,HEX_ABORT
	CALL	ASBIN		;Convert to binary
	SLA	A
	SLA	A
	SLA	A
	SLA	A		;Shift to high nibble	
	LD	B,A		;Store it
	CALL	GETCMD		;Get 2nd character from keyboard & ECHO
	CP	A,ESC
	JR	Z,HEX_ABORT
	CP	'/'		;check 0-9, A-F
	JR	C,HEX_ABORT
	CP	'F'+1
	JR	NC,HEX_ABORT
	CALL	ASBIN		;Convert to binary
	OR	A,B		;add in the first digit
	OR	A,A		;To return NC
	POP	BC
	RET
	
HEX_ABORT:
	SCF			;Set Carry flag 
	LD	A,ESC
	POP	BC
	RET
;
;
; Put 4 HEX characters in [HL] 
GET_HEX4:	
	LD      H,0000H
	CALL	GET_HEX		;get 2 HEX digits
	JR	C,SCAN_ABORT
	LD	H,A
	CALL	GET_HEX		;get 2 more HEX digits
	JR	C,SCAN_ABORT
	LD	L,A
	OR	A,A		;To return NC
	RET
	
SCAN_ABORT:
	SCF			;Set Carry flag 
	RET

; ASCII TO BINARY CONVERSION ROUTINE
ASBIN:	SUB	30H 
	CP	0AH 
	RET	M
	SUB	07H 
	RET
;	
;
; PRINT [HL] ON CONSOL
PRINT_HL:
	LD	A,H
	CALL	PRINT_A
	LD	A,L
PRINT_A:
	PUSH	AF
	RRCA
	RRCA
	RRCA
	RRCA
	CALL	SF598
	POP	AF
SF598:	CALL	CONV
	JP	CO

; CONVERT HEX TO ASCII
CONV:	AND	0FH
	ADD	A,90H
	DAA 
	ADC	A,40H
	DAA 
	LD	C,A
	RET
	
; DISPLAY 8 BITS OF [A] (No registers changed)
; DISPLAY BIT PATTERN IN [A]
ZBITS:	PUSH	AF
	PUSH	BC
	PUSH	DE
	LD	E,A		
	LD	B,8
BQ2:	SLA	E	
	LD	A,18H
	ADC	A,A
	LD	C,A
	CALL	CO
	DJNZ	BQ2
	POP	DE
	POP	BC
	POP	AF
	RET

;<<<<<<<<<<<<<<<<<<<<<< MAIN CONSOL OUTPUT ROUTINE >>>>>>>>>>>>>>>>>>>>>>>>>
;
CO:	IN	A,(CONSTAT)	; SD SYSTEMS or PROPELLER VIDIO BOARD PORT
	AND	4H
	JP	Z,CO
	LD	A,C
	OUT	(CONOUT),A
	RET			; RETURN CHARACTER SENT IN [A]
 
;<<<<<<<<<<<<<<<<<<< MAIN CONSOL STATUS ROUTINE >>>>>>>>>>>>>>>>>>>>>>
;
CSTS:	IN	A,(CONSTAT)
	AND	02H
	RET	Z
	XOR	A
	DEC	A		; RETURN WITH 0FFH IN [A] IF SOMETHING
	RET

;<<<<<<<<<<<<<<<<<<<< MAIN CONSOL INPUT ROUTINE >>>>>>>>>>>>>>>>>>>>
;
CI:	IN 	A,(CONSTAT)	; NEED CONSTAT TO CLEAN UP SHIFT KEYS ETC
	AND	02H
	JR	Z,CI
	IN	A,(CONIN)
	AND	7FH
	RET

;---------------------------------------------------------------------------------------
SIGNON:		DB	CR,LF
		DB	CR,LF,'Test program for SD CARD interface of S100Computers.com FPGA Prototype board'
		DB	CR,LF,'By John Monahan S100Computers.COM  (V1.0)  12/20/2018'
		DB	CR,LF,'Note: 1. The test is with a ScanDisk EDGE 4GB card',0
		
SIGNON1:	DB	CR,LF,LF,'---------- Main Menu ---------------------------------------'
		DB	CR,LF,'0.   Reset SD CARD Interface.'
		DB	CR,LF,'1.   Fill a Disk Sector (512 Bytes) with an 8 bit value.'
		DB	CR,LF,'2.   Read and Display a Disk Sector'
		DB	CR,LF,'3.   Move 512 Bytes of S100 Bus RAM to a Sector.'
		DB	CR,LF,'4.   Copy a sector to S100 Bus RAM.'
		DB	CR,LF,'ESC  To abort program.',CR,LF,0H

MENU_MSG:	DB	BELL,BELL,CR,LF,'Menu error.',0
NR_WR_MSG: DB	BELL,BELL,CR,LF,'Drive not Initilized/Ready (Before Sector Write).',0H
NR_WR_MSG2:DB	BELL,BELL,CR,LF,'Drive not Ready (After Sector Write).',0H
ERROR_MSG:	DB	BELL,CR,LF,'Data format error.',0H

RESET_MSG:	DB	CR,LF,'SD_CARD Interface was reset. (Status = ',0
RESET_MSG1:	DB	'B)',CR,LF,0
		
FILL_MSG:	DB	CR,LF,'Enter the Sector address (0000-FFFFH): ',0H		
FILL_MSG1:	DB	CR,LF,'Enter the Sector Fill Value (00-FFH): ',0H		
FILL_MSG2:	DB	CR,LF,LF,'Will fill SD Card Sector: ',0H		
FILL_MSG3:	DB	'H with a fill value of ',0H	
FILL_MSG4:	DB	'H.'
		DB	CR,LF,'Press any character to continue. ESC to return to the main menu.',0H	
FILL_MSG5:	DB	CR,LF,'SD Card Sector filled OK.',CR,LF,0H
	
READ_MSG:	DB	CR,LF,'Enter the Sector address (0000-FFFFH): ',0H		
READ_MSG2:	DB	CR,LF,LF,'Will Read SD Card Sector: ',0H		
READ_MSG4:	DB	'H.'
		DB	CR,LF,'Press any character to continue. ESC to return to the main menu.',0H	
READ_MSG5:	DB	CR,LF,'SD Card Sector Read OK.',CR,LF,0H

NR_RD_MSG: DB	BELL,BELL,CR,LF,'Drive not Initilized/Ready (Before Sector Read).',0H
NR_RD_MSG2:DB	BELL,BELL,CR,LF,'Drive not Ready (After Sector Read).',0H
	


START_OF_STORE:	DB	'>>>>>>>>>>>>>>>>>>>>>>>>>'	
DISK_CMD_BYTE1	DB	0H
DISK_CMD_BYTE2	DB	0H
DISK_CMD_BYTE3	DB	0H
DISK_CMD_BYTE4	DB	0H			
DISK_CMD_BYTE4	DB	95H			;always 95H for CRC check
	
START_STORE:	DW	0H   ;<--- Note:- Low Byte,High Byte
RANGE_STORE:	DB	0H
DATA_STORE:	DB	0H
S100_STORE:	DW	0H
END_OF_STORE:	DB	'<<<<<<<<<<<<<<<<<<<<<<<<<'
		
SECTOR_DATA_STORE: DS	513
;
		DS	40H
STACK:		DB	0H
; END
	



