00000000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 12/24/2017 7:55:57 AM

00000000                             1  * 12/24/17 trace command in DDT does not mask off interrupts.  mask off 68681 interrupt
00000000                             2  *   in the 68681 device itself.
00000000                             3  * 10/30/17 rev5, fix the console input so data is not filtered at all.  This resolves the
00000000                             4  *  problem with gkermit binary load.
00000000                             5  * 10/28/17 rev 4, DMA address can be odd or even, so word or long word move to/from dma
00000000                             6  *  may cause address error.  Replace the longword move with 4 byte moves.
00000000                             7  * 7/12/17 Rev 3, Add RAM drive to DRAM, 8 megbyte, from $700000 to $F00000
00000000                             8  *  reduce the size of TPA so it is now from $20000 to $700000
00000000                             9  * 7/6/17 Use blocking/deblocking algorithm provided by Roger Hanscom
00000000                            10  *  The blocking/deblocking algorithm is also described in section 5.3.1 of
00000000                            11  *  CP/M-68K System Guide
00000000                            12  * 6/28/2017
00000000                            13  * start with ERGBIOS.s in distribution disk #7 of CPM68kv1_3
00000000                            14  * use CPM15000.SR, CPM S record starts at location 0x15000
00000000                            15  *****************************************************************
00000000  =00FFF000                 16  DUART    equ $FFF000       * base address of 68692 DUART
00000000  =00FFF001                 17  MRA      equ $FFF001       * mode reg A
00000000  =00FFF003                 18  SRA      equ $FFF003       * status A (read)
00000000  =00FFF003                 19  CSRA     equ $FFF003       * clock select reg (write)
00000000  =00FFF005                 20  CRA      equ $FFF005       * command register (write only)
00000000  =00FFF007                 21  RHRA     equ $FFF007       * Rx Hold reg A (read)
00000000  =00FFF007                 22  THRA     equ $FFF007       * Tx Holding reg (write)
00000000  =00FFF009                 23  IPCR     equ $FFF009       * Input port change reg (read)
00000000  =00FFF009                 24  ACR      equ $FFF009       * Aux control reg (write)
00000000  =00FFF00B                 25  ISRD     equ $FFF00B       * interrupt status reg (read)
00000000  =00FFF00B                 26  IMRD     equ $FFF00B       * interrupt mask reg (write)                          
00000000  =00FFF00D                 27  CTU      equ $FFF00D       * Counter/timer upper (read)
00000000  =00FFF00F                 28  CTL      equ $FFF00F       * counter/timer lower (read)
00000000  =00FFF00D                 29  CTUR     equ $FFF00D       * Counter/timer preload upper (write)
00000000  =00FFF00F                 30  CTLR     equ $FFF00F       * counter/timer preload lower (write)
00000000  =00FFF011                 31  MR1B     equ $FFF011       * mode reg B
00000000  =00FFF013                 32  SRB      equ $FFF013       * status reg B
00000000  =00FFF017                 33  RHRB     equ $FFF017       * Rx holding reg B
00000000  =00FFF019                 34  IVRD     equ $FFF019       * interrupt vector reg
00000000  =00FFF01F                 35  STOPCTR  equ $FFF01F       * stop counter command reg (read)
00000000  =00FFF01D                 36  STARTCTR equ $FFF01D       * start counter command reg (read)
00000000  =00FFF01D                 37  SETOPR   equ $FFF01D       * bit set output register bits (write)
00000000  =00FFF01F                 38  CLROPR   equ $FFF01F       * bit clear output register (write)
00000000  =00FFF01B                 39  OPCR     equ $FFF01B       * output configuration register(write)
00000000                            40  
00000000  =000150BC                 41  _ccp     equ $150BC                  * hard location for _ccp of CPM15000.SR
0001B000                            42           org $1B000                 * this is the hard location for _init for CPM15000.SR
0001B000                            43  _init:   
0001B000  6004                      44           bra.s init1
0001B002= 30 2E 36 00               45           dc.b '0.6',0               * rev 0.6 of TinyBIOS
0001B006                            46  init1:         
0001B006  13FC 0000 00FFF00B        47           move.b #0,IMRD             * mask off 68681 interrupts
0001B00E  46FC 2700                 48           move.w #$2700,sr           * disable interrupts
0001B012                            49  *****************
0001B012                            50  * need to initialize DUART here instead of relying on Tinybug
0001B012                            51  ****************
0001B012  21FC 0001B026 008C        52           move.l   #traphndl,$8c     * set up trap #3 handler
0001B01A  4280                      53           clr.l    d0                * log on disk A, user 0
0001B01C  13FC 0040 00FFE00D        54           move.b   #$40,CF2427       * set Logical Address addressing mode
0001B024  4E75                      55           rts
0001B026                            56  
0001B026                            57  traphndl:
0001B026  0C40 0017                 58           cmpi     #nfuncs,d0
0001B02A  6400 000A                 59           bcc      trapng
0001B02E  E548                      60           lsl      #2,d0             * multiply bios function by 4
0001B030                            61  **X won't assemble         movea.l 6(pc,d0),a0        * get handler address
0001B030                            62  **X replace with this:
0001B030  207B 0006                 63           movea.l  *+8(pc,d0),a0     * get handler address
0001B034  4E90                      64           jsr      (a0)              * call handler
0001B036                            65  trapng:
0001B036  4E73                      66           rte
0001B038                            67  
0001B038                            68  biosbase:
0001B038= 0001B000                  69           dc.l  _init
0001B03C= 0001B094                  70           dc.l  wboot
0001B040= 0001B09A                  71           dc.l  constat
0001B044= 0001B0AE                  72           dc.l  conin
0001B048= 0001B0BC                  73           dc.l  conout
0001B04C= 0001B0CE                  74           dc.l  lstout
0001B050= 0001B0D0                  75           dc.l  pun
0001B054= 0001B0D2                  76           dc.l  rdr
0001B058= 0001B0DA                  77           dc.l  home
0001B05C= 0001B0E2                  78           dc.l  seldsk
0001B060= 0001B104                  79           dc.l  settrk
0001B064= 0001B10C                  80           dc.l  setsec
0001B068= 0001B118                  81           dc.l  setdma
0001B06C= 0001B120                  82           dc.l  read
0001B070= 0001B1F2                  83           dc.l  write
0001B074= 0001B0D4                  84           dc.l  listst
0001B078= 0001B114                  85           dc.l  sectran
0001B07C= 0001B118                  86           dc.l  setdma
0001B080= 0001B2D8                  87           dc.l  getseg
0001B084= 0001B2E0                  88           dc.l  getiob
0001B088= 0001B2E2                  89           dc.l  setiob
0001B08C= 0001B2D4                  90           dc.l  flush
0001B090= 0001B2E4                  91           dc.l  setexc
0001B094                            92  
0001B094  =00000017                 93  nfuncs   equ (*-biosbase)/4
0001B094                            94  
0001B094  4EF9 000150BC             95  wboot:   jmp      _ccp
0001B09A                            96  
0001B09A                            97  constat: 
0001B09A                            98  * Check for keyboard input. Set d0 to 1 if keyboard input is pending, otherwise set to 0.
0001B09A                            99  
0001B09A  0839 0000 00FFF003       100           btst.b #0,SRA     * Does receiver has a char input?
0001B0A2  6700 0006                101           beq noton         * branch if no input
0001B0A6  7001                     102           moveq.l  #$1,d0            * set result to true
0001B0A8  4E75                     103           rts
0001B0AA  4280                     104  noton:   clr.l    d0                * set result to false
0001B0AC  4E75                     105           rts
0001B0AE                           106  
0001B0AE                           107  conin:   
0001B0AE                           108  * Read single ASCII character from the keyboard into d0
0001B0AE  61EA                     109           bsr      constat           * see if key pressed
0001B0B0  4A40                     110           tst      d0
0001B0B2  67FA                     111           beq      conin             * wait until key pressed
0001B0B4  1039 00FFF007            112           move.b RHRA,d0             * get character
0001B0BA  4E75                     113           rts
0001B0BC                           114  
0001B0BC                           115  conout: 
0001B0BC                           116  * Display single ASCII character in d1
0001B0BC  0839 0002 00FFF003       117           btst.b #2,SRA              * check for transmit ready
0001B0C4  67F6                     118           beq conout                 * wait until it is ready
0001B0C6  13C1 00FFF007            119           move.b d1,THRA             * put char in d1.b out to console
0001B0CC  4E75                     120           rts                        * and exit
0001B0CE                           121  
0001B0CE  4E75                     122  lstout:  rts
0001B0D0                           123  
0001B0D0  4E75                     124  pun:     rts
0001B0D2                           125  
0001B0D2  4E75                     126  rdr:     rts
0001B0D4                           127  
0001B0D4  103C 00FF                128  listst:  move.b   #$ff,d0
0001B0D8  4E75                     129           rts
0001B0DA                           130  
0001B0DA                           131  * Compact flash registers
0001B0DA  =00000005                132  maxdsk   equ 5             * five drives
0001B0DA  =0000001A                133  dphlen   equ 26            * length of disk parameter header
0001B0DA                           134  
0001B0DA  =00FFE000                135  CFdata   equ $FFE000       * CF data register
0001B0DA  =00FFE002                136  CFerr    equ $FFE002       * CF error reg
0001B0DA  =00FFE005                137  CFsectcnt equ $FFE005      * CF sector count reg
0001B0DA  =00FFE007                138  CF07     equ $FFE007       * CF LA0-7
0001B0DA  =00FFE009                139  CF815    equ $FFE009       * CF LA8-15
0001B0DA  =00FFE00B                140  CF1623   equ $FFE00B       * CF LA16-23
0001B0DA  =00FFE00D                141  CF2427   equ $FFE00D       * CF LA24-27
0001B0DA  =00FFE00F                142  CFstat   equ $FFE00F       * CF status/command reg
0001B0DA                           143  
0001B0DA  4279 0001B302            144  home:    clr.w    track
0001B0E0  4E75                     145           rts
0001B0E2                           146  
0001B0E2                           147  seldsk:  
0001B0E2                           148  *        select disk given by register d1.b
0001B0E2  7000                     149           moveq    #0,d0
0001B0E4  B23C 0005                150           cmp.b    #maxdsk,d1        * valid drive number?
0001B0E8  6A00 0018                151           bpl      selrtn            * if no, return 0 in d0
0001B0EC  13C1 0001B2FC            152           move.b   d1,seldrv         * else, save drive number
0001B0F2  1039 0001B2FC            153           move.b   seldrv,d0
0001B0F8  C0FC 001A                154           mulu     #dphlen,d0
0001B0FC  0680 0001B31A            155           add.l    #dph0,d0          * point d0 at correct dph
0001B102  4E75                     156  selrtn:  rts
0001B104                           157  
0001B104  33C1 0001B302            158  settrk:  move.w   d1,track
0001B10A  4E75                     159           rts
0001B10C                           160  
0001B10C                           161  setsec:  
0001B10C  33C1 0001B304            162           move.w   d1,sector
0001B112  4E75                     163           rts
0001B114                           164  
0001B114                           165  sectran:
0001B114                           166  *        no sector translate, put d1 into d0 and return
0001B114  3001                     167           move.w d1,d0
0001B116  4E75                     168           rts
0001B118                           169  
0001B118                           170  setdma:
0001B118  23C1 0001B306            171           move.l   d1,dma
0001B11E  4E75                     172           rts
0001B120                           173  
0001B120                           174  read:
0001B120                           175  * Read one sector from requested disk, track, sector to dma address
0001B120                           176  * Retry if necessary, return in d0 00 if ok, else non-zero
0001B120  0C39 0004 0001B2FC       177           cmp.b #4,seldrv            * RAM drive?
0001B128  6700 0096                178           beq RAMdrvRd               * if RAM drive, handle it differently
0001B12C  4280                     179           clr.l d0                   * make sure d0 is all zero
0001B12E  3039 0001B304            180           move.w sector,d0           * check if need to read a new sector from CF
0001B134  E458                     181           ror.w #2,d0                * 2 lsb are 128-byte index into CF data, save to high byte
0001B136                           182  
0001B136  2239 0001B302            183           move.l track,d1            * this will read in track (in high word) and sector 
0001B13C                           184                                      * (in low word)
0001B13C  C2BC FFFFFFFC            185           and.l #$fffffffc,d1        * mask off the 2 lsb
0001B142  B2B9 0001B2FE            186           cmp.l curCFsect,d1         * does it match track/sect of CF data in the buffer?                           
0001B148                           187  
0001B148  6700 0050                188           beq move2dma                * data already there, 
0001B14C                           189  readCF:         
0001B14C  23C1 0001B2FE            190           move.l d1,curCFsect        * update current CF sector
0001B152  13FC 0001 00FFE005       191           move.b #1,CFsectcnt        * read 1 sector
0001B15A  13F9 0001B302 00FFE00B   192           move.b track,CF1623        * MSB of track goes to LA16-23
0001B164  13F9 0001B303 00FFE009   193           move.b track+1,CF815       * LSB of 16-bit track value goes to LA8-15
0001B16E  13C0 00FFE007            194           move.b d0,CF07             * CF sector goes to LA07
0001B174  41F9 0001B46C            195           lea sectCF,a0             * read into CF sector data buffer
0001B17A  13FC 0020 00FFE00F       196           move.b #$20,CFstat         * read sector command
0001B182                           197  readdrq:
0001B182  0839 0003 00FFE00F       198           btst.b #3,CFstat           * check data request bit set before reading
0001B18A  67F6                     199           beq readdrq
0001B18C  343C 00FF                200           move.w #$ff,d2             * read 512 bytes
0001B190                           201  readCF1:
0001B190  30F9 00FFE000            202           move.w CFdata,(a0)+        * 16-bit read
0001B196  51CA FFF8                203           dbra d2,readCF1
0001B19A                           204  move2dma:
0001B19A  4200                     205           clr.b d0                   * clear the low byte 
0001B19C  EE48                     206           lsr.w #7,d0                * forming 128 byte offset using values in high byte of d0
0001B19E  0680 0001B46C            207           add.l #sectCF,d0          * index into CF data buffer
0001B1A4  2040                     208           move.l d0,a0               * a0 points to the CP/M sector 
0001B1A6  2279 0001B306            209           move.l dma,a1              * a1 points to buffer pointed by dma
0001B1AC  343C 001F                210           move.w #31,d2              * transfer 128 bytes
0001B1B0                           211  cpdma:
0001B1B0                           212  *         move.l (a0)+,(a1)+         * copy long word at a time
0001B1B0  12D8                     213           move.b (a0)+,(a1)+         * move long word, byte at a time
0001B1B2  12D8                     214           move.b (a0)+,(a1)+         * DMA pointer may be odd or even address
0001B1B4  12D8                     215           move.b (a0)+,(a1)+         *  so move word or move longword may cause address error
0001B1B6                           216  
0001B1B6  12D8                     217           move.b (a0)+,(a1)+
0001B1B8  51CA FFF6                218           dbra d2,cpdma 
0001B1BC  6000 0012                219           bra readexit
0001B1C0                           220  RAMdrvRd:
0001B1C0  6100 0012                221           bsr setupRD                * translate track/sector values into RAM loc
0001B1C4                           222  RAMdrvR:
0001B1C4                           223  *         move.l (a0)+,(a1)+
0001B1C4  12D8                     224           move.b (a0)+,(a1)+         * move long word, byte at a time
0001B1C6  12D8                     225           move.b (a0)+,(a1)+         * DMA pointer may be odd or even address
0001B1C8  12D8                     226           move.b (a0)+,(a1)+         *  so move word or move longword may cause address error
0001B1CA                           227  
0001B1CA  12D8                     228           move.b (a0)+,(a1)+
0001B1CC  51CA FFF6                229           dbra d2,RAMdrvR
0001B1D0                           230  readexit:
0001B1D0  4280                     231           clr.l d0                   * return OK status         
0001B1D2  4E75                     232           rts         
0001B1D4                           233  setupRD:
0001B1D4                           234  * translate track/sector into RAM location on the RAM drive
0001B1D4  2039 0001B302            235           move.l track,d0            * get track & sector values
0001B1DA  ED48                     236           lsl.w #6,d0                * multiply by 64
0001B1DC  E388                     237           lsl.l #1,d0                * multiply the track/sector by 128 to index into RAM
0001B1DE  0680 00700000            238           add.l #$700000,d0          * add base address of RAM drive
0001B1E4  2040                     239           move.l d0,a0               * point to the track/sector in RAM drive
0001B1E6  2279 0001B306            240           move.l dma,a1             * get dma
0001B1EC  343C 001F                241           move.w #(128/4)-1,d2        * long word move 128 bytes of sector data
0001B1F0  4E75                     242           rts
0001B1F2                           243  write:
0001B1F2                           244  * Write one sector to requested disk, track, sector from dma address
0001B1F2                           245  * Retry if necessary, return in d0 00 if ok, else non-zero
0001B1F2                           246  *         cmp.w #2,d1                * if new block, skip pre-read
0001B1F2                           247  *         beq writeCF         
0001B1F2  0C39 0004 0001B2FC       248           cmp.b #4,seldrv            * RAM drive?
0001B1FA  6700 00C4                249           beq RAMdrvWr               * if RAM drive, handle it differently
0001B1FE  4280                     250           clr.l d0                   * make sure d0 is all zero
0001B200  3039 0001B304            251           move.w sector,d0           * pre-read the CF sector before write
0001B206  E458                     252           ror.w #2,d0                * 2 lsb are 128-byte index into CF data, save to high byte
0001B208  2239 0001B302            253           move.l track,d1            * this will read in track (in high word) and sector 
0001B20E                           254                                      * (in low word)
0001B20E  C2BC FFFFFFFC            255           and.l #$fffffffc,d1        * mask off the 2 lsb
0001B214  23C1 0001B2FE            256           move.l d1,curCFsect        * update current CF sector 
0001B21A  13FC 0001 00FFE005       257           move.b #1,CFsectcnt        * read 1 sector
0001B222  13F9 0001B302 00FFE00B   258           move.b track,CF1623        * MSB of track goes to LA16-23
0001B22C  13F9 0001B303 00FFE009   259           move.b track+1,CF815       * LSB of 16-bit track value goes to LA8-15
0001B236  13C0 00FFE007            260           move.b d0,CF07             * CF sector goes to LA07
0001B23C                           261  
0001B23C  41F9 0001B46C            262           lea sectCF,a0             * read into CF sector data buffer
0001B242  13FC 0020 00FFE00F       263           move.b #$20,CFstat         * read sector command
0001B24A                           264  readdrqw:
0001B24A  0839 0003 00FFE00F       265           btst.b #3,CFstat           * check data request bit set before reading
0001B252  67F6                     266           beq readdrqw
0001B254  343C 00FF                267           move.w #$ff,d2             * read 512 bytes
0001B258                           268  preadCF:
0001B258  30F9 00FFE000            269           move.w CFdata,(a0)+        * 16-bit read
0001B25E  51CA FFF8                270           dbra d2,preadCF
0001B262                           271  
0001B262                           272  writeCF:
0001B262                           273  * calculate the index into CF data block
0001B262  4200                     274           clr.b d0                   * clear the low byte 
0001B264  EE48                     275           lsr.w #7,d0                * forming 128 byte offset with values in high byte of d0
0001B266  0680 0001B46C            276           add.l #sectCF,d0          * index into CF data buffer
0001B26C  2040                     277           move.l d0,a0               * a0 points to the CP/M sector 
0001B26E  2279 0001B306            278           move.l dma,a1              * a1 points to buffer pointed by dma
0001B274  343C 001F                279           move.w #31,d2              * transfer 128 bytes
0001B278                           280  wrcpdma:
0001B278                           281  *         move.l (a1)+,(a0)+         * copy data to be written, long word at a time
0001B278  10D9                     282           move.b (a1)+,(a0)+         * move long word, byte at a time
0001B27A  10D9                     283           move.b (a1)+,(a0)+         * DMA pointer may be odd or even address
0001B27C  10D9                     284           move.b (a1)+,(a0)+         *  so move word or move longword may cause address error
0001B27E  10D9                     285           move.b (a1)+,(a0)+
0001B280  51CA FFF6                286           dbra d2,wrcpdma 
0001B284                           287                         
0001B284  41F9 0001B46C            288           lea sectCF,a0             * points to the 512 byte CF buffer to be written
0001B28A  13FC 0001 00FFE005       289           move.b #1,CFsectcnt        * read 1 sector
0001B292                           290  * no need to write CF07, CF815, CF1623.  They are already done with pre-read
0001B292  13FC 0030 00FFE00F       291           move.b #$30,CFstat
0001B29A                           292  writedrq
0001B29A  0839 0003 00FFE00F       293           btst.b #3,CFstat          * check data request bit set before writing sector
0001B2A2  67F6                     294           beq writedrq        
0001B2A4  343C 00FF                295           move.w #$ff,d2            * write 512 bytes
0001B2A8                           296  WriteCF1:
0001B2A8  33D8 00FFE000            297           move.w (a0)+,CFdata        * write data
0001B2AE  51CA FFF8                298           dbra d2,WriteCF1           * write 512 bytes of data
0001B2B2                           299  WriteCF2:
0001B2B2  0839 0007 00FFE00F       300           btst.b #7,CFstat           * check busy bit for write completed
0001B2BA  66F6                     301           bne WriteCF2         
0001B2BC  6000 0012                302           bra wrexit
0001B2C0                           303  RAMdrvWr:
0001B2C0  6100 FF12                304           bsr setupRD                * translate track/sector values into RAM loc
0001B2C4                           305  RAMdrvW:
0001B2C4                           306  *         move.l (a1)+,(a0)+
0001B2C4  10D9                     307           move.b (a1)+,(a0)+         * move long word, byte at a time
0001B2C6  10D9                     308           move.b (a1)+,(a0)+         * DMA pointer may be odd or even address
0001B2C8  10D9                     309           move.b (a1)+,(a0)+         *  so move word or move longword may cause address error
0001B2CA                           310  
0001B2CA  10D9                     311           move.b (a1)+,(a0)+
0001B2CC  51CA FFF6                312           dbra d2,RAMdrvW
0001B2D0                           313  wrexit:
0001B2D0  4280                     314           clr.l d0
0001B2D2  4E75                     315           rts         
0001B2D4                           316  
0001B2D4                           317  flush:
0001B2D4  4280                     318           clr.l    d0                * return successful
0001B2D6  4E75                     319           rts
0001B2D8                           320  
0001B2D8                           321  getseg:
0001B2D8  203C 0001B310            322           move.l   #memrgn,d0        * return address of mem region table
0001B2DE  4E75                     323           rts
0001B2E0                           324  
0001B2E0                           325  getiob:
0001B2E0  4E75                     326           rts
0001B2E2                           327  
0001B2E2                           328  setiob:
0001B2E2  4E75                     329           rts
0001B2E4                           330  
0001B2E4                           331  setexc:
0001B2E4  0281 000000FF            332           andi.l   #$ff,d1           * do only for exceptions 0 - 255
0001B2EA  0C41 002F                333           cmpi     #47,d1
0001B2EE  6700 000A                334           beq      noset             * this BIOS doesn't set Trap 15
0001B2F2                           335  *        cmpi     #9,d1             * or Trace
0001B2F2                           336  *        beq      noset
0001B2F2  E549                     337           lsl      #2,d1             * multiply exception nmbr by 4
0001B2F4  2041                     338           movea.l  d1,a0
0001B2F6  2010                     339           move.l   (a0),d0           * return old vector value
0001B2F8  2082                     340           move.l   d2,(a0)           * insert new vector
0001B2FA  4E75                     341  noset:   rts
0001B2FC                           342  
0001B2FC                           343  
0001B2FC                           344  **X      .data
0001B2FC                           345  
0001B2FC= FF                       346  seldrv:  dc.b     $ff      * drive requested by seldsk
0001B2FD= 00                       347  resv:    dc.b    0         * reserve byte, padding
0001B2FE= FFFFFFFF                 348  curCFsect: dc.l   -1 * current CF sector, the 512 bytes data of curtrk is in sectCF
0001B302= 0000                     349  track:   dc.w     0        * track requested by settrk
0001B304= 0000                     350  sector:  dc.w     0        * max sector value is 0x3FF
0001B306= 00000000                 351  dma:     dc.l     0
0001B30A= 00                       352  selcode: dc.b     0        * reserve byte
0001B30B= 00                       353  resv1:   dc.b     0        * reserve byte, padding
0001B30C= 00C00000                 354  pLog     dc.l     $c00000  * diagnostic buffer
0001B310                           355  
0001B310= 0001                     356  memrgn:  dc.w     1        * 1 memory region
0001B312= 00020000                 357           dc.l     $20000   * starts above CP/M
0001B316= 006E0000                 358           dc.l     $6e0000  * goes until $7000000.  RAM drive above it
0001B31A                           359  *         dc.l     $dd0000   * goes until $df0000, TPA is ~14meg bytes
0001B31A                           360  
0001B31A                           361  * disk parameter headers
0001B31A                           362  
0001B31A                           363  dph0:    
0001B31A= 00000000                 364           dc.l     0        * no sector translation table
0001B31E= 0000                     365           dc.w     0        * dummy
0001B320= 0000                     366           dc.w     0
0001B322= 0000                     367           dc.w     0
0001B324= 0001B3EC                 368           dc.l     dirbuf   * ptr to directory buffer
0001B328= 0001B39C                 369           dc.l     dpb0     * ptr to disk parameter block
0001B32C= 00000000                 370           dc.l     0        * permanent drive, no check vector
0001B330= 0001B66C                 371           dc.l     alv0     * ptr to allocation vector
0001B334                           372  
0001B334                           373  dph1:
0001B334= 00000000                 374           dc.l     0        * no sector translation table
0001B338= 0000                     375           dc.w     0        * dummy
0001B33A= 0000                     376           dc.w     0
0001B33C= 0000                     377           dc.w     0
0001B33E= 0001B3EC                 378           dc.l     dirbuf   * ptr to directory buffer
0001B342= 0001B3AC                 379           dc.l     dpb1     * ptr to disk parameter block
0001B346= 00000000                 380           dc.l     0        * permanent drive, no check vector
0001B34A= 0001B76C                 381           dc.l     alv1     * ptr to allocation vector
0001B34E                           382  
0001B34E                           383  dph2:
0001B34E= 00000000                 384           dc.l     0        * no sector translation table
0001B352= 0000                     385           dc.w     0        * dummy
0001B354= 0000                     386           dc.w     0
0001B356= 0000                     387           dc.w     0
0001B358= 0001B3EC                 388           dc.l     dirbuf   * ptr to directory buffer
0001B35C= 0001B3BC                 389           dc.l     dpb2     * ptr to disk parameter block
0001B360= 00000000                 390           dc.l     0        * permanent drive, no check vector
0001B364= 0001B86C                 391           dc.l     alv2     * ptr to allocation vector
0001B368                           392  
0001B368                           393  dph3:
0001B368= 00000000                 394           dc.l     0        * no sector translation table
0001B36C= 0000                     395           dc.w     0        * dummy
0001B36E= 0000                     396           dc.w     0
0001B370= 0000                     397           dc.w     0
0001B372= 0001B3EC                 398           dc.l     dirbuf   * ptr to directory buffer
0001B376= 0001B3CC                 399           dc.l     dpb3     * ptr to disk parameter block
0001B37A= 00000000                 400           dc.l     0        * permanent drive, no check vector
0001B37E= 0001B96C                 401           dc.l     alv3     * ptr to allocation vector
0001B382                           402           
0001B382                           403  dph4:
0001B382= 00000000                 404           dc.l     0        * no sector translation table
0001B386= 0000                     405           dc.w     0        * dummy
0001B388= 0000                     406           dc.w     0
0001B38A= 0000                     407           dc.w     0
0001B38C= 0001B3EC                 408           dc.l     dirbuf   * ptr to directory buffer
0001B390= 0001B3DC                 409           dc.l     dpb4     * ptr to disk parameter block
0001B394= 00000000                 410           dc.l     0        * permanent drive, no check vector
0001B398= 0001BA6C                 411           dc.l     alv4     * ptr to allocation vector
0001B39C                           412  
0001B39C                           413  * disk parameter block
0001B39C                           414  * choose a BLS of 4096
0001B39C                           415  * 1024 sectors (128 byte sector) per track
0001B39C                           416  * 64 sectors per block
0001B39C                           417  * 62 tracks per drive 
0001B39C                           418  dpb0:    
0001B39C= 0400                     419           dc.w     1024      * 1024 sectors per track
0001B39E= 05                       420           dc.b     5        * block shift for BLS of 4096
0001B39F= 1F                       421           dc.b     31       * block mask for BLS of 4096
0001B3A0= 01                       422           dc.b     1        * extent mask, EXM
0001B3A1= 00                       423           dc.b     0        * dummy fill
0001B3A2= 07BF                     424           dc.w     1983     * DSM, does not count the 1st track, and leave a head room of 1 track
0001B3A4                           425                             * 62 tracks * 1024 sectors * 128 bytes = 1984 blocks or ~8meg
0001B3A4= 01FF                     426           dc.w     511      * DRM, 512 directory entries
0001B3A6= 0000                     427           dc.w     0        * directory mask
0001B3A8= 0000                     428           dc.w     0        * permanent mounted drive, check size is zero
0001B3AA= 0001                     429           dc.w     1        * track offset of 1
0001B3AC                           430  
0001B3AC                           431  * disk parameter block
0001B3AC                           432  * choose a BLS of 4096
0001B3AC                           433  * 1024 sectors (128 byte sector) per track
0001B3AC                           434  * 64 sectors per block
0001B3AC                           435  * 63 tracks per drive 
0001B3AC                           436  dpb1:    
0001B3AC= 0400                     437           dc.w     1024      * 1024 sectors per track
0001B3AE= 05                       438           dc.b     5        * block shift for BLS of 4096
0001B3AF= 1F                       439           dc.b     31       * block mask for BLS of 4096
0001B3B0= 01                       440           dc.b     1        * extent mask, EXM
0001B3B1= 00                       441           dc.b     0        * dummy fill
0001B3B2= 07DF                     442           dc.w     2015     * DSM, leave a head room of 1 track before next drive
0001B3B4                           443                             * 63 tracks * 1024 sectors * 128 bytes ~ 8 meg or 2016 blocks
0001B3B4= 01FF                     444           dc.w     511      * DRM, 512 directory entries
0001B3B6= 0000                     445           dc.w     0        * directory mask
0001B3B8= 0000                     446           dc.w     0        * permanent mounted drive, check size is zero
0001B3BA= 0040                     447           dc.w     64       * track offset of 64
0001B3BC                           448  
0001B3BC                           449  * disk parameter block
0001B3BC                           450  * choose a BLS of 4096
0001B3BC                           451  * 1024 sectors (128 byte sector) per track
0001B3BC                           452  * 64 sectors per block
0001B3BC                           453  * 63 tracks per drive 
0001B3BC                           454  dpb2:    
0001B3BC= 0400                     455           dc.w     1024      * 1024 sectors per track
0001B3BE= 05                       456           dc.b     5        * block shift for BLS of 4096
0001B3BF= 1F                       457           dc.b     31       * block mask for BLS of 4096
0001B3C0= 01                       458           dc.b     1        * extent mask, EXM
0001B3C1= 00                       459           dc.b     0        * dummy fill
0001B3C2= 07DF                     460           dc.w     2015     * DSM, leave a head room of 1 track before next drive
0001B3C4                           461                             * 63 tracks * 1024 sectors * 128 bytes ~ 8 meg or 2016 blocks
0001B3C4= 01FF                     462           dc.w     511      * DRM, 512 directory entries
0001B3C6= 0000                     463           dc.w     0        * directory mask
0001B3C8= 0000                     464           dc.w     0        * permanent mounted drive, check size is zero
0001B3CA= 0080                     465           dc.w     128       * track offset of 128
0001B3CC                           466           
0001B3CC                           467  * disk parameter block
0001B3CC                           468  * choose a BLS of 4096
0001B3CC                           469  * 1024 sectors (128 byte sector) per track
0001B3CC                           470  * 64 sectors per block
0001B3CC                           471  * 63 tracks per drive 
0001B3CC                           472  dpb3:    
0001B3CC= 0400                     473           dc.w     1024      * 1024 sectors per track
0001B3CE= 05                       474           dc.b     5        * block shift for BLS of 4096
0001B3CF= 1F                       475           dc.b     31       * block mask for BLS of 4096
0001B3D0= 01                       476           dc.b     1        * extent mask, EXM
0001B3D1= 00                       477           dc.b     0        * dummy fill
0001B3D2= 07DF                     478           dc.w     2015     * DSM, leave a head room of 1 track before next drive
0001B3D4                           479                             * 63 tracks * 1024 sectors * 128 bytes ~ 8 meg or 2016 blocks
0001B3D4= 01FF                     480           dc.w     511      * DRM, 512 directory entries
0001B3D6= 0000                     481           dc.w     0        * directory mask
0001B3D8= 0000                     482           dc.w     0        * permanent mounted drive, check size is zero
0001B3DA= 00C0                     483           dc.w     192        * track offset of 192
0001B3DC                           484  
0001B3DC                           485  * RAM drive in memory from $700000 to $E00000
0001B3DC                           486  * disk parameter block
0001B3DC                           487  * choose a BLS of 4096
0001B3DC                           488  * 1024 sectors (128 byte sector) per track
0001B3DC                           489  * 64 sectors per block
0001B3DC                           490  * 63 tracks per drive 
0001B3DC                           491  dpb4:    
0001B3DC= 0400                     492           dc.w     1024      * 1024 sectors per track
0001B3DE= 05                       493           dc.b     5        * block shift for BLS of 4096
0001B3DF= 1F                       494           dc.b     31       * block mask for BLS of 4096
0001B3E0= 01                       495           dc.b     1        * extent mask, EXM
0001B3E1= 00                       496           dc.b     0        * dummy fill
0001B3E2= 07FF                     497           dc.w     2047     * DSM, leave a head room of 1 track before next drive
0001B3E4                           498                             * 63 tracks * 1024 sectors * 128 bytes ~ 8 meg or 2016 blocks
0001B3E4= 01FF                     499           dc.w     511      * DRM, 512 directory entries
0001B3E6= 0000                     500           dc.w     0        * directory mask
0001B3E8= 0000                     501           dc.w     0        * permanent mounted drive, check size is zero
0001B3EA= 0000                     502           dc.w     0        * no track offset
0001B3EC                           503  
0001B3EC                           504  **X no sector translation table
0001B3EC                           505  
0001B3EC                           506  **X      .bss
0001B3EC                           507  
0001B3EC                           508  dirbuf:  ds.b     128      * directory buffer
0001B46C                           509  
0001B46C                           510  * block/deblock buffer area
0001B46C                           511  * data from a CF sector (512 bytes) are stored here
0001B46C                           512  sectCF:  ds.b     512      * CF sector data buffer
0001B66C                           513  
0001B66C                           514  alv0:    ds.b     256      * allocation vector, DSM/8+1 = 249
0001B76C                           515  alv1:    ds.b     256      * DSM/8 +1 = 253, round up to 256
0001B86C                           516  alv2:    ds.b     256      * DSM/8 +1 = 253, round up to 256
0001B96C                           517  alv3:    ds.b     256      * DSM/8 +1 = 253, round up to 256
0001BA6C                           518  alv4:    ds.b     256      * DSM/8 +1 = 253, round up to 256
0001BB6C                           519  
0001BB6C                           520  *        end $15000        * start executing CPM at $15000
0001BB6C                           521           end 0

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ACR                 FFF009
ALV0                1B66C
ALV1                1B76C
ALV2                1B86C
ALV3                1B96C
ALV4                1BA6C
BIOSBASE            1B038
CF07                FFE007
CF1623              FFE00B
CF2427              FFE00D
CF815               FFE009
CFDATA              FFE000
CFERR               FFE002
CFSECTCNT           FFE005
CFSTAT              FFE00F
CLROPR              FFF01F
CONIN               1B0AE
CONOUT              1B0BC
CONSTAT             1B09A
CPDMA               1B1B0
CRA                 FFF005
CSRA                FFF003
CTL                 FFF00F
CTLR                FFF00F
CTU                 FFF00D
CTUR                FFF00D
CURCFSECT           1B2FE
DIRBUF              1B3EC
DMA                 1B306
DPB0                1B39C
DPB1                1B3AC
DPB2                1B3BC
DPB3                1B3CC
DPB4                1B3DC
DPH0                1B31A
DPH1                1B334
DPH2                1B34E
DPH3                1B368
DPH4                1B382
DPHLEN              1A
DUART               FFF000
FLUSH               1B2D4
GETIOB              1B2E0
GETSEG              1B2D8
HOME                1B0DA
IMRD                FFF00B
INIT1               1B006
IPCR                FFF009
ISRD                FFF00B
IVRD                FFF019
LISTST              1B0D4
LSTOUT              1B0CE
MAXDSK              5
MEMRGN              1B310
MOVE2DMA            1B19A
MR1B                FFF011
MRA                 FFF001
NFUNCS              17
NOSET               1B2FA
NOTON               1B0AA
OPCR                FFF01B
PLOG                1B30C
PREADCF             1B258
PUN                 1B0D0
RAMDRVR             1B1C4
RAMDRVRD            1B1C0
RAMDRVW             1B2C4
RAMDRVWR            1B2C0
RDR                 1B0D2
READ                1B120
READCF              1B14C
READCF1             1B190
READDRQ             1B182
READDRQW            1B24A
READEXIT            1B1D0
RESV                1B2FD
RESV1               1B30B
RHRA                FFF007
RHRB                FFF017
SECTCF              1B46C
SECTOR              1B304
SECTRAN             1B114
SELCODE             1B30A
SELDRV              1B2FC
SELDSK              1B0E2
SELRTN              1B102
SETDMA              1B118
SETEXC              1B2E4
SETIOB              1B2E2
SETOPR              FFF01D
SETSEC              1B10C
SETTRK              1B104
SETUPRD             1B1D4
SRA                 FFF003
SRB                 FFF013
STARTCTR            FFF01D
STOPCTR             FFF01F
THRA                FFF007
TRACK               1B302
TRAPHNDL            1B026
TRAPNG              1B036
WBOOT               1B094
WRCPDMA             1B278
WREXIT              1B2D0
WRITE               1B1F2
WRITECF             1B262
WRITECF1            1B2A8
WRITECF2            1B2B2
WRITEDRQ            1B29A
_CCP                150BC
_INIT               1B000
