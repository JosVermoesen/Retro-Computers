/*
 *  signal.c	(libc)
 *
 *  signal.c **MUST** be compiled with the -Of1 flag to create a frame
 *
 *  Copyright 1987, 1992 by Sierra Systems.  All rights reserved.
 */

#include <errno.h>
#include <stdlib.h>
#include <stdio.h>
#include <signal.h>

/*
 * The functions[] array contains either a code (the macros SIG_DFL or
 * SIG_IGN) or a function address which has been registered to be called
 * when a signal occurs.  At program startup, all elements of the array
 * are initialized to macro SIG_DFL, value 0.  This means that if a signal
 * is received, raise() will invoke the default signal handler for the
 * signal.  Currently these are all dflt_sig().	 However, this function can
 * be modified to have different default functions called depending on the
 * signal received by using a switch to call different default functions.
 *
 * When signal() is called with the macro SIG_IGN for a particular signal,
 * raise simply returns when the signal is received.  When signal() is called
 * with a function address, that function is registered in the array
 * functions[] under the signal number.	 When a signal occurs, SIG_DFL is
 * re-registered, then the previously registered function is called with the
 * signal number as its argument.
 *
 * When an exception occurs, the trap handler which was installed by
 * ldtraps() or ldftraps() saves all the registers, calls _xraise(), which
 * calls the function registered with signal().	 Note, ldtraps() and
 * ldftraps() are called from the C Run-Time header.  If the trap handlers
 * are to be installed in ROM, the trap handlers must be inserted at compile
 * time, not run-time.
 */

void _disp_xcptn_info(long);

static void dflt_sig(long);

/* functions[] is set to 0 at run-time by virtue of being bss */

static void (*functions[MAXSIG + 1])(int);

/*------------------------------- signal() ----------------------------------*/

/*
 * signal registers a function to be called when a given signal is received.
 * It takes a signal number, and a pointer to a function returning a void.
 * It returns a pointer to the previous function registered.
 *
 * If the signal number is not recognized by signal(), errno is set to
 * EINSIG, and the value SIG_ERR is returned.
 */

void (*signal(int signal_nbr, void (*func)(int)))(int)
{
    register void (*prev_func)(int);

    if( (signal_nbr < 1) || (signal_nbr > MAXSIG) ) {
	errno = EINSIG;
	return(SIG_ERR);
    }
    prev_func = functions[signal_nbr];
    functions[signal_nbr] = func;
    return(prev_func);
}

/*-------------------------------- raise() ----------------------------------*/

/*
 * raise is a user callable function that causes a signal to occur
 */

int raise(register int signal_nbr)
{
    register void (*func)(int);

    /* not a valid signal number */

    if( (signal_nbr < 1) || (signal_nbr > MAXSIG) ) {
	errno = EINSIG;
	return(-1);
    }

    /* ignore this signal */

    if( (func = functions[signal_nbr]) == SIG_IGN )
	return(0);

    /* call default signal handler */

    if( func == SIG_DFL ) {
	dflt_sig(signal_nbr);
	return(0);
    }

    /* call the registered function */

    functions[signal_nbr] = SIG_DFL;
    func(signal_nbr);
    return(0);
}

/*-------------------------------- _xraise() ---------------------------------*/

/*
 * _xraise() is used for exceptions.  When the information passed to _xraise()
 * is passed onto the default signal handling routine, dflt_sig(), the high bit
 * of the passed value is set to tell it to get detailed information off the
 * exception stack.  Similarly, other high bits are used to identify the type
 * of exception causing a SIGFPE.  This information is passed to _xraise() by
 * the exception handler via.
 */

void _xraise(unsigned long sig)
{
    void (*func)(int);
    int sig_nbr;

    /* prevent from going into registers */

    &sig;
    &func;
    &sig_nbr;

    /* clear the high 2 byte to get the actual signal number */

    sig_nbr = sig & 0xffff;

    /* not a valid signal number */

    if( (sig_nbr < 1) || (sig_nbr > MAXSIG) ) {
	errno = EINSIG;
	return;
    }

    /* ignore this signal */

    if( (func = functions[sig_nbr]) == SIG_IGN )
	return;

    /* call default signal handler */

    if( func == SIG_DFL ) {
	dflt_sig(sig | 0x80000000);	/* 0x80000000 indicated exception */
	return;
    }

    /* call the registered function */

    functions[sig_nbr] = SIG_DFL;
    func(sig_nbr);
}

/*------------------------------ dflt_sig() ---------------------------------*/

static void dflt_sig(long sig)
{
    register char *err_msg;
    register char *fp_err_msg;

    fp_err_msg = NULL;

    /* If the signal was generated by a processor exception (indicated by */
    /* high bit set), get the information from the stack and print it out */
    /* to stderr.							  */

    if( sig & 0x80000000 ) {
	_disp_xcptn_info(sig & 0x7fffffff);
#if 0
	return;		/* return to continue from exception processing */
#else
	_exit(EXIT_FAILURE);
#endif
    }
	
    switch( sig & 0xffff ) {
    case SIGABRT:   err_msg = "Abnormal Program Termination";	break;
    case SIGBUS:    err_msg = "Bus Error";			break;
    case SIGCHK:    err_msg = "Chk Instruction Exception";	break;
    case SIGFPE:    err_msg = "Floating Point Exception";
	switch( (sig & 0x7fffffff) >> 24 ) {
	case 1:	fp_err_msg = "Illegal Instruction";		    break;
	case 2:	fp_err_msg = "Protocol Violation";		    break;
	case 3:	fp_err_msg = "Branch Set on Unordered Condition";   break;
	case 4:	fp_err_msg = "Inexact Result";			    break;
	case 5:	fp_err_msg = "Divide by Zero";			    break;
	case 6:	fp_err_msg = "Underflow";			    break;
	case 7:	fp_err_msg = "Operand Error";			    break;
	case 8:	fp_err_msg = "Overflow";			    break;
	case 9: fp_err_msg = "Signaling NaN";			    break;
	case 10:fp_err_msg = "Unimplemented Data Type";		    break;
	default:fp_err_msg = "Integer Divide By Zero";
	}
	break;
    case SIGILL:    err_msg = "Illegal Instruction";		break;
    case SIGINT:    err_msg = "^C";				break;
    case SIGTRAP:   err_msg = "TRAPV - TRAPcc";			break;
    case SIGPRIV:   err_msg = "Privilege Violation";		break;
    case SIGADDR:   err_msg = "Address Error";			break;
    case SIGTERM:   err_msg = "Termination";			break;
    case SIGSPUR:   err_msg = "Spurious Interrupt";		break;
    case SIGZDIV:   err_msg = "Divide By Zero";			break;
/*
    case SIGUSER:   err_msg = "User Defined Signal";		break;
*/
    default:	    err_msg = "Undefined Signal";
    }

    fputs(err_msg, stderr);
    if( fp_err_msg ) {
	fputs(" ---- ", stderr);
	fputs(fp_err_msg, stderr);
    }
    fputc('\n', stderr);

    _exit(EXIT_FAILURE);
}
