diff --git a/bios/bios.c b/bios/bios.c
index f127542..a4c567a 100644
--- a/bios/bios.c
+++ b/bios/bios.c
@@ -304,6 +304,7 @@ static void bios_init(void)
     etv_timer = (ETV_TIMER_T) just_rts;
     etv_critic = default_etv_critic;
     etv_term = just_rts;
+    swv_vec = just_rts;
 
     /* setup default VBL queue with vbl_list[] */
     nvbls = ARRAY_SIZE(vbl_list);
@@ -433,6 +434,7 @@ static void bios_init(void)
     boot_status |= DOS_AVAILABLE;   /* track progress */
 
     /* Enable VBL processing */
+    swv_vec = os_header.reseth; /* reset system on monitor change & jump to _main */
     vblsem = 1;
 
 #if CONF_WITH_CARTRIDGE
diff --git a/bios/screen.c b/bios/screen.c
index 15cf57d..4511ba2 100644
--- a/bios/screen.c
+++ b/bios/screen.c
@@ -37,6 +37,7 @@
 #include "amiga.h"
 #endif
 
+void detect_monitor_change(void);
 static void setphys(const UBYTE *addr);
 
 #if CONF_WITH_ATARI_VIDEO
@@ -1075,3 +1076,96 @@ void vsync(void)
     set_sr(old_sr);
 #endif /* CONF_WITH_ATARI_VIDEO */
 }
+
+#if CONF_WITH_ATARI_VIDEO
+/*
+ * detect_monitor_change(): called by VBL interrupt handler
+ *
+ * this checks if the current monitor mode (monochrome/colour) is the
+ * same as that set in the shifter.  if not, it calls swv_vec() which
+ * by default does a system restart.
+ */
+void detect_monitor_change(void)
+{
+    SBYTE monoflag;
+    volatile SBYTE *gpip = ((volatile SBYTE *)0xfffffa01);
+    volatile UBYTE *shifter;
+    UBYTE monores;
+    UBYTE curres;
+    UBYTE newres;
+    
+    /* not supported on VIDEL */
+    if (HAS_VIDEL)
+        return;
+
+    monoflag = *gpip;
+    if (HAS_DMASOUND)
+    {
+        WORD sr = set_sr(0x2700);
+        SBYTE monoflag2;
+        SBYTE dmaplay;
+        
+        for (;;)
+        {
+            dmaplay = *((volatile SBYTE *)0xffff8901);
+            monoflag = *gpip;
+            monoflag2 = *gpip;
+            if ((monoflag ^ monoflag2) < 0)
+                continue;
+            if (*((volatile SBYTE *)0xffff8901) == dmaplay)
+                break;
+        }
+    
+        set_sr(sr);
+        if (dmaplay & 1)
+            monoflag = -monoflag;
+    }
+    
+    if (HAS_TT_SHIFTER)
+    {
+        shifter = ((volatile UBYTE *)0xffff8262);
+        curres = *shifter & 7;
+        monores = TT_HIGH;
+    }
+    else    /* assumed ST(e) shifter */
+    {
+        shifter = ((volatile UBYTE *)0xffff8260);
+        curres = *shifter & 3;
+        monores = ST_HIGH;
+    }
+
+    if (curres == monores)  /* current resolution is mono */
+    {
+        if (monoflag >= 0)  /* mono monitor detected */
+            return;
+        /* colour monitor detected: switch resolution */
+        newres = defshiftmod;   /* use default shifter mode */
+        if (newres == monores)  /* but if it's mono, make it ST LOW */
+            newres = ST_LOW;
+    }
+    else        /* current resolution is a colour resolution */
+    {
+        if (monoflag < 0)   /* & colour monitor detected */
+            return;
+        /* mono monitor detected: switch resolution */
+#if 0
+        /*
+         * TOS 2.06 & 3.06 (at least) call this here to wait until just
+         * after a VBL.  it is surmised that this is because:
+         * (a) experience shows that at least some video hardware
+         *     misbehaves if the shifter value is not changed 'soon'
+         *     after the interrupt, and
+         * (b) in TOS 2/3, the vblqueue is processed before this routine
+         *     is called, and thus lengthy vblqueue function(s) could
+         *     trigger the misbehaviour.
+         */
+        vsync();
+#endif
+        newres = monores;
+    }
+
+    sshiftmod = newres;
+    *shifter = (*shifter & 0xf8) | newres;
+    (*swv_vec)();
+}
+#endif /* CONF_WITH_ATARI_VIDEO */
diff --git a/bios/vectors.S b/bios/vectors.S
index 42b713d..c7e70e4 100644
--- a/bios/vectors.S
+++ b/bios/vectors.S
@@ -55,6 +55,7 @@
         .extern _timer_ms
         .extern _v_bas_ad
 
+        .extern _detect_monitor_change  // screen.c
         .extern _blink          // conout.c - console output
 
 // Note: this scheme is designed to print the exception number
@@ -294,8 +295,6 @@ is_ipl:
 /*
  * _int_vbl - Int 0x70 - VBL interrupt
  *
- * no video resolution change is done.
- *
  * The sequence of events within the VBL interrupt handler
  * -------------------------------------------------------
  * According to p.47 of "A Hitchhiker's Guide to the BIOS (November 1985)",
@@ -327,8 +326,10 @@ _int_vbl:
 #endif
         addq.l  #1, _vbclock.w          // count number of VBL interrupts
 
-        // TODO: Check for monitor switching on normal ST(E) here,
-        // and jump to _swv_vec if necessary...
+#if CONF_WITH_ATARI_VIDEO
+// check for monitor switching and jump to _swv_vec if necessary...
+        jsr     _detect_monitor_change
+#endif
 
         jsr     _blink                  // blink cursor
 
diff --git a/include/tosvars.h b/include/tosvars.h
index b6fc740..b844927 100644
--- a/include/tosvars.h
+++ b/include/tosvars.h
@@ -43,6 +43,7 @@ extern UBYTE *v_bas_ad;
 
 extern const UWORD *colorptr;
 extern UBYTE *screenpt;
+extern UBYTE defshiftmod;
 extern UBYTE sshiftmod;
 
 extern UBYTE *phystop;
@@ -108,4 +109,6 @@ extern ETV_TIMER_T etv_timer;
 extern LONG (*etv_critic)(WORD err,WORD dev);
 extern void (*etv_term)(void);
 
+extern void (*swv_vec)(void);
+
 #endif /* TOSVARS_H */
