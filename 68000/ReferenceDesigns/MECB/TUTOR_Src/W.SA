W        IDNT      2,0       Software Abort, Hex print routines      06/05/82         XDEF      ABORT335         XDEF      ABORTB         XDEF      ABORTE         XDEF      CKADDR         XDEF      CKWADR         XDEF      EVECT2         XDEF      EVECT4         XDEF      EVECTL         XDEF      FNEXTF         XDEF      FRELADDR         XDEF      GETDECNU         XDEF      GETEXP         XDEF      GETHEX         XDEF      GETHEXNU         XDEF      GETNUMA         XDEF      GETNUMD         XDEF      PNTZHX         XDEF      PNT8HX         XDEF      PNT6HX         XDEF      PNT4HX         XDEF      PNT2HX         XDEF      PUTHEX SPC 1         XREF.S    AV12         XREF.S    AV31         XREF      ERROR         XREF      FAULTSER         XREF      FIXBUF         XREF      FIXDADD         XREF      FIXDATA         XREF      FIXDCRLF         XREF      INITSER         XREF      MACSBUG         XREF      MSG         XREF.S    OFFSET         XREF      OUT1CR         XREF      OUTPUT         XREF.S    REGA7         XREF      SAVE         XREF.S    TEMP         XREF      TDISPLY SPC 3CR       EQU       $DLF       EQU       $AEOT      EQU       4 SPC 1ADDR2MEM MACRO         PEA       \1(PC)              MOVE ADDRESS TO MEMORY; POSITION         MOVE.L    (A7)+,\2               INDEPENDANT = TO "MOVE.L #\1,\2"         ENDM SPC 1SAVEREGS MACRO         MOVE.L    A7,REGA7            SAVE STACK POINTER         LEA       SV\@(PC),A7    A7   = RETURN ADDRESS (FOR CALL TO SAVE)         MOVE.L    A7,TEMP             TEMP = RETURN ADDRESS         BRA       SAVE                BSR WITHOUT USING STACKSV\@     DS        0 SPC 1         ENDM SPC 1         SECTION   10         ADDR2MEM  ABORTB,AV31         ABORT         SECTION   11 SPC 1**   HANDLE THE ABORT BUTTON*ABORTB   MOVE.W    #$2700,SR         SAVEREGS         BSR       FAULTSER            RESET SERIAL PORTS         LEA       MSG012(PC),A5       'SOFTWARE ABORT' SPC 1         BSR       INITSER   RESET SERIAL PORTS (CLEAR TM MODE)         BSR     FIXDCRLF    MOVE MESSAGE TO BUFFEREVECT4   BSR     OUTPUT    MSG TO PORT1                              2,0ABORT335 BSR     TDISPLY            DISPLAY REGISTERS         BRA     MACSBUG SPC 1MSG012   DC.B      LF,LF,'SOFTWARE ABORT',CR,LF,EOT PAGEABORTE MOVE.L      #'????',$30         UNKNOWN INTERRUPT SPC 1*    SAVE REGISTERS AND PRINT VECTOR MSG*EVECTL   SAVEREGS         BSR       FAULTSER            RESET SERIAL PORTSEVECT2   BSR FIXBUF  PRINT MESSAGE "XXXX TRAP ERROR"       MOVE.W #$0D0A,(A6)+       MOVE.L AV12,(A6)+     TYPE OF ERROR         LEA       MSG010(PC),A5     'TRAP ERROR'         BSR    FIXDADD         BRA    EVECT4                 .                             2,0 SPC 1MSG010   DC.B      ' TRAP ERROR',CR,LF,EOT         PAGE**  PRINT HEX ROUTINES*** PRINT 8 HEX CHARACTERS**  D0,D1,D2 DESTROYED*PNT8HX   SWAP D0  FLIP REG HALVES         BSR.S  PNT4HX  DO TOP WORD         SWAP D0  NOW DO LOWER WORD         BRA.S PNT4HX* PRINT 6 HEX CHARACTERSPNT6HX   SWAP D0  FLIP REGISTER HALVES         BSR.S PNT2HX         SWAP D0  FLIP BACK REG HALVES* PRINT 4 HEX CHARACTERS IN D0.WPNT4HX   MOVE.W D0,D1  SAVE IN TEMP         ROR.W  #8,D0  GET BITS 15-8 INTO LOWER BYTE         BSR.S  PNT2HX  PRINT IT         MOVE.W D1,D0  PULL IT BACK* PRINT 2 HEX CHARACTERS IN D0.BPNT2HX   MOVE.W D0,D2  SAVE IN TEMP REG         ROXR.W #4,D0  FORM UPPER NIBBLE         BSR.S PUTHEX  PUT ASCII INTO PRINT BUFFER         MOVE.W D2,D0  GET BACK FROM TEMP* CONVERT D0.NIBBLE TO HEX & PUT IT IN PRINT BUFFER*PUTHEX   AND.B #$0F,D0  SAVE LOWER NIBBLE         OR.B #$30,D0  CONVERT TO ASCII         CMP.B #$39,D0   SEE IF IT IS>9         BLE.S SAVHEX         ADD #7,D0  ADD TO MAKE 10=>ASAVHEX   MOVE.B D0,(A6)+ PUT IT IN PRINT BUFFER         RTS           PAGE* FORMAT RELATIVE ADDRESS  AAAAAA+Rn*        ENTER     D0 = VALUE*                  A6 = STORE POINTER*FRELADDR MOVEM.L   D1/D5-D7/A0,-(A7)         LEA       OFFSET,A0         MOVE.L    #-1,D7              D7 = DIFF. BEST FIT         CLR.L     D6                  D6 = OFFSET POSITIONFREL10   MOVE.L    D0,D1         TST.L     (A0)         BEQ.S     FREL15              ZERO OFFSET         SUB.L     (A0),D1             D1 = DIFF.         BMI.S     FREL15              NO FIT         CMP.L     D7,D1         BCC.S     FREL15              OLD FIT BETTER         MOVE.L    D1,D7               D7 = NEW BEST FIT         MOVE.L    D6,D5               D5 = POSITIONFREL15   ADD.L     #4,A0         ADD.L     #1,D6         CMP.W     #8,D6               .                             2,0         BNE       FREL10              MORE OFFSETS TO CHECK         TST.L     D7         BMI.S     FREL25              NO FIT         TST       D6         BNE.S     FREL20         TST.L     OFFSET         BEQ.S     FREL25              R0 = 000000; NO FITFREL20   MOVE.L    D7,D0         BSR       PNT6HX              FORMAT OFFSET         MOVE.B    #'+',(A6)+          +         MOVE.B    #'R',(A6)+          R         ADD.B     #'0',D5             MAKE ASCII         BRA.S     FREL30FREL25   BSR       PNT6HX              FORMAT ADDRESS AS IS         MOVE.B    #' ',D5             .                             2,0         MOVE.B    D5,(A6)+            THREE SPACES FOR ALIGNMENT    2,0         MOVE.B    D5,(A6)+            .                             2,0FREL30   MOVE.B    D5,(A6)+            .                             2,0         MOVEM.L   (A7)+,D1/D5-D7/A0   .                             2,0         RTS         PAGE***   PRINT HEX (ZERO SURPRESS)*PNTZHX   CLR.L D4  IS ZERO WHEN SURPRESSING         MOVE.L D0,D1  SAVE IN TEMP         BEQ.S PNTZ81  IF ZERO         BPL.S PNTZ0         NEG.L D1  CHANGE TO POSITIVE VALUE         BMI.S  PNTZ81 WATCH OUT SPECIAL CASE $80000000         MOVE.B #'-',(A6)+  PUT SIGN INTO BUFFERPNTZ0    MOVE.L #8,D2   8 POSSIBLE CHARACTERSPNTZ1    MOVE.L D1,D0  UNSAVE IT         MOVE.L D2,D3 COUNT DOWN FROM HERE         SUB.L #1,D3  BACK OFF ONE         BEQ.S PNTZ4  IF NO ROTATE SKIP THISPNTZ2    ASR.L #4,D0  ROTATE LRIGHT         AND.L #$FFFFFFF,D0  CLEAR TOP NIBBLE         SUB.L #1,D3         BNE PNTZ2PNTZ4    AND.B #$F,D0  SAVE ONLY NIBBLE         BNE.S PNTZ3         TST.B D4  SEE IF STILL SURPRESSING         BEQ.S PNTZ8PNTZ3    BSR PUTHEX  PUT A HEX CHAR IN BUFFER         MOVE.B D0,D4  MARK AS NON-SURPRESSING MODEPNTZ8    SUB.L #1,D2    DO ANOTHER CHAR         BNE PNTZ1         TST.B D4  SEE IF ANYTHING PRINTED         BNE.S PNTZ9PNTZ81   MOVE.B #'0',(A6)+  MOVE AT LEAST ONE ZEROPNTZ9    RTS         PAGE* FIND NEXT FIELD... (A5) POINTS TO FIELD, (A0) NULL FIELD RETURN*   *-*-WARNING-*-* IF (A0) RETURN IS USED;  RETURN MUST BE AT*                   SAME SUBROUTINE LEVEL OR STACK GETS SCREWED UP**  SKIP LEADING SPACES*  TERMINATE NULL FIELD ON COMA ,SEMICOLEN OR A5=A6FNEXTF1  ADD.L     #1,A5 SPC 1FNEXTF   MOVE.B    (A5),D0   ENTRY POINT         CMP.L     A6,A5         BCC.S     FNEXTF7   AT END OF BUFFER         CMP.B     #' ',D0         BEQ       FNEXTF1   SPACE SPC 1         CMP.B     #',',D0         BEQ.S     FNEXTF7   COMA- NULL FIELD         CMP.B     #';',D0         BEQ.S     FNEXTF7   SEMICOLEN - NULL FIELD         RTS                 NORMAL FOUND FIELD RETURN SPC 1FNEXTF7  ADD.L     #4,A7     TRIM STACK         JMP       (A0)      NULL FIELD RETURN         PAGE*************************************************************** THIS ROUTINE MAKES SURE YOU ARE ON THE CORRECT BOUNDRY.    **  D0 = ARGUMENT...   CHECKS ADDRESS AND WORD ALIGNMENTS.   *************************************************************** SPC 2CKWADR   ROR.L     #1,D0         ROL.L     #1,D0         BCS.S     CKADR39   NOT WORD ALIGNED SPC 1CKADDR   CMP.L   #$1000000,D0 VALID ADDRESS?         BCS.S   CKADR99     GOOD ADDRESS SPC 1CKADR39  LEA     MSG018(PC),A5         BSR     FIXDATA         BSR       PNT8HX         BSR     OUT1CR         BRA     MACSBUG SPC 1CKADR99  RTS SPC 1MSG018   DC.B      'INVALID ADDRESS=',EOT PAGE* EVALUATE EXPRESSION*  NUMBER PLUS OR MINUS NUMBER....*GETEXP   MOVE.L    D7,-(A7)            SAVE D7         CLR.L     D7GETEXP21 BSR.S     GETNUMA             GET NUMBER         ADD.L     D0,D7               D7 = NUMBER BEING BUILTGETEXP15 MOVE.B    (A5)+,D1            D1 = TERMINATING CHAR         CLR.L     D0                  D0 = NEXT NUMBER (=0 1ST TIME)         CMP.B     #'+',D1         BEQ       GETEXP21            PLUS         CMP.B     #'-',D1         BNE.S     GETEXP39            NOT MINUS         BSR.S     GETNUMA             GET NEXT NUMBER         SUB.L     D0,D7         BRA       GETEXP15 SPC 1GETEXP39 MOVE.L    D7,D0               D0 = VALUE BUILT         SUB.L     #1,A5               A5 = CHAR AFTER EXPRESSION         MOVE.L    (A7)+,D7            RESTORE D7         RTS PAGE*   ROUTINES TO CONVERT STRING TO BINARY VALUE**        ACCEPTS PREFIXES:*         % binary*         @ octal*         & decimal*         $ hex*GETNUMD  BSR.S     GETDECNU            GET DECIMAL NUMBERGETNUMD9 BNE       ERROR         RTSGETNUMA  BSR.S     GETHEXNU            GET HEX NUMBER         BRA       GETNUMD9GETDECNU MOVEM.L   D1-D5/A0,-(A7)      DECODE AS A DECIMAL NUMBER         MOVE.L    #10,D3              D3 = BASE (DECIMAL)         BRA.S     GETN20 SPC 2GETHEXNU MOVEM.L   D1-D5/A0,-(A7)      DECODE AS A HEX NUMBER         MOVE.L    #16,D3    D3 = BASE SPC 1GETN20   CLR.W     D4        D4 = FLAG FOR CHARACTER HIT         CLR.L     D1        D1 = TEMP RESULTS         CMP.B     #' ',(A5)         BEQ.S     GETN80              FIRST CHAR SPACE; ERRORGETN30   CMP.L A6,A5   SEE IF AT END OF BUFFER         BEQ.S     GETN90         CLR.L     D0         MOVE.B    (A5)+,D0            D0 = CHARACTER SPC 1         LEA       GETNDATA(PC),A0     POINTER TO TERMINATE CHARSGETN40   MOVE.B    (A0)+,D5            D5 = TERMINATION CHAR         BEQ.S     GETN50              NOT TERM.CHAR         CMP.B     D5,D0         BEQ.S     GETN85              FOUND TERMINATION CHAR; EXIT         BRA       GETN40 SPC 1GETN50   CMP.B     #'%',D0             SEE IF FLAGGED AS BINARY         BNE.S     GETN60         MOVE.L    #2,D3               BASE IS BINARYGETN55   TST.W     D4                  ANYTHING ENTERED         BNE.S     GETN80              CONFLICTGETN57   MOVE.L    #-1,D4              SET DATA ENTERED FLAG         BRA       GETN30GETN60   CMP.B     #'@',D0             SEE IF FLAGGED AS OCTAL         BNE.S     GETN65         MOVE.L    #8,D3               BASE IS OCTAL         BRA       GETN55GETN65   CMP.B     #'&',D0             SEE IF FLAGGED AS DECIMAL         BNE.S     GETN70         MOVE.L    #10,D3              BASE IS DECIMAL         BRA       GETN55 SPC 1GETN70   CMP.B     #'$',D0             SEE IF FLAGGED AS HEX         BNE.S     GETN75         MOVE.L    #16,D3              BASE IS 16         BRA       GETN55 SPC 1GETN75   SUB.B     #$30,D0         BLT.S     GETN80              LESS THAN ZERO         CMP.B     #9,D0         BLE.S     GETN77              VALUE 0 - 9         CMP.B     #$11,D0         BLT.S     GETN80              LESS THAN A         CMP.B     #$16,D0         BGT.S     GETN80              GREATER THAN F         SUB.B     #7,D0               MAKE BINARYGETN77   CMP.W     D3,D0               IS INPUT LARGER THAN BASE         BCC.S     GETN80              LARGER THAN BASE         MOVE.L    D1,D2               GET READY TO MULTIPLY D1*BASE         SWAP      D1         MULU      D3,D1   TOP PART         SWAP      D1         TST.W     D1   CHECK FOR OVERFLOW         BNE.S     GETN80              VALUE IS TOO LARGE         MULU      D3,D2  NOW WORK ON LOW WORD         ADD.L     D2,D1  PUT IT BACK TOGETHER         BVS.S     GETN80  OVERFLOW?         ADD.L     D0,D1  ADD IN NEW STUFF         BVC       GETN57GETN80   MOVE.L    #-1,D0              ERROR RETURN (BNE)         BRA.S     GETN95GETN85   SUB.L     #1,A5     BACK UP TO POINT AT SPACE/PREVIOUS CHARGETN90   MOVE.L    D1,D0     SET UP RESULT FOR RETURN         CLR.L     D1                  NORMAL RETURN (BEQ)GETN95   MOVEM.L   (A7)+,D1-D5/A0      RESTORE SOME REGISTERS         RTSGETNDATA DC.B      ' (+,-.:;=^]',0      TERMINATE CHARS         PAGE**  ***GETHEX***  GET HEX (BINARY VALUE FROM ASCII)*   D0.B HAS ASCII CHAR  RETURNS $0-$F BINARY*GETHEX CMP.B #$30,D0  IS IT LESS THAN ZERO       BLT.S PNMSG011       CMP.B #$39,D0  IS IT GREATER THAN 9         BLE.S     GTHX2     GOOD HEX SPC 1       CMP.B #$41,D0  IS IT LESS THAN 'A'       BLT.S       PNMSG011       CMP.B #$46,D0  IS IT GT 'F'       BGT.S       PNMSG011       SUB.B #7,D0  MAKE IT SMALLER A=10GTHX2    AND.L     #$F,D0         RTS SPC 1PNMSG011 BSR       FIXBUF  PRINT NOT A HEX DIGIT         MOVE.B    D0,(A6)+  PUT IN OFFENDING CHAR         LEA       MSG011(PC),A5          '  IS NOT A HEX DIGIT'         BSR       FIXDADD         BRA MSG  GO PRINT IT AND ENTER MACSBUG SPC 1MSG011   DC.B      '  IS NOT A HEX DIGIT',EOT SPC 3         END