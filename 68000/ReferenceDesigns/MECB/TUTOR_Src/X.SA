X        IDNT      1,1       COMMON I/O                              05/17/82         XDEF      BUFFSIZE         XDEF      CRPADS         XDEF      FIXBUF         XDEF      GETSER1         XDEF      GETSER2         XDEF      NULLPADS         XDEF      OUTCH1         XDEF      OUTP2         XDEF      OUT1CR         XDEF      OUT1CR0         XDEF      OUTPUT         XDEF      OUTPUT2         XDEF      OUTPUT20         XDEF      OUTPUT21         XDEF      PORTIN1         XDEF      PORTIN1N         XDEF      PORTIN10 SPC 1         XREF.S    ALTSER1         XREF.S    ALTSER2         XREF.S    BUFFER         XREF      INCHNE         XREF.S    INFROM         XREF.S    INPORT1         XREF      OUTCH         XREF.S    OUTPORT1         XREF.S    OUTPORT2         XREF.S    OUTTO         XREF      SER1         XREF      SER2         XREF.S    XONOFFBUFFSIZE EQU       128CR       EQU       $DLF       EQU       $ACTLD     EQU       $4CTLH     EQU       $8CTLX     EQU       $18DEL      EQU       $7F PAGE         SECTION.S 1NULLPADS DS.B 2  CHARACTER NULL PADSCRPADS   DS.B 2  CARRIAGE RETURN NULL PADS         SECTION   11********************************    SEND LINE TO PORT1 WITH CR/LF*OUT1CR   MOVE.B    #$D,(A6)+           CR         MOVE.B    #$A,(A6)+           LF         TST.L OUTTO  SEE IF ALTERNATE ADDRESS         BEQ.S OUT1CRX         MOVE.L OUTTO,-(A7)  PUSH ON STACK         RTS . GO DO ITOUT1CRX  MOVE.L OUTPORT1,-(A7)  GO TO I/O ADDRESS         RTS  . (THIS NORMALLY GOES TO OUT1CR0)*OUT1CR0  DS      0**    OUTPUT BUFFER TO PORT1*OUTPUT   MOVEM.L D0-D3/A0-A1,-(A7)  GET SOME WORKING ROOM         CLR.L D3            D3 = NO OFFSET INTO NULL CHARACTERS         BSR.S     GETSER1         A0 = GET SERIAL PORT 1 ADDRESS         BRA.S OUTP2**    SEND LINE TO PORT2 WITH CR*OUTPUT2  MOVE.B  #$D,(A6)+   TACK ON A "CR"         TST.L   OUTTO       SEE IF ALTERNATE ADDRESS         BEQ.S OUTPUT2X         MOVE.L OUTTO,-(A7)  PUSH ON STACK         RTS .  GO DO ITOUTPUT2X MOVE.L OUTPORT2,-(A7)  GO TO IO ROUTINE         RTS .  (THIS NORMALLY GOES TO OUTPUT20)*OUTPUT20 DS      0**     OUTPUT BUFFER TO PORT2*OUTPUT21 MOVEM.L D0-D3/A0-A1,-(A7)         MOVE.L #1,D3  SIGNAL FOR PORT2         BSR.S     GETSER2   RETURNS SERIAL PORT 2 BASE ADDRESS IN A0**   SEND BUFFER TO PORT*OUTP2    CMP.L A6,A5  SEE IF AT OR BEYOND END OF LINE         BCS.S OUTP3  NO... KEEP GOING, ELSE         MOVEM.L (A7)+,D0-D3/A0-A1  RESTORE REGISTERS         RTS .   END OF ROUTINEOUTP3    MOVE.B (A5)+,D0   GRAB BYTE TO OUTPUT         BSR.S OUTCH1  GO PRINT IT         BRA.S OUTP2   GO DO ANOTHER PAGE*   SEND CHARACTER IN D0.B TO PORT1*   WHOSE BASE ADDRESS IS IN A0*   D3=0 FOR PORT1  D3=1 FOR PORT2*   PUTS IN NULL PADDING AS NEEDED*OUTCH1   BSR       OUTCH   GO PRINT D0         TST.B D0  SEE IF NULL         BEQ.S OUTCHRTS  JUST END IF NULL         CLR.L D2  CLEAR UPPER BYTES OF NULL LOOP COUNTER         LEA       NULLPADS,A1  FORM ADDRESS OF PADS         ADD.L D3,A1   D3=0 FOR PORT1 1=PORT2         MOVE.B (A1),D2  DEFAULT NULL PADS         CMP.B #$D,D0    SEE IF CR         BNE.S OUTCH2         LEA       CRPADS,A1  FORM ADDRESS OF CR PADS         ADD.L D3,A1   D3=0 FOR PORT1  1=PORT2         MOVE.B (A1),D2  NULLS AFTER CROUTCH2   TST.L D2  SEE IF ANY PADDS TO BE SEND         BEQ.S OUTCHRTS  0=NONE         CLR.L D0  0=NULL CHAR TO BE SENDOUTCH3   BSR       OUTCH   SEND A NULL         SUB.L #1,D2  LOOP AROUND         BNE OUTCH3OUTCHRTS RTS .  END OF OUTCH ROUTINE PAGE**   GET BASE ADDRESS OF SERIAL PORT 1 IN  A0* SPC 1GETSER1  LEA       SER1,A0   DEFAULT         TST.L     ALTSER1   IF ALTERNATE IS ZERO         BEQ.S     RETURN    THEN RETURN         MOVE.L    ALTSER1,A0  ELSE USE ALTERNATE SERIAL PORT 1RETURN   RTS       RETURN  (USED FROM A COUPLE OF PLACES) SPC 2**   GET BASE ADDRESS OF SERIAL PORT 2 IN A0* SPC 1GETSER2  LEA       SER2,A0   DEFAULT SERIAL PORT 2         TST.L     ALTSER2   IF ALTERNATE IS ZERO         BEQ       RETURN    THEN RETURN         MOVE.L ALTSER2,A0   ELSE USE ALTERNATE SERIAL PORT 2         RTS                 RETURN**     FIX THE BUFFER A5 & A6 SET TO START OF BUFFER QUE*FIXBUF   LEA       BUFFER,A5         MOVE.L A5,A6         RTS PAGE*   INPUT A LINE FROM PORT1*PORTIN1  TST.L INFROM          SEE IF ALTERNAME ADDRESS         BEQ.S PORTIN1X         MOVE.L INFROM,-(A7)   PUSH ON STACK         RTS                   .  GO DO ITPORTIN1X MOVE.L INPORT1,-(A7)  GO TO IO ROUTINE         RTS                   .  NORMALLY GOES TO PORTIN10 SPC 4PORTIN1N MOVEM.L D0-D4/D7/A0-A2,-(A7)         TST.B     XONOFF+2         BNE.S     PORTIN1V  OVERRIDE "No Auto Line Feed"         MOVE.L  #1,D7       "No Auto Line Feed" Entry point         BRA.S   PORTIN1W SPC 3* ENTRY ALSO POSSIBLE FROM:  PORTIN2PORTIN10 MOVEM.L D0-D4/D7/A0-A2,-(A7)PORTIN1V CLR.L   D7          "Auto Line Feed" Entry point.PORTIN1W CLR.L D3          FLAG AS PORT1         BSR GETSER1       MOVE ADDRESS INTO A0 SPC 1READBUF  BSR INCHNE        GO GET SOME DATA  (NO ECHO)         TST.B D0          CHECK FOR NULLS         BEQ.S READBUF         MOVE.W D0,D4      SAVE FOR A WHILE         BSR OUTCH1        ECHO WHAT IS IN D0         MOVE.W D4,D0      RESTORE IT         CMP.B #LF,D0      SEE IF LINE FEED         BEQ.S READBUF     DONT PUT IT IN BUFFER SPC 1         CMP.B #CTLX,D0    SEE IF CTRL-X "CANCEL LINE"         BNE.S CHKCTLH     No... Then go check for backspace         MOVE.L #CR,D0     Yes.. 1) Send a carriage return         BSR OUTCH1        *         MOVE.L #LF,D0     *     2) Send a line feed         BSR OUTCH1        *         MOVE.L A5,A6      *     3) Set BUFFER at start again         BRA.S READBUF     *     4) Restart this routine SPC 1CHKCTLH  CMP.B #CTLH,D0    CTRL-H? (Backspace)         BEQ.S BS4CTLH     Yes...  Go backspace 1 character         CMP.B #DEL,D0     DEL?    (Also a Backspace)         BNE.S CHKCTLD     No....  Then go check for CTRL DBKSPACE  CMP.L  A5,A6      Yes...  Usually need an extra "Backspace"         BEQ    READBUF    If at start of buffer, don't back up any more.         MOVE.B #CTLH,D0    Backspace cursor.         BSR    OUTCH1     *         BRA.S  BLANKIT    Bypass check for start of buffer SPC 1BS4CTLH  DS     0          CTL-H already backed up 1 character.         CMP.L  A5,A6      At beginning of buffer?         BEQ    READBUF    Yes...  Then don't back up any more.BLANKIT  MOVE.L #$20,D0    Now blank out previous character.         BSR   OUTCH1      *         MOVE.B -(A6),D0   Remove last character from buffer.         MOVE.B  #CTLH,D0   Backup cursor again.         BSR   OUTCH1      *         BRA   READBUF     Go get next character. SPC 1CHKCTLD  CMP.B #CTLD,D0    CTL D?  (REPRINT)         BNE.S CHKCR       No....  Then go check if a "CR".         MOVE.L #CR,D0     Yes...  Print "CR"         BSR OUTCH1        *         MOVE.L #LF,D0     Print "LF"         BSR OUTCH1        *         MOVE.L A5,-(A7)  SAVE ON STACK FOR A MOMENT         BSR OUTPUT    GO PRINT BUFFER         MOVE.L (A7)+,A5  GET BACK FROM STACK         BRA READBUF SPC 1CHARSAVE MOVE.B D0,(A6)+   SAVE DATA INTO BUFFER         MOVE.L A6,D1      CALCULATE ROOM USED         SUB.L A5,D1       DONT USE MORE THAN "BUFFSIZE"         CMP.W #BUFFSIZE,D1         BMI READBUF       We're OK, go get next character.         BRA BKSPACE       If not, handle as though a "CNTL-H" SPC 1CHKCR    CMP.B #CR,D0      CR?  (End of command line).         BNE.S CHARSAVE    No.. Then go store this character. SPC 1         TST.B D7          Check "Auto Line Feed" switch         BNE.S  NOAUTOLF   Yes.. Bypass sending Line feed.         MOVE.L #LF,D0     No... Set one up and...         BSR    OUTCH1     .     Send it!NOAUTOLF DS     0          . SPC 1 MOVEM.L (A7)+,D0-D4/D7/A0-A2 Restore Regs.         RTS               RETURN TO CALLER SPC 1         END