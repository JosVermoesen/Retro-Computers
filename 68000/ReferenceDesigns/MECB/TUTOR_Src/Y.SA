Y        IDNT      2,1       TUTOR     I/O Routine                   05/19/82         XDEF      ALTSER1         XDEF      ALTSER2         XDEF      CHKBRK         XDEF      CHRPRINT         XDEF      FAULTSER         XDEF      INCHNE         XDEF      INFROM         XDEF      INITSER         XDEF      INPORT1         XDEF      INPORT2         XDEF      MD1CON         XDEF      OUTCH         XDEF      OUTPORT1         XDEF      OUTPORT2         XDEF      OUTTO         XDEF      PACMD         XDEF      PORTIN2         XDEF      PORTIN20         XDEF      PRCRLF         XDEF      SCANPORT         XDEF      SER1         XDEF      SER2         XDEF      TAPEIN         XDEF      TAPEIN20         XDEF      TAPEO         XDEF      TAPEOUT         XREF.S    ECHOPT1         XREF      FIXDATA         XREF      FIXDCRLF         XREF      GETSER1         XREF      GETSER2         XREF      MACSBUG         XREF      OUT1CR0         XREF      OUTPUT         XREF      OUTPUT20         XREF      PORTIN10         XREF.S    XONOFFBUFFSIZE EQU       80CR       EQU       $DLF       EQU       $ACTLW     EQU       $17EOT      EQU       4RESET    EQU       $43       MASTER RESET FOR ACIALTIME    SET       205000    LONG TIMER 5 SEC @ 8 MHZSTIME    SET       41000     SHORT TIMER  100 MLS @ 8 MHZPDI1     SET       $010000   PARALLEL PORT ADDRESSPITCDDR  SET       $010009   PORT C DATA DIRECTION REGISTERPITPCDR  SET       $010019   PORT C DATA REGISTERPITTCR   SET       $010021   TIMER CONTROL REGISTERPSTATUS  SET       $B        PRINTER STATUSPBDATA   SET       3         PRINTER CONTROL--BUSY,PAPER,SELECTPDATA    SET       1         PRINTER DATASER1     SET       $010040   TERMINALSER2     SET       $010041   SERIAL PORT2 ADDRESS SPC 1ADDR2MEM MACRO         PEA.L     \1(PC)              MOVE ADDRESS TO MEMORY         MOVE.L    (A7)+,\2         ENDM SPC 2         SECTION.S 1OUTTO    DS.L 1  HOLDS ADDRESS OF OUTPUT ROUTINEINFROM   DS.L 1  HOLDS ADDRESS OF INPUT ROUTINEALTSER1  DS.L 1  ALTERNATE SERIAL PORT#1ALTSER2  DS.L 1  ALTERNATE SERIAL PORT#2INPORT1  DS.L 1  INPUT ROUTINE ADDRESSOUTPORT1 DS.L 1  ADDRESS FOR OUPUT ROUTINEINPORT2  DS.L 1  ADDRESS FOR INPUT ROUTINEOUTPORT2 DS.L 1  FOR OUTPURT ROUTINEINPORT3  DS.L 1  THIS MIGHT BE FOR TAPEOUTPORT3 DS.L 1  THIS MIGHT BE FOR PRINTERINPORT4  DS.L      1         CASSETTEOUTPORT4 DS.L      1         CASSETTEMD1CON   DS.W      1                   ACIA PROFILE (PORT1/PORT2)PDIPORT  DS.L      1         PDIPORT ADDRESSCRTPNT   DS.W      1                   OUTPUT TO PRINTER AND CRTTAPENULS DS.B      1                   NULLS FOR CASSETTE PAGE         SECTION   10         ADDR2MEM  OUT1CR0,OUTPORT1 INITIALIZE I/O ROUTINES         ADDR2MEM  OUTPUT20,OUTPORT2         ADDR2MEM  PRCRLF,OUTPORT3     PRINTER DRIVER         ADDR2MEM  TAPEOUT,OUTPORT4    CASSETTE         ADDR2MEM  PORTIN10,INPORT1         ADDR2MEM  PORTIN20,INPORT2         ADDR2MEM  PORTIN10,INPORT3         ADDR2MEM  TAPEIN,INPORT4      CASSETTE         MOVE.B    #8,TAPENULS         NULLS FOR CASSETTE         MOVE.L    #PDI1,PDIPORT       PRINTER*        INITIALIZE MC68230 PI/T         MOVE.L    #PDI1,A0            BASE ADDRESS OF PI/T         MOVE.L    #$0000FF00,D0         MOVEP.L   D0,1(A0)*        SELECT MODE 0*        IRQ'S INACTIVATED*        PORT A--ALL BITS OUTPUTS*        PORT B--ALL BITS INPUTS         MOVE.B    #$60,13(A0)         SUBMODE 01 FOR PORT A; INTERLOCKED HANDS         MOVE.B    #$A0,15(A0)         SUBMODE 1X FOR PORT B         MOVE.B    #$30,1(A0)          ENABLE HANDSHAKE LINES         MOVE.B    #$A8,15(A0)         RESET AND INIT PRINTER         MOVE.L    #PDI1+$10,PDIPORT         MOVE.B    #$A0,15(A0)         CLEAR INIT SPC 1* INITIALIZE THE PDI'S         MOVE.W    #$1515,MD1CON         BSR       INITSER             RESET & PROGRAM PDI SPC 1* INITIALIZE XON/XOFF (READER ON / READER OFF)*            AUTO-LINE FEED OVERRIDE         MOVE.L    #$00000000,XONOFF PAGE         SECTION   11*        PRINTER DRIVER**    SEND BUFFER TO PRINTER*PRCRLF   DS        0 SPC 1         MOVEM.L       A5-A6,-(A7)   SAVE REGISTERS**   SEND LINE*LIST     CMP.L A6,A5         SEE IF AT END OF BUFFER         BMI.S LIST1         MOVEM.L (A7)+,A5-A6  RESTORE REGISTERS         RTS*LIST1    MOVE.B    (A5)+,D0  GRAB BYTE         BSR.S     CHRPRINT  PRINT CHAR         BRA       LIST PAGE* OUTPUT CHAR IN D0 TO PRINTERCHRPRINT MOVEM.L D0/D1/D7/A0/A5/A6,-(A7) SAVE SOME REGISTERSLIST2    BSR       CHKBRK    CHECK FOR BREAK SPC 1         MOVE.L    PDIPORT,A0  A0 = ADDRESS OF PORT SPC 1         MOVE.B 3(A7),D0     D0 = CHAR TO BE SENT* CHANGE CONTROL CHARS TO "."         AND.B     #$7F,D0         CMP.B     #CR,D0         BEQ.S     LIST25    OK CARRIAGE RETURN         CMP.B     #LF,D0         BEQ.S     LIST25    OK LINE FEED         CMP.B     #$20,D0         BLT.S     LIST24         CMP.B     #$7F,D0         BLT.S     LIST25LIST24   MOVE.B    #'.',D0   MAKE CHAR A PERIODLIST25   DS        0 SPC 1         MOVE.B    D0,PDATA(A0) SEND DATA         MOVE.B    #$68,PDI1+13 STROBE PRINTER         MOVE.B    #$60,PDI1+13**LIST3    BSR       CHKBRK    CHECK FOR BREAK         MOVE.B    PBDATA(A0),D0         AND.B     #3,D0 PAPER OUT? DESELECTED?         SUB.B     #1,D0         BEQ.S     LIST5         MOVE.W    CRTPNT,D7         CLR.W     CRTPNT         LEA       MSG007(PC),A5         BSR       FIXDATA         BSR       OUTPUT**   WAIT FOR BREAK OR PRINTER TO BE READY*LERR1    BSR.S     CHKBRK         MOVE.B    PBDATA(A0),D0         AND.B #3,D0         SUB.B #1,D0         BNE       LERR1     PRINTER NOT READY         MOVE.W  D7,CRTPNT   RESTORE POSSIBLE "PA" SWITCH         BRA       LIST2     TRY AGAIN SPC 1LIST5    BTST.B    #0,PSTATUS(A0) ACKNOWLEDGE?         BEQ.S     LIST3 SPC 1         MOVEM.L   (A7)+,D0/D1/D7/A0/A5/A6      RESTORE REGISTERS         RTS SPC 1MSG007   DC.B      CR,LF,'PRINTER NOT READY',CR,LF,EOT         DS.B      0 SPC 2**       SEND CHARACTER IN D0.B TO SERIAL PORT IN (A0) (NO NULL PADS)*OUTCH    BSR.S CHKBRK  CHECK FOR BREAK         MOVE.B (A0),D1  READ STATUS AGAIN         AND.B #$2,D1     CHECK FOR READY TO SEND         BEQ.S  OUTCH     STILL NOT READY         MOVE.B D0,2(A0)  SEND CHARACTER  **************** SPC 1* IF PRINT FLAG SET GOTO PRINTER         BEQ.S     OUTCH21   NULL; IGNORE SENDING TO PRINTER         TST.W     CRTPNT         BEQ.S     OUTCH21   CRT ONLY         BSR       CHRPRINT  GOTO PRINTEROUTCH21  DS        0 SPC 1*   CHECK FOR CONTROL W         MOVE.B    (A0),D1   READ STATUS         AND.B     #1,D1         BEQ.S     CTLW9     CHAR NOT READY         MOVE.B    2(A0),D1  READ CHARACTER         CMP.B     #CTLW,D1         BNE.S     CTLW9     NOT CNTL/WCTLWH    BSR.S     CHKBRK    CHECK FOR BREAK         MOVE.B    (A0),D1   READ STATUS         AND.B     #1,D1         BEQ       CTLWH     WAIT FOR ANY CHAR TO CONTINUECTLW9    RTS PAGE**   CHECK FOR BREAK ON PORT #1*CHKBRK   MOVE.L  A0,-(A7)    SAVE A0 * * *         BSR       GETSER1     RETURNS ADDRESS IN A0         MOVE.B (A0),D1  READ STATUS         AND.B #$10,D1         BNE.S BREAK         MOVE.L  (A7)+,A0    RESTORE A0 * * *         RTS SPC 1*    WHAT TO DO WHEN THE BREAK IS PRESSED* SPC 1BREAK2   CLR.B  2(A0)    SEND NULL TO ACIA TO RESETBREAK1   BTST.B #1,(A0)  CHECK IF "TRANSMIT READY"         BEQ.S  BREAK1   WAIT FOR READY SPC 1         MOVE.B    2(A0),D0  READ TWO CHARS         MOVE.B    2(A0),D0  * SPC 1         BTST.B    #4,(A0)   SEE IF BREAK BUTTON RELEASED         BNE       BREAK2    NO... KEEP LOOPING         RTS SPC 1BREAK    BSR       BREAK2         LEA       MSG013(PC),A5 MSG:  "BREAK"BREAK79  BSR       FIXDCRLF    *         BSR       OUTPUT      PRINT MESSAGE         BRA       MACSBUG     AND REENTER MACSBUGMSG013   DC.B      LF,LF,'BREAK',CR,LF,LF,EOT PAGE***  OUTPUT BUFFER TO TAPE  ***TAPEOUT  MOVEM.L   D0-D4/A0-A1,-(A7)   SAVE REGISTERS         MOVE.L    A5,A0     REMEMBER WHERE BUFFER STARTS         MOVEA.L   #PDI1,A1         CLR.B     $21(A1)         CMP.W     #'S0',(A0)          HEADER RECORD?         BNE.S     TAPEOUT2  NO         MOVE.B    #2,9(A1)            YES, PC0 INPUT, PC1 OUTPUT         MOVE.W    #700,D3   OUTPUT NULLS (HEADER)TAPEOUT1 CLR.B     D0         BSR.S     TAPEO         SUBQ.W    #1,D3         BNE.S     TAPEOUT1TAPEOUT2 CMP.L     A6,A5     SEE IF AT OR BEYOND END OF LINE         BCS.S     TAPEOUT4  NO. KEEP GOING.         MOVE.B    TAPENULS,D3     OUTPUT NULLS AFTER EACH RECORDTAPEOUT5 CLR.B     D0        YES. OUTPUT A NULL         BSR.S     TAPEO         SUB.B     #1,D3         BNE.S     TAPEOUT5         MOVEM.L   (A7)+,D0-D4/A0-A1   RESTORE REGISTERS         RTSTAPEOUT4 MOVE.B    (A5)+,D0  GRAB BYTE TO OUTPUT         BSR.S     TAPEO     GO OUTPUT IT         BRA.S     TAPEOUT2  GO DO ANOTHER** OUTPUTS THE CHARACTER IN D0.B TO TAPE* A LOGIC `0' IS RECORDED AS ONE SQUARE WAVE PERIOD OF*        1 MILLISEC DURATION, 50% DUTY CYCLE* A LOGIC `1' IS RECORDED AS ONE SQUARE WAVE PERIOD OF*        500 MICROSEC DURATION, 50% DUTY CYCLE*TAPEO    ORI.B     #%10000,SR SET X BIT IN SR         ROXL.B    #1,D0     DATA BIT INTO XTAPEO1   ROXL.B    #1,D2     DATA BIT INTO D2         BSR.S     TIMERTST  WAIT UNTIL LAST PULSE DONE         BCLR.B    #0,$21(A1) HALT TIMER         MOVE.L    #30,D1    TIMER COUNT FOR A `1'         BTST.L    #0,D2     SENDING A `1'?         BNE.S     TAPEO2    YES.         ADDI.L    #32,D1    NO. TIMER COUNT FOR 0TAPEO2   MOVEP.L   D1,$25(A1) SET TIMER PRELOAD REGISTER         BSET.B    #1,$19(A1)          SEND 1 TO TAPE         BSET.B    #0,$21(A1) START TIMER         BSR.S     TIMERTST  WAIT UNTIL PULSE DONE         BCLR.B    #0,$21(A1) HALT TIMER         BCLR.B    #1,$19(A1)          SEND 0 TO TAPE         BSET.B    #0,$21(A1) START TIMER         ASL.B     #1,D0     SENT 8 BITS?         BNE       TAPEO1    NO. CONTINUE         RTS** WAITS UNTIL PROGRAMMED TIME DELAY HAS ELAPSED* (IF TIMER IS RUNNING)* ALSO CHECKS FOR BREAK* USES D1*TIMERTST BSR       CHKBRK    CHECK FOR BREAK         BTST.B    #0,$21(A1) IS TIMER RUNNING?         BEQ.S     TIMERTS1  NO. RETURN         BTST.B    #0,$35(A1) HAS TIME DELAY ELAPSED?         BEQ.S     TIMERTST  NO. WAITTIMERTS1 RTS PAGE*   IF FAULT THEN INITIALIZE AN ACIA*FAULTSER MOVEM.L D0/A0,-(A7)  FREE UP SOME WORKING REGISTERS* DELAY TO ALLOW ACIA TO FINISH TRANSMITTING                         2,1*  LONGEST TIME FOR TWO CHARACTERS; 110 BAUD, 16MHZ NO WAIT STATES   2,1         MOVE.L    #50000,D0          DELAY A WHILE                 2,1FAULTAC4 SUB.L     #1,D0               LOOP AROUND                   2,1         BNE FAULTAC4                  .                             2,1         BSR GETSER1   MOVE ADDRESS INTO A0         MOVE.B (A0),D0  READ STATUS         AND.B #$70,D0 SEE IF FAULT         BEQ.S FAULTAC2         MOVE.B    #RESET,(A0)  MASTER RESET         MOVE.B MD1CON,(A0)  HOW TO PROGRAM IT SPC 1FAULTAC2 BSR GETSER2   MOVE ADDRESS INTO A0         MOVE.B (A0),D0         AND.B #$70,D0         BEQ.S FAULTAC3         MOVE.B    #RESET,(A0)  MASTER RESET         MOVE.B MD1CON+1,(A0)  HOW TO PROGRAM ITFAULTAC3         MOVEM.L (A7)+,A0/D0    RESTORE REGISTERS         RTS PAGE*   INITIALIZE BOTH ACIAs*INITSER  MOVEM.L D0/A0,-(A7)  FREE UP SOME WORKING REGISTERS* DELAY TO ALLOW ACIA TO FINISH TRANSMITTING                         2,1*  LONGEST TIME FOR TWO CHARACTERS; 110 BAUD, 16MHZ NO WAIT STATES   2,1         MOVE.L    #50000,D0          DELAY A WHILE                 2,1INITAC3  SUB.L     #1,D0               LOOP AROUND                   2,1         BNE       INITAC3             .                             2,1         BSR GETSER1   MOVE ADDRESS INTO A0         MOVE.B    #RESET,(A0)  MASTER RESET         MOVE.B MD1CON,(A0)  HOW TO PROGRAM IT         BSR GETSER2   MOVE ADDRESS INTO A0         MOVE.B    #RESET,(A0)  MASTER RESET         MOVE.B MD1CON+1,(A0)  HOW TO PROGRAM IT         MOVEM.L (A7)+,A0/D0 RESTORE REGISTERS         RTS PAGE*    INPUT CHARACTER FROM PORT1*    ACIA ADDRESS IN (A0)* SPC 1INCHNE   MOVE.B (A0),D1  (INCH NO ECHO) LOAD STATUS SIDE         AND.B #$10,D1   .              CHECK FOR BREAK         BNE BREAK       .              GO PROCESS IT SPC 1         MOVE.B (A0),D1  LOAD STATUS SIDE         AND.B #1,D1  SEE IF READY         BEQ.S INCHNE   IF NOT READY         MOVE.B 2(A0),D0  READ DATA SIDE   *****************         AND.B #$7F,D0  DROP PARIETY BIT         RTS PAGE*  INPUT A LINE FROM PORT2 (ACIA2)*   [ECHO TO PORT1 (ACIA1)]*                  XONOFF*                   0000     NULL  NULL    DO NOTHING*                   0817   BKSPACE CNTL/W*                   1214     X-ON  X-OFF   READER ON OFF*PORTIN2 TST.L INFROM   SEE IF ALTERNATE ADDRESS        BEQ.S PORTIN2X        MOVE.L INFROM,-(A7)        RTS .    GO DO ITPORTIN2X MOVE.L INPORT2,-(A7)  GO TO IO ROUTINE         RTS .  (THIS NORMALLY GOES TO PORTIN20)*PORTIN20 MOVEM.L D1-D3/A0/A3,-(A7)  SAVE WORKING REGISTERS        BSR GETSER2        MOVE.L A0,A3         A3 = ADDRESS OF PORT 2        BSR GETSER1          A0 = ADDRESS OF PORT 1 SPC 1         MOVE.L    #LTIME,D2 D2 = 5 SEC DEADMAN @ 8MHZPORT2100 BSR.S     P2READY         BEQ.S     PORT2120            PORT2 DATA IN NOT-READY         BSR.S     RES                 READ/ECHO/STORE CHAR         BRA       PORT2100PORT2120 MOVE.L    #1,D3               D3 = MLS TIMER (ONE TICK)PORT2130 BSR.S     P2READY         BNE.S     PORT2250            PORT2 DATA IN READY         SUB.L     #1,D2         BMI.S     PORT2300            SECOND TIME OUT         SUB.L     #1,D3         BNE       PORT2130            MLS TIMERPORT2140 MOVE.B    XONOFF,D0         BEQ.S     PORT2150            NULL; IGNORE READER ON         MOVE.B    (A3),D1         AND.B     #2,D1         BEQ       PORT2120            PORT2 DATA OUT NOT-READY         MOVE.B    D0,2(A3)            SEND START READER CHARPORT2150         MOVE.L    #STIME,D3           D3 = 100 MLS @ 8MHZ         BRA       PORT2130PORT2250 BSR.S     P2READY         BEQ.S     PORT2260            PORT2 DATA IN NOT-READY         BSR.S     RES                 READ/ECHO/STORE CHARPORT2260 SUB.L     #1,D3         BMI       PORT2140            CHARACTER TIME OUT         BRA       PORT2250PORT2300 LEA       MSG030(PC),A5    TIMEOUT ERROR         BRA       BREAK79MSG030   DC.B      'TIMEOUT',EOTP2READY MOVE.B (A0),D1  CHECK FOR ACTIVITY ON PORT1        AND.B #$10,D1 CHECK FOR BREAK        BNE BREAK        MOVE.B 2(A0),D1   READ POSSIBLE CHAR PORT 1; IGNORE SPC 1         MOVE.B (A3),D1     READ STATUS OF PORT2         AND.B #1,D1        SEE IF CHARACTER SENT         RTSRES      MOVE.B 2(A3),D1     D1 = CHAR READ FROM PORT2         AND.B #$7F,D1  DROP PARIETY BIT SPC 1         TST.W ECHOPT1  SEE IF ECHO ON         BEQ.S     RES140         MOVE.B    D1,2(A0)  SEND TO DATA SIDE (PORT1)RES140 SPC 1         CMP.B #CR,D1         BEQ.S     RES190        END OF LINE         CMP.B #$20,D1      IGNORE CONTROL CHARACTERS (NULLS)         BLT.S     RES150         MOVE.B    D1,(A6)   SAVE CHAR IN BUFFER SPC 1         MOVE.L    #LTIME/2,D3      D3 = 2 1/2 SEC @ 8MHZ (CHARATER  TIMER) SPC 1         MOVE.L    A6,D1     CHECK BUFFER FULL         SUB.L     A5,D1         CMP.W     #BUFFSIZE,D1         BPL.S     RES150    FULL         ADD.L     #1,A6     INCREMENT STORE POINTERRES150   RTSRES190   CMP.L     A5,A6         BEQ       RES150              NULL RECORD; IGNORE         ADD.L     #4,A7               TRIM STACK         MOVE.B    XONOFF+1,D0         BEQ.S     RES195              XOFF = NULL CHAR; IGNORERES194   MOVE.B    (A3),D1         AND.B     #2,D1         BEQ       RES194              PORT2 DATA OUT NOT-READY         MOVE.B    D0,2(A3)            STOP READERRES195         MOVEM.L (A7)+,D1-D3/A0/A3   RESTORE THE REGISTERS         RTS         PAGE** INPUT A LINE FROM AUDIO TAPE (PI/T)* [ECHO TO PORT1 (ACIA1)]*TAPEIN   MOVEM.L   D1-D4/A0-A3,-(A7)   SAVE WORKING REGISTERS         BSR       GETSER1   ACIA1 ADDRESS INTO A0         MOVEA.L   #PDI1,A1         MOVE.B    #2,PITCDDR          PC0 INPUT, PC1 OUTPUT.* SYNCHRONIZE ON S CHARACTER         CLR.B     D1TAPEIN10 BSR.S     TAPEIN40  GET TAPE         BCS.S     TAPEIN10  WAIT FOR LOWTAPEIN11 BSR.S     TAPEIN40  GET TAPE         BCC.S     TAPEIN11  WAIT FOR HIGH         BSR.S     STARTIMR START TIMERTAPEIN12 ASL.B     #1,D1         BSR.S     TAPEIN30  GET ONE BIT FROM TAPE         CMP.B     #'S',D1   S?         BNE.S     TAPEIN12  NO. GET NEXT BIT         BRA.S     TAPEIN51* GET ONE CHARACTER FROM THE TAPETAPEIN20 MOVEQ     #2,D1     SET STOP BITTAPEIN21 BSR.S     TAPEIN30  GET 1 BIT FROM TAPE         ASL.B     #1,D1     STOP IN CARRY         BCC.S     TAPEIN21  NO*FALL INTO LOAD BIT ROUTINE FOR LAST BITTAPEIN30 BSR.S     TAPEIN40  GET TAPE         BCS.S     TAPEIN30  WAIT FOR LOWTAPEIN31 BSR.S     TAPEIN40  GET TAPE         BCC.S     TAPEIN31  WAIT FOR HIGH         CLR.B     PITTCR    STOP TIMER         MOVEP.L   $2D(A1),D3  GET PERIOD MEASUREMENT         BSR.S     STARTIMR  START TIMER         SUBI.L    #$FFFFFF-94,D3      IS IT A LOGIC 1?         BLO.S     TAPEIN32  NO         ADDQ.B    #1,D1     YES. STORE LOGIC 1TAPEIN32 RTS* READ THE TAPE LEVEL INTO THE CARRY AND CHECK FOR BREAKTAPEIN40 MOVE.B    (A0),D2   CHECK FOR ACTIVITY ON PORT1         AND.B     #$10,D2   CHECK FOR BREAK         BNE       BREAK         MOVE.B    (A0),D2   SEE IF CHARACTER SENT         AND.B     #1,D2         BEQ.S     TAPEIN41  NONE SENT.         MOVE.B    2(A0),D2  READ WHAT WAS SENTTAPEIN41 MOVE.B    PITPCDR,D2          READ PI/T         ASR.B     #1,D2     DATA INTO CARRY         RTS*STARTS PROGRAMMABLE TIMERSTARTIMR MOVE.L    #$00FFFFFF,D4 INIT. COUNT. PRELOAD REG.         MOVEP.L   D4,$25(A1)         MOVE.B    #1,PITTCR START TIMER         RTSTAPEIN53 CMP.B     #$20,D1         BLT.S     TAPEIN50  IGNORE CONTROL CHARACTERS         MOVE.B    D1,(A6)   SAVE CHARACTER IN BUFFER         MOVE.L    A6,D1     CHECK BUFFER FULL         SUB.L     A5,D1         CMP.W     #BUFFSIZE,D1         BPL.S     TAPEIN50  FULL         ADD.L     #1,A6     INCREMENT BUFFER POINTERTAPEIN50 BSR       TAPEIN20  GET ONE CHARACTER FROM TAPETAPEIN51 AND.B     #$7F,D1   DROP PARITY BIT         TST.W     ECHOPT1   SEE IF ECHO ON         BEQ.S     TAPEIN52         MOVE.B    D1,2(A0)  SEND TO PORT1TAPEIN52 CMP.B     #LF,D1    END OF LINE?         BNE.S     TAPEIN53  NO.         MOVEM.L   (A7)+,D1-D4/A0-A3   RESTORE REGISTERS         RTS       PAGE*     SCAN COMMAND LINE FOR PORT NUMBER*     DU LO VE MD*SCANPORT CLR.L INFROM  DEFAULT IS WHATEVER IS CALLED         CLR.L OUTTO         MOVE.B    (A5),D0   NO....GET CHARACTER         CMP.B     #' ',D0   .     IS IT A BLANK?         BEQ.S     SCANP6    .     YES..EXIT SPC 1         CMP.B #'1',D0    SEE IF PORT 1 OVERRIDE         BNE.S SCANP4         MOVE.L INPORT1,INFROM         MOVE.L OUTPORT1,OUTTO         BRA.S     SCANP7 SPC 1SCANP4   CMP.B #'2',D0    SEE IF PORT 2 OVERRIDE         BNE.S SCANP5         MOVE.L INPORT2,INFROM         MOVE.L OUTPORT2,OUTTO         BRA.S     SCANP7 SPC 1SCANP5   CMP.B #'3',D0    SEE IF PORT3 OVERRIDE         BNE.S     SCANP8         MOVE.L INPORT3,INFROM         MOVE.L OUTPORT3,OUTTO         BRA.S     SCANP7 SPC 1SCANP8   CMP.B #'4',D0 SEE IF PORT4 OVERRIDE         BNE.S SCANP6         MOVE.L    INPORT4,INFROM         MOVE.L    OUTPORT4,OUTTO SPC 1SCANP7   ADD.L     #1,A5     ADJUST GET CHAR POINTERSCANP6   RTS PAGE*       *  P A  *      "PRINTER ATTACH" COMMAND          **                                                        ** IF THE "PRINTER" HAS BEEN ATTACHED, ALL CHARACTERS     ** ENTERED AND TRANSMITTED VIA THE CONSOLE WILL PRINT ON  ** THE HARD COPY PRINTER. -- TO TERMINATE, ENTER "NOPA"   **                                                        ** THIS COMMAND MAKES USE OF THE "NO" OPTION.  THERE IS A ** 4 BYTE HARD BRANCH INFRONT OF THE REGULAR ENTRY POINT. ***********************************************************         BRA.L     NOPACMD             ENTRY FOR "NOPA"  SPC 1*PACMD    MOVE.L    #-1,D0              ENTRY FOR "PA" (D0=-1[CRT & PRINT])         BRA.S     SETCRTPR            GO ACTUALLY SET THE SWITCHNOPACMD  CLR.L     D0                  D0 = ZEROS... "CRT" ONLYSETCRTPR MOVE.W    D0,CRTPNT           SET THE "CRT" AND "PRINTER" SWITCH         BRA       MACSBUG             GO BE "READY"         END