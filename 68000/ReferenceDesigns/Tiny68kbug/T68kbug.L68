0000040E Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 11/5/2017 10:16:01 AM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :T68kBug
00000000                             3  * Written by :H Shen
00000000                             4  * Date       :6/4/2017
00000000                             5  * Description:fork from v003 of T030bug
00000000                             6  *-----------------------------------------------------------
00000000                             7  * fork from v003 of T030bug 
00000000                             8  * 6/4/2017
00000000                             9  * memory map: DRAM 0-ff7fff, I/O is ff8000 to ffffff, 68681: fff000-ffffff
00000000                            10  * CF-IDE: cs0:ffe000-ffe00f, cs1:ffe010-ffe01f
00000000                            11  * 7/11/17: add 'bo' command to boot into CP/M stored in LA 1 of compact flash
00000000                            12  * 7/12/17: add 'sw' command to swap monitor to $FE8000.  This allow new monitor to be loaded
00000000                            13  *   in $400 and test out its functionality
00000000                            14  * 11/1/17: 7-seg display will display critical steps during booting.
00000000                            15  *   Only have one 7-seg display in rev 1 pc board.
00000000                            16  
00000000                            17  
00000000  =00FFF000                 18  DUART    equ $FFF000       * base address of 68692 DUART
00000000  =00FFF001                 19  MRA      equ $FFF001       * mode reg A
00000000  =00FFF003                 20  SRA      equ $FFF003       * status A (read)
00000000  =00FFF003                 21  CSRA     equ $FFF003       * clock select reg (write)
00000000  =00FFF005                 22  CRA      equ $FFF005       * command register (write only)
00000000  =00FFF007                 23  RHRA     equ $FFF007       * Rx Hold reg A (read)
00000000  =00FFF007                 24  THRA     equ $FFF007       * Tx Holding reg (write)
00000000  =00FFF009                 25  IPCR     equ $FFF009       * Input port change reg (read)
00000000  =00FFF009                 26  ACR      equ $FFF009       * Aux control reg (write)
00000000  =00FFF00B                 27  ISRD     equ $FFF00B       * interrupt status reg (read)
00000000  =00FFF00B                 28  IMRD     equ $FFF00B       * interrupt mask reg (write)                          
00000000  =00FFF00D                 29  CTU      equ $FFF00D       * Counter/timer upper (read)
00000000  =00FFF00F                 30  CTL      equ $FFF00F       * counter/timer lower (read)
00000000  =00FFF00D                 31  CTUR     equ $FFF00D       * Counter/timer preload upper (write)
00000000  =00FFF00F                 32  CTLR     equ $FFF00F       * counter/timer preload lower (write)
00000000  =00FFF011                 33  MR1B     equ $FFF011       * mode reg B
00000000  =00FFF013                 34  SRB      equ $FFF013       * status reg B
00000000  =00FFF017                 35  RHRB     equ $FFF017       * Rx holding reg B
00000000  =00FFF019                 36  IVRD     equ $FFF019       * interrupt vector reg
00000000  =00FFF01F                 37  STOPCTR  equ $FFF01F       * stop counter command reg (read)
00000000  =00FFF01D                 38  STARTCTR equ $FFF01D       * start counter command reg (read)
00000000  =00FFF01D                 39  SETOPR   equ $FFF01D       * bit set output register bits (write)
00000000  =00FFF01F                 40  CLROPR   equ $FFF01F       * bit clear output register (write)
00000000  =00FFF01B                 41  OPCR     equ $FFF01B       * output configuration register(write)
00000000                            42  
00000000                            43  
00000000  =00000000                 44  True     equ 0
00000000  =00000001                 45  False    equ 1
00000000  =000000FF                 46  Error    equ $ff
00000000                            47  
00FF0000                            48           org      $FF0000           * top 32K of RAM is for stack and global variables
00FF0000                            49  ROMver   ds.l 1                     * this is 1st variable of a task descriptor block
00FF0004                            50  wallclock ds.l 1           * global wall clock
00FF0008                            51  downtimer1 ds.w 1          * this is always the 3rd variable of a TDB, room for 2
00FF000A                            52                                      * down timers
00FF000A                            53  downtimer2 ds.w 1
00FF000C                            54  amrsvp   ds.l 1                     * reserve fix long word for future
00FF0010                            55  
00FF0010                            56  savd0    ds.l 1                     * allocate for 68302 registers
00FF0014                            57  savd1    ds.l 1
00FF0018                            58  savd2    ds.l 1
00FF001C                            59  savd3    ds.l 1
00FF0020                            60  savd4    ds.l 1
00FF0024                            61  savd5    ds.l 1
00FF0028                            62  savd6    ds.l 1
00FF002C                            63  savd7    ds.l 1
00FF0030                            64  sava0    ds.l 1
00FF0034                            65  sava1    ds.l 1
00FF0038                            66  sava2    ds.l 1
00FF003C                            67  sava3    ds.l 1
00FF0040                            68  sava4    ds.l 1
00FF0044                            69  sava5    ds.l 1
00FF0048                            70  sava6    ds.l 1
00FF004C                            71  savsp    ds.l 1
00FF0050                            72  savpc    ds.l 1
00FF0054                            73           
00FF0054                            74  cUErr    ds.w 1
00FF0056                            75  fWval    ds.b 1                     * write flag
00FF0057                            76  fSerr    ds.b 1                     * S record error
00FF0058                            77  pStr     ds.l 1                     * string pointer for DUARTisr
00FF005C                            78  bAnswer  ds.l 5                     * 20 bytes of response buffer, byte order:
00FF0070                            79                             * LF, CR, A, A, A, A, A, A, A, A ':', 
00FF0070                            80                             * D, D, D, D, LF, CR, '>', ' ', 0
00FF0070                            81  bByteAns ds.l 1            * buffer for a byte of data for printing: space-ascii-ascii-null
00FF0074                            82  bCmdline ds.l 5            * command line, handle up to 20 characters
00FF0088                            83  pCmdln   ds.l 1            * pointer into the command line buffer
00FF008C                            84  cCmd     ds.b 1            * count number of bytes in command buffer
00FF008D                            85  fDoCmd   ds.b 1            * flag for command ready to execute 
00FF008E                            86  cCmdparam ds.b 1  * number of command parameters
00FF008F                            87  fCmdDone ds.b 1            * flag for command in progress (0) or done (1)
00FF0090                            88  cmdparam ds.l 4            * command parameters
00FF00A0                            89  RegASCII ds.b 10  * ASCII value of a register, null terminated
00FF00AA                            90  corner7seg ds.b 1 * value of corner 7-segment display
00FF00AB                            91            ds.b 1  * reserve
00FF00AC                            92  cntIdle  ds.l 1            * idle loop counter
00FF00B0                            93  maxIdle  ds.l 1            * Idle loop count for this time period
00FF00B4                            94  nullchar ds.b 2            * string terminator, two characters, 
00FF00B6                            95                             * one will be modified for mr command use
00FF00B6                            96  fTxDone  ds.b 1            * flag for ISR finishs transmitting string
00FF00B7                            97  fbpverbose ds.b 1 * verbose flag for breakpoint
00FF00B8                            98  bkptaddr ds.l 1            * address where illegal instruction is inserted
00FF00BC                            99  bkptinstr ds.w 1  * instruction swapped out for breakpoint
00FF00BE                           100  fdobkpt  ds.b 1            * indicating whether breakpoint is in progress or not
00FF00BF                           101  fSerrAll ds.b 1            * reserve byte
00FF00C0                           102  cTrace   ds.w 1            * number of trace to perform
00FF00C2                           103  seconds  ds.b 1            * time register (seconds) in RTC72423
00FF00C3                           104  sInteractive ds.b 1        * Interactive session state, 0=none, 1=mm cmd, 2=mr cmd
00FF00C4                           105  startaddr ds.l 1  * starting address for the S record file load
00FF00C8                           106  pidle7seg ds.l 1  * pointer to which 7-segment to display in idle routine
00FF00CC                           107  mmaddress ds.l 1  * address value from mm command saved for interactive session
00FF00D0                           108  cTxChar  ds.w 1            * count of how many characters to transmit. -1 to disable 
00FF00D2                           109  fTxChar  ds.b 1            * enable (1) or disable (0) transmission of character in DUART isr
00FF00D3                           110  exitCode ds.b 1            ** error code for command execution.  0=normal, 1=error
00FF00D4                           111            ds.b 1           * reserve
00FF00D5                           112  sav7seg  ds.b 1            * saved data for manipulated 7-seg display
00FF00D6                           113  fEASyTEcho ds.b 1         * echo flag for EASy trap 15 task 12 echo is default to on, 
00FF00D7                           114                             * 0=echo off 
00FF00D7                           115  fEASyTCRLF ds.b 1          * flag to signify adding CR LF to output string
00FF00D8                           116  LA2427   ds.b     1        * head 
00FF00D9                           117  LA1623   ds.b     1        * cylinder high
00FF00DA                           118  LA815    ds.b     1        * cylinder low
00FF00DB                           119  LA07     ds.b     1        * sector
00FF00DC                           120           
00000000                           121           org      $0                
00000000                           122  * This program will be serially loaded in DRAM at start up
00000000= 00FF7FFC                 123           dc.l $FF7FFC               * stack at the top task space
00000004= 00000400                 124           dc.l Tiny68kbug   * start address of Tiny68kbug
00000008= 00002EA0                 125           dc.l buserr       * BERR handler
0000000C= 000020F4                 126           dc.l addrerr      * address error handler
00000010= 0000212E                 127           dc.l breakpt      * illegal instruction used as breakpoint
00000014= 000020C8 000020C8 ...    128           dcb.l 4,unknown
00000024= 00002466                 129           dc.l trace        * trace handling
00000028= 000020C8 000020C8 ...    130           dcb.l 37,unknown
000000BC= 0000259A                 131           dc.l EASyTrap     * trap 15 implementing EASy68K trap services 
000000C0= 000020C8 000020C8 ...    132           dcb.l 81,unknown  
00000204= 00002700                 133           dc.l DUARTisr     * No. $81, service DUART connected to PB8
00000208= 000020C8 000020C8 ...    134           dcb.l 126,unknown * the rest to unknown
00000400                           135  
00000400                           136           org $400          * not necessary, but just in case...
00000400                           137  Tiny68kbug:                         * starting point when tiny020 is boot off flash
00000400                           138  * this part of code will not execute when Tiny68kbug is loaded in RAM
00000400  46FC 2700                139           move.w #$2700,sr  * mask off interrupts
00000404  4FF9 00FF7FFC            140           lea $FF7FFC,sp    * initialize stack to top of task descriptor block
0000040A  6000 004E                141           bra entry
0000040E                           142  RAMstart:                  * starting point for tiny68kbug loaded in RAM
0000040E  46FC 2700                143           move.w #$2700,sr  * mask off interrupts
00000412  4FF9 00FF7FFC            144           lea $FF7FFC,sp    * initialize stack to top of task descriptor block
00000418  6000 0040                145           bra entry
0000041C                           146  
0000041C                           147  * User command dispatch tables
0000041C                           148  commands:
0000041C= 00000114                 149           dc.l do_dm-exec_cmd        * display memory
00000420= 000001A6                 150           dc.l do_dr-exec_cmd        * display register
00000424= 000002C6                 151           dc.l do_mm-exec_cmd        * modify memory
00000428= 0000038C                 152           dc.l do_mr-exec_cmd        * modify register
0000042C= 00000520                 153           dc.l do_go-exec_cmd        * go
00000430= 000005E2                 154           dc.l do_bp-exec_cmd        * breakpoint
00000434= 000006B8                 155           dc.l do_help-exec_cmd      * help message
00000438= 000007AC                 156           dc.l do_du-exec_cmd        * dump memory content command
0000043C= 000009C6                 157           dc.l do_sw-exec_cmd        * swap monitor software to $FE8000
00000440= 000008A0                 158           dc.l do_bo-exec_cmd        * boot CP/M 68K
00000444                           159  * corresponding mnemonic for the user command table
00000444                           160  mnemonictbl:
00000444= 646D                     161           dc.w 'dm'
00000446= 6472                     162           dc.w 'dr'
00000448= 6D6D                     163           dc.w 'mm'
0000044A= 6D72                     164           dc.w 'mr'
0000044C= 676F                     165           dc.w 'go'
0000044E= 6270                     166           dc.w 'bp'
00000450= 6865                     167           dc.w 'he'
00000452= 6475                     168           dc.w 'du'
00000454= 7377                     169           dc.w 'sw'
00000456= 626F                     170           dc.w 'bo'         * boot CP/M68k from Compact flash
00000458= 0000                     171           dc.w $0  
0000045A                           172  entry:
0000045A  4E70                     173           reset             * reset peripherals
0000045C  6100 1A78                174           bsr iDUART        * initialize 68681 and drive the display immediately
00000460  13FC 00FF 00FFF01D       175           move.b #$ff,SETOPR         * clear display
00000468  13FC 000C 00FFF01F       176           move.b #$c,CLROPR * drive the value '1' on a 7-seg display
00000470  23FC 1E1E1E1E 00FF7FFC   177           move.l #$1e1e1e1e,$FF7FFC  * mark memory beyond top of the stack as a
0000047A                           178                                      * way to check stack underflow               
0000047A  4281                     179           clr.l d1          * clear all data and address registers, except a5
0000047C  4282                     180           clr.l d2
0000047E  4283                     181           clr.l d3
00000480  4284                     182           clr.l d4
00000482  4285                     183           clr.l d5
00000484  4286                     184           clr.l d6
00000486  4287                     185           clr.l d7
00000488  43F8 0000                186           lea $0,a1
0000048C  45F8 0000                187           lea $0,a2
00000490  47F8 0000                188           lea $0,a3
00000494  49F8 0000                189           lea $0,a4
00000498  4DF8 0000                190           lea $0,a6
0000049C                           191  * @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ Change rev # here @@@@@@@@@@@@@@@@@@@@@@@@@@
0000049C  23FC 30303036 00FF0000   192           move.l #$30303036,ROMver   * version number need a better way of doing this
000004A6  13FC 005B 00FF00AA       193           move.b #$5b,corner7seg     * diagnostic, put '2' out on 7-segment displays
000004AE  42B9 00FF00B8            194           clr.l bkptaddr             * no breakpoint
000004B4  4239 00FF00BE            195           clr.b fdobkpt
000004BA  13FC 0001 00FF00B7       196           move.b #1,fbpverbose       * the verbose flag for breakpoint
000004C2  6100 19D0                197           bsr iBuffer
000004C6  13FC 00FF 00FFF01D       198           move.b #$ff,SETOPR         * clear display
000004CE  13FC 009E 00FFF01F       199           move.b #$9e,CLROPR         * drive the value '3' on a 7-seg display
000004D6  4239 00FF008C            200           clr.b cCmd                 * clear command line state
000004DC  4239 00FF008D            201           clr.b fDoCmd               * clear command ready to execute flag
000004E2  23FC 00FF0074 00FF0088   202           move.l #bCmdline,pCmdln    * initialize command line pointer to the beginning
000004EC  4239 00FF00C3            203           clr.b sInteractive         * set interactive session state to none
000004F2  4279 00FF00B4            204           clr.w nullchar             * null terminator for the register string
000004F8  4239 00FF00D7            205           clr.b fEASyTCRLF  * no carriage return & line feed to put string
000004FE  13FC 0020 00FF0070       206           move.b #$20,bByteAns       * initialize byte answer buffer, bByteAns
00000506  4239 00FF0073            207           clr.b bByteAns+3  * space, high-nibble, low-nibble, null-terminator
0000050C  6100 0076                208           bsr idleinit               * initialize idling 7 segment display variables
00000510  4239 00FF0057            209           clr.b fSerr                * clear s record error flag
00000516  13FC 0020 00FF00A8       210           move.b #' ',RegASCII+8     * put a space character at the end of register string
0000051E  4239 00FF00A9            211           clr.b RegASCII+9  * null terminate the register string
00000524  33FC FFFF 00FF00D0       212           move.w #-1,cTxChar         * disable counting how many character to transmit
0000052C  4239 00FF00D2            213           clr.b fTxChar              * disable transmission of character in DUART ISR
00000532  4239 00FF00BF            214           clr.b fSerrAll             * clear cumulated S record error flag
00000538  42B9 00FF00AC            215           clr.l cntIdle              * reset idle loop counter
0000053E  13FC 0000 00FF00B6       216           move.b #True,fTxDone       * initialize to transmission done
00000546                           217  mpuinit1:                  
00000546  13FC 0005 00FFF005       218           move.b #5,CRA              * enable transmit and receive
0000054E  13FC 00FF 00FFF01D       219           move.b #$ff,SETOPR         * clear display
00000556  13FC 00CC 00FFF01F       220           move.b #$cc,CLROPR         * drive the value '4' on a 7-seg display
0000055E  46FC 2000                221           move.w #$2000,SR           * lower interrupt level
00000562  43FA 0BB4                222           lea signon(pc),a1          * output signon message
00000566  103C 000E                223           move.b #14,d0
0000056A  4E4F                     224           trap #15
0000056C  13FC 007D 00FF00AA       225           move.b #$7d,corner7seg     * put version # on 7-seg displays
00000574                           226  ******************************************
00000574                           227  * value in corner7seg     value displayed    
00000574                           228  *        $3F                0
00000574                           229  *        $06                1
00000574                           230  *        $5B                2       
00000574                           231  *        $4F                3       
00000574                           232  *        $66                4       
00000574                           233  *        $6D                5       
00000574                           234  *        $7D                6       
00000574                           235  *        $07                7       
00000574                           236  *        $7F                8       
00000574                           237  *        $6F                9
00000574                           238  ******************************************
00000574                           239  * write to CLROPR   value displayed
00000574                           240  *        $7E               0
00000574                           241  *        $0C               1
00000574                           242  *        $B4               2
00000574                           243  *        $9E               3
00000574                           244  *        $CC               4
00000574                           245  *        $DA               5
00000574                           246  *        $FA               6
00000574                           247  *        $0E               7
00000574                           248  *        $FE               8
00000574                           249  *        $DE               9
00000574                           250  ****************************************
00000574                           251  * foreground loop
00000574                           252  fore:
00000574  6100 0020                253           bsr newidle7seg            * idle routine moving 7-segment display
00000578  6100 00C2                254           bsr Tiny68kcmd             * processing console command
0000057C                           255  *@@@@ add additional tasks here @@@@*******
0000057C                           256  
0000057C                           257  fore9:
0000057C  52B9 00FF00AC            258           add.l #1,cntIdle  * increment idle loop counter
00000582  60F0                     259           bra fore
00000584                           260  ******************************************
00000584                           261  idleinit:
00000584  487A 0086                262           pea inv7segtbl(pc)         * initialize pointer to segment manipulation table
00000588  23DF 00FF00C8            263           move.l (sp)+,pidle7seg     * save pointer
0000058E  4279 00FF000A            264           clr.w downtimer2  * clear downtimer2 so circulating segments will commence
00000594  4E75                     265           rts
00000596                           266  
00000596                           267  newidle7seg:
00000596                           268  * a new idle routine, every 1/2 second it will invert a segment of display.  It visits
00000596                           269  * 6 segments in a circular fashion
00000596                           270  * restore the manipulation 200ms second later, so the display will just flicker for 200ms
00000596  48E7 C0C0                271           movem.l d0-d1/a0-a1,-(sp)  * save registers
0000059A  0C79 001E 00FF000A       272           cmp.w #30,downtimer2       * if downtimer is at 300ms, undo the manipulation
000005A2  6700 0046                273           beq uninv7seg
000005A6  4A79 00FF000A            274           tst.w downtimer2
000005AC  6600 0036                275           bne newidle7seg9
000005B0  33FC 0032 00FF000A       276           move.w #50,downtimer2      * set downtimer to expire in half second
000005B8  2079 00FF00C8            277           move.l pidle7seg,a0        * get pointer to manipulate next segment of display
000005BE  41E8 0008                278           lea 8(a0),a0               * point to next segment to manipulate
000005C2  43FA 0078                279           lea inv7segEnd(pc),a1      * get end of table
000005C6  B1C9                     280           cmp.l a1,a0                * end of the table?
000005C8  6D00 0006                281           blt newnxtidle7seg
000005CC  41FA 003E                282           lea inv7segtbl(pc),a0      * reload segment manipulation table
000005D0                           283  newnxtidle7seg:
000005D0  2250                     284           move.l (a0),a1             * get the address of display into a2
000005D2  1228 0007                285           move.b 7(a0),d1            * get the bit to manipulate
000005D6  B311                     286           eor.b d1,(a1)              * invert the manipulated bit
000005D8  13D1 00FF00D5            287           move.b (a1),sav7seg        * save the manipulated data
000005DE  23C8 00FF00C8            288           move.l a0,pidle7seg        * save pointer
000005E4                           289  newidle7seg9:
000005E4  4CDF 0303                290           movem.l (sp)+,d0-d1/a0-a1  * restore registers
000005E8  4E75                     291           rts
000005EA                           292  uninv7seg:
000005EA  2079 00FF00C8            293           move.l pidle7seg,a0        * get pointer to manipulate next segment of display
000005F0  2250                     294           move.l (a0),a1             * get the address of display into a2
000005F2  1228 0007                295           move.b 7(a0),d1            * get the bit to manipulate
000005F6  1011                     296           move.b (a1),d0             * if saved manipulated data is different than current data,
000005F8  B039 00FF00D5            297           cmp.b sav7seg,d0  * then new data has been written since, don't flicker
000005FE  6600 0004                298           bne uninv7seg1
00000602  B311                     299           eor.b d1,(a1)              * invert the manipulated bit
00000604                           300  uninv7seg1:
00000604  5379 00FF000A            301           sub.w #1,downtimer2        * change it so this routine execute once every 1/2 sec
0000060A  60D8                     302           bra newidle7seg9
0000060C                           303           
0000060C                           304  inv7segtbl:
0000060C                           305  *          00000           Segments patterns represented by 
0000060C                           306  *         5     1          data bits 0 through 6
0000060C                           307  *         5     1 
0000060C                           308  *          66666  
0000060C                           309  *         4     2 
0000060C                           310  *         4     2 
0000060C                           311  *          33333
0000060C                           312  * 
0000060C                           313  * start with 2 and works clockwise "figure 8" pattern
0000060C= 00FF00AA                 314           dc.l corner7seg
00000610= 00000004                 315           dc.l $4           * data bit 2
00000614= 00FF00AA                 316           dc.l corner7seg
00000618= 00000008                 317           dc.l $8           * data bit 3
0000061C= 00FF00AA                 318           dc.l corner7seg
00000620= 00000010                 319           dc.l $10          * data bit 4
00000624= 00FF00AA                 320           dc.l corner7seg
00000628= 00000020                 321           dc.l $20          * data bit 5
0000062C= 00FF00AA                 322           dc.l corner7seg
00000630= 00000001                 323           dc.l $1           * data bit 0
00000634= 00FF00AA                 324           dc.l corner7seg
00000638= 00000002                 325           dc.l $2           * data bit 1
0000063C                           326  inv7segEnd:
0000063C                           327           
0000063C                           328  Tiny68kcmd:       
0000063C                           329  * when in interactive session, look for difference sources of inputs depending on the session
0000063C                           330  * session #1, looks for fDoCmd ready (keyboard inputs)
0000063C                           331  * interactive session of mm command 
0000063C  4A39 00FF00C3            332           tst.b sInteractive
00000642  6700 002E                333           beq doCmd
00000646  48E7 FFFC                334           movem.l a0-a5/d0-d7,-(sp)  * save registers 
0000064A  0C39 0001 00FF00C3       335           cmp.b #1,sInteractive
00000652  6600 0014                336           bne interact9
00000656  4A39 00FF008D            337           tst.b fDoCmd               * Is a command ready for execution?
0000065C  6700 00D0                338           beq dodo9
00000660  6100 072E                339           bsr mminteractive          *mm command interactive session
00000664  6000 00C8                340           bra dodo9
00000668                           341  interact9:
00000668  4239 00FF00C3            342           clr.b sInteractive                  * error condition, 
0000066E                           343  * should print error message 
0000066E  6000 00BE                344           bra dodo9
00000672                           345  
00000672                           346  doCmd:
00000672  4A39 00FF008D            347           tst.b fDoCmd               * Is a keyboard command ready for execution?
00000678  6700 004A                348           beq doPrompt               * check if prompt needs to be output
0000067C                           349  cmdtodo:
0000067C  48E7 FFFC                350           movem.l a0-a5/d0-d7,-(sp)  * save registers 
00000680  0C39 0002 00FF008C       351           cmp.b #2,cCmd              * need at least 2 char in command line before
00000688                           352                                      * a valid CR
00000688  6500 0084                353           blo badcommand
0000068C  41FA FDB6                354           lea mnemonictbl(pc),a0     * point to command mnemonic
00000690  43FA FD8A                355           lea commands(pc),a1        * the corresponding command entry point
00000694  3039 00FF0074            356           move.w bCmdline,d0         * current command
0000069A                           357  parsecmd:
0000069A  B058                     358           cmp.w (a0)+,d0             * look for command
0000069C  6700 000E                359           beq cmdproc
000006A0  5889                     360           add.l #4,a1                * bump to next command
000006A2  0C50 0000                361           cmp.w #0,(a0)              * end of mnemonic table?
000006A6  6700 0066                362           beq badcommand
000006AA  60EE                     363           bra parsecmd
000006AC                           364  cmdproc:
000006AC  6100 0086                365           bsr cmdreformat
000006B0  6100 0A44                366           bsr enableNextCmd * ready for next command while current command is running 
000006B4  4A80                     367           tst.l d0
000006B6  6600 0056                368           bne badcommand
000006BA  2251                     369           move.l (a1),a1             * get the actual subroutine address in a1
000006BC                           370  exec_cmd:
000006BC  4EBB 90FE                371           jsr *(pc,a1)
000006C0  6000 006C                372           bra dodo9
000006C4                           373           
000006C4                           374  doPrompt:
000006C4                           375  ** check fCmdDone.  If set, issue a prompt depend on the exit code.  check fTxDone first
000006C4                           376  ** to make sure previous output has completed.
000006C4  4A39 00FF008F            377           tst.b fCmdDone    ** every command subroutine should mark completion with fCmdDone set
000006CA  6700 0066                378           beq dodo9n        ** end of AMbug task list
000006CE  0C39 0001 00FF00B6       379           cmp.b #False,fTxDone       ** check if still outputting previous message
000006D6  6700 005A                380           beq dodo9n
000006DA  48E7 FFFC                381           movem.l a0-a5/d0-d7,-(sp)  ** save registers
000006DE  4239 00FF008F            382           clr.b fCmdDone    ** this is where fCmdDone is cleared
000006E4  4A39 00FF00D3            383           tst.b exitCode    ** exit code of a command execution determines what prompt to display
000006EA                           384                             ** 0=normal exit, 1=error condition
000006EA  6700 0032                385           beq OKcommand     ** normal prompt
000006EE  6000 001E                386           bra badcommand    ** exit with error prompt
000006F2                           387           
000006F2                           388  * don't like this approach because D0 may contains values returned from user program via 
000006F2                           389  * 'go' command.  The content of D0 is unpredictable.  On the other hand, the value of D0
000006F2                           390  * is displayed when user program terminates, so maybe this is all right...
000006F2  B07C 0000                391           cmp.w #0,d0                * test result to chose the right prompt, 0=normal prompt
000006F6                           392                                      * 1=error prompt, 2=no prompt (interactive session in progress)
000006F6  6700 0026                393           beq OKcommand              * normal prompt
000006FA  B07C 0001                394           cmp.w #1,d0                * check for error condition
000006FE  6700 000E                395           beq badcommand
00000702  B07C 0002                396           cmp.w #2,d0                * chk for interactive session
00000706  6700 0026                397           beq dodo9                  * interactive session in progress
0000070A  6000 0012                398           bra OKcommand              * normal prompt for all other values
0000070E                           399  badcommand:
0000070E  487A 0A43                400           pea qprompt(pc)            * load error prompt
00000712  225F                     401           move.l (sp)+,a1            * output error prompt
00000714  103C 000E                402           move.b #14,d0
00000718  4E4F                     403           trap #15
0000071A  6000 000E                404           bra docommand9
0000071E                           405  OKcommand:
0000071E  487A 0A2E                406           pea prompt(pc)             * a different way to put string address into pStr
00000722  225F                     407           move.l (sp)+,a1            * bounce off stack so no register is altered
00000724  103C 000E                408           move.b #14,d0              * output normal prompt
00000728  4E4F                     409           trap #15
0000072A                           410  docommand9:
0000072A  6100 09CA                411          bsr enableNextCmd           * ready for next command
0000072E                           412  dodo9:
0000072E  4CDF 3FFF                413           movem.l (sp)+,a0-a5/d0-d7  * restore registers
00000732                           414  dodo9n:
00000732  4E75                     415           rts
00000734                           416  
00000734                           417  ***********************
00000734                           418  * convert ascii inputs to hex values in cmdline buffer into cmdparam
00000734                           419  * Able to hold up to 4 long word parameters in cmdparam, cCmdparam contains the number of param
00000734                           420  * d0.w returns valid values (0), or invalid values (1)
00000734                           421  cmdreformat:
00000734  48E7 60C0                422           movem.l d1-d2/a0/a1,-(sp)  * save
00000738  41F9 00FF0076            423           lea bCmdline+2,a0          * start after the command mnemonic
0000073E                           424  * get rid of extra space characters
0000073E                           425  * routine here to eliminate extra spaces and no space after the last parameter
0000073E                           426  cmdrf0:
0000073E  4239 00FF008E            427           clr.b cCmdparam            * clear command parameter count
00000744  5539 00FF008C            428           sub.b #2,cCmd              * if there are only two bytes, then there are no parameter
0000074A  6700 0068                429           beq cmdrf7                 * exit with zero parameter count
0000074E                           430           
0000074E  0C10 0020                431           cmp.b #' ',(a0)            * first space after command is different than subsequent space
00000752  6600 000C                432           bne cmdrf1
00000756  41E8 0001                433           lea 1(a0),a0               * same as (a0)+
0000075A  5339 00FF008C            434           sub.b #1,cCmd              * reduce byte count for command line buffer
00000760                           435  cmdrf1:
00000760                           436  
00000760  1439 00FF008C            437           move.b cCmd,d2             * d2 contains number of bytes in command buffer
00000766  4882                     438           ext.w d2                   * sign extend, prepare for dbra operation
00000768  4281                     439           clr.l d1                   * d1 accumulate each nibble of ASCII input
0000076A  43F9 00FF0090            440           lea cmdparam,a1            * a1 points to parameters
00000770  6000 002A                441           bra cmdrf6
00000774                           442  cmdrf2:
00000774  1018                     443           move.b (a0)+,d0
00000776  B03C 0020                444           cmp.b #' ',d0              * space is parameter delimiter
0000077A  6600 0010                445           bne cmdrf3
0000077E  5239 00FF008E            446           add.b #1,cCmdparam         * increment parameter count
00000784  22C1                     447           move.l d1,(a1)+   
00000786  4281                     448           clr.l d1                   * ready for next parameter
00000788  6000 0012                449           bra cmdrf6
0000078C                           450  cmdrf3:
0000078C  6100 17B0                451           bsr asc2hex       `        * accumulate valid ASCII into hex value
00000790  B03C 00FF                452           cmp.b #$FF,d0
00000794  6700 002A                453           beq cmdrf8
00000798  E989                     454           lsl.l #4,d1
0000079A  D200                     455           add.b d0,d1
0000079C                           456  cmdrf6:
0000079C  51CA FFD6                457           dbra d2,cmdrf2
000007A0  0C39 0004 00FF008E       458           cmp.b #4,cCmdparam         * can't have more than 4 parameters
000007A8  6700 0016                459           beq cmdrf8
000007AC  5239 00FF008E            460           add.b #1,cCmdparam         * last parameter
000007B2  22C1                     461           move.l d1,(a1)+
000007B4                           462  cmdrf7:
000007B4  4280                     463           clr.l d0                   * signal a good command line
000007B6  4239 00FF008F            464           clr.b fCmdDone             * flag the command in progress
000007BC  6000 000C                465           bra cmdrf9
000007C0                           466  cmdrf8:
000007C0  7001                     467           move.l #1,d0               * signal a bad command line
000007C2  13FC 0001 00FF008F       468           move.b #1,fCmdDone         * flag the command is finished
000007CA                           469  cmdrf9:
000007CA  4CDF 0306                470           movem.l (sp)+,d1-d2/a0/a1  * restore
000007CE  4E75                     471           rts
000007D0                           472  
000007D0                           473  *************************** User Commands ************************************
000007D0                           474  * display memory in word, address, <count>
000007D0                           475  do_dm:
000007D0  4283                     476           clr.l d3                   * loop count
000007D2  02B9 FFFFFFFE 00FF0090   477           and.l #$FFFFFFFE,cmdparam  * make sure address is even
000007DC  2079 00FF0090            478           move.l cmdparam,a0         * this is starting address to be displayed
000007E2  0C39 0000 00FF008E       479           cmp.b #0,cCmdparam
000007EA  6700 0062                480           beq do_dm8                 * no parameter, exit with error prompt
000007EE  0C39 0002 00FF008E       481           cmp.b #2,cCmdparam         * one or two parameters
000007F6  6E00 0056                482           bgt do_dm8
000007FA  13FC 0000 00FF006B       483           move.b #0,bAnswer+15       * modify the bAnswer message string so not to print prompt
00000802  0C39 0001 00FF008E       484           cmp.b #1,cCmdparam
0000080A  6700 000C                485           beq do_dm1                 * do one line of display memory
0000080E  2639 00FF0094            486           move.l cmdparam+4,d3       * number of words to display
00000814  6000 0016                487           bra do_dm9        
00000818                           488  do_dm1:
00000818  2208                     489           move.l a0,d1               * copy of a0
0000081A  3018                     490           move.w (a0)+,d0            * read the specified memory location
0000081C  6100 1840                491           bsr compuAnswer            * forming the answer in buffer
00000820  227C 00FF005C            492           move.l #bAnswer,a1         * send out the answer
00000826  103C 000E                493           move.b #14,d0
0000082A  4E4F                     494           trap #15
0000082C                           495  
0000082C                           496  do_dm9:
0000082C  0C39 0000 00FF00B6       497           cmp.b #True,fTxDone        * must wait for string transmission done, otherwise bAnswer
00000834                           498                           * will be overwritten with next value.  This problem can
00000834                           499                           * be solved by copying data into another buffer in trap #15
00000834  66F6                     500           bne do_dm9                 * OS swap task here
00000836  51CB FFE0                501           dbra d3,do_dm1
0000083A  13FC 000A 00FF006B       502           move.b #$a,bAnswer+15      * restore bAnswer message string to print prompt      
00000842  4280                     503           clr.l d0                   * signal regular prompt
00000844  4239 00FF00D3            504           clr.b exitCode             ** exit normally
0000084A  6000 000C                505           bra do_dm9x
0000084E                           506  do_dm8:
0000084E  7001                     507           moveq.l #1,d0              * signal error prompt
00000850  13FC 0001 00FF00D3       508           move.b #1,exitCode         ** exit with error
00000858                           509  do_dm9x:
00000858  13FC 0001 00FF008F       510           move.b #1,fCmdDone         * flag the command is finished
00000860  4E75                     511           rts
00000862                           512  * display register <a|d> <0-7>
00000862                           513  * dr without parameter displays all registers, dr a|d displays all address or data registers
00000862                           514  * dr a0-7 displays address a0-a7, dr d0-7 displays d0-d7
00000862                           515  do_dr:
00000862  48F9 FFFF 00FF0010       516           movem.l d0-d7/a0-a7,savd0  * save data & addr registers into system RAM
0000086A                           517  do_bp_dr:                           * entry point for dr command in breapoint handler
0000086A                           518                                      * the register array is already saved, do not save again
0000086A  2439 00FF0090            519           move.l cmdparam,d2         * this is address or data register select
00000870  0C39 0000 00FF008E       520           cmp.b #0,cCmdparam
00000878  6700 00A2                521           beq do_dr1                 * no parameter, display all registers
0000087C  0C39 0001 00FF008E       522           cmp.b #1,cCmdparam
00000884  6E00 00BE                523           bgt do_dr8                 * greater than 1 parameters, exit with error prompt
00000888  B4BC 0000000A            524           cmp.l #$a,d2               
0000088E  6700 005C                525           beq do_dr_a                * 1st parameter = $a 
00000892  B4BC 0000000D            526           cmp.l #$d,d2               
00000898  6700 006A                527           beq do_dr_d                * 1st parameter = $d
0000089C  B4BC 000000A0            528           cmp.l #$a0,d2              * $a0 <= parameter <= $a7
000008A2  6500 00A0                529           blo do_dr8
000008A6  B4BC 000000A7            530           cmp.l #$a7,d2
000008AC  6200 0016                531           bhi do_dr_dx               * check for $d0-$d7
000008B0  7200                     532           moveq.l #0,d1              * display just one register
000008B2  0482 000000A0            533           sub.l #$a0,d2
000008B8  2602                     534           move.l d2,d3
000008BA  C6FC 0010                535           mulu.w #RegStrLen,d3       * compute string array address offset
000008BE  E58A                     536           lsl.l #2,d2                * compute register array offset
000008C0  6000 0030                537           bra do_dra0_7
000008C4                           538  do_dr_dx:
000008C4  B4BC 000000D0            539           cmp.l #$d0,d2              * $d0 <= parameter <= $d7
000008CA  6500 0078                540           blo do_dr8                 * exit with error prompt
000008CE  B4BC 000000D7            541           cmp.l #$d7,d2
000008D4  6200 006E                542           bhi do_dr8                 * exit with error prompt
000008D8  7200                     543           moveq.l #0,d1              * display just one register
000008DA  0482 000000D0            544           sub.l #$d0,d2
000008E0  2602                     545           move.l d2,d3
000008E2  C6FC 0010                546           mulu.w #RegStrLen,d3       * compute string array address offset
000008E6  E58A                     547           lsl.l #2,d2                * compute register array offset
000008E8  6000 0020                548           bra do_drd0_7
000008EC                           549  do_dr_a:
000008EC  7207                     550           moveq.l #7,d1              * all 8 address registers
000008EE  4283                     551           clr.l d3                   * no string offset
000008F0  4282                     552           clr.l d2                   * no register array offset
000008F2                           553  do_dra0_7:
000008F2  41F9 00FF0030            554           lea savA0,a0
000008F8  D1C2                     555           adda.l d2,a0
000008FA  43FA 1448                556           lea regA0(pc),a1
000008FE  D3C3                     557           adda.l d3,a1
00000900  6000 0026                558           bra do_dr2
00000904                           559  do_dr_d:
00000904  7207                     560           moveq.l #7,d1              * display all data registers
00000906  4283                     561           clr.l d3                   * no string offset
00000908  4282                     562           clr.l d2                   * no register array offset 
0000090A                           563  do_drd0_7:
0000090A  41F9 00FF0010            564           lea savD0,a0
00000910  D1C2                     565           adda.l d2,a0
00000912  43FA 13B0                566           lea regD0(pc),a1
00000916  D3C3                     567           adda.l d3,a1
00000918  6000 000E                568           bra do_dr2        
0000091C                           569  do_dr1:
0000091C  41F9 00FF0010            570           lea savd0,a0               * point to the register array 
00000922  7210                     571           moveq.l #16,d1             * loop count +1
00000924  43FA 139E                572           lea regD0(pc),a1
00000928                           573  do_dr2:
00000928  6100 002E                574           bsr do_dr_reg
0000092C  D3FC 00000010            575           adda.l #RegStrLen,a1       * increment to next message string
00000932  5888                     576           adda.l #4,a0               * next register in the register array
00000934  51C9 FFF2                577           dbra d1,do_dr2
00000938                           578  do_dr9:  
00000938  4280                     579           clr.l d0          
0000093A  4239 00FF00D3            580           clr.b exitCode             ** exit normally
00000940  6000 000C                581           bra do_dr9x
00000944                           582  do_dr8:
00000944  7001                     583           moveq.l #1,d0
00000946  13FC 0001 00FF00D3       584           move.b #1,exitCode         ** exit with error prompt
0000094E                           585  do_dr9x:
0000094E  13FC 0001 00FF008F       586           move.b #1,fCmdDone
00000956  4E75                     587           rts
00000958                           588  do_dr_reg:        
00000958                           589  * a1 points to a null terminated message
00000958                           590  * a0 points to save register array
00000958  48E7 8000                591          movem.l d0,-(sp)            * save registers used in trap 15 call
0000095C                           592  * a1 is already points at the null terminated message
0000095C  103C 000E                593          move.b #14,d0               * send message without CR LF
00000960  4E4F                     594          trap #15
00000962  4CDF 0001                595          movem.l (sp)+,d0            * restore registers
00000966                           596  * no need to wait for string transmission done because RegASCII is not reused immediately
00000966                           597  *  The label for RegASCII needs to be output first, trap #15 task 14 checks for transmit
00000966                           598  *  done before transmit next string.         
00000966  2010                     599           move.l (a0),d0             
00000968  6100 1656                600           bsr reg2ascii              * convert d0 to ASCII equivalent
0000096C  48E7 0040                601           movem.l a1,-(sp)           * save registers used in trap 15 call
00000970  43F9 00FF00A0            602           lea RegASCII,a1            * sign on message
00000976  103C 000E                603           move.b #14,d0              * send message without CR LF
0000097A  4E4F                     604           trap #15
0000097C  4CDF 0200                605           movem.l (sp)+,a1           * restore registers        
00000980  4E75                     606           rts
00000982                           607           
00000982                           608  do_mm:   
00000982  02B9 FFFFFFFE 00FF0090   609           and.l #$FFFFFFFE,cmdparam  * make sure address is even
0000098C  2079 00FF0090            610           move.l cmdparam,a0         * this is starting address to be modified
00000992  0C39 0000 00FF008E       611           cmp.b #0,cCmdparam
0000099A  6700 0050                612           beq do_mm8                 * no parameter, exit with error prompt
0000099E  0C39 0002 00FF008E       613           cmp.b #2,cCmdparam         * one or two parameters
000009A6  6E00 0044                614           bgt do_mm8                 * more than two parameters, exit with error prompt
000009AA  13FC 0000 00FF006B       615           move.b #0,bAnswer+15       * modify the bAnswer message string so not to print prompt
000009B2  0C39 0001 00FF008E       616           cmp.b #1,cCmdparam
000009BA  6700 0042                617           beq do_mm3                 * do memory modify submenu
000009BE  30B9 00FF0096            618           move.w cmdparam+6,(a0)     * modify the address with word size data, 
000009C4                           619                                      * discard the upper word
000009C4  3010                     620           move.w (a0),d0             * read back and display
000009C6  2208                     621           move.l a0,d1
000009C8  6100 1694                622           bsr compuAnswer
000009CC  48E7 0040                623          movem.l a1,-(sp)            * save registers used in trap 15 call
000009D0  43F9 00FF005C            624          lea bAnswer,a1              * sign on message
000009D6  103C 000E                625          move.b #14,d0               * send message without CR LF
000009DA  4E4F                     626          trap #15
000009DC  4CDF 0200                627          movem.l (sp)+,a1            * restore registers        
000009E0  4280                     628           clr.l d0                   * signal regular prompt
000009E2  4239 00FF00D3            629           clr.b exitCode             ** normal exit
000009E8  6000 000C                630           bra do_mm9x       
000009EC                           631  do_mm8:
000009EC  7001                     632           moveq.l #1,d0              * signal error prompt
000009EE  13FC 0001 00FF00D3       633           move.b #1,exitCode         ** exit with error prompt
000009F6                           634  do_mm9x: 
000009F6  6100 149C                635           bsr iBuffer                * restore the bAnswer buffer
000009FA  6000 0042                636           bra do_mm9y
000009FE                           637  do_mm3:
000009FE                           638  * interactive session, period (.) to end session, minus (-) to go back, CR for next address
000009FE  13FC 003A 00FF006B       639           move.b #':',bAnswer+15     * add a colon to prompt for new value
00000A06  13FC 0000 00FF006C       640           move.b #0,bAnswer+16       * terminate string after colon
00000A0E                           641  do_mm4:
00000A0E  3010                     642           move.w (a0),d0             * read memory and display
00000A10  2208                     643           move.l a0,d1               * d1 contains the address
00000A12  6100 164A                644           bsr compuAnswer            * 
00000A16  48E7 0040                645          movem.l a1,-(sp)            * save registers used in trap 15 call
00000A1A  43F9 00FF005C            646          lea bAnswer,a1              * sign on message
00000A20  103C 000E                647          move.b #14,d0               * send message without CR LF
00000A24  4E4F                     648          trap #15
00000A26  4CDF 0200                649          movem.l (sp)+,a1            * restore registers        
00000A2A  6100 06CA                650          bsr enableNextCmd           * get ready for a new command
00000A2E  13FC 0001 00FF00C3       651           move.b #1,sInteractive     * set the mm command interactive session flag
00000A36  23C8 00FF00CC            652           move.l a0,mmaddress        * save the address for next interactive session
00000A3C  7002                     653           move.l #2,d0               * signal interactive session in progress
00000A3E                           654  do_mm9y:
00000A3E  13FC 0001 00FF008F       655           move.b #1,fCmdDone         * flag the command is finished
00000A46  4E75                     656           rts                        
00000A48                           657  do_mr:
00000A48  48F9 FFFF 00FF0010       658           movem.l d0-d7/a0-a7,savd0  * capture current register values
00000A50                           659  do_bp_mr:                           * entry point for mr command in breakpoint handler
00000A50                           660                                      * register array is already saved
00000A50  0C39 0002 00FF008E       661           cmp.b #2,cCmdparam         * expect one or two parameters
00000A58  6200 016E                662           bhi do_mr8
00000A5C  0C39 0000 00FF008E       663           cmp.b #0,cCmdparam         * if no parameter, exit with error prompt
00000A64  6700 0162                664           beq do_mr8
00000A68  2439 00FF0090            665           move.l cmdparam,d2         * get the parameter
00000A6E  B4BC 000000A0            666           cmp.l #$a0,d2              * $a0 <= parameter <= $a7
00000A74  6500 0152                667           blo do_mr8
00000A78  B4BC 000000A7            668           cmp.l #$a7,d2
00000A7E  6200 001E                669           bhi do_mr_dx               * check for $d0-$d7
00000A82  0482 000000A0            670           sub.l #$a0,d2
00000A88  2602                     671           move.l d2,d3
00000A8A  C6FC 0010                672           mulu.w #RegStrLen,d3       * compute string array address offset
00000A8E  E58A                     673           lsl.l #2,d2                * compute register array offset
00000A90  41F9 00FF0030            674           lea savA0,a0               * offset from address register 0
00000A96  43FA 12AC                675           lea regA0(pc),a1  * array base is address register 0 string
00000A9A  6000 002E                676           bra do_mr2
00000A9E                           677  do_mr_dx:
00000A9E  B4BC 000000D0            678           cmp.l #$d0,d2              * $d0 <= parameter <= $d7
00000AA4  6500 0122                679           blo do_mr8                 * exit with error prompt
00000AA8  B4BC 000000D7            680           cmp.l #$d7,d2
00000AAE  6200 0118                681           bhi do_mr8
00000AB2  0482 000000D0            682           sub.l #$d0,d2
00000AB8  2602                     683           move.l d2,d3
00000ABA  C6FC 0010                684           mulu.w #RegStrLen,d3       * compute string array address offset
00000ABE  E58A                     685           lsl.l #2,d2                * compute register array offset
00000AC0  41F9 00FF0010            686           lea savD0,a0               * array base is the data register 0
00000AC6  43FA 11FC                687           lea regD0(pc),a1  * array base is the data register 0 string
00000ACA                           688  do_mr2:
00000ACA  D1C2                     689           adda.l d2,a0               * compute correct offset from base
00000ACC  D3C3                     690           adda.l d3,a1               * compute correct string to display
00000ACE  0C39 0001 00FF008E       691           cmp.b #1,cCmdparam         * if one parameter, go to interactive session
00000AD6  6700 0010                692           beq do_mr3
00000ADA  20B9 00FF0094            693           move.l cmdparam+4,(a0)     * modified the specified register
00000AE0  6100 FE76                694           bsr do_dr_reg
00000AE4  6000 00BC                695           bra do_mr9
00000AE8                           696  do_mr3:
00000AE8                           697  * interactive session, period (.) to end session, minus (-) to go back, CR for next address
00000AE8  13FC 003A 00FF00B4       698           move.b #':',nullchar       * replace first null character with colon prompt
00000AF0                           699  do_mr4:
00000AF0  6100 FE66                700           bsr do_dr_reg
00000AF4  6100 0600                701          bsr enableNextCmd          * initialize for new command
00000AF8  6100 0614                702           bsr wUserInput             * wait for fDoCmd flag
00000AFC  4A39 00FF008C            703           tst.b cCmd                 * if just CR, examine/modify next register
00000B02  6700 007C                704           beq do_mr7
00000B06  0C39 002E 00FF0074       705           cmp.b #'.',bCmdline        * period terminate the session
00000B0E  6700 008E                706           beq do_mr9i
00000B12  0C39 003D 00FF0074       707           cmp.b #'=',bCmdline        * = re-display the same register
00000B1A  67D4                     708           beq do_mr4
00000B1C  0C39 0020 00FF0074       709           cmp.b #' ',bCmdline        * no blank allow
00000B24  6700 0070                710           beq do_mr8i
00000B28  0C39 002D 00FF0074       711           cmp.b #'-',bCmdline        * minus go back one register
00000B30  6600 0014                712           bne do_mr5
00000B34  B1FC 00FF0010            713           cmp.l #savd0,a0            * make sure we are within the register array
00000B3A  67B4                     714           beq do_mr4                 * don't go back one register if already register d0
00000B3C  5988                     715           suba.l #4,a0
00000B3E  93FC 00000010            716           suba.l #RegStrLen,a1
00000B44  60AA                     717           bra do_mr4
00000B46                           718  do_mr5:
00000B46                           719  * cCmd may be 0 - 8.  If 0, advanced to next address, else write data to current
00000B46                           720  * register and advnced to next address.  exit session with error prompt if illegal value  
00000B46  0C39 0008 00FF008C       721           cmp.b #8,cCmd              * no more than 8 characters should be entered
00000B4E  6E00 0046                722           bgt do_mr8i
00000B52  1639 00FF008C            723           move.b cCmd,d3             * d3 is loop counter
00000B58  4883                     724           ext.w d3
00000B5A  5343                     725           sub.w #1,d3                * this is the actual loop count
00000B5C  4282                     726           clr.l d2                   * d2 contains the new value for register
00000B5E  2449                     727           move.l a1,a2               * save copy of a1
00000B60  43F9 00FF0074            728           lea bCmdline,a1
00000B66                           729  do_mr6:
00000B66  1019                     730           move.b (a1)+,d0            * accumulate value one nibble at a time
00000B68  6100 13D4                731           bsr asc2hex
00000B6C  B03C 00FF                732           cmp.b #$FF,d0              * exit interactive session if illegal hex value
00000B70  6700 0024                733           beq do_mr8i
00000B74  E98A                     734           lsl.l #4,d2
00000B76  D400                     735           add.b d0,d2
00000B78  51CB FFEC                736           dbra d3,do_mr6
00000B7C  224A                     737           move.l a2,a1               * restore original a1
00000B7E  2082                     738           move.l d2,(a0)             * write new value into current register
00000B80                           739  do_mr7:
00000B80  B1FC 00FF0050            740           cmp.l #savpc,a0            * don't increment beyond pc register
00000B86  6700 FF68                741           beq do_mr4
00000B8A  5888                     742           adda.l #4,a0               * bump to next register array
00000B8C  D3FC 00000010            743           adda.l #RegStrLen,a1       * bump to next message array
00000B92  6000 FF5C                744           bra do_mr4
00000B96                           745  do_mr8i:
00000B96                           746  * Interactive command consumed in this session, don't carry into next command
00000B96  6100 055E                747          bsr enableNextCmd          * initialize for new command         
00000B9A  6000 002C                748           bra do_mr8
00000B9E                           749  do_mr9i:
00000B9E                           750  * Interactive command consumed in this session, don't carry into next command
00000B9E  6100 0556                751          bsr enableNextCmd          * initialize for new command
00000BA2                           752  do_mr9:
00000BA2  4A39 00FF00BE            753           tst.b fdobkpt              * check for breakpoint in progress
00000BA8  6600 000A                754           bne do_mr9y                * skip over the save register array if 
00000BAC                           755                                      * executing from breakpoint service routine
00000BAC  4CF9 FFFF 00FF0010       756           movem.l savd0,d0-d7/a0-a7  * copy save registers back to real registers
00000BB4                           757  do_mr9y:
00000BB4  13FC 0000 00FF00B4       758           move.b #0,nullchar         * restore the null terminator for normal use
00000BBC  4280                     759           clr.l d0
00000BBE  4239 00FF00D3            760           clr.b exitCode             ** normal exit
00000BC4  6000 000C                761           bra do_mr9x
00000BC8                           762  do_mr8:
00000BC8  7001                     763           moveq.l #1,d0
00000BCA  13FC 0001 00FF00D3       764           move.b #1,exitCode         ** exit with error prompt
00000BD2                           765  do_mr9x:
00000BD2  13FC 0001 00FF008F       766           move.b #1,fCmdDone         * flag the command is finished
00000BDA  4E75                     767           rts                        
00000BDC                           768  do_go:
00000BDC                           769  * if no parameter, use the save register array
00000BDC  0C39 0000 00FF008E       770           cmp.b #0,cCmdparam         * if no parameter, use the save register array
00000BE4  6700 0068                771           beq do_go6
00000BE8  0C39 0002 00FF008E       772           cmp.b #2,cCmdparam         * 2 parameters means breakpoint on the 2nd parameter location
00000BF0  6700 0024                773           beq do_go2
00000BF4  0C39 0001 00FF008E       774           cmp.b #1,cCmdparam         * 1 parameter is the address
00000BFC  6600 008C                775           bne do_go8
00000C00                           776  do_go3:
00000C00  02B9 FFFFFFFE 00FF0090   777           and.l #$FFFFFFFE,cmdparam  * make sure address is even
00000C0A  2079 00FF0090            778           move.l cmdparam,a0
00000C10  4E90                     779           jsr (a0)
00000C12  6000 0042                780           bra do_go7
00000C16                           781  do_go2:
00000C16  4AB9 00FF00B8            782           tst.l bkptaddr                      * check if valid breakpoint already exists
00000C1C  6600 0062                783           bne do_go8x
00000C20  02B9 FFFFFFFE 00FF0094   784           and.l #$FFFFFFFE,cmdparam+4         * make sure the breakpoint address is even
00000C2A  23F9 00FF0094 00FF00B8   785           move.l cmdparam+4,bkptaddr * save the breakpoint address
00000C34  2079 00FF0094            786           move.l cmdparam+4,a0
00000C3A  23D0 00FF00BC            787           move.l (a0),bkptinstr               * save the instruction
00000C40  30BC 48FC                788           move.w #$48FC,(a0)                  * insert illegal instruction
00000C44  0C50 48FC                789           cmp.w #$48FC,(a0)          * verify breakpoint inersertion successful
00000C48  6600 0106                790           bne do_bp8x
00000C4C  60B2                     791           bra do_go3        
00000C4E                           792  do_go6:
00000C4E                           793  * abandon the idea of setting up register array with certain set of value and go
00000C4E                           794  * this is something that can be done interactively during breakpoint and trace
00000C4E                           795  * this function is used exclusively to support S record loading with starting address
00000C4E  2079 00FF0050            796           move.l savpc,a0                     * except a0
00000C54  4E90                     797           jsr (a0)
00000C56                           798  do_go7:
00000C56  23C0 00FF0010            799           move.l d0,savd0            * display returned value of d0
00000C5C  41F9 00FF0010            800           lea savd0,a0
00000C62  43FA 0629                801           lea procdonemsg(pc),a1
00000C66  6100 FCF0                802           bsr do_dr_reg              * display process terminated message
00000C6A  2039 00FF0010            803           move.l savd0,d0            * restore the returned value of d0
00000C70  6000 0022                804           bra do_go9x
00000C74                           805  do_go9:
00000C74  4280                     806           clr.l d0
00000C76  4239 00FF00D3            807           clr.b exitCode             ** normal exit
00000C7C  6000 FF54                808           bra do_mr9x
00000C80                           809  do_go8x:
00000C80  43FA 0571                810          lea badgomsg(pc),a1          * sign on message
00000C84  103C 000E                811          move.b #14,d0               * send message without CR LF
00000C88  4E4F                     812          trap #15
00000C8A                           813  do_go8:
00000C8A  7001                     814           moveq.l #1,d0
00000C8C  13FC 0001 00FF00D3       815           move.b #1,exitCode         ** exit with error prompt
00000C94                           816  do_go9x:
00000C94  13FC 0001 00FF008F       817           move.b #1,fCmdDone         * flag the command is finished
00000C9C  4E75                     818           rts
00000C9E                           819  do_bp:
00000C9E                           820  * breakpoint insert/display/clear
00000C9E                           821  * no parameter display the current breakpoint, one parameter swap out the word in specified
00000C9E                           822  *  address with illegal instruction.  bp 0 clear breakpoint
00000C9E  0C39 0000 00FF008E       823           cmp.b #0,cCmdparam         * no parameter means display breakpoint
00000CA6  6700 0076                824           beq do_bp5
00000CAA  0C39 0001 00FF008E       825           cmp.b #1,cCmdparam         
00000CB2  6600 00AC                826           bne do_bp8
00000CB6  4AB9 00FF0090            827           tst.l cmdparam             * if parameter is zero, restore breakpoint
00000CBC  6700 0032                828           beq do_bp3
00000CC0  02B9 FFFFFFFE 00FF0090   829           and.l #$FFFFFFFE,cmdparam  * make sure address is even
00000CCA  2079 00FF0090            830           move.l cmdparam,a0
00000CD0  23F9 00FF0090 00FF00B8   831           move.l cmdparam,bkptaddr   * update the breakpoint address
00000CDA  33D0 00FF00BC            832           move.w (a0),bkptinstr               * save the original instruction
00000CE0  30BC 48FC                833           move.w #$48FC,(a0)                  * insert illegal instr to specified location
00000CE4  0C50 48FC                834           cmp.w #$48FC,(a0)          * verify insertion successful
00000CE8  6600 0066                835           bne do_bp8x
00000CEC  6000 003A                836           bra do_bp6                          * display breakpoint
00000CF0                           837  do_bp3:
00000CF0  4AB9 00FF00B8            838           tst.l bkptaddr                      * if no breakpoint found, display no breakpoint message
00000CF6  6700 0042                839           beq do_bp7
00000CFA  2079 00FF00B8            840           move.l bkptaddr,a0                  * address of the original instruction
00000D00  30B9 00FF00BC            841           move.w bkptinstr,(a0)               * restore original instruction
00000D06  41F9 00FF00B8            842           lea bkptaddr,a0
00000D0C  43FA 0F3C                843           lea bpremovemsg(pc),a1              * display the breakpoint removed message
00000D10  6100 FC46                844           bsr do_dr_reg
00000D14  42B9 00FF00B8            845           clr.l bkptaddr                      * no breakpoint exists
00000D1A  6000 0028                846           bra do_bp9
00000D1E                           847  do_bp5:  
00000D1E  4AB9 00FF00B8            848           tst.l bkptaddr                      * check if valid breakpoint exists
00000D24  6700 0014                849           beq do_bp7
00000D28                           850  do_bp6:
00000D28  41F9 00FF00B8            851           lea bkptaddr,a0
00000D2E  43FA 0F08                852           lea bkptmsg(pc),a1                  * print display current breakpoint
00000D32  6100 FC24                853           bsr do_dr_reg                       * a0 is pointed at the address of breakpoint 
00000D36  6000 000C                854           bra do_bp9
00000D3A                           855  do_bp7:
00000D3A  43FA 0EC4                856          lea nobpmsg(pc),a1          * sign on message
00000D3E  103C 000E                857          move.b #14,d0               * send message without CR LF
00000D42  4E4F                     858          trap #15  
00000D44                           859  do_bp9:
00000D44  4280                     860           clr.l d0
00000D46  4239 00FF00D3            861           clr.b exitCode             ** normal exit
00000D4C  6000 FE84                862           bra do_mr9x
00000D50                           863  do_bp8x:
00000D50                           864  * unable to insert breakpoint
00000D50  42B9 00FF00B8            865           clr.l bkptaddr             * remove breakpoint
00000D56  43FA 0EC2                866          lea badbpmsg(pc),a1          * sign on message
00000D5A  103C 000E                867          move.b #14,d0               * send message without CR LF
00000D5E  4E4F                     868          trap #15
00000D60                           869  do_bp8:
00000D60  7001                     870           moveq.l #1,d0
00000D62  13FC 0001 00FF00D3       871           move.b #1,exitCode         ** exit with error prompt
00000D6A                           872  do_bp9x:
00000D6A  13FC 0001 00FF008F       873           move.b #1,fCmdDone         * flag the command is finished
00000D72  4E75                     874           rts
00000D74                           875  
00000D74                           876  do_help:
00000D74  43FA 0657                877           lea helpmsg(pc),a1         * A1 points at the help message
00000D78  103C 000E                878           move.b #14,d0              * output null terminated string without LR/CF
00000D7C  4E4F                     879           trap #15
00000D7E  4280                     880           clr.l d0
00000D80  4239 00FF00D3            881           clr.b exitCode             ** normal exit
00000D86  13FC 0001 00FF008F       882           move.b #1,fCmdDone         * flag the command is finished      
00000D8E  4E75                     883           rts
00000D90                           884           
00000D90                           885  mminteractive:
00000D90                           886  * this is the interactive session for mm command
00000D90  2079 00FF00CC            887           move.l mmaddress,a0        * restore address to be modified
00000D96  4A39 00FF008C            888           tst.b cCmd                 * if just CR, modify next address
00000D9C  6700 0068                889           beq mminteract1
00000DA0  0C39 002E 00FF0074       890           cmp.b #'.',bCmdline        * period terminate the session
00000DA8  6700 009E                891           beq mminteract9
00000DAC  0C39 003D 00FF0074       892           cmp.b #'=',bCmdline        * = re-display the same address
00000DB4  6700 0058                893           beq mminteract2
00000DB8  0C39 0020 00FF0074       894           cmp.b #' ',bCmdline        * no blank allow
00000DC0  6700 0078                895           beq mminteract8
00000DC4  0C39 002D 00FF0074       896           cmp.b #'-',bCmdline        * minus go back one word address
00000DCC  6700 003E                897           beq mminteract3
00000DD0                           898  * cCmd may be 0 - 4.  If 0, advanced to next address, else write data to current
00000DD0                           899  * memory and advnced to next address.  exit session with error prompt if illegal value    
00000DD0  0C39 0004 00FF008C       900           cmp.b #4,cCmd
00000DD8  6E00 0060                901           bgt mminteract8
00000DDC  1639 00FF008C            902           move.b cCmd,d3             * d3 is loop count
00000DE2  4883                     903           ext.w d3          * get d3 ready for dbra operation
00000DE4  5343                     904           sub.w #1,d3                * the actual loop count is one less
00000DE6  4282                     905           clr.l d2          * d2 contains the new data value
00000DE8  43F9 00FF0074            906           lea bCmdline,a1
00000DEE                           907  mminteract6:
00000DEE  1019                     908           move.b (a1)+,d0            * accumulate value one nibble at a time
00000DF0  6100 114C                909           bsr asc2hex
00000DF4  B03C 00FF                910           cmp.b #$FF,d0              * exit session if illegal hex value
00000DF8  6700 0040                911           beq mminteract8
00000DFC  E98A                     912           lsl.l #4,d2
00000DFE  D400                     913           add.b d0,d2
00000E00  51CB FFEC                914           dbra d3,mminteract6
00000E04  3082                     915           move.w d2,(a0)             * write new data value into current address
00000E06                           916  mminteract1:      
00000E06  5488                     917           add.l #2,a0                * next address location
00000E08  6000 0004                918           bra mminteract2
00000E0C                           919  mminteract3:
00000E0C  5588                     920           sub.l #2,a0
00000E0E                           921  mminteract2:
00000E0E  3010                     922           move.w (a0),d0             * read memory and display
00000E10  2208                     923           move.l a0,d1               * d1 contains the address
00000E12  6100 124A                924           bsr compuAnswer            * 
00000E16  48E7 0040                925          movem.l a1,-(sp)            * save registers used in trap 15 call
00000E1A  43F9 00FF005C            926          lea bAnswer,a1              * sign on message
00000E20  103C 000E                927          move.b #14,d0               * send message without CR LF
00000E24  4E4F                     928          trap #15
00000E26  4CDF 0200                929          movem.l (sp)+,a1            * restore registers        
00000E2A  6100 02CA                930          bsr enableNextCmd          * initialize for new command
00000E2E  23C8 00FF00CC            931           move.l a0,mmaddress        * save the address for next interactive session
00000E34  7002                     932           move.l #2,d0               * signal interactive session in progress
00000E36  6000 002A                933           bra mminteract9y  
00000E3A                           934  mminteract8:
00000E3A  7001                     935           moveq.l #1,d0              * error prompt
00000E3C  13FC 0001 00FF00D3       936           move.b #1,exitCode         ** exit with error prompt
00000E44  6000 000A                937           bra mminteract9x
00000E48                           938  mminteract9:
00000E48  4280                     939           clr.l d0                   * normal prompt
00000E4A  4239 00FF00D3            940           clr.b exitCode             ** normal exit
00000E50                           941  mminteract9x:
00000E50  4239 00FF00C3            942           clr.b sInteractive         * interactive session is over
00000E56  6100 103C                943           bsr iBuffer                * restore the bAnswer buffer content
00000E5A  13FC 0001 00FF008F       944           move.b #1,fCmdDone         * flag the command is finished
00000E62                           945  mminteract9y:                       ** return without setting the fCmdDone flag
00000E62                           946                                      ** session not over
00000E62                           947  * Interactive command consumed in this session, don't carry into next command
00000E62  6100 0292                948          bsr enableNextCmd          * initialize for new command
00000E66  4E75                     949           rts
00000E68                           950           
00000E68                           951  do_du:   
00000E68                           952  * display specified lines of data in hex and ascii
00000E68                           953  * each line is 16 bytes of data in the format:
00000E68                           954  * address hex data (16x) ascii-equivalent
00000E68                           955  * 01234560 00 01 02 03 04 05 06 07 08 09 31 11 12 13 14 32  .........1.....2
00000E68  02B9 FFFFFFF0 00FF0090   956           and.l #$FFFFFFF0,cmdparam  * make sure address is on 16-byte boundary
00000E72  2479 00FF0090            957           move.l cmdparam,a2                  * starting address to dump data
00000E78  0C39 0001 00FF008E       958           cmp.b #1,cCmdparam                  * expect 1 or 2 parameters
00000E80  6D00 00C6                959           blt do_du8                 * if lesser than 1 parameter, exit with error
00000E84  6700 0018                960           beq do_du3
00000E88  0C39 0002 00FF008E       961           cmp.b #2,cCmdparam         * if 2, load the line count
00000E90  6E00 00B6                962           bgt do_du8                 * error if greater than 2 parameters
00000E94  2639 00FF0094            963           move.l cmdparam+4,d3       * d3 is line count
00000E9A  6000 009C                964           bra do_du2
00000E9E                           965  do_du3:
00000E9E                           966  * display one line of data
00000E9E  487A 02AB                967           pea CRLF(pc)               * pc-relative address of CRLF message
00000EA2  225F                     968           move.l (sp)+,a1            * 
00000EA4  103C 000E                969           move.b #14,d0              * output null-terminated string with task 14
00000EA8  4E4F                     970           trap #15
00000EAA  200A                     971           move.l a2,d0               * display the address value
00000EAC  6100 1112                972           bsr reg2ascii              * convert to ASCII and store in RegASCII buffer
00000EB0  43F9 00FF00A0            973           lea RegASCII,a1            * output content of RegASCII
00000EB6  103C 000E                974           move.b #14,d0              * using trap #15, task 14
00000EBA  4E4F                     975           trap #15
00000EBC  264A                     976           move.l a2,a3               * save a2
00000EBE  41F9 00FF0070            977           lea bByteAns,a0            * point to bByteAns buffer for printing
00000EC4  343C 000F                978           move.w #15,d2              * do 16 bytes of data
00000EC8                           979  do_du4:
00000EC8  101A                     980           move.b (a2)+,d0            * fetch data
00000ECA  6100 10C0                981           bsr hex2asc
00000ECE                           982  * trap #15 task #14 ensures the previous string is finished transmission before  submit
00000ECE                           983  * next string for output.  It does not check the string is done transmitting before return
00000ECE                           984  * So if the same string buffer is to be used repeatly, the calling routine must make sure
00000ECE                           985  * the data in the string buffer is already consumed before putting in new data.  Otherwise
00000ECE                           986  * the new data may overwritten the data waiting to be transmitted.  
00000ECE                           987  * fTxDone is the mechanism to make sure string is consumed
00000ECE                           988  wBufDu:
00000ECE  0C39 0000 00FF00B6       989           cmp.b #True,fTxDone        * wait for the previous string is transmitted before 
00000ED6  66F6                     990           bne wBufDu                 *   writing new data
00000ED8                           991  * 68000 can not handle misaligned word write, so do this in two byte writes
00000ED8  1140 0002                992           move.b d0,2(a0)            * write lsb first to print buffer
00000EDC  E048                     993           lsr.w #8,d0                * shift the msb of word into lower byte
00000EDE  1140 0001                994           move.b d0,1(a0)            * write the msb to print buffer
00000EE2  2248                     995           move.l a0,a1               * output null-terminated string with trap 15, task 14
00000EE4  103C 000E                996           move.b #14,d0
00000EE8  4E4F                     997           trap #15
00000EEA  51CA FFDC                998           dbra d2,do_du4             * do a line of 16 data
00000EEE                           999  wBufDu1:
00000EEE  0C39 0000 00FF00B6      1000           cmp.b #True,fTxDone        * wait for the previous string is transmitted before 
00000EF6  66F6                    1001           bne wBufDu1                *   writing new data
00000EF8                          1002  * 68000 can not handle misaligned word write, so do this in two byte writes
00000EF8  117C 0020 0001          1003           move.b #$20,1(a0)          * put a space in print buffer
00000EFE  117C 0020 0002          1004           move.b #$20,2(a0)          * put another space in print buffer 
00000F04  2248                    1005           move.l a0,a1               * output null-terminated string with trap 15, task 14
00000F06  103C 000E               1006           move.b #14,d0
00000F0A  4E4F                    1007           trap #15
00000F0C  343C 000F               1008           move.w #15,d2              * display 16 hex as ascii characters on the same line
00000F10                          1009  do_du7:
00000F10  121B                    1010           move.b (a3)+,d1
00000F12  C23C 007F               1011           and.b #$7F,d1              * print 7-bit ASCII character set
00000F16  B23C 007F               1012           cmp.b #$7f,d1              * 'del' character is not printable
00000F1A  6600 0006               1013           bne do_du5
00000F1E  123C 002E               1014           move.b #'.',d1             * replace 'del char with '.'
00000F22                          1015  do_du5:
00000F22  B23C 0020               1016           cmp.b #$20,d1              * anything lesser than 0x20 is not printable
00000F26  6C00 0006               1017           bge do_du6
00000F2A  123C 002E               1018           move.b #'.',d1
00000F2E                          1019  do_du6:
00000F2E  103C 0006               1020           move.b #6,d0               * output single ascii character in d1.b with trap 15 task 6
00000F32  4E4F                    1021           trap #15
00000F34  51CA FFDA               1022           dbra d2,do_du7
00000F38                          1023  do_du2:
00000F38  51CB FF64               1024           dbra d3,do_du3             * do the specified number of lines
00000F3C  4280                    1025           clr.l d0                   * signal regular prompt
00000F3E  4239 00FF00D3           1026           clr.b exitCode             ** normal exit
00000F44  6000 000C               1027           bra do_du9x
00000F48                          1028  do_du8:  
00000F48  7001                    1029           moveq.l #1,d0              * signal error prompt
00000F4A  13FC 0001 00FF00D3      1030           move.b #1,exitCode         ** exit with error prompt
00000F52                          1031  do_du9x:
00000F52  13FC 0001 00FF008F      1032           move.b #1,fCmdDone         * flag the command is finished
00000F5A  4E75                    1033           rts
00000F5C                          1034           
00000F5C                          1035  do_bo:
00000F5C                          1036  * boot CP/M 68K from compact flash
00000F5C                          1037  * The program is stored starting from Logical Address 1
00000F5C                          1038  * copy program into $15000 to $20000 and then jump into $15000
00000F5C  =00FFE000               1039  CFdata   equ $FFE000       * CF data register
00000F5C  =00FFE002               1040  CFerr    equ $FFE002       * CF error reg
00000F5C  =00FFE005               1041  CFsectcnt equ $FFE005      * CF sector count reg
00000F5C  =00FFE007               1042  CF07     equ $FFE007       * CF LA0-7
00000F5C  =00FFE009               1043  CF815    equ $FFE009       * CF LA8-15
00000F5C  =00FFE00B               1044  CF1623   equ $FFE00B       * CF LA16-23
00000F5C  =00FFE00D               1045  CF2427   equ $FFE00D       * CF LA24-27
00000F5C  =00FFE00F               1046  CFstat   equ $FFE00F       * CF status/command reg
00000F5C  43FA 0356               1047           lea bootCPM(pc),a1         * print boot CPM message
00000F60  103C 000E               1048           move.b #14,d0              * print without adding CRLF
00000F64  4E4F                    1049           trap #15    
00000F66  45F9 00015000           1050           lea $15000,a2              * clear memory from $15000-$20000
00000F6C  3C3C 2BFF               1051           move.w #$b000/4-1,d6       * ($20000-$15000)/4-1
00000F70                          1052  clrmembo:
00000F70  24FC 00000000           1053           move.l #0,(a2)+            * clear memory
00000F76  51CE FFF8               1054           dbra d6,clrmembo
00000F7A  4285                    1055           clr.l d5                   * d5 is checksum of CP/M-68K code      
00000F7C  23FC 40000001 00FF00D8  1056           move.l #$40000001,LA2427   * select logical addressing mode, start from LA 1        
00000F86  13F9 00FF00D8 00FFE00D  1057           move.b LA2427,CF2427       * write logical address
00000F90  13F9 00FF00D9 00FFE00B  1058           move.b LA1623,CF1623
00000F9A  13F9 00FF00DA 00FFE009  1059           move.b LA815,CF815
00000FA4  13F9 00FF00DB 00FFE007  1060           move.b LA07,CF07           * least significant address bits
00000FAE  45F9 00015000           1061           lea $15000,a2               * CP/M 68K starts from $15000 to $20000
00000FB4  3C3C 0057               1062           move.w #$58-1,d6            * total number of sectors is 0x58
00000FB8                          1063  nextsect:
00000FB8  6100 0094               1064           bsr readCF
00000FBC  52B9 00FF00D8           1065           add.l #1,LA2427            * next logical address
00000FC2  13F9 00FF00D8 00FFE00D  1066           move.b LA2427,CF2427       * write logical address
00000FCC  13F9 00FF00D9 00FFE00B  1067           move.b LA1623,CF1623
00000FD6  13F9 00FF00DA 00FFE009  1068           move.b LA815,CF815
00000FE0  13F9 00FF00DB 00FFE007  1069           move.b LA07,CF07           * least significant address bits
00000FEA  51CE FFCC               1070           dbra d6,nextsect
00000FEE                          1071  endreadCF:
00000FEE  45F9 00015000           1072           lea $15000,a2              * point to first line of CPM         
00000FF4  0C9A 4EF90001           1073           cmp.l #$4ef90001,(a2)+     * is the first two long words correct?
00000FFA  6600 0034               1074           bne badCPM
00000FFE  0C92 50504EF9           1075           cmp.l #$50504ef9,(a2)
00001004  6600 002A               1076           bne badCPM
00001008  43FA 02D3               1077           lea crcCPM(pc),a1          * print checksum accumulated in d5
0000100C  103C 000E               1078           move.b #14,d0              * print string without adding CRLF
00001010  4E4F                    1079           trap #15
00001012  6100 00D6               1080           bsr wTxDone                * finish sending message out
00001016  2005                    1081           move.l d5,d0               * print content of d5
00001018  6100 100A               1082           bsr TxRegD0
0000101C  43FA 02F4               1083           lea runCPM(pc),a1          * print execute CP/M message
00001020  103C 000E               1084           move.b #14,d0              * print string without adding CRLF
00001024  4E4F                    1085           trap #15 
00001026  6100 00C2               1086           bsr wTxDone                * finish sending message out before start CPM
0000102A  4EF9 00015000           1087           jmp $15000                 * start CP/M will not return
00001030                          1088  badCPM:   
00001030  43FA 02B8               1089           lea noCPM(pc),a1           * print CP/M code does not exist
00001034  103C 000E               1090           move.b #14,d0              * print string without adding CRLF
00001038  4E4F                    1091           trap #15
0000103A                          1092  do_bo9:
0000103A  7001                    1093           moveq.l #1,d0              * signal error prompt
0000103C  13FC 0001 00FF00D3      1094           move.b #1,exitCode         ** exit with error
00001044  13FC 0001 00FF008F      1095           move.b #1,fCmdDone         * flag the command is finished
0000104C  4E75                    1096           rts       
0000104E                          1097  readCF:         
0000104E                          1098  * read a sector of CF data, accumulate checksum in d5
0000104E  2F07                    1099           move.l d7,-(sp)            * save d7
00001050  7E00                    1100           move.l #0,d7               * clear d7
00001052  13FC 0001 00FFE005      1101           move.b #1,CFsectcnt        * read one sector count
0000105A  13FC 0020 00FFE00F      1102           move.b #$20,CFstat         * read sector command
00001062                          1103  
00001062                          1104  chkdrq:
00001062  0839 0003 00FFE00F      1105           btst.b #3,CFstat          * check data request bit set before reading
0000106A  67F6                    1106           beq chkdrq        
0000106C  343C 00FF               1107           move.w #$ff,d2            * read 512 bytes
00001070                          1108  readCF1:
00001070  3E39 00FFE000           1109           move.w CFdata,d7           * get data and put in destination
00001076  34C7                    1110           move.w d7,(a2)+
00001078  DA87                    1111           add.l d7,d5                * accumulate checksum
0000107A  51CA FFF4               1112           dbra d2,readCF1
0000107E  2E1F                    1113           move.l (sp)+,d7            * restore d7
00001080  4E75                    1114           rts
00001082                          1115  do_sw:
00001082                          1116  * move monitor program from $400 to $FE8000 and jump into $FE8000.  This frees up the space
00001082                          1117  * in $400 so a updated monitor can be loaded and check out.
00001082                          1118  * Check to make sure sw has not executed already.
00001082                          1119  * change exception table to point to $FE8000
00001082                          1120  * copy relocatable code from $400 to $8000
00001082  0CB8 00000400 0004      1121           cmp.l #$400,4              * Is reset location equal to 0x400?
0000108A  6600 003E               1122           bne do_sw8                 * if not, already switched, exit with error message
0000108E  487A 02FA               1123           pea switchmsg(pc)          * output
00001092  225F                    1124           move.l (sp)+,a1            * output null-terminated string with trap 15, task 13
00001094  103C 000D               1125           move.b #13,d0
00001098  4E4F                    1126           trap #15
0000109A  41F8 0400               1127           lea $400,a0                * current monitor code
0000109E  43F9 00FE8000           1128           lea $FE8000,a1             * destination of the swiched monitor code
000010A4  343C 1EFF               1129           move.w #$1f00-1,d2         * copy $1f00-1 long words
000010A8                          1130  do_sw2:
000010A8  22D8                    1131           move.l (a0)+,(a1)+         * copy code from $400 to $FE8000
000010AA  51CA FFFC               1132           dbra d2,do_sw2    
000010AE  41F8 0004               1133           lea 4,a0                   * modify exception table to point to $FE8000
000010B2  343C 00FE               1134           move.w #$100-2,d2          * copy $100-2 long words (loc 0 is not copied)
000010B6                          1135  do_sw3:
000010B6  0698 00FE7C00           1136           add.l #$fe7c00,(a0)+       * adjust exception vectors
000010BC  51CA FFF8               1137           dbra d2,do_sw3
000010C0  6100 0028               1138           bsr wTxDone       * wait for transmission done before jump into $FE8000
000010C4  4EF9 00FE8000           1139           jmp $FE8000       * restart the monitor, no return to here         
000010CA                          1140  
000010CA                          1141  do_sw8:
000010CA  487A 028A               1142           pea switchedmsg(pc)        * monitor already switched to $FE8000, do nothing
000010CE  225F                    1143           move.l (sp)+,a1            * output null-terminated string with trap 15, task 13
000010D0  103C 000D               1144           move.b #13,d0
000010D4  4E4F                    1145           trap #15
000010D6  7001                    1146           moveq.l #1,d0              * signal error prompt
000010D8  13FC 0001 00FF00D3      1147           move.b #1,exitCode         ** exit with error prompt
000010E0  13FC 0001 00FF008F      1148           move.b #1,fCmdDone         * flag the command is finished
000010E8  4E75                    1149           rts
000010EA                          1150  * consolidate waiting for string transmission done here to facilitate OS later
000010EA                          1151  wTxDone:
000010EA  0C39 0000 00FF00B6      1152           cmp.b #True,fTxDone        * wait for string transmission done before returning
000010F2  66F6                    1153           bne wTxDone                * OS swap task here
000010F4  4E75                    1154           rts
000010F6                          1155  enableNextCmd:
000010F6                          1156  * These are setup for next command
000010F6  23FC 00FF0074 00FF0088  1157           move.l #bCmdline,pCmdln  * point to beginning of command line
00001100  4239 00FF008D           1158           clr.b fDoCmd               * clear the command ready flag
00001106  4239 00FF008C           1159           clr.b cCmd                 * clear the command buffer character count
0000110C  4E75                    1160           rts 
0000110E                          1161  wUserInput:
0000110E  4A39 00FF008D           1162           tst.b fDoCmd               * wait for user input
00001114  67F8                    1163           beq wUserInput             * OS swap task here
00001116  4E75                    1164           rts
00001118= 0A 0D 54 69 6E 79 ...   1165  signon   dc.b $a,$d,'Tiny68kbug',$a,$d,'11/5/17 v0.6, type "he" for help',$a,$d,'> ',0
0000114B= 0A 0D 00                1166  CRLF     dc.b $a,$d,0
0000114E= 0A 0D 3E 20 00          1167  prompt   dc.b $a,$d,'> ',0
00001153= 0A 0D 3F 3E 20 00       1168  qprompt  dc.b $a,$d,'?> ',0
00001159= 0A 0D 72 65 67 69 ...   1169  zmemmsg  dc.b $a,$d,'register memory cleared',$a,$d,'> ',0
00001177= 0A 0D 42 75 73 20 ...   1170  berrmsg  dc.b $a,$d,'Bus Error!',$a,$d,'Faulted address is: ',0
0000119A= 0A 0D 49 6C 6C 65 ...   1171  illegalmsg dc.b $a,$d,'Illegal instruction at: ',0
000011B5= 0A 0D 50 72 6F 67 ...   1172  pcmsg    dc.b $a,$d,'Program counter is: ',0
000011CC= 0A 0D 41 64 64 72 ...   1173  addrerrmsg dc.b $a,$d,'Address Error!',$a,$d,'Faulted address is: ',0
000011F3= 0A 0D 42 72 65 61 ...   1174  badgomsg dc.b $a,$d,'Breakpoint already in use, unable to execute go to breakpoint',0
00001233= 0A 0D 56 61 6C 69 ...   1175  runSrecord dc.b $a,$d,'Valid S record received, executing from starting address',0
0000126E= 0A 0D 53 20 72 65 ...   1176  rundoneSR dc.b $a,$d,'S record execution completed',0
0000128D= 0A 0D 50 72 6F 63 ...   1177  procdonemsg dc.b $a,$d,'Process completed.  Reg D0 returns: ',0
000012B4= 0A 0D 43 6F 70 79 ...   1178  bootCPM  dc.b $a,$d,'Copying CP/M 68K from Compact Flash...',0
000012DD= 63 68 65 63 6B 73 ...   1179  crcCPM   dc.b 'checksum is ',0
000012EA= 0A 0D 6E 6F 20 76 ...   1180  noCPM    dc.b $a,$d,'no valid CP/M code, command cancelled',0
00001312= 0A 0D 0A 0D 43 50 ...   1181  runCPM   dc.b $a,$d,$a,$d,'CP/M-68K V1.3 COPYRIGHT (C) 1982, 1984, 1985 Digital Research',$a,$d,0
00001356= 0A 0D 41 6C 72 65 ...   1182  switchedmsg dc.b $a,$d,'Already switched, monitor is currently at $FE8000',0
0000138A= 0A 0D 53 77 69 74 ...   1183  switchmsg dc.b $a,$d,'Switch monitor to $FE8000 and start monitor execution at $FE8000',0
000013CD= 0A 0D 43 6F 6D 6D ...   1184  helpmsg dc.b $a,$d,'Commands are in lower case, <>optional, []mandatory'
00001402= 0A 0D 64 6D 20 5B ...   1185           dc.b $a,$d,'dm [address] <count>'
00001418= 0A 0D 64 72 20 3C ...   1186           dc.b $a,$d,'dr <a|d|a0-a7|d0-d7>  Display all registers if no parameter'
00001455= 0A 0D 6D 6D 20 5B ...   1187           dc.b $a,$d,'mm [address] <value>  If only address entered, a submenu will follow:'
0000149C= 0A 0D 20 20 20 20 ...   1188           dc.b $a,$d,'      . terminates submenu session',$a,$d,'      - go back one word address'
000014E2= 0A 0D 20 20 20 20 ...   1189           dc.b $a,$d,'      [value] modify current address and display next address'
00001521= 0A 0D 20 20 20 20 ...   1190           dc.b $a,$d,'      CR not modify current address but display next address'
0000155F= 0A 0D 6D 72 20 5B ...   1191           dc.b $a,$d,'mr [a0-a7|d0-d7] <value>  If only register entered, a submenu will follow:'
000015AB= 0A 0D 20 20 20 20 ...   1192           dc.b $a,$d,'      . terminates submenu session',$a,$d,'      - go back one register'
000015ED= 0A 0D 20 20 20 20 ...   1193           dc.b $a,$d,'      [value] modify current register and display next register'
0000162E= 0A 0D 20 20 20 20 ...   1194           dc.b $a,$d,'      CR not modify current register but display next register'
0000166E= 0A 0D 67 6F 20 3C ...   1195           dc.b $a,$d,'go <from_addr> <to_addr> If no address specified, use save register values'
000016BA= 0A 0D 62 70 20 3C ...   1196           dc.b $a,$d,'bp <addr>  If no address specified, display current break point'
000016FB= 0A 0D 20 20 20 20 ...   1197           dc.b $a,$d,'      special case: bp 0 removes breakpoint'
00001728= 0A 0D 64 75 20 5B ...   1198           dc.b $a,$d,'du [address] <line count> dump specified number of lines'
00001762= 0A 0D 73 77 20 73 ...   1199           dc.b $a,$d,'sw switch monitor to $FE8000 and start execution at $FE8000'
0000179F= 0A 0D 62 6F 20 62 ...   1200           dc.b $a,$d,'bo boot CP/M 68K from compact flash',0
000017C5                          1201  
000017C5= 0A 0D 64 6D 20 5B ...   1202  bphelpmsg dc.b $a,$d,'dm [address] <count>'
000017DB= 0A 0D 64 72 20 3C ...   1203           dc.b $a,$d,'dr <a|d|a0-a7|d0-d7>  Display all registers if no parameter'
00001818= 0A 0D 6D 6D 20 5B ...   1204           dc.b $a,$d,'mm [address] <value>  If only address entered, a submenu will follow:'
0000185F= 0A 0D 20 20 20 20 ...   1205           dc.b $a,$d,'      . terminates submenu session',$a,$d,'      - go back one word address'
000018A5= 0A 0D 20 20 20 20 ...   1206           dc.b $a,$d,'      [value] modify current address and display next address'
000018E4= 0A 0D 20 20 20 20 ...   1207           dc.b $a,$d,'      CR not modify current address but display next address'
00001922= 0A 0D 6D 72 20 5B ...   1208           dc.b $a,$d,'mr [a0-a7|d0-d7] <value>  If only register entered, a submenu will follow:'
0000196E= 0A 0D 20 20 20 20 ...   1209           dc.b $a,$d,'      . terminates submenu session',$a,$d,'      - go back one register'
000019B0= 0A 0D 20 20 20 20 ...   1210           dc.b $a,$d,'      [value] modify current register and display next register'
000019F1= 0A 0D 20 20 20 20 ...   1211           dc.b $a,$d,'      CR not modify current register but display next register'
00001A31= 0A 0D 67 74 20 3C ...   1212           dc.b $a,$d,'gt <addr>  Set a breakpoint at specified address and resume program execution'
00001A80= 0A 0D 20 20 20 20 ...   1213           dc.b $a,$d,'      if no address specified, resume normal program execution'
00001AC0= 0A 0D 62 70 20 3C ...   1214           dc.b $a,$d,'bp <addr>  If no address specified, display current break point'
00001B01= 0A 0D 20 20 20 20 ...   1215           dc.b $a,$d,'      special case: bp 0 removes breakpoint'
00001B2E= 0A 0D 74 72 20 3C ...   1216           dc.b $a,$d,'tr <count>  Trace instruction execution <count> times'
00001B65= 0A 0D 20 20 20 20 ...   1217           dc.b $a,$d,'      if no parameter specified, trace one instruction'
00001B9D= 0A 0D 76 62 20 20 ...   1218           dc.b $a,$d,'vb  Toggle verbose mode on or off'
00001BC0= 0A 0D 5B 63 61 72 ...   1219           dc.b $a,$d,'[carriage return] trace one instruction',0
00001BEA                          1220           
00001BEA= 3F 00                   1221  q_no_cr  dc.b '?',0
00001BEC= 0A 0D 42 50 3E 20 00    1222  bpprompt dc.b $a,$d,'BP> ',0        * prompt used in breakpoint session
00001BF3= 0A 0D 42 50 3F 3E ...   1223  bpqprompt dc.b $a,$d,'BP?> ',0
00001BFB= 20 42 50 3E 00          1224  bppromptnc dc.b ' BP>',0            * prompt without carriage return.
00001C00= 0A 0D 4E 6F 20 62 ...   1225  nobpmsg  dc.b $a,$d,'No breakpoint specified',0
00001C1A= 0A 0D 55 6E 61 62 ...   1226  badbpmsg dc.b $a,$d,'Unable to insert breakpoint',0
00001C38= 0A 0D 42 72 65 61 ...   1227  bkptmsg dc.b $a,$d,'Breakpoint at: ',0
00001C4A= 0A 0D 42 72 65 61 ...   1228  bpremovemsg dc.b $a,$d,'Breakpoint removed from: ',0
00001C66= 0A 0D 54 72 61 63 ...   1229  tracemsg dc.b $a,$d,'Trace --> Next instr:',0
00001C7E= 20 61 74 20 61 64 ...   1230  tracepcmsg dc.b ' at addr:',0
00001C88= 20 63 75 72 72 65 ...   1231  tracestmsg dc.b ' current Status:',0
00001C99= 0A 0D 56 65 72 62 ...   1232  verbosemsg dc.b $a,$d,'Verbose mode is On',0
00001CAE= 0A 0D 56 65 72 62 ...   1233  simplemsg dc.b $a,$d,'Verbose mode is Off',0                            
00001CC4= 0A 0D 52 65 67 69 ...   1234  regD0    dc.b $a,$d,'Register D0: ',0
00001CD4= 0A 0D 52 65 67 69 ...   1235  regD1    dc.b $a,$d,'Register D1: ',0
00001CE4= 0A 0D 52 65 67 69 ...   1236  regD2    dc.b $a,$d,'Register D2: ',0
00001CF4= 0A 0D 52 65 67 69 ...   1237  regD3    dc.b $a,$d,'Register D3: ',0
00001D04= 0A 0D 52 65 67 69 ...   1238  regD4    dc.b $a,$d,'Register D4: ',0
00001D14= 0A 0D 52 65 67 69 ...   1239  regD5    dc.b $a,$d,'Register D5: ',0
00001D24= 0A 0D 52 65 67 69 ...   1240  regD6    dc.b $a,$d,'Register D6: ',0
00001D34= 0A 0D 52 65 67 69 ...   1241  regD7    dc.b $a,$d,'Register D7: ',0
00001D44= 0A 0D 52 65 67 69 ...   1242  regA0    dc.b $a,$d,'Register A0: ',0        
00001D54= 0A 0D 52 65 67 69 ...   1243  regA1    dc.b $a,$d,'Register A1: ',0
00001D64= 0A 0D 52 65 67 69 ...   1244  regA2    dc.b $a,$d,'Register A2: ',0
00001D74= 0A 0D 52 65 67 69 ...   1245  regA3    dc.b $a,$d,'Register A3: ',0
00001D84= 0A 0D 52 65 67 69 ...   1246  regA4    dc.b $a,$d,'Register A4: ',0
00001D94= 0A 0D 52 65 67 69 ...   1247  regA5    dc.b $a,$d,'Register A5: ',0
00001DA4= 0A 0D 52 65 67 69 ...   1248  regA6    dc.b $a,$d,'Register A6: ',0
00001DB4= 0A 0D 52 65 67 69 ...   1249  regA7    dc.b $a,$d,'Register A7: ',0
00001DC4= 0A 0D 50 72 6F 67 ...   1250  regPC    dc.b $a,$d,'Program Counter (for "go" command use only): ',0   *PC had different length
00001DF4= 0A 0D 44 30 3A 20 00    1251  regD0short dc.b $a,$d,'D0: ',0
00001DFB= 20 20 44 31 3A 20 00    1252  regD1short dc.b '  D1: ',0
00001E02= 20 20 44 32 3A 20 00    1253  regD2short dc.b '  D2: ',0
00001E09= 20 20 44 33 3A 20 00    1254  regD3short dc.b '  D3: ',0
00001E10= 0A 0D 44 34 3A 20 00    1255  regD4short dc.b $a,$d,'D4: ',0
00001E17= 20 20 44 35 3A 20 00    1256  regD5short dc.b '  D5: ',0
00001E1E= 20 20 44 36 3A 20 00    1257  regD6short dc.b '  D6: ',0
00001E25= 20 20 44 37 3A 20 00    1258  regD7short dc.b '  D7: ',0
00001E2C= 0A 0D 41 30 3A 20 00    1259  regA0short dc.b $a,$d,'A0: ',0
00001E33= 20 20 41 31 3A 20 00    1260  regA1short dc.b '  A1: ',0
00001E3A= 20 20 41 32 3A 20 00    1261  regA2short dc.b '  A2: ',0
00001E41= 20 20 41 33 3A 20 00    1262  regA3short dc.b '  A3: ',0
00001E48= 0A 0D 41 34 3A 20 00    1263  regA4short dc.b $a,$d,'A4: ',0
00001E4F= 20 20 41 35 3A 20 00    1264  regA5short dc.b '  A5: ',0
00001E56= 20 20 41 36 3A 20 00    1265  regA6short dc.b '  A6: ',0
00001E5D= 20 20 41 37 3A 20 00    1266  regA7short dc.b '  A7: ',0
00001E64  =00000010               1267  regstrlen equ regA7-regA6  * compute the length of each string
00001E64                          1268  
00001E64                          1269           org (*+1)&-2      * force word alignment
00001E64                          1270  ******************* subroutines*************************
00001E64                          1271  *
00001E64                          1272  * initialize the various buffers
00001E64                          1273  *
00001E64                          1274  * clear a chunk of RAM area as pointed by a5
00001E64                          1275  clrRAMa5:
00001E64  48E7 8004               1276           movem.l d0/a5,-(sp)        * save
00001E68  303C 1000               1277           move.w #$1000,d0           * clear a 16K block
00001E6C                          1278  clrRAM0:
00001E6C  429D                    1279           clr.l (a5)+
00001E6E  51C8 FFFC               1280           dbra d0,clrRAM0
00001E72  4CDF 2001               1281           movem.l (sp)+,d0/a5        * restore
00001E76  4E75                    1282           rts
00001E78                          1283  *
00001E78                          1284  * clear the saved register area in the system RAM
00001E78                          1285  clrsavr:
00001E78  41F9 00FF0010           1286           lea savd0,a0               * savd0 is the beginning of register block
00001E7E  303C 0010               1287           move.w #16,d0              * 17 registers total
00001E82                          1288  clrsavr0:
00001E82  4298                    1289           clr.l (a0)+
00001E84  51C8 FFFC               1290           dbra d0,clrsavr0
00001E88  4258                    1291           clr.w (a0)+                * this clear the exception counter
00001E8A  4BF9 00FE0000           1292           lea $FE0000,a5             * $FE0000 to FE3FFF is diagnostic area
00001E90  61D2                    1293           bsr clrRAMa5
00001E92  4E75                    1294           rts
00001E94                          1295  iBuffer:
00001E94  13FC 000A 00FF005C      1296           move.b #$a,bAnswer         * start with LF, CR
00001E9C  13FC 000D 00FF005D      1297           move.b #$d,bAnswer+1
00001EA4  13FC 003A 00FF0066      1298           move.b #':',bAnswer+10     * separator
00001EAC  13FC 000A 00FF006B      1299           move.b #$a,bAnswer+15
00001EB4  13FC 000D 00FF006C      1300           move.b #$d,bAnswer+16
00001EBC  13FC 003E 00FF006D      1301           move.b #'>',bAnswer+17
00001EC4  13FC 0020 00FF006E      1302           move.b #' ',bAnswer+18
00001ECC  13FC 0000 00FF006F      1303           move.b #0,bAnswer+19       * zero terminator
00001ED4  4E75                    1304           rts
00001ED6                          1305  
00001ED6                          1306  *
00001ED6                          1307  * initialize the DUART 68692, only lower byte is connected to data bus d0-d7
00001ED6                          1308  **HH 10/25/17 enable hardware handshake of serial port A
00001ED6                          1309  iDUART:
00001ED6                          1310  *        move.b #$13,MRA            * write to MR1A as follow:
00001ED6                          1311                             * no RxRTS, RxRDY int, Char error, no parity, 8 bits
00001ED6  13FC 0093 00FFF001      1312           move.b #$93,MRA            * write to MR1A as follow:
00001EDE                          1313                             **HH RxRTS, RxRDY int, Char error, no parity, 8 bits
00001EDE                          1314  *        move.b #$07,MRA            * now write to MR2A as follow:
00001EDE                          1315                             * normal, no TxRTS, no CTS, 1 stop
00001EDE  13FC 0017 00FFF001      1316           move.b #$17,MRA            * now write to MR2A as follow:
00001EE6                          1317                             **HH normal, no TxRTS, CTS, 1 stop
00001EE6  13FC 0000 00FFF00B      1318           move.b #$0,IMRD            * mask off interrupt
00001EEE  13FC 0081 00FFF019      1319           move.b #$81,IVRD  * vector number 0x81 is where DUART ISR is located
00001EF6  13FC 0000 00FFF01B      1320           move.b #0,OPCR             * make output register general purpose
00001EFE  13FC 00FF 00FFF01D      1321           move.b #$ff,SETOPR         * clear display
00001F06  13FC 007E 00FFF01F      1322           move.b #$7e,CLROPR         * drive the value '0' on a 7-seg display
00001F0E  13FC 0070 00FFF009      1323           move.b #$70,ACR            * clear ACR[7] bit, timer mode, 16x prescaler
00001F16  13FC 0080 00FFF00F      1324           move.b #$80,CTLR  * to get 10ms interrupt, timer preload value is 0x480
00001F1E  13FC 0004 00FFF00D      1325           move.b #$4,CTUR
00001F26  13FC 00CC 00FFF003      1326           move.b #$CC,CSRA  * 38.4K baud
00001F2E  1039 00FFF01F           1327           move.b STOPCTR,d0 * read clear the interrupt bit associated with timer
00001F34  13FC 000A 00FFF005      1328           move.b #$A,CRA             * disable Chan A transmit and receive
00001F3C  4E75                    1329           rts
00001F3E                          1330  *
00001F3E                          1331  * check for valid ascii representation of hexdecimal
00001F3E                          1332  * d0 contains input, return 0xFF if invalid, otherwise hex value
00001F3E                          1333  asc2hex:
00001F3E  B03C 0066               1334           cmp.b #'f',d0              
00001F42  6200 002A               1335           bhi aschex9                * not valid, >'f'
00001F46  B03C 0060               1336           cmp.b #'a'-1,d0
00001F4A  6200 003A               1337           bhi aschex1                * 'f'> valid >'a'
00001F4E  B03C 0046               1338           cmp.b #'F',d0              
00001F52  6200 001A               1339           bhi aschex9                * not valid, >'F'
00001F56  B03C 0040               1340           cmp.b #'A'-1,d0
00001F5A  6200 001A               1341           bhi aschex3                * 'F'> valid >'A'
00001F5E  B03C 0039               1342           cmp.b #'9',d0
00001F62  6200 000A               1343           bhi aschex9                * not valid >'9'
00001F66  B03C 002F               1344           cmp.b #'0'-1,d0
00001F6A  6200 0012               1345           bhi aschex2                * '9'> valid >'0'
00001F6E                          1346  aschex9:
00001F6E  103C 00FF               1347           move.b #$FF,d0             * return 0xFF in not hex
00001F72  6000 0016               1348           bra aschex0
00001F76                          1349  aschex3:
00001F76  0400 0037               1350           sub.b #$37,d0
00001F7A  6000 000E               1351           bra aschex0
00001F7E                          1352  aschex2:
00001F7E  0400 0030               1353           sub.b #$30,d0
00001F82  6000 0006               1354           bra aschex0
00001F86                          1355  aschex1:
00001F86  0400 0057               1356           sub.b #$57,d0              * 'a'-'f'
00001F8A                          1357  aschex0: 
00001F8A  4E75                    1358           rts
00001F8C                          1359  *
00001F8C                          1360  * hex to ascii
00001F8C                          1361  * byte value in d0.b is converted to ascii in d0.w
00001F8C                          1362  hex2asc:
00001F8C  48E7 4000               1363           movem.l d1,-(sp)
00001F90  1200                    1364           move.b d0,d1
00001F92  E809                    1365           lsr.b #4,d1                * get the high nibble first
00001F94  0601 0030               1366           add.b #$30,d1
00001F98  B23C 0039               1367           cmp.b #'9',d1              * '0' to '9'
00001F9C  6300 0004               1368           bls hex2asc7
00001FA0  5E01                    1369           add.b #7,d1                * or 'A' to 'F'
00001FA2                          1370  hex2asc7:
00001FA2  E149                    1371           lsl.w #8,d1                * put result in high byte
00001FA4  1200                    1372           move.b d0,d1               * work on the low nibble
00001FA6  C23C 000F               1373           and.b #$F,d1               * isolate low nibble
00001FAA  0601 0030               1374           add.b #$30,d1
00001FAE  B23C 0039               1375           cmp.b #'9',d1              * '0' to '9'
00001FB2  6300 0004               1376           bls hex2asc8
00001FB6  5E01                    1377           add.b #7,d1                * or 'A' to 'F'
00001FB8                          1378  hex2asc8:
00001FB8  2001                    1379           move.l d1,d0               * done
00001FBA  4CDF 0002               1380           movem.l (sp)+,d1
00001FBE  4E75                    1381           rts
00001FC0                          1382  *
00001FC0                          1383  * convert content of register d0 into ASCII equivalent and store in RegASCII system buffer
00001FC0                          1384  reg2ascii:
00001FC0  48E7 4000               1385           movem.l d1,-(sp)           * save
00001FC4  2200                    1386           move.l d0,d1               * save a copy
00001FC6  E198                    1387           rol.l #8,d0                * do MSB first
00001FC8  61C2                    1388           bsr hex2asc
00001FCA  33C0 00FF00A0           1389           move.w d0,RegASCII
00001FD0  2001                    1390           move.l d1,d0               * restore the copy
00001FD2  4840                    1391           swap d0                    * do MUB next
00001FD4  61B6                    1392           bsr hex2asc
00001FD6  33C0 00FF00A2           1393           move.w d0,RegASCII+2
00001FDC  2001                    1394           move.l d1,d0
00001FDE  E098                    1395           ror.l #8,d0                * do MLB next
00001FE0  61AA                    1396           bsr hex2asc
00001FE2  33C0 00FF00A4           1397           move.w d0,RegASCII+4
00001FE8  2001                    1398           move.l d1,d0               * do LSB last
00001FEA  61A0                    1399           bsr hex2asc
00001FEC  33C0 00FF00A6           1400           move.w d0,RegASCII+6
00001FF2  4CDF 0002               1401           movem.l (sp)+,d1           * restore
00001FF6  4E75                    1402           rts
00001FF8                          1403  *
00001FF8                          1404  * transmit a null-terminated string pointed by a0
00001FF8                          1405  TxStringA0:
00001FF8  48E7 8080               1406           movem.l d0/a0,-(sp)        * save regs
00001FFC                          1407  TxStr1:
00001FFC  0839 0002 00FFF003      1408           btst.b #2,SRA              * look for transmit ready
00002004  67F6                    1409           beq TxStr1
00002006  1018                    1410           move.b (a0)+,d0
00002008  6700 000A               1411           beq Txstr9
0000200C  13C0 00FFF007           1412           move.b d0,THRA
00002012  60E8                    1413           bra TxStr1
00002014                          1414  TxStr9:
00002014  0839 0002 00FFF003      1415           btst.b #2,SRA              * wait for transmit done before restart
0000201C  67F6                    1416           beq TxStr9
0000201E  4CDF 0101               1417           movem.l (sp)+,d0/a0        * restore regs
00002022  4E75                    1418           rts
00002024                          1419  *
00002024                          1420  * transmit the content of d0 register
00002024                          1421  TxRegD0:
00002024  48E7 6000               1422           movem.l d1/d2,-(sp)        * save
00002028  343C 0003               1423           move.w #3,d2
0000202C                          1424  txregd01:
0000202C  E198                    1425           rol.l #8,d0                * do the MSB first
0000202E  2200                    1426           move.l d0,d1               * save a copy
00002030  6100 FF5A               1427           bsr hex2asc
00002034  E058                    1428           ror.w #8,d0                * print the high nibble of byte first
00002036  6100 0012               1429           bsr txregd0q                        
0000203A  6100 000E               1430           bsr txregd0q
0000203E  2001                    1431           move.l d1,d0
00002040  51CA FFEA               1432           dbra d2,txregd01
00002044  4CDF 0006               1433           movem.l (sp)+,d1/d2        * restore
00002048  4E75                    1434           rts
0000204A                          1435  txregd0q:
0000204A  0839 0002 00FFF003      1436           btst.b #2,SRA              * look for transmit ready
00002052  67F6                    1437           beq txregd0q
00002054  13C0 00FFF007           1438           move.b d0,THRA
0000205A  E058                    1439           ror.w #8,d0
0000205C  4E75                    1440           rts
0000205E                          1441  * form the answer in buffer
0000205E                          1442  * d0 is the value, d1 is the address
0000205E                          1443  * 3/29/17 change to 32-bit address field
0000205E                          1444  compuAnswer:
0000205E  48E7 6000               1445           movem.l d1/d2,-(sp)        * save 
00002062  3400                    1446           move.w d0,d2               * save a copy of d0
00002064  6100 FF26               1447           bsr hex2asc
00002068  13C0 00FF006A           1448           move.b d0,bAnswer+14       
0000206E  E048                    1449           lsr.w #8,d0                * get the middle-lowerbyte
00002070  13C0 00FF0069           1450           move.b d0,bAnswer+13       * get the LSB byte
00002076  3002                    1451           move.w d2,d0
00002078  E048                    1452           lsr.w #8,d0
0000207A  6100 FF10               1453           bsr hex2asc
0000207E  13C0 00FF0068           1454           move.b d0,bAnswer+12       * do the MSB byte
00002084  E048                    1455           lsr.w #8,d0
00002086  13C0 00FF0067           1456           move.b d0,bAnswer+11
0000208C  1001                    1457           move.b d1,d0               * do the address value
0000208E  6100 FEFC               1458           bsr hex2asc
00002092  33C0 00FF0064           1459           move.w d0,bAnswer+8        * LSB of address
00002098  E089                    1460           lsr.l #8,d1
0000209A  1001                    1461           move.b d1,d0
0000209C  6100 FEEE               1462           bsr hex2asc
000020A0  33C0 00FF0062           1463           move.w d0,bAnswer+6        * middle lower byte of address
000020A6  E089                    1464           lsr.l #8,d1
000020A8  1001                    1465           move.b d1,d0
000020AA  6100 FEE0               1466           bsr hex2asc
000020AE  33C0 00FF0060           1467           move.w d0,bAnswer+4        * MUB of address
000020B4  E089                    1468           lsr.l #8,d1
000020B6  1001                    1469           move.b d1,d0
000020B8  6100 FED2               1470           bsr hex2asc
000020BC  33C0 00FF005E           1471           move.w d0,bAnswer+2        * MSB of address (32-bit address)
000020C2  4CDF 0006               1472           movem.l (sp)+,d1/d2        * restore
000020C6  4E75                    1473           rts
000020C8                          1474  *@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
000020C8                          1475  * unexpected exception
000020C8                          1476  * stay here and output values on 7-segment display 
000020C8                          1477  **************  save this for later **********888
000020C8                          1478  unknown:
000020C8  5279 00FF0054           1479           add.w #1,cUErr
000020CE  48F9 FFFF 00FF0010      1480           movem.l d0-d7/a0-a7,savd0  * save away registers
000020D6  23EF 0002 00FF0050      1481           move.l $2(sp),savpc
000020DE                          1482  unknown3:
000020DE  203C 00012CC8           1483           move.l #77000,d0  * 100ms of spin
000020E4                          1484  unknown1:
000020E4  5380                    1485           sub.l #1,d0
000020E6  66FC                    1486           bne unknown1
000020E8  203C 00025990           1487           move.l #154000,d0 * 200ms of red
000020EE                          1488  unknown2:
000020EE  5380                    1489           sub.l #1,d0
000020F0  66FC                    1490           bne unknown2
000020F2  60EA                    1491           bra unknown3               * never exit here
000020F4                          1492  *
000020F4                          1493  * address error
000020F4                          1494  * stay here and blink light red/green at 1/5 second rate
000020F4                          1495  addrerr:
000020F4  0679 0100 00FF0054      1496           add.w #$100,cUErr
000020FC  48F9 FFFF 00FF0010      1497           movem.l d0-d7/a0-a7,savd0  * save away registers
00002104  23EF 000A 00FF0050      1498           move.l $A(sp),savpc
0000210C                          1499  
0000210C  41FA F0BE               1500           lea addrerrmsg(pc),a0
00002110  6100 FEE6               1501           bsr TxStringA0
00002114  202F 0002               1502           move.l 2(sp),d0            * print the access address
00002118  6100 FF0A               1503           bsr TxRegD0
0000211C  41FA F097               1504           lea pcmsg(pc),a0           * print program counter
00002120  6100 FED6               1505           bsr TxStringA0
00002124  202F 000A               1506           move.l $a(sp),d0
00002128  6100 FEFA               1507           bsr TxRegD0
0000212C  609A                    1508           bra unknown                * blink lights forever
0000212E                          1509  *
0000212E                          1510  * Use illegal instruction as breakpoint.  original instruction is stored in bkptinstr
0000212E                          1511  * 
0000212E                          1512  breakpt:
0000212E  48F9 FFFF 00FF0010      1513           movem.l d0-d7/a0-a7,savd0  * save all registers
00002136  202F 0002               1514           move.l 2(sp),d0            * get the breakpoint address
0000213A  B0B9 00FF00B8           1515           cmp.l bkptaddr,d0 * if equal, this is the user specified breakpoint
00002140  6600 0140               1516           bne breakpt8
00002144  43FA FAF2               1517           lea bkptmsg(pc),a1         * print breakpoint message
00002148  41F9 00FF00B8           1518           lea bkptaddr,a0            * breakpoint location
0000214E  6100 E808               1519           bsr do_dr_reg
00002152  4A39 00FF00B7           1520           tst.b fbpverbose  * if verbose flag is set, display all registers
00002158  6600 0018               1521           bne breakpt1
0000215C  48E7 8040               1522          movem.l d0/a1,-(sp)         * save registers used in trap 15 call
00002160  43FA FA99               1523          lea bppromptnc(pc),a1          * sign on message
00002164  103C 000E               1524          move.b #14,d0               * send message without CR LF
00002168  4E4F                    1525          trap #15
0000216A  4CDF 0201               1526          movem.l (sp)+,d0/a1         * restore registers        
0000216E  6000 0018               1527           bra breakpt2
00002172                          1528  breakpt1:         
00002172  6100 0210               1529           bsr displayall
00002176  48E7 8040               1530          movem.l d0/a1,-(sp)         * save registers used in trap 15 call
0000217A  43FA FA70               1531          lea bpprompt(pc),a1          * sign on message
0000217E  103C 000E               1532          move.b #14,d0               * send message without CR LF
00002182  4E4F                    1533          trap #15
00002184  4CDF 0201               1534          movem.l (sp)+,d0/a1         * restore registers
00002188                          1535  breakpt2:
00002188  206F 0002               1536           move.l 2(sp),a0
0000218C  30B9 00FF00BC           1537           move.w bkptinstr,(a0)      * restore original instruction
00002192  42B9 00FF00B8           1538           clr.l bkptaddr             * remove breakpoint
00002198  13FC 0001 00FF00BE      1539           move.b #1,fdobkpt
000021A0  6100 EF54               1540          bsr enableNextCmd          * initialize for new command
000021A4                          1541  bpcmdloop:
000021A4  6100 EF68               1542           bsr wUserInput             * wait for user input      
000021A8  0C39 0000 00FF008C      1543           cmp.b #0,cCmd              * if a carriage return, do one trace instruction
000021B0  6700 0078               1544           beq do_crlf
000021B4  0C39 0002 00FF008C      1545           cmp.b #2,cCmd              * need at least 2 char in command line before
000021BC                          1546                                      * a valid CR
000021BC  6500 003C               1547           blo badbpcmd
000021C0  41FA 014E               1548           lea bpmnemonictbl(pc),a0   * point to command mnemonic
000021C4  43FA 0126               1549           lea bpcommands(pc),a1      * the corresponding command entry point
000021C8  3039 00FF0074           1550           move.w bCmdline,d0         * current command
000021CE                          1551  parsebpcmd:
000021CE  B058                    1552           cmp.w (a0)+,d0             * look for command
000021D0  6700 000E               1553           beq bpcmdproc
000021D4  5889                    1554           add.l #4,a1                * bump to next command
000021D6  0C50 0000               1555           cmp.w #0,(a0)              * end of mnemonic table?
000021DA  6700 001E               1556           beq badbpcmd
000021DE  60EE                    1557           bra parsebpcmd
000021E0                          1558  bpcmdproc:
000021E0  6100 E552               1559           bsr cmdreformat
000021E4  6100 EF10               1560          bsr enableNextCmd          * initialize for new command
000021E8  4A80                    1561           tst.l d0
000021EA  6600 000E               1562           bne badbpcmd
000021EE  2251                    1563           move.l (a1),a1             * get the actual subroutine address in a1
000021F0                          1564  exec_bpcmd:
000021F0  4EBB 90FE               1565           jsr *(pc,a1)               * PC relative jsr
000021F4  4A40                    1566           tst.w d0                   * test result to chose the right prompt
000021F6  6700 0018               1567           beq nobpcmd
000021FA                          1568  badbpcmd:
000021FA  48E7 8040               1569          movem.l d0/a1,-(sp)         * save registers used in trap 15 call
000021FE  43FA F9F3               1570          lea bpqprompt(pc),a1          * sign on message
00002202  103C 000E               1571          move.b #14,d0               * send message without CR LF
00002206  4E4F                    1572          trap #15
00002208  4CDF 0201               1573          movem.l (sp)+,d0/a1         * restore registers        
0000220C  6000 0014               1574           bra nobpcmd9
00002210                          1575  nobpcmd:
00002210  48E7 8040               1576          movem.l d0/a1,-(sp)         * save registers used in trap 15 call
00002214  43F8 1BEC               1577          lea bpprompt,a1             * sign on message
00002218  103C 000E               1578          move.b #14,d0               * send message without CR LF
0000221C  4E4F                    1579          trap #15
0000221E  4CDF 0201               1580          movem.l (sp)+,d0/a1         * restore registers
00002222                          1581  nobpcmd9:
00002222  6100 EED2               1582          bsr enableNextCmd           * initialize for new command
00002226  6000 FF7C               1583           bra bpcmdloop
0000222A                          1584  do_crlf:                            * carriage return trace one instruction
0000222A  4279 00FF00C0           1585           clr.w cTrace
00002230  3017                    1586           move.w (sp),d0             * locate the status register of breakpoint exception
00002232  C07C 3FFF               1587           and.w #$3FFF,d0            * enable trace
00002236  807C 8000               1588           or.w #$8000,d0
0000223A  3E80                    1589           move.w d0,(sp)
0000223C  6000 009A               1590           bra breakpt9
00002240                          1591  do_tr:
00002240  4279 00FF00C0           1592           clr.w cTrace               * clear the trace count for now
00002246  0C39 0001 00FF008E      1593           cmp.b #1,cCmdparam         * expect one parameters
0000224E  6200 002E               1594           bhi do_tr8
00002252  0C39 0000 00FF008E      1595           cmp.b #0,cCmdparam         * if no parameter, do trace once
0000225A  6700 000C               1596           beq do_tr4
0000225E  33F9 00FF0092 00FF00C0  1597           move.w cmdparam+2,cTrace   * trace loop count         
00002268                          1598  do_tr4:
00002268  302F 0004               1599           move.w 4(sp),d0            * locate the status register for breakpoint
0000226C  C07C 3FFF               1600           and.w #$3FFF,d0            * trace every instruction
00002270  807C 8000               1601           or.w #$8000,d0
00002274  3F40 0004               1602           move.w d0,4(sp)
00002278  588F                    1603           add.l #4,sp                * adjust stack, not returning back to subroutine
0000227A  6000 005C               1604           bra breakpt9               * exit breapoint exception with specified trace bits
0000227E                          1605  do_tr8:
0000227E  7001                    1606           move.l #1,d0               * return to BP session with error prompt
00002280  4E75                    1607           rts
00002282                          1608  breakpt8:         
00002282  41FA EF16               1609           lea illegalmsg(pc),a0
00002286  6100 FD70               1610           bsr TxStringA0
0000228A  202F 0002               1611           move.l 2(sp),d0
0000228E  6100 FD94               1612           bsr TxRegD0
00002292  6100 E688               1613           bsr do_dr1                 * display all registers
00002296  6000 FE30               1614           bra unknown
0000229A                          1615  do_goto:
0000229A  0C39 0000 00FF008E      1616           cmp.b #0,cCmdparam         * expect zero or one parameter
000022A2  6700 0026               1617           beq do_gt2
000022A6  0C39 0001 00FF008E      1618           cmp.b #1,cCmdparam
000022AE  66CE                    1619           bne do_tr8                 * same error handling as in trace parameter handling
000022B0  23F9 00FF0090 00FF00B8  1620           move.l cmdparam,bkptaddr   * save to bkpt address
000022BA  2079 00FF0090           1621           move.l cmdparam,a0
000022C0  33D0 00FF00BC           1622           move.w (a0),bkptinstr      * save the instruction
000022C6  30BC 48FC               1623           move.w #$48FC,(a0)         * insert illegal instruction to specified location
000022CA                          1624  do_gt2:
000022CA  302F 0004               1625           move.w 4(sp),d0            * locate the status register for breakpoint
000022CE  C07C 3FFF               1626           and.w #$3FFF,d0            * turn trace bits to zero
000022D2  3F40 0004               1627           move.w d0,4(sp)            * put it back
000022D6  588F                    1628           add.l #4,sp                * adjust stack, not returning back to subroutine
000022D8                          1629  breakpt9:
000022D8  6100 EE1C               1630          bsr enableNextCmd          * initialize for new command
000022DC  4239 00FF00BE           1631           clr.b fdobkpt              * clear the breakpoint in progress flag
000022E2  4CF9 FFFF 00FF0010      1632           movem.l savd0,d0-d7/a0-a7  * restore registers        
000022EA  4E73                    1633           rte      
000022EC                          1634  
000022EC                          1635  * BP command dispatch tables
000022EC                          1636  bpcommands:
000022EC= FFFFE5E0                1637           dc.l do_dm-exec_bpcmd               * display memory
000022F0= FFFFE67A                1638           dc.l do_bp_dr-exec_bpcmd   * display register
000022F4= FFFFE792                1639           dc.l do_mm-exec_bpcmd               * modify memory
000022F8= FFFFE860                1640           dc.l do_bp_mr-exec_bpcmd   * modify register
000022FC= 000000AA                1641           dc.l do_goto-exec_bpcmd    * go till next breakpoint
00002300= FFFFEAAE                1642           dc.l do_bp-exec_bpcmd               * breakpoint
00002304= 00000050                1643           dc.l do_tr-exec_bpcmd               * trace
00002308= 00000134                1644           dc.l do_vb-exec_bpcmd               * verbose flag
0000230C= 00000178                1645           dc.l do_bphelp-exec_bpcmd  * help message             
00002310                          1646  * corresponding mnemonic for the breakpoint command table
00002310                          1647  bpmnemonictbl:
00002310= 646D                    1648           dc.w 'dm'
00002312= 6472                    1649           dc.w 'dr'
00002314= 6D6D                    1650           dc.w 'mm'
00002316= 6D72                    1651           dc.w 'mr'
00002318= 6774                    1652           dc.w 'gt'
0000231A= 6270                    1653           dc.w 'bp'
0000231C= 7472                    1654           dc.w 'tr'
0000231E= 7662                    1655           dc.w 'vb'
00002320= 6865                    1656           dc.w 'he'
00002322= 0000                    1657           dc.w $0  
00002324                          1658  
00002324                          1659  ***********************BP commands***************************
00002324                          1660  do_vb:
00002324                          1661  * toggle the verbose mode, whatever additional parameters are ignored
00002324  4A39 00FF00B7           1662           tst.b fbpverbose
0000232A  6600 0018               1663           bne do_vb2
0000232E  43FA F969               1664           lea verbosemsg(pc),a1          * sign on message
00002332  103C 000E               1665          move.b #14,d0               * send message without CR LF
00002336  4E4F                    1666          trap #15  
00002338  13FC 0001 00FF00B7      1667           move.b #1,fbpverbose       * verbose mode is On
00002340  6000 0014               1668           bra do_vb9
00002344                          1669  do_vb2:
00002344  13FC 0000 00FF00B7      1670           move.b #0,fbpverbose       * verbose mode is off
0000234C  43FA F960               1671          lea simplemsg(pc),a1          * sign on message
00002350  103C 000E               1672          move.b #14,d0               * send message without CR LF
00002354  4E4F                    1673          trap #15  
00002356                          1674  do_vb9:  
00002356  4280                    1675           clr.l d0
00002358  4239 00FF00D3           1676           clr.b exitCode             ** normal exit
0000235E  13FC 0001 00FF008F      1677           move.b #1,fCmdDone         * flag the command is finished
00002366  4E75                    1678           rts
00002368                          1679  do_bphelp:
00002368  43FA F45B               1680          lea bphelpmsg(pc),a1          * sign on message
0000236C  103C 000E               1681          move.b #14,d0               * send message without CR LF
00002370  4E4F                    1682          trap #15
00002372  4280                    1683           clr.l d0
00002374  4239 00FF00D3           1684           clr.b exitCode             ** normal exit
0000237A  13FC 0001 00FF008F      1685           move.b #1,fCmdDone         * flag the command is finished      
00002382  4E75                    1686           rts
00002384                          1687  displayall:
00002384  43FA FA6E               1688           lea regD0short(pc),a1
00002388  41F9 00FF0010           1689           lea savd0,a0
0000238E  6100 E5C8               1690           bsr do_dr_reg
00002392  43FA FA67               1691           lea regD1short(pc),a1
00002396  41F9 00FF0014           1692           lea savd1,a0
0000239C  6100 E5BA               1693           bsr do_dr_reg
000023A0  43FA FA60               1694           lea regD2short(pc),a1
000023A4  41F9 00FF0018           1695           lea savd2,a0
000023AA  6100 E5AC               1696           bsr do_dr_reg
000023AE  43FA FA59               1697           lea regD3short(pc),a1
000023B2  41F9 00FF001C           1698           lea savd3,a0
000023B8  6100 E59E               1699           bsr do_dr_reg
000023BC  43FA FA52               1700           lea regD4short(pc),a1
000023C0  41F9 00FF0020           1701           lea savd4,a0
000023C6  6100 E590               1702           bsr do_dr_reg
000023CA  43FA FA4B               1703           lea regD5short(pc),a1
000023CE  41F9 00FF0024           1704           lea savd5,a0
000023D4  6100 E582               1705           bsr do_dr_reg     
000023D8  43FA FA44               1706           lea regD6short(pc),a1
000023DC  41F9 00FF0028           1707           lea savd6,a0
000023E2  6100 E574               1708           bsr do_dr_reg     
000023E6  43FA FA3D               1709           lea regD7short(pc),a1
000023EA  41F9 00FF002C           1710           lea savd7,a0
000023F0  6100 E566               1711           bsr do_dr_reg     
000023F4                          1712           
000023F4  43FA FA36               1713           lea regA0short(pc),a1
000023F8  41F9 00FF0030           1714           lea savA0,a0
000023FE  6100 E558               1715           bsr do_dr_reg
00002402  43FA FA2F               1716           lea regA1short(pc),a1
00002406  41F9 00FF0034           1717           lea savA1,a0
0000240C  6100 E54A               1718           bsr do_dr_reg
00002410  43FA FA28               1719           lea regA2short(pc),a1
00002414  41F9 00FF0038           1720           lea savA2,a0
0000241A  6100 E53C               1721           bsr do_dr_reg
0000241E  43FA FA21               1722           lea regA3short(pc),a1
00002422  41F9 00FF003C           1723           lea savA3,a0
00002428  6100 E52E               1724           bsr do_dr_reg
0000242C  43FA FA1A               1725           lea regA4short(pc),a1
00002430  41F9 00FF0040           1726           lea savA4,a0
00002436  6100 E520               1727           bsr do_dr_reg
0000243A  43FA FA13               1728           lea regA5short(pc),a1
0000243E  41F9 00FF0044           1729           lea savA5,a0
00002444  6100 E512               1730           bsr do_dr_reg     
00002448  43FA FA0C               1731           lea regA6short(pc),a1
0000244C  41F9 00FF0048           1732           lea savA6,a0
00002452  6100 E504               1733           bsr do_dr_reg     
00002456  43FA FA05               1734           lea regA7short(pc),a1
0000245A  41F9 00FF004C           1735           lea savsp,a0
00002460  6100 E4F6               1736           bsr do_dr_reg
00002464  4E75                    1737           rts
00002466                          1738           
00002466                          1739  *
00002466                          1740  * trace exception handling
00002466                          1741  * display PC, status, and instruction
00002466                          1742  trace:
00002466  48F9 FFFF 00FF0010      1743           movem.l d0-d7/a0-a7,savd0  * save all registers
0000246E  6100 EC86               1744           bsr enableNextCmd          * initialize for new command
00002472                          1745  trace1:
00002472  41FA F7F2               1746           lea tracemsg(pc),a0
00002476  6100 FB80               1747           bsr TxStringA0             * send out trace message
0000247A  206F 0002               1748           move.l 2(sp),a0            * get program counter of instruction
0000247E  2010                    1749           move.l (a0),d0             * get the instruction being traced
00002480  6100 FBA2               1750           bsr TxRegD0
00002484  41FA F7F8               1751           lea tracepcmsg(pc),a0
00002488  6100 FB6E               1752           bsr TxStringA0             * next line of trace message
0000248C  202F 0002               1753           move.l 2(sp),d0
00002490  6100 FB92               1754           bsr TxRegD0                * print pc value
00002494  41FA F7F2               1755           lea tracestmsg(pc),a0
00002498  6100 FB5E               1756           bsr TxStringA0
0000249C  4280                    1757           clr.l d0
0000249E  3017                    1758           move.w (sp),d0
000024A0  6100 FB82               1759           bsr TxRegD0
000024A4  5379 00FF00C0           1760           sub.w #1,cTrace            * decrement trace loop count
000024AA                          1761                                      * if zero, no more trace, insert breakpoint for next instruction
000024AA  6E00 0024               1762           bgt trace7
000024AE                          1763  trace5:
000024AE  3017                    1764           move.w (sp),d0
000024B0  C07C 3FFF               1765           and.w #$3FFF,d0            * remove trace
000024B4  3E80                    1766           move.w d0,(sp)             * put back status word
000024B6  206F 0002               1767           move.l 2(sp),a0            * breakpoint for next instruction
000024BA  33D0 00FF00BC           1768           move.w (a0),bkptinstr      * save original instruction
000024C0  30BC 48FC               1769           move.w #$48FC,(a0)         * illegal instruction
000024C4  23EF 0002 00FF00B8      1770           move.l 2(sp),bkptaddr      * save away breakpoint address
000024CC  6000 0010               1771           bra trace9
000024D0                          1772  trace7:
000024D0  4A39 00FF00B7           1773           tst.b fbpverbose
000024D6  6700 0006               1774           beq trace9
000024DA  6100 FEA8               1775           bsr displayall
000024DE                          1776  trace9:
000024DE  4CF9 FFFF 00FF0010      1777           movem.l savd0,d0-d7/a0-a7
000024E6  4E73                    1778           rte
000024E8                          1779           
000024E8                          1780  ************ EASy68K trap routines *********************         
000024E8                          1781  EASyTrapTbl:      
000024E8                          1782  ***** Text I/O *****
000024E8  6000 00E2               1783           bra.w EASy0
000024EC  6000 00DE               1784           bra.w EASy1
000024F0  6000 00A6               1785           bra.w EASy2
000024F4  6000 00A2               1786           bra.w EASy3
000024F8  6000 009E               1787           bra.w EASy4
000024FC  6000 0118               1788           bra.w EASy5
00002500  6000 0130               1789           bra.w EASy6
00002504  6000 0148               1790           bra.w EASy7
00002508  6000 015A               1791           bra.w EASy8
0000250C  6000 008A               1792           bra.w EASy9
00002510  6000 0086               1793           bra.w EASy10
00002514  6000 0082               1794           bra.w EASy11
00002518  6000 0152               1795           bra.w EASy12
0000251C  6000 0156               1796           bra.w EASy13
00002520  6000 0152               1797           bra.w EASy14
00002524  6000 0072               1798           bra.w EASy15
00002528  6000 006E               1799           bra.w EASy16
0000252C  6000 006A               1800           bra.w EASy17
00002530  6000 0066               1801           bra.w EASy18
00002534  6000 0062               1802           bra.w EASy19
00002538  6000 005E               1803           bra.w EASy20
0000253C  6000 005A               1804           bra.w EASy21
00002540  6000 0056               1805           bra.w EASy22
00002544  6000 0052               1806           bra.w EASy23
00002548  6000 004E               1807           bra.w EASy24
0000254C  6000 004A               1808           bra.w EASy25
00002550  6000 0162               1809           bra.w EASy32               * hardware display service
00002554  6000 0042               1810           bra.w EASy80
00002558  6000 003E               1811          bra.w EASy81
0000255C  6000 003A               1812          bra.w EASy82
00002560  6000 0036               1813          bra.w EASy83
00002564  6000 0032               1814          bra.w EASy84
00002568  6000 002E               1815          bra.w EASy85
0000256C  6000 002A               1816          bra.w EASy86
00002570  6000 0026               1817          bra.w EASy87
00002574  6000 0022               1818          bra.w EASy88
00002578  6000 001E               1819          bra.w EASy89
0000257C  6000 001A               1820          bra.w EASy90
00002580  6000 0016               1821          bra.w EASy91
00002584  6000 0012               1822          bra.w EASy92
00002588  6000 000E               1823          bra.w EASy93
0000258C  6000 000A               1824          bra.w EASy94
00002590  6000 0006               1825          bra.w EASy95
00002594  6000 0002               1826          bra.w EASy96
00002598                          1827  
00002598                          1828  ******* Graphic ****
00002598                          1829           
00002598                          1830  * not yet implemented trap
00002598                          1831  EASy2:
00002598                          1832  EASy3:
00002598                          1833  EASy4:
00002598                          1834  EASy9:
00002598                          1835  EASy10:
00002598                          1836  EASy11:
00002598                          1837  EASy15:
00002598                          1838  EASy16:
00002598                          1839  EASy17:
00002598                          1840  EASy18:
00002598                          1841  EASy19:
00002598                          1842  EASy20:
00002598                          1843  EASy21:
00002598                          1844  EASy22:
00002598                          1845  EASy23:
00002598                          1846  EASy24:
00002598                          1847  EASy25:
00002598                          1848  EASy80:
00002598                          1849  EASy81:
00002598                          1850  EASy82:
00002598                          1851  EASy83:
00002598                          1852  EASy84:
00002598                          1853  EASy85:
00002598                          1854  EASy86:
00002598                          1855  EASy87:
00002598                          1856  EASy88:
00002598                          1857  EASy89:
00002598                          1858  EASy90:
00002598                          1859  EASy91:
00002598                          1860  EASy92:
00002598                          1861  EASy93:
00002598                          1862  EASy94:
00002598                          1863  EASy95:
00002598                          1864  EASy96:
00002598  4E75                    1865           rts
0000259A                          1866  
0000259A                          1867  EASyTrap:
0000259A                          1868  * EASy68K trap services
0000259A                          1869   
0000259A  48E7 9010               1870           movem.l a3/d0/d3,-(sp)     * save registers
0000259E  47FA FF48               1871          lea EASyTrapTbl(pc),a3      * a position independ table of trap routines
000025A2  B03C 0019               1872          cmp.b #25,d0                * modify index if taks # is greater than 25
000025A6  6F00 0014               1873          ble calcEASyTask
000025AA  B03C 0020               1874           cmp.b #32,d0               * modify index if task # is 32
000025AE  6F00 000A               1875           ble calcEASyTask32
000025B2  0400 0036               1876          sub.b #54,d0                * modified index for task #80 and up
000025B6  6000 0004               1877           bra calcEASyTask
000025BA                          1878  calcEASyTask32:
000025BA  5D00                    1879           sub.b #6,d0
000025BC                          1880  calcEASyTask:
000025BC  4283                    1881           clr.l d3                   * setup to index into the trap service table
000025BE  1600                    1882           move.b d0,d3               * d0 contains the index value
000025C0  E58B                    1883           lsl.l #2,d3                * compute long word offset
000025C2  4EB3 3000               1884           jsr (a3,d3)                * jsr into array of trap routines        
000025C6                          1885  EASyT15z: 
000025C6  4CDF 0809               1886           movem.l (sp)+,a3/d0/d3 * restore register
000025CA  4E73                    1887           rte      
000025CC                          1888  EASy0:
000025CC                          1889  EASy1:
000025CC                          1890  * Task 0: Display n characters of string at (A1), n is D1.W (stops on NULL or max 255) 
000025CC                          1891  *   with CR, LF. 
000025CC                          1892  * Task 1: Display n characters of string at (A1), n is D1.W (stops on NULL or max 255) 
000025CC                          1893  *   without CR, LF. 
000025CC                          1894  * if transmitter is unavailable, wait until it is available
000025CC  0C39 0000 00FF00B6      1895           cmp.b #True,fTxDone        * wait for string transmission done before proceeding
000025D4  66F6                    1896           bne EASy1                  * possible OS swap task here
000025D6  23C9 00FF0058           1897           move.l a1,pStr             * pStr points to the string
000025DC  C27C 00FF               1898           and.w #$ff,d1              * maximum of 255 character to transmit
000025E0  33C1 00FF00D0           1899           move.w d1,cTxChar          * number of character to transmit
000025E6  13FC 0001 00FF00B6      1900           move.b #False,fTxDone      * start transmission
000025EE  4239 00FF00D7           1901           clr.b fEASyTCRLF           * assume it is task 1 (no CR LF)
000025F4  B03C 0001               1902           cmp.b #1,d0               
000025F8  6700 000A               1903          beq EASy0z                  * if task 1, don't change CR/LF flag
000025FC  13FC 0001 00FF00D7      1904          move.b #1,fEASyTCRLF        * task 0, add carriage, line feed to the end of message        
00002604                          1905  EASy0z:
00002604  13FC 0001 00FF00D2      1906           move.b #1,fTxChar          * enable transmit in DUART ISR
0000260C  13FC 000B 00FFF00B      1907           move.b #$B,IMRD            * enable Chan A TxRDY/RxRdy interrupts
00002614  4E75                    1908           rts
00002616                          1909  EASy5:   
00002616                          1910  * Read single ASCII character from the keyboard into D1.B
00002616  0839 0000 00FFF003      1911           btst.b #0,SRA              * Does receiver has a char input
0000261E  67F6                    1912           beq EASy5                  * wait until it has an input
00002620  1239 00FFF007           1913           move.b RHRA,d1             * get character into d1.b
00002626  4A39 00FF00D6           1914           tst.b fEASyTEcho
0000262C  6600 0004               1915           bne EASy6                  * echo back char for T15Echo != 0   
00002630  4E75                    1916           rts                                     
00002632                          1917  EASy6:   
00002632                          1918  * Display single ASCII character in D1.B.
00002632  0C39 0000 00FF00B6      1919           cmp.b #True,fTxDone        * wait for previous string transmission done
0000263A  66F6                    1920           bne EASy6
0000263C  0839 0002 00FFF003      1921           btst.b #2,SRA              * look for transmit ready
00002644  67EC                    1922           beq EASy6                                 
00002646  13C1 00FFF007           1923           move.b d1,THRA             * put char in d1.b out to serial port    
0000264C  4E75                    1924           rts
0000264E                          1925  EASy7:
0000264E                          1926  * Check for keyboard input. Set D1.B to 1 if keyboard input is pending, otherwise set to 0.
0000264E                          1927  * Use task 2 or 5 to read pending key.
0000264E  123C 0000               1928          move.b #0,d1       * assume there is no char input
00002652  0839 0000 00FFF003      1929          btst.b #0,SRA      * Does receiver has a char input?
0000265A  6700 0006               1930          beq EASy7z
0000265E  123C 0001               1931          move.b #1,d1       * A char input is ready
00002662                          1932  EASy7z:
00002662  4E75                    1933          rts
00002664                          1934  
00002664                          1935  EASy8:
00002664                          1936  * Return time in hundredths of a second since midnight in D1.L. 
00002664  2239 00FF0004           1937           move.l wallclock,d1        * wallclock is increment every 10ms
0000266A  4E75                    1938           rts
0000266C                          1939  EASy12:  
0000266C                          1940  * Keyboard Echo. 
0000266C                          1941  * D1.B = 0 to turn off keyboard echo. 
0000266C                          1942  * D1.B = non zero to enable. (default). 
0000266C                          1943  * Echo is restored on 'Reset' or when a new file is loaded
0000266C  13C1 00FF00D6           1944           move.b d1,fEASyTEcho       * store echo value
00002672  4E75                    1945          rts
00002674                          1946  EASy13:
00002674                          1947  EASy14:
00002674                          1948  * task 13: Display the NULL terminated string at (A1) with CR, LF.
00002674                          1949  * task 14: Display the NULL terminated string at (A1) without CR, LF.
00002674                          1950  * send null terminated string pointed by A1 to console.  No CR, LF added
00002674                          1951  * if transmitter is unavailable, wait until it is available
00002674  0C39 0000 00FF00B6      1952           cmp.b #True,fTxDone        * wait for string transmission done before proceeding
0000267C  66F6                    1953           bne EASy14                 * possible OS swap task here
0000267E  23C9 00FF0058           1954           move.l a1,pStr             * pStr points to null-terminated message
00002684  13FC 0001 00FF00B6      1955           move.b #False,fTxDone      * start transmission
0000268C  4239 00FF00D7           1956           clr.b fEASyTCRLF           * assume it is task 14 (no CR LF)
00002692  B03C 000E               1957           cmp.b #14,d0               
00002696  6700 000A               1958          beq EASy14z                 * if task 14, don't change CR/LF flag
0000269A  13FC 0001 00FF00D7      1959          move.b #1,fEASyTCRLF       * task 13, add carriage, line feed to the end of message        
000026A2                          1960  EASy14z:
000026A2  13FC 0001 00FF00D2      1961           move.b #1,fTxChar          * enable transmit in DUART ISR
000026AA  13FC 000B 00FFF00B      1962           move.b #$B,IMRD            * enable Chan A TxRDY/RxRdy interrupts
000026B2  4E75                    1963           rts
000026B4                          1964  EASy32:
000026B4                          1965  * 7-segment display service, ignore subtask 0 (hardware display), 5 (enable exception)
000026B4                          1966  * 6 (set auto IRA).
000026B4  B23C 0001               1967           cmp.b #1,d1                * address of 7-seg display
000026B8  6700 0026               1968           beq EASy32a
000026BC  B23C 0002               1969           cmp.b #2,d1                * address of LEDs
000026C0  6700 0028               1970           beq EASy32b
000026C4  B23C 0003               1971           cmp.b #3,d1                * address of toggle switches
000026C8  6700 0026               1972           beq EASy32c
000026CC  B23C 0004               1973           cmp.b #4,d1                * SIM68K version number
000026D0  6700 0024               1974           beq EASy32d
000026D4  B23C 0007               1975           cmp.b #7,d1                * address of push buttons
000026D8  6700 0022               1976           beq EASy32g
000026DC  6000 0020               1977           bra EASy32z
000026E0                          1978  EASy32a:
000026E0  223C 00FF00AA           1979           move.l #corner7seg,d1      * base address of 7-seg display
000026E6  6000 0016               1980           bra EASy32z
000026EA                          1981  EASy32b:
000026EA  7200                    1982           move.l #0,d1      * address of LEDs, none for now
000026EC  6000 0010               1983           bra EASy32z
000026F0                          1984  EASy32c:
000026F0  7200                    1985           move.l #0,d1      * address of toggle switches, none for now
000026F2  6000 000A               1986           bra EASy32z
000026F6                          1987  EASy32d:
000026F6  7201                    1988           move.l #$1,d1              * version number of the trap service
000026F8  6000 0004               1989           bra EASy32z
000026FC                          1990  EASy32g:
000026FC  7200                    1991           move.l #0,d1      * address of push buttons, none for now      
000026FE                          1992  EASy32z:
000026FE  4E75                    1993           rts
00002700                          1994  ************ EASy68K trap routines *********************       
00002700                          1995  
00002700                          1996  *
00002700                          1997  * interrupt service for TxRdyA
00002700                          1998  * look for timer interrupt first
00002700                          1999  * look at receive data first and process if needed and shut off background transmit
00002700                          2000  * then look at transmit data.  If in the middle of transmitting, keep on transmitting
00002700                          2001  * send next byte as pointed by a2.  When zero is encountered, shut off the transmitter
00002700                          2002  DUARTisr:
00002700  48E7 F8E0               2003           movem.l d0-d4/a0-a2,-(sp)  * save
00002704  0839 0003 00FFF00B      2004           btst.b #3,ISRD             * look for timer interrupt set first
0000270C  6700 0044               2005           beq rcvrA
00002710  52B9 00FF0004           2006           add.l #1,wallclock         * increment the wallclock, 1 tick equals 10ms
00002716  4A79 00FF0008           2007           tst.w downtimer1           * if downtimer is not zero, decrement it
0000271C  6700 0008               2008           beq dntimer2
00002720  5379 00FF0008           2009           sub.w #1,downtimer1
00002726                          2010  dntimer2:
00002726  4A79 00FF000A           2011           tst.w downtimer2  * check the 2nd downtimer, if not zero, decrement it
0000272C  6700 0008               2012           beq timerisr6
00002730  5379 00FF000A           2013           sub.w #1,downtimer2
00002736                          2014  timerisr6:
00002736  13FC 00FF 00FFF01D      2015           move.b #$ff,SETOPR         **HH clear the display
0000273E  1039 00FF00AA           2016           move.b corner7seg,d0       * get the value for the corner 7-seg display
00002744  E308                    2017           lsl.b #1,d0                * shift by one bit to conform to EASy68K format
00002746  13C0 00FFF01F           2018           move.b d0,CLROPR  * put value out to display
0000274C                          2019  timerisr9:
0000274C  1039 00FFF01F           2020           move.b STOPCTR,d0 * read clear the timer interrupt flag
00002752                          2021  rcvrA:   
00002752  0839 0000 00FFF003      2022           btst.b #0,SRA              * look at receiver next
0000275A  6700 0652               2023           beq chktx                  * if no char received, check char to send
0000275E  1639 00FFF007           2024           move.b RHRA,d3    * get character
00002764  4A39 00FF008C           2025           tst.b cCmd                 * if non zero, fill command buffer til CR
0000276A  6600 002A               2026           bne getcmdline
0000276E  B63C 0052               2027           cmp.b #'R',d3
00002772  6700 00FE               2028           beq dorwg
00002776  B63C 0057               2029           cmp.b #'W',d3
0000277A  6700 00F6               2030           beq dorwg
0000277E  B63C 0047               2031           cmp.b #'G',d3
00002782  6700 00EE               2032           beq dorwg
00002786  B63C 005A               2033           cmp.b #'Z',d3
0000278A  6700 023A               2034           beq doz
0000278E  B63C 0053               2035           cmp.b #'S',d3
00002792  6700 02CC               2036           beq doload1
00002796                          2037  getCmdline:
00002796  B63C 000D               2038           cmp.b #$d,d3               * CR terminates the command line
0000279A  6600 001E               2039           bne echo_rx                * if not CR, echo back the char entered in the command buffer
0000279E  13FC 0001 00FF008D      2040           move.b #1,fDoCmd           * make command ready to execute
000027A6  2079 00FF0088           2041           move.l pCmdln,a0
000027AC  0C28 0020 FFFF          2042           cmp.b #' ',-1(a0) * if trailing space, discard the space character
000027B2  6700 0034               2043           beq gobackone
000027B6  6000 0688               2044           bra edisr1
000027BA                          2045  echo_rx:
000027BA  0839 0002 00FFF003      2046           btst.b #2,SRA              * echo back 
000027C2  67F6                    2047           beq echo_rx
000027C4  B63C 0008               2048           cmp.b #8,d3                * backspace?
000027C8  6700 000C               2049           beq echo_rubout
000027CC  13C3 00FFF007           2050           move.b d3,THRA
000027D2  6000 0024               2051           bra chkextrasp
000027D6                          2052  echo_rubout
000027D6  13FC 0008 00FFF007      2053           move.b #$8,THRA   * try rubout character instead of 0x8, didn't work
000027DE  4A39 00FF008C           2054           tst.b cCmd                 * don't backspace past the first character
000027E4  6700 0068               2055           beq what_no_CR             * try this approach, no perfect either
000027E8                          2056  gobackone:
000027E8  53B9 00FF0088           2057           sub.l #1,pCmdln            * backspace, go back one character
000027EE  5339 00FF008C           2058           sub.b #1,cCmd
000027F4  6000 064A               2059           bra edisr1                 * get next character
000027F8                          2060  chkextrasp:
000027F8  2079 00FF0088           2061           move.l pCmdln,a0           * get pointer into command line buffer
000027FE  B63C 0020               2062           cmp.b #' ',d3              * if extra space, do not store
00002802  6600 000C               2063           bne fillcmdbuf
00002806  0C28 0020 FFFF          2064           cmp.b #' ',-1(a0)          * if previous is also space
0000280C  6700 0632               2065           beq edisr1
00002810                          2066  fillcmdbuf
00002810  1083                    2067           move.b d3,(a0)
00002812  52B9 00FF0088           2068           add.l #1,pCmdln            * bump up one character    
00002818  5239 00FF008C           2069           add.b #1,cCmd
0000281E  0C39 0014 00FF008C      2070           cmp.b #20,cCmd             * up to 20 characters. 
00002826  6600 0618               2071           bne edisr1
0000282A                          2072  what:
0000282A  487A E927               2073           pea qprompt(pc)            * push error prompt pointer into stack
0000282E  23DF 00FF0058           2074           move.l (sp)+,pStr          * pStr points to error prompt string
00002834  4239 00FF008D           2075           clr.b fDoCmd               * abort command ready
0000283A  4239 00FF008C           2076           clr.b cCmd                 * reset command line 
00002840  23FC 00FF0074 00FF0088  2077           move.l #bCmdline,pCmdln
0000284A  6000 0156               2078           bra txen
0000284E                          2079  what_no_CR:
0000284E  487A F39A               2080           pea q_no_cr(pc)            * put a single ? mark
00002852  23DF 00FF0058           2081           move.l (sp)+,pStr
00002858  4239 00FF008D           2082           clr.b fDoCmd               * abort command ready
0000285E  4239 00FF008C           2083           clr.b cCmd                 * reset command line 
00002864  23FC 00FF0074 00FF0088  2084           move.l #bCmdline,pCmdln
0000286E  6000 0132               2085           bra txen
00002872                          2086  dorwg:
00002872  0839 0002 00FFF003      2087           btst.b #2,SRA              * echo back character
0000287A  67F6                    2088           beq dorwg
0000287C  13C3 00FFF007           2089           move.b d3,THRA             * echo back 'r' or 'w', 'g'
00002882  4281                    2090           clr.l d1                   * d1 is the address pointer
00002884  4284                    2091           clr.l d4                   * d4 is modified value for write command
00002886  4239 00FF0056           2092           clr.b fWval                * existance of valid value for read/write cmd
0000288C                          2093  * handle read/write the same, but the 2nd parameter has different meaning:
0000288C                          2094  * for read, it indicates how many words to print
0000288C                          2095  * for write, it indicates the modified value
0000288C                          2096  * if 2nd parameter is not present, read the current address and write nothing
0000288C                          2097  sp_1st:
0000288C  0839 0000 00FFF003      2098           btst.b #0,SRA              * loop for the 1st space char after command
00002894  67F6                    2099           beq sp_1st
00002896  1039 00FFF007           2100           move.b RHRA,d0             
0000289C  B03C 0020               2101           cmp.b #' ',d0
000028A0  6600 003A               2102           bne dorwg5                 * valid inputs at this point are hex values
000028A4  6000 0054               2103           bra echo_chr               * echo back
000028A8                          2104  more_sp:
000028A8  4A39 00FF0056           2105           tst.b fWval
000028AE  6600 FF7A               2106           bne what          * if fWval already set and ' ' entered print ?>
000028B2  13FC 0001 00FF0056      2107           move.b #1,fWval            * mark write cmd with valid value
000028BA  6000 003E               2108           bra echo_chr               * echo back
000028BE                          2109  get_char:
000028BE  0839 0000 00FFF003      2110           btst.b #0,SRA              * look for character
000028C6  67F6                    2111           beq get_char
000028C8  1039 00FFF007           2112           move.b RHRA,d0             * check for valid characters
000028CE  B03C 0020               2113           cmp.b #' ',d0
000028D2  67D4                    2114           beq more_sp                * space is separator for read/write
000028D4  B03C 000D               2115           cmp.b #$d,d0
000028D8  6700 0038               2116           beq dorwg9                 * CR also marks the end of command
000028DC                          2117  dorwg5:
000028DC  1400                    2118           move.b d0,d2               * save a copy
000028DE  6100 F65E               2119           bsr asc2hex
000028E2  B03C 00FF               2120           cmp.b #$FF,d0              * valid hex?
000028E6  6700 FF42               2121           beq what          
000028EA  4A39 00FF0056           2122           tst.b fWval                * r address or w data?
000028F0  6600 001A               2123           bne dorwg6
000028F4  E989                    2124           lsl.l #4,d1                * shift existing value one nibble to left
000028F6  D200                    2125           add.b d0,d1                * append new address to existing one.
000028F8                          2126  dorwg7:
000028F8  1002                    2127           move.b d2,d0               * echo back       
000028FA                          2128  echo_chr:
000028FA  0839 0002 00FFF003      2129           btst.b #2,SRA
00002902  67F6                    2130           beq echo_chr
00002904  13C0 00FFF007           2131           move.b d0,THRA             * echo back typed char
0000290A  60B2                    2132           bra get_char               * get more data
0000290C                          2133  dorwg6:
0000290C  E98C                    2134           lsl.l #4,d4                * d4 contains the second parameter
0000290E  D800                    2135           add.b d0,d4
00002910  60E6                    2136           bra dorwg7
00002912                          2137  dorwg9:
00002912  C2BC 00FFFFFE           2138           and.l #$00FFFFFE,d1        * make sure it is even address and 24-bit addr
00002918  2041                    2139           move.l d1,a0
0000291A  B63C 0057               2140           cmp.b #'W',d3
0000291E  6700 0096               2141           beq dowrite
00002922  B63C 0047               2142           cmp.b #'G',d3
00002926  6700 0066               2143           beq dorunrun
0000292A  4A44                    2144           tst.w d4          * if d4 equals 0, do one line of display memory
0000292C  6700 0004               2145           beq dorwg8
00002930  5344                    2146           sub.w #1,d4                * for read cmd, print the number of words specified by d4
00002932                          2147  dorwg8:
00002932  3010                    2148           move.w (a0),d0             * read the specified memory location
00002934  6100 F728               2149           bsr compuAnswer            * forming the answer in buffer
00002938  23FC 00FF005C 00FF0058  2150           move.l #bAnswer,pStr       * send out the answer
00002942  B63C 0057               2151           cmp.b #'W',d3              * if write cmd, print the memory content outside of ISR
00002946  6700 005A               2152           beq txen          * if read cmd, print number of words specified by d4
0000294A  4A39 00FF0056           2153           tst.b fwval                * check valid 2nd parameter for read cmd
00002950  6700 0050               2154           beq txen          * if no 2nd parameter, print the memory content outside of ISR
00002954  45F9 00FF005C           2155           lea bAnswer,a2
0000295A  13FC 0000 00FF006B      2156           move.b #0,bAnswer+15       * modify the bAnswer message string so not to print prompt
00002962                          2157  dorwg8b:
00002962  0839 0002 00FFF003      2158           btst.b #2,SRA              * txRdy
0000296A  67F6                    2159           beq dorwg8b
0000296C  101A                    2160           move.b (a2)+,d0
0000296E  6700 000A               2161           beq dorwg8c
00002972  13C0 00FFF007           2162           move.b d0,THRA
00002978  60E8                    2163           bra dorwg8b       
0000297A                          2164  dorwg8c:
0000297A  5488                    2165           add.l #2,a0                * next memory content, a0 contains the address value
0000297C  2208                    2166           move.l a0,d1               * 
0000297E  51CC FFB2               2167           dbra d4,dorwg8             * else print memory content d4 times within ISR
00002982  13FC 000A 00FF006B      2168           move.b #$a,bAnswer+15      * replace the prompt back into bAnswer message string
0000298A  6000 000C               2169           bra txprompt               * put out a prompt
0000298E                          2170  dorunrun:
0000298E  4280                    2171           clr.l d0                   * status is passed back in d0
00002990  4E90                    2172           jsr (a0)                   * jump into whatever address user is entered
00002992  4A80                    2173           tst.l d0
00002994  6600 FE94               2174           bne what
00002998                          2175  txprompt:
00002998  41FA E7B4               2176           lea prompt(pc),a0          * relocatable code
0000299C  23C8 00FF0058           2177           move.l a0,pStr             * pStr points to prompt string
000029A2                          2178  txen:
000029A2  13FC 0001 00FF00D2      2179           move.b #1,fTxChar          * enable transmit in DUART ISR
000029AA  13FC 000B 00FFF00B      2180           move.b #$B,IMRD            * enable tx/rx interrupts, enable timer
000029B2  6000 048C               2181           bra edisr1                 
000029B6                          2182  dowrite:
000029B6  4A39 00FF0056           2183           tst.b fWval                * chk for valid write value
000029BC  6700 FF74               2184           beq dorwg8                 * don't write if invalid
000029C0  3084                    2185           move.w d4,(a0)             * write value out
000029C2  6000 FF6E               2186           bra dorwg8                 * read back value
000029C6                          2187  * clear memory
000029C6                          2188  doz:
000029C6  0839 0002 00FFF003      2189           btst.b #2,SRA              * echo back
000029CE  67F6                    2190           beq doz
000029D0  13C3 00FFF007           2191           move.b d3,THRA
000029D6                          2192  doz1:
000029D6  0839 0000 00FFF003      2193           btst.b #0,SRA              * read next char, must be $0d
000029DE  67F6                    2194           beq doz1
000029E0  1039 00FFF007           2195           move.b RHRA,d0
000029E6  B03C 000D               2196           cmp.b #$d,d0
000029EA  6600 FE3E               2197           bne what
000029EE  6100 F488               2198           bsr clrsavr
000029F2  41FA E765               2199           lea zmemmsg(pc),a0
000029F6  23C8 00FF0058           2200           move.l a0,pStr
000029FC  60A4                    2201           bra txen
000029FE                          2202  *
000029FE                          2203  * S record format as generated by qlink, ignore S0
000029FE                          2204  * only echo back '.' per S record. send prompt if OK, send qprompt if error
000029FE                          2205  * S1: byte count, 16 bit address, end with checksum 
000029FE                          2206  * a0 is address, d1 is data, store value as they are received
000029FE                          2207  * d2 is nibble count, d3 is srecord byte count, d4 is accumulated checksum
000029FE                          2208  doload:
000029FE  46FC 2700               2209           move.w #$2700,sr  * mask off all interrupt so vector table can be
00002A02                          2210                                      * modified without crashing the code
00002A02  0839 0000 00FFF003      2211           btst.b #0,SRA              * look for another 'S'
00002A0A  67F2                    2212           beq doload
00002A0C  1039 00FFF007           2213           move.b RHRA,d0
00002A12  B03C 000D               2214           cmp.b #$d,d0               * put out '.' when CR encountered
00002A16  6600 0042               2215           bne doload2
00002A1A  4A39 00FF0057           2216           tst.b fSerr                * if error, put out '?'
00002A20  6700 0026               2217           beq doload3
00002A24  4239 00FF0057           2218           clr.b fSerr
00002A2A  13FC 0001 00FF00BF      2219           move.b #1,fSerrAll         * flag S record error in file load
00002A32                          2220  doload3b
00002A32  0839 0002 00FFF003      2221           btst.b #2,SRA              * look for tx ready before sending character
00002A3A  67F6                    2222           beq doload3b
00002A3C  13FC 003F 00FFF007      2223           move.b #'?',THRA
00002A44  6000 0014               2224           bra doload2
00002A48                          2225  doload3:
00002A48  0839 0002 00FFF003      2226           btst.b #2,SRA              * look for tx ready before sending char
00002A50  67F6                    2227           beq doload3
00002A52  13FC 002E 00FFF007      2228           move.b #'.',THRA
00002A5A                          2229  doload2:
00002A5A  B03C 0053               2230           cmp.b #'S',d0
00002A5E  669E                    2231           bne doload
00002A60                          2232  doload1:
00002A60  0839 0000 00FFF003      2233           btst.b #0,SRA              * look for S1 or exit with ?>
00002A68  67F6                    2234           beq doload1
00002A6A  1039 00FFF007           2235           move.b RHRA,d0
00002A70  B03C 0030               2236           cmp.b #'0',d0
00002A74  6788                    2237           beq doload
00002A76  B03C 0031               2238           cmp.b #'1',d0              * S1 record?
00002A7A  6700 0210               2239           beq doS1
00002A7E  B03C 0032               2240           cmp.b #'2',d0              * S2 record?
00002A82  6700 0264               2241           beq doS2
00002A86  B03C 0033               2242           cmp.b #'3',d0              * S3 record?
00002A8A  6700 02BE               2243           beq doS3
00002A8E  B03C 0037               2244           cmp.b #'7',d0              * S7 record?
00002A92  6700 001C               2245           beq doS7
00002A96  B03C 0038               2246           cmp.b #'8',d0              * S8 record?
00002A9A  6700 00B6               2247           beq doS8
00002A9E  B03C 0039               2248           cmp.b #'9',d0              * S9 record?
00002AA2  6700 014E               2249           beq doS9
00002AA6  4639 00FF0057           2250           not.b fSerr                * mark the line as error
00002AAC  6000 FF50               2251           bra doload
00002AB0                          2252  doS7:
00002AB0                          2253  * if the address field is 0, or there are checksum error, exit
00002AB0                          2254  * if the address field is non zero, and no checksum error, jump to the specified address
00002AB0                          2255  * There are only 5 bytes: 4-byte address and checksum 
00002AB0  4284                    2256           clr.l d4                   * prepare checksum
00002AB2  343C 0001               2257           move.w #1,d2               * get Srecord byte count
00002AB6  6100 03B8               2258           bsr char2hex
00002ABA  D801                    2259           add.b d1,d4                * accumulate checksum
00002ABC  B23C 0005               2260           cmp.b #5,d1                * should have a length of 5 exactly
00002AC0  6600 0078               2261           bne doS7x
00002AC4  343C 0007               2262           move.w #7,d2               * get 4-byte starting address
00002AC8  6100 03A6               2263           bsr char2hex
00002ACC  D801                    2264           add.b d1,d4                * accumulate checksum, low address
00002ACE  E099                    2265           ror.l #8,d1
00002AD0  D801                    2266           add.b d1,d4                * accumulate checksum, mid-low address
00002AD2  E099                    2267           ror.l #8,d1
00002AD4  D801                    2268           add.b d1,d4                * accumulate checksum, mid-high address
00002AD6  E099                    2269           ror.l #8,d1
00002AD8  D801                    2270           add.b d1,d4                * accumulate checksum, msb address
00002ADA  E099                    2271           ror.l #8,d1                * restore original value
00002ADC  23C1 00FF00C4           2272           move.l d1,startaddr        * save the start address
00002AE2  4604                    2273           not.b d4                   * checksum expected next
00002AE4  343C 0001               2274           move.w #1,d2
00002AE8  6100 0386               2275           bsr char2hex
00002AEC  B801                    2276           cmp.b d1,d4                * compare calculated checksum
00002AEE  6600 004A               2277           bne doS7x
00002AF2  4A39 00FF00BF           2278           tst.b fSerrAll             * check for total error count
00002AF8  6600 0040               2279           bne doS7x
00002AFC  6100 0348               2280           bsr wCRquitX               * wait for CR and mark end of SR load before continuing
00002B00  4AB9 00FF00C4           2281           tst.l startaddr            * If starting address is 0, return to prompt
00002B06  6700 0024               2282           beq doS7y
00002B0A  41FA E727               2283           lea runSrecord(pc),a0      * notify S record is loaded and running
00002B0E  6100 F4E8               2284           bsr TxStringA0             * not using interrupt service to put out string       
00002B12                          2285  
00002B12                          2286  * delay 0.1 second before jump into application
00002B12  2C3C 00030000           2287           move.l #$30000,d6 * diagnostic
00002B18                          2288  w3abit:
00002B18  5386                    2289           sub.l #1,d6                * diagnostic
00002B1A  66FC                    2290           bne w3abit                 * diagnostic
00002B1C                          2291  
00002B1C  2279 00FF00C4           2292           move.l startaddr,a1        * else jump into the start address
00002B22  4E91                    2293           jsr (a1)                   
00002B24  41FA E748               2294           lea rundoneSR(pc),a0       * notify that s record execution completed
00002B28  6100 F4CE               2295           bsr TxStringA0    
00002B2C                          2296  doS7y:   
00002B2C  41FA E620               2297           lea prompt(pc),a0          * relocatable code
00002B30  23C8 00FF0058           2298           move.l a0,pStr             * pStr points to prompt string
00002B36  6000 FE6A               2299           bra txen
00002B3A                          2300  doS7x:
00002B3A  6100 030A               2301           bsr wCRquitX               * wait for CR and exit SR loader
00002B3E  487A E613               2302           pea qprompt(pc)
00002B42  23DF 00FF0058           2303           move.l (sp)+,pStr
00002B48  4239 00FF00BF           2304           clr.b fSerrAll
00002B4E  6000 FE52               2305           bra txen 
00002B52                          2306  doS8:
00002B52                          2307  * if the address field is 0, or there are checksum error, exit
00002B52                          2308  * if the address field is non zero, and no checksum error, jump to the specified address
00002B52                          2309  * There are only 4 bytes: 3-byte address and checksum 
00002B52  4284                    2310           clr.l d4                   * prepare checksum
00002B54  343C 0001               2311           move.w #1,d2               * get Srecord byte count
00002B58  6100 0316               2312           bsr char2hex
00002B5C  D801                    2313           add.b d1,d4                * accumulate checksum
00002B5E  B23C 0004               2314           cmp.b #4,d1                * should have a length of 4 exactly
00002B62  6600 0076               2315           bne doS8x
00002B66  343C 0005               2316           move.w #5,d2               * get 3-byte starting address
00002B6A  6100 0304               2317           bsr char2hex
00002B6E  D801                    2318           add.b d1,d4                * accumulate checksum, low address
00002B70  E099                    2319           ror.l #8,d1
00002B72  D801                    2320           add.b d1,d4                * accumulate checksum, mid address
00002B74  E099                    2321           ror.l #8,d1
00002B76  D801                    2322           add.b d1,d4                * accumulate checksum, high address
00002B78  E099                    2323           ror.l #8,d1
00002B7A  E099                    2324           ror.l #8,d1                * restore original value
00002B7C  23C1 00FF00C4           2325           move.l d1,startaddr        * save the start address
00002B82  4604                    2326           not.b d4                   * checksum expected next
00002B84  343C 0001               2327           move.w #1,d2
00002B88  6100 02E6               2328           bsr char2hex
00002B8C  B801                    2329           cmp.b d1,d4                * compare calculated checksum
00002B8E  6600 004A               2330           bne doS8x
00002B92  4A39 00FF00BF           2331           tst.b fSerrAll             * check for total error count
00002B98  6600 0040               2332           bne doS8x
00002B9C  6100 02A8               2333           bsr wCRquitX               * wait for CR and mark end of SR load before continuing
00002BA0  4AB9 00FF00C4           2334           tst.l startaddr            * If starting address is 0, return to prompt
00002BA6  6700 0024               2335           beq doS8y
00002BAA  41FA E687               2336           lea runSrecord(pc),a0      * notify S record is loaded and running
00002BAE  6100 F448               2337           bsr TxStringA0             * not using interrupt service to put out string       
00002BB2                          2338  
00002BB2                          2339  * delay 0.1 second before jump into application
00002BB2  2C3C 00030000           2340           move.l #$30000,d6          * diagnostic
00002BB8                          2341  w2abit:
00002BB8  5386                    2342           sub.l #1,d6                * diagnostic
00002BBA  66FC                    2343           bne w2abit                 * diagnostic
00002BBC                          2344  
00002BBC  2279 00FF00C4           2345           move.l startaddr,a1        * else jump into the start address
00002BC2  4E91                    2346           jsr (a1)                   
00002BC4  41FA E6A8               2347           lea rundoneSR(pc),a0       * notify that s record execution completed
00002BC8  6100 F42E               2348           bsr TxStringA0    
00002BCC                          2349  doS8y:   
00002BCC  41FA E580               2350           lea prompt(pc),a0          * relocatable code
00002BD0  23C8 00FF0058           2351           move.l a0,pStr             * pStr points to prompt string
00002BD6  6000 FDCA               2352           bra txen
00002BDA                          2353  doS8x:
00002BDA  6100 026A               2354           bsr wCRquitX               * wait for CR and exit SR loader
00002BDE  487A E573               2355           pea qprompt(pc)
00002BE2  23DF 00FF0058           2356           move.l (sp)+,pStr
00002BE8  4239 00FF00BF           2357           clr.b fSerrAll
00002BEE  6000 FDB2               2358           bra txen 
00002BF2                          2359  doS9:
00002BF2                          2360  * if the address field is 0, or there are checksum error, exit
00002BF2                          2361  * if the address field is non zero, and no checksum error, jump to the specified address
00002BF2                          2362  * There are only 3 bytes: 2-byte address and checksum 
00002BF2  4284                    2363           clr.l d4                   * prepare checksum
00002BF4  343C 0001               2364           move.w #1,d2               * get Srecord byte count
00002BF8  6100 0276               2365           bsr char2hex
00002BFC  D801                    2366           add.b d1,d4                * accumulate checksum
00002BFE  B23C 0003               2367           cmp.b #3,d1                * should have a length of 3 exactly
00002C02  6600 0070               2368           bne doS9x
00002C06  343C 0003               2369           move.w #3,d2               * get 2-byte starting address
00002C0A  6100 0264               2370           bsr char2hex
00002C0E  D801                    2371           add.b d1,d4                * accumulate checksum, lower address
00002C10  E059                    2372           ror.w #8,d1
00002C12  D801                    2373           add.b d1,d4                * accumulate checksum, higher address
00002C14  E059                    2374           ror.w #8,d1                * restore original value
00002C16  23C1 00FF00C4           2375           move.l d1,startaddr        * save the start address
00002C1C  4604                    2376           not.b d4                   * checksum expected next
00002C1E  343C 0001               2377           move.w #1,d2
00002C22  6100 024C               2378           bsr char2hex
00002C26  B801                    2379           cmp.b d1,d4                * compare calculated checksum
00002C28  6600 004A               2380           bne doS9x
00002C2C  4A39 00FF00BF           2381           tst.b fSerrAll             * check for total error count
00002C32  6600 0040               2382           bne doS9x
00002C36  6100 020E               2383           bsr wCRquitX               * wait for CR and mark end of SR load before continuing
00002C3A  4AB9 00FF00C4           2384           tst.l startaddr            * If starting address is 0, return to prompt
00002C40  6700 0024               2385           beq doS9y
00002C44  41FA E5ED               2386           lea runSrecord(pc),a0      * notify S record is loaded and running
00002C48  6100 F3AE               2387           bsr TxStringA0             * not using interrupt service to put out string       
00002C4C                          2388  * delay 0.1 second before jump into application
00002C4C  2C3C 00030000           2389           move.l #$30000,d6          * diagnostic
00002C52                          2390  w1abit:
00002C52  5386                    2391           sub.l #1,d6                * diagnostic
00002C54  66FC                    2392           bne w1abit                 * diagnostic
00002C56                          2393  
00002C56  2279 00FF00C4           2394           move.l startaddr,a1        * else jump into the start address
00002C5C  4E91                    2395           jsr (a1)                   
00002C5E  41FA E60E               2396           lea rundoneSR(pc),a0       * notify that s record execution completed
00002C62  6100 F394               2397           bsr TxStringA0
00002C66                          2398  doS9y:   
00002C66  41FA E4E6               2399           lea prompt(pc),a0          * relocatable code
00002C6A  23C8 00FF0058           2400           move.l a0,pStr             * pStr points to prompt string
00002C70  6000 FD30               2401           bra txen
00002C74                          2402  doS9x:
00002C74  6100 01D0               2403           bsr wCRquitX               * wait for CR and exit SR loader
00002C78  487A E4D9               2404           pea qprompt(pc)
00002C7C  23DF 00FF0058           2405           move.l (sp)+,pStr
00002C82  4239 00FF00BF           2406           clr.b fSerrAll
00002C88  6000 FD18               2407           bra txen
00002C8C                          2408  doS1:
00002C8C                          2409  * 2-byte address field
00002C8C  4284                    2410           clr.l d4
00002C8E  343C 0001               2411           move.w #1,d2               * get Srecord byte count
00002C92  6100 01DC               2412           bsr char2hex
00002C96  D801                    2413           add.b d1,d4                * accumulate checksum
00002C98  3601                    2414           move.w d1,d3
00002C9A  5943                    2415           sub.w #4,d3                * don't count CRC byte nor 2-byte address             
00002C9C  343C 0003               2416           move.w #3,d2               * get 2-byte starting address
00002CA0  6100 01CE               2417           bsr char2hex
00002CA4  D801                    2418           add.b d1,d4                * accumulate checksum, lower address
00002CA6  E059                    2419           ror.w #8,d1                
00002CA8  D801                    2420           add.b d1,d4                * accumulate checksum, higher address
00002CAA  E059                    2421           ror.w #8,d1                * restore
00002CAC  2041                    2422           move.l d1,a0
00002CAE                          2423  srdata:
00002CAE  343C 0001               2424           move.w #1,d2               * get byte data
00002CB2  6100 01BC               2425           bsr char2hex
00002CB6  D801                    2426           add.b d1,d4                * accumulate checksum
00002CB8  1081                    2427           move.b d1,(a0)             * store value to destination
00002CBA  B218                    2428           cmp.b (a0)+,d1             * write verify
00002CBC  6700 000A               2429           beq srdatax
00002CC0  13FC 0001 00FF0057      2430           move.b #1,fSerr
00002CC8                          2431  srdatax: 
00002CC8  51CB FFE4               2432           dbra d3,srdata
00002CCC  4604                    2433           not.b d4                   * checksum expected
00002CCE  343C 0001               2434           move.w #1,d2
00002CD2  6100 019C               2435           bsr char2hex
00002CD6  B801                    2436           cmp.b d1,d4
00002CD8  6700 FD24               2437           beq doload
00002CDC  13FC 0001 00FF0057      2438           move.b #1,fSerr            * send out a question mark
00002CE4  6000 FD18               2439           bra doload
00002CE8                          2440  doS2:
00002CE8                          2441  * 3-byte address field
00002CE8  4284                    2442           clr.l d4
00002CEA  343C 0001               2443           move.W #1,d2               * get Srecord byte count
00002CEE  6100 0180               2444           bsr char2hex
00002CF2  D801                    2445           add.b d1,d4                * accumulate checksum
00002CF4  3601                    2446           move.W d1,d3
00002CF6  5B43                    2447           sub.W #5,d3                * don't count CRC byte nor 3-byte address             
00002CF8  343C 0005               2448           move.W #5,d2               * get 3-byte starting address
00002CFC  6100 0172               2449           bsr char2hex
00002D00  D801                    2450           add.b d1,d4                * accumulate checksum, lower address
00002D02  E099                    2451           ror.l #8,d1                
00002D04  D801                    2452           add.b d1,d4                * accumulate checksum, middle address
00002D06  E099                    2453           ror.l #8,d1                * 
00002D08  D801                    2454           add.b d1,d4                * accumulate checksum, upper address
00002D0A  E099                    2455           ror.l #8,d1
00002D0C  E099                    2456           ror.l #8,d1                * restore
00002D0E  2041                    2457           move.l d1,a0
00002D10                          2458  srdata2:
00002D10  343C 0001               2459           move.w #1,d2               * get byte data
00002D14  6100 015A               2460           bsr char2hex
00002D18  D801                    2461           add.b d1,d4                * accumulate checksum
00002D1A  1081                    2462           move.b d1,(a0)             * store value to destination
00002D1C  B218                    2463           cmp.b (a0)+,d1             * write verify
00002D1E  6700 000A               2464           beq srdata2x
00002D22  13FC 0001 00FF0057      2465           move.b #1,fSerr            * flag if not able to write
00002D2A                          2466  srdata2x:
00002D2A  51CB FFE4               2467           dbra d3,srdata2
00002D2E  4604                    2468           not.b d4                   * checksum expected
00002D30  343C 0001               2469           move.w #1,d2
00002D34  6100 013A               2470           bsr char2hex
00002D38  B801                    2471           cmp.b d1,d4
00002D3A  6700 FCC2               2472           beq doload
00002D3E  13FC 0001 00FF0057      2473           move.b #1,fSerr            * send out a question mark
00002D46  6000 FCB6               2474           bra doload        
00002D4A                          2475  
00002D4A                          2476  doS3:
00002D4A                          2477  * 4-byte address field
00002D4A  4284                    2478           clr.l d4
00002D4C  343C 0001               2479           move.w #1,d2               * get Srecord byte count
00002D50  6100 011E               2480           bsr char2hex
00002D54  D801                    2481           add.b d1,d4                * accumulate checksum
00002D56  3601                    2482           move.w d1,d3
00002D58  5D43                    2483           sub.w #6,d3                * don't count CRC byte nor 4-byte address             
00002D5A  343C 0007               2484           move.w #7,d2               * get 3-byte starting address
00002D5E  6100 0110               2485           bsr char2hex
00002D62  D801                    2486           add.b d1,d4                * accumulate checksum, lsb address
00002D64  E099                    2487           ror.l #8,d1                
00002D66  D801                    2488           add.b d1,d4                * accumulate checksum, mid-lower address
00002D68  E099                    2489           ror.l #8,d1                * 
00002D6A  D801                    2490           add.b d1,d4                * accumulate checksum, mid-upper address
00002D6C  E099                    2491           ror.l #8,d1
00002D6E  D801                    2492           add.b d1,d4                * accumulate checksum, msb address
00002D70  E099                    2493           ror.l #8,d1                * restore
00002D72  2041                    2494           move.l d1,a0
00002D74                          2495  srdata3:
00002D74  343C 0001               2496           move.w #1,d2               * get byte data
00002D78  6100 00F6               2497           bsr char2hex
00002D7C  D801                    2498           add.b d1,d4                * accumulate checksum
00002D7E  1081                    2499           move.b d1,(a0)             * store value to destination
00002D80  B218                    2500           cmp.b (a0)+,d1             * write verify
00002D82  6700 000A               2501           beq srdata3x
00002D86  13FC 0001 00FF0057      2502           move.b #1,fSerr            * flag if not able to write
00002D8E                          2503  srdata3x:
00002D8E  51CB FFE4               2504           dbra d3,srdata3
00002D92  4604                    2505           not.b d4                   * checksum expected
00002D94  343C 0001               2506           move.w #1,d2
00002D98  6100 00D6               2507           bsr char2hex
00002D9C  B801                    2508           cmp.b d1,d4
00002D9E  6700 FC5E               2509           beq doload
00002DA2  13FC 0001 00FF0057      2510           move.b #1,fSerr            * send out a question mark
00002DAA  6000 FC52               2511           bra doload                 
00002DAE                          2512  chktx:
00002DAE  4A39 00FF00D2           2513           tst.b fTxChar              * is transmit enabled?
00002DB4  6700 008A               2514           beq edisr1
00002DB8  0839 0002 00FFF003      2515           btst.b #2,SRA              * look for transmit ready
00002DC0  6700 007E               2516           beq edisr1                 * nothing, exit
00002DC4  2079 00FF0058           2517           move.l pStr,a0             * load the string pointer
00002DCA  0C79 FFFF 00FF00D0      2518           cmp.w #-1,cTxChar * use character count to terminate string transmission?
00002DD2  6700 0012               2519           beq chktx1                 * default to not use char count except task 0 & 1
00002DD6  4A79 00FF00D0           2520           tst.w cTxChar              * has character count reached zero?
00002DDC  6700 000E               2521           beq chkfCRLF               * if reached the end, check if need to append CR/LF
00002DE0  5379 00FF00D0           2522           sub.w #1,cTxChar  * transmit a char, reduce char count by 1
00002DE6                          2523  chktx1:
00002DE6  1010                    2524           move.b (a0),d0
00002DE8  6600 0026               2525           bne txNxtChar              * if end of string, check if need to append CR/LF
00002DEC                          2526  chkfCRLF:
00002DEC                          2527  * null terminator reached, check if need to append CR/LF
00002DEC  4A39 00FF00D7           2528          tst.b fEASyTCRLF           * if flag set, add append CR LF to message
00002DF2  6700 002C               2529          beq edisr                  * no CR LF, transmission completed
00002DF6                          2530  * apend a carriage return/line feed string here
00002DF6  4239 00FF00D7           2531           clr.b fEASyTCRLF  * clear the CRLF flag
00002DFC  33FC FFFF 00FF00D0      2532           move.w #-1,cTxChar         * disable string transmission based on character count
00002E04  487A E345               2533           pea CRLF(pc)               * append the CRLF message
00002E08  23DF 00FF0058           2534           move.l (sp)+,pStr * update string pointer
00002E0E  609E                    2535           bra chktx
00002E10                          2536  txNxtChar:
00002E10  13C0 00FFF007           2537           move.b d0,THRA    * put out the next byte as pointed by a0
00002E16  52B9 00FF0058           2538           add.l #1,pStr              * update the string pointer
00002E1C  6000 0022               2539           bra edisr1        
00002E20                          2540  edisr:
00002E20  33FC FFFF 00FF00D0      2541           move.w #-1,cTxChar         * disable string transmission based on character count
00002E28  13FC 0000 00FF00D2      2542           move.b #0,fTxChar * disable transmit in DUART ISR
00002E30  13FC 000A 00FFF00B      2543           move.b #$A,IMRD            * mask off transmit interrupts, enable timer
00002E38  13FC 0000 00FF00B6      2544           move.b #True,fTxDone       * flag transmission of string finished
00002E40                          2545  edisr1:
00002E40  4CDF 071F               2546           movem.l (sp)+,d0-d4/a0-a2  * restore
00002E44  4E73                    2547           rte
00002E46                          2548  * 
00002E46                          2549  * subroutine wait for CR then quit with 'X' output
00002E46                          2550  wCRquitX:
00002E46  0839 0000 00FFF003      2551           btst.b #0,SRA              * look for CR and quit
00002E4E  67F6                    2552           beq wCRquitX
00002E50  1039 00FFF007           2553           move.b RHRA,d0
00002E56  B03C 000D               2554           cmp.b #$d,d0
00002E5A  66EA                    2555           bne wCRquitX
00002E5C  13FC 0058 00FFF007      2556           move.b #'X',THRA
00002E64                          2557  wCRquitX1:
00002E64  0839 0002 00FFF003      2558           btst.b #2,SRA              * look for transmit done before returning
00002E6C  67F6                    2559           beq wCRquitX1
00002E6E  4E75                    2560           rts
00002E70                          2561  *
00002E70                          2562  * subroutine to get prescribed number of characters in d2+1, convert to hex and put in
00002E70                          2563  * d1 
00002E70                          2564  char2hex:
00002E70  4281                    2565           clr.l d1                   * important to clear all d1 when start
00002E72                          2566  c2h1:
00002E72  0839 0000 00FFF003      2567           btst.b #0,SRA
00002E7A  67F6                    2568           beq c2h1
00002E7C  1039 00FFF007           2569           move.b RHRA,d0
00002E82  6100 F0BA               2570           bsr asc2hex
00002E86  B03C 00FF               2571           cmp.b #$FF,d0
00002E8A  6600 000A               2572           bne c2h1_1
00002E8E  13FC 0001 00FF0057      2573           move.b #1,fSerr            * mark this as an error and go on
00002E96                          2574  c2h1_1:
00002E96  E989                    2575           lsl.l #4,d1                
00002E98  D200                    2576           add.b d0,d1                * append to existing value
00002E9A  51CA FFD6               2577           dbra d2,c2h1
00002E9E  4E75                    2578           rts
00002EA0                          2579  *
00002EA0                          2580  * Bus error handling
00002EA0                          2581  * print "Bus error" in polling mode and return
00002EA0                          2582  buserr:
00002EA0  0679 1000 00FF0054      2583           add.w #$1000,cUErr
00002EA8  48F9 FFFF 00FF0010      2584           movem.l d0-d7/a0-a7,savd0  * save away registers
00002EB0  23EF 000A 00FF0050      2585           move.l $A(sp),savpc
00002EB8                          2586  
00002EB8  41FA E2BD               2587           lea berrmsg(pc),a0
00002EBC  6100 F13A               2588           bsr TxStringA0
00002EC0  202F 0002               2589           move.l 2(sp),d0            * print the access address
00002EC4  6100 F15E               2590           bsr TxRegD0
00002EC8  41FA E2EB               2591           lea pcmsg(pc),a0  * print PC value
00002ECC  6100 F12A               2592           bsr TxStringA0
00002ED0  202F 000A               2593           move.l $a(sp),d0
00002ED4  6100 F14E               2594           bsr TxRegD0
00002ED8  6000 F1EE               2595           bra unknown                * blink lights forever
00002EDC                          2596  
00002EDC  4E71                    2597           nop                        * extra pad
00002EDE  4E71                    2598           nop
00002EE0                          2599           
00002EE0                          2600  * that's all folks!
00002EE0                          2601  
00002EE0                          2602           end RAMstart

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ACR                 FFF009
ADDRERR             20F4
ADDRERRMSG          11CC
AMRSVP              FF000C
ASC2HEX             1F3E
ASCHEX0             1F8A
ASCHEX1             1F86
ASCHEX2             1F7E
ASCHEX3             1F76
ASCHEX9             1F6E
BADBPCMD            21FA
BADBPMSG            1C1A
BADCOMMAND          70E
BADCPM              1030
BADGOMSG            11F3
BANSWER             FF005C
BBYTEANS            FF0070
BCMDLINE            FF0074
BERRMSG             1177
BKPTADDR            FF00B8
BKPTINSTR           FF00BC
BKPTMSG             1C38
BOOTCPM             12B4
BPCMDLOOP           21A4
BPCMDPROC           21E0
BPCOMMANDS          22EC
BPHELPMSG           17C5
BPMNEMONICTBL       2310
BPPROMPT            1BEC
BPPROMPTNC          1BFB
BPQPROMPT           1BF3
BPREMOVEMSG         1C4A
BREAKPT             212E
BREAKPT1            2172
BREAKPT2            2188
BREAKPT8            2282
BREAKPT9            22D8
BUSERR              2EA0
C2H1                2E72
C2H1_1              2E96
CALCEASYTASK        25BC
CALCEASYTASK32      25BA
CCMD                FF008C
CCMDPARAM           FF008E
CF07                FFE007
CF1623              FFE00B
CF2427              FFE00D
CF815               FFE009
CFDATA              FFE000
CFERR               FFE002
CFSECTCNT           FFE005
CFSTAT              FFE00F
CHAR2HEX            2E70
CHKDRQ              1062
CHKEXTRASP          27F8
CHKFCRLF            2DEC
CHKTX               2DAE
CHKTX1              2DE6
CLRMEMBO            F70
CLROPR              FFF01F
CLRRAM0             1E6C
CLRRAMA5            1E64
CLRSAVR             1E78
CLRSAVR0            1E82
CMDPARAM            FF0090
CMDPROC             6AC
CMDREFORMAT         734
CMDRF0              73E
CMDRF1              760
CMDRF2              774
CMDRF3              78C
CMDRF6              79C
CMDRF7              7B4
CMDRF8              7C0
CMDRF9              7CA
CMDTODO             67C
CNTIDLE             FF00AC
COMMANDS            41C
COMPUANSWER         205E
CORNER7SEG          FF00AA
CRA                 FFF005
CRCCPM              12DD
CRLF                114B
CSRA                FFF003
CTL                 FFF00F
CTLR                FFF00F
CTRACE              FF00C0
CTU                 FFF00D
CTUR                FFF00D
CTXCHAR             FF00D0
CUERR               FF0054
DISPLAYALL          2384
DNTIMER2            2726
DOCMD               672
DOCOMMAND9          72A
DODO9               72E
DODO9N              732
DOLOAD              29FE
DOLOAD1             2A60
DOLOAD2             2A5A
DOLOAD3             2A48
DOLOAD3B            2A32
DOPROMPT            6C4
DORUNRUN            298E
DORWG               2872
DORWG5              28DC
DORWG6              290C
DORWG7              28F8
DORWG8              2932
DORWG8B             2962
DORWG8C             297A
DORWG9              2912
DOS1                2C8C
DOS2                2CE8
DOS3                2D4A
DOS7                2AB0
DOS7X               2B3A
DOS7Y               2B2C
DOS8                2B52
DOS8X               2BDA
DOS8Y               2BCC
DOS9                2BF2
DOS9X               2C74
DOS9Y               2C66
DOWNTIMER1          FF0008
DOWNTIMER2          FF000A
DOWRITE             29B6
DOZ                 29C6
DOZ1                29D6
DO_BO               F5C
DO_BO9              103A
DO_BP               C9E
DO_BP3              CF0
DO_BP5              D1E
DO_BP6              D28
DO_BP7              D3A
DO_BP8              D60
DO_BP8X             D50
DO_BP9              D44
DO_BP9X             D6A
DO_BPHELP           2368
DO_BP_DR            86A
DO_BP_MR            A50
DO_CRLF             222A
DO_DM               7D0
DO_DM1              818
DO_DM8              84E
DO_DM9              82C
DO_DM9X             858
DO_DR               862
DO_DR1              91C
DO_DR2              928
DO_DR8              944
DO_DR9              938
DO_DR9X             94E
DO_DRA0_7           8F2
DO_DRD0_7           90A
DO_DR_A             8EC
DO_DR_D             904
DO_DR_DX            8C4
DO_DR_REG           958
DO_DU               E68
DO_DU2              F38
DO_DU3              E9E
DO_DU4              EC8
DO_DU5              F22
DO_DU6              F2E
DO_DU7              F10
DO_DU8              F48
DO_DU9X             F52
DO_GO               BDC
DO_GO2              C16
DO_GO3              C00
DO_GO6              C4E
DO_GO7              C56
DO_GO8              C8A
DO_GO8X             C80
DO_GO9              C74
DO_GO9X             C94
DO_GOTO             229A
DO_GT2              22CA
DO_HELP             D74
DO_MM               982
DO_MM3              9FE
DO_MM4              A0E
DO_MM8              9EC
DO_MM9X             9F6
DO_MM9Y             A3E
DO_MR               A48
DO_MR2              ACA
DO_MR3              AE8
DO_MR4              AF0
DO_MR5              B46
DO_MR6              B66
DO_MR7              B80
DO_MR8              BC8
DO_MR8I             B96
DO_MR9              BA2
DO_MR9I             B9E
DO_MR9X             BD2
DO_MR9Y             BB4
DO_MR_DX            A9E
DO_SW               1082
DO_SW2              10A8
DO_SW3              10B6
DO_SW8              10CA
DO_TR               2240
DO_TR4              2268
DO_TR8              227E
DO_VB               2324
DO_VB2              2344
DO_VB9              2356
DUART               FFF000
DUARTISR            2700
EASY0               25CC
EASY0Z              2604
EASY1               25CC
EASY10              2598
EASY11              2598
EASY12              266C
EASY13              2674
EASY14              2674
EASY14Z             26A2
EASY15              2598
EASY16              2598
EASY17              2598
EASY18              2598
EASY19              2598
EASY2               2598
EASY20              2598
EASY21              2598
EASY22              2598
EASY23              2598
EASY24              2598
EASY25              2598
EASY3               2598
EASY32              26B4
EASY32A             26E0
EASY32B             26EA
EASY32C             26F0
EASY32D             26F6
EASY32G             26FC
EASY32Z             26FE
EASY4               2598
EASY5               2616
EASY6               2632
EASY7               264E
EASY7Z              2662
EASY8               2664
EASY80              2598
EASY81              2598
EASY82              2598
EASY83              2598
EASY84              2598
EASY85              2598
EASY86              2598
EASY87              2598
EASY88              2598
EASY89              2598
EASY9               2598
EASY90              2598
EASY91              2598
EASY92              2598
EASY93              2598
EASY94              2598
EASY95              2598
EASY96              2598
EASYT15Z            25C6
EASYTRAP            259A
EASYTRAPTBL         24E8
ECHO_CHR            28FA
ECHO_RUBOUT         27D6
ECHO_RX             27BA
EDISR               2E20
EDISR1              2E40
ENABLENEXTCMD       10F6
ENDREADCF           FEE
ENTRY               45A
ERROR               FF
EXEC_BPCMD          21F0
EXEC_CMD            6BC
EXITCODE            FF00D3
FALSE               1
FBPVERBOSE          FF00B7
FCMDDONE            FF008F
FDOBKPT             FF00BE
FDOCMD              FF008D
FEASYTCRLF          FF00D7
FEASYTECHO          FF00D6
FILLCMDBUF          2810
FORE                574
FORE9               57C
FSERR               FF0057
FSERRALL            FF00BF
FTXCHAR             FF00D2
FTXDONE             FF00B6
FWVAL               FF0056
GETCMDLINE          2796
GET_CHAR            28BE
GOBACKONE           27E8
HELPMSG             13CD
HEX2ASC             1F8C
HEX2ASC7            1FA2
HEX2ASC8            1FB8
IBUFFER             1E94
IDLEINIT            584
IDUART              1ED6
ILLEGALMSG          119A
IMRD                FFF00B
INTERACT9           668
INV7SEGEND          63C
INV7SEGTBL          60C
IPCR                FFF009
ISRD                FFF00B
IVRD                FFF019
LA07                FF00DB
LA1623              FF00D9
LA2427              FF00D8
LA815               FF00DA
MAXIDLE             FF00B0
MMADDRESS           FF00CC
MMINTERACT1         E06
MMINTERACT2         E0E
MMINTERACT3         E0C
MMINTERACT6         DEE
MMINTERACT8         E3A
MMINTERACT9         E48
MMINTERACT9X        E50
MMINTERACT9Y        E62
MMINTERACTIVE       D90
MNEMONICTBL         444
MORE_SP             28A8
MPUINIT1            546
MR1B                FFF011
MRA                 FFF001
NEWIDLE7SEG         596
NEWIDLE7SEG9        5E4
NEWNXTIDLE7SEG      5D0
NEXTSECT            FB8
NOBPCMD             2210
NOBPCMD9            2222
NOBPMSG             1C00
NOCPM               12EA
NULLCHAR            FF00B4
OKCOMMAND           71E
OPCR                FFF01B
PARSEBPCMD          21CE
PARSECMD            69A
PCMDLN              FF0088
PCMSG               11B5
PIDLE7SEG           FF00C8
PROCDONEMSG         128D
PROMPT              114E
PSTR                FF0058
QPROMPT             1153
Q_NO_CR             1BEA
RAMSTART            40E
RCVRA               2752
READCF              104E
READCF1             1070
REG2ASCII           1FC0
REGA0               1D44
REGA0SHORT          1E2C
REGA1               1D54
REGA1SHORT          1E33
REGA2               1D64
REGA2SHORT          1E3A
REGA3               1D74
REGA3SHORT          1E41
REGA4               1D84
REGA4SHORT          1E48
REGA5               1D94
REGA5SHORT          1E4F
REGA6               1DA4
REGA6SHORT          1E56
REGA7               1DB4
REGA7SHORT          1E5D
REGASCII            FF00A0
REGD0               1CC4
REGD0SHORT          1DF4
REGD1               1CD4
REGD1SHORT          1DFB
REGD2               1CE4
REGD2SHORT          1E02
REGD3               1CF4
REGD3SHORT          1E09
REGD4               1D04
REGD4SHORT          1E10
REGD5               1D14
REGD5SHORT          1E17
REGD6               1D24
REGD6SHORT          1E1E
REGD7               1D34
REGD7SHORT          1E25
REGPC               1DC4
REGSTRLEN           10
RHRA                FFF007
RHRB                FFF017
ROMVER              FF0000
RUNCPM              1312
RUNDONESR           126E
RUNSRECORD          1233
SAV7SEG             FF00D5
SAVA0               FF0030
SAVA1               FF0034
SAVA2               FF0038
SAVA3               FF003C
SAVA4               FF0040
SAVA5               FF0044
SAVA6               FF0048
SAVD0               FF0010
SAVD1               FF0014
SAVD2               FF0018
SAVD3               FF001C
SAVD4               FF0020
SAVD5               FF0024
SAVD6               FF0028
SAVD7               FF002C
SAVPC               FF0050
SAVSP               FF004C
SECONDS             FF00C2
SETOPR              FFF01D
SIGNON              1118
SIMPLEMSG           1CAE
SINTERACTIVE        FF00C3
SP_1ST              288C
SRA                 FFF003
SRB                 FFF013
SRDATA              2CAE
SRDATA2             2D10
SRDATA2X            2D2A
SRDATA3             2D74
SRDATA3X            2D8E
SRDATAX             2CC8
STARTADDR           FF00C4
STARTCTR            FFF01D
STOPCTR             FFF01F
SWITCHEDMSG         1356
SWITCHMSG           138A
THRA                FFF007
TIMERISR6           2736
TIMERISR9           274C
TINY68KBUG          400
TINY68KCMD          63C
TRACE               2466
TRACE1              2472
TRACE5              24AE
TRACE7              24D0
TRACE9              24DE
TRACEMSG            1C66
TRACEPCMSG          1C7E
TRACESTMSG          1C88
TRUE                0
TXEN                29A2
TXNXTCHAR           2E10
TXPROMPT            2998
TXREGD0             2024
TXREGD01            202C
TXREGD0Q            204A
TXSTR1              1FFC
TXSTR9              2014
TXSTRINGA0          1FF8
UNINV7SEG           5EA
UNINV7SEG1          604
UNKNOWN             20C8
UNKNOWN1            20E4
UNKNOWN2            20EE
UNKNOWN3            20DE
VERBOSEMSG          1C99
W1ABIT              2C52
W2ABIT              2BB8
W3ABIT              2B18
WALLCLOCK           FF0004
WBUFDU              ECE
WBUFDU1             EEE
WCRQUITX            2E46
WCRQUITX1           2E64
WHAT                282A
WHAT_NO_CR          284E
WTXDONE             10EA
WUSERINPUT          110E
ZMEMMSG             1159
