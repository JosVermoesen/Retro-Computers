library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.numeric_std.ALL;

entity TG68Test is
	port (
		clk : in std_logic;

		counter : out std_logic_vector(15 downto 0);
		reset : in std_logic
	);
end entity;


architecture rtl of TG68Test is
signal cpu_datain : std_logic_vector(15 downto 0);	-- Data provided by us to CPU
signal cpu_dataout : std_logic_vector(15 downto 0); -- Data received from the CPU
signal cpu_addr : std_logic_vector(31 downto 0); -- CPU's current address
signal cpu_as : std_logic; -- Address strobe
signal cpu_uds : std_logic; -- upper data strobe
signal cpu_lds : std_logic; -- lower data strobe
signal cpu_r_w : std_logic; -- read(high)/write(low)
signal cpu_dtack : std_logic := '0' ; -- data transfer acknowledge
signal write_cycle : std_logic := '0' ;
signal dtack : std_logic :='1';
begin


myTG68 : entity work.TG68
   port map
	(
		clk => clk,
      reset => reset,
      clkena_in => '1',
      data_in => cpu_datain,
		IPL => "111",	-- For this simple demo we'll ignore interrupts
		dtack => cpu_dtack,
		addr => cpu_addr,
		as => cpu_as,
		data_out => cpu_dataout,
		rw => cpu_r_w,
		uds => cpu_uds,
		lds => cpu_lds,
		enaRDreg => '1',
		enaWRreg => '1'
);


-- Test program: 
--		0x5240 (loop: addq.w #1,d0)
--		0x31c0 (move.w d0,$100.w)
--		0x0100
--		0x60f8 (bra.s loop)

-- Address decoding
process(clk,cpu_addr)
begin
	if rising_edge(clk) then
		if cpu_as='0' then
			case cpu_addr(11 downto 0) is
				-- We have a simple program encoded into four words here...
				when X"006" =>
					cpu_datain <= X"0008";
					cpu_dtack<='0';	-- Data is ready immediately.
				when X"008" =>
					cpu_datain <= X"5240";  -- addq.w #1,d0
					cpu_dtack<='0';	-- Data is ready immediately.
				when X"00A" =>
					cpu_datain <= X"31c0";  -- move.w d0...
	--				cpu_datain <= X"33c0";  -- move.w d0...
					cpu_dtack<='0';	-- Data is ready immediately.
				when X"00C" =>
					cpu_datain <= X"0100";  -- ...,$100
					cpu_dtack<='0';	-- Data is ready immediately.
				when X"00E" =>
					cpu_datain <= X"60f8";  -- bra.s 0
					cpu_dtack<='0';	-- Data is ready immediately.
			-- Now a simple hardware register at 0x100, written to by the program:
				when X"100" =>
					if cpu_uds='0' and cpu_lds='0' then
						counter<=cpu_dataout;
						cpu_dtack<='0';
					end if;
				when others =>
					cpu_datain <= X"0000";
					cpu_dtack<='0';
			end case;
		end if;

		if cpu_uds='1' and cpu_lds='1' then
			cpu_dtack<='1';
		end if;
	end if;
end process;

end architecture;
