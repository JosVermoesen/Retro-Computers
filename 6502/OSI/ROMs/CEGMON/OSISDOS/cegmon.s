; Source for CEGMON monitor.;
; Was generated by disassembling ROM image.;
; Original content (c) 1980 George Chkintz, Richard Elen, Tom Graves;
; Found on the Internet at: ;
; https://raw.githubusercontent.com/jefftranter/6502/master/asm/OSI/cegmon.s;
;;
; DGG 2019-04-11 - Added labels from CEGMON users guide found at:;
; http://uk101.sourceforge.net/docs/pdf/cegmon.pdf;
; ;
; Assemble using AS65 (from the CC65 suite);
;	https://cc65.github.io/doc/ca65.html;
; Command line:;
;	retroassembler.exe cegmon.s -O=bin
;
; Page zero defines
L0000           := $0000;
L002E           := $002E;
BKTABK			:= $00E4	; Part of break table
BTABCL			:= $00E5	; save new block start address in move
BRKVAL			:= $00E7	; store for opcode moved by Z when setting breakpoint
LOTO			:= $00F9	; store for 'to' address in save, move and tabular display
HITO			:= $00FA	; 
STORE			:= $00FC	; Store for current data during data mode
L00FD           := $00FD	; 
LOFROM          := $00FE	; $00FE LOFROM store current address for most routines the from address in save move and tabular display;
HIFROM			:= $00FF
; CEGMON uses BASIC flags and routines for I/O;
CURDIS			:= $0200	; Cursor displacement on current line
OLDCHR			:= $0201	; Stores current character during SCREEN; exits containing char beneath the cursor
NEWCHPK			:= $0202	; Park for new char for SCREEN
BLOADFL         := $0203	; BASIC Load Flag ($80 means load from tape)
EDFLAG			:= $0204	; EDFLAG Editor flag 00-disable edit cursor, ff-enabe edit cursor
BSAVEFL         := $0205	; BASIC Save Flag (0 means not SAVE mode, 0xFF = dump to serial port)
SDELAY 			:= $0206 	; Print-delay value for SCREEN delay is delay-value times approx. 400 machine-cycles (ie times 400 micro-seconds at 1MHz)
CCFLAG			:= $0212 	; BASIC CTRL-C flag 00-enables CTRL-C break, 01-disables CTRL-C break
COUNTR			:= $0214 	; Auto-repeat counter for GETKEY
SCRTCH			:= $0215	; Returns from GETKEY with final ASCII value of key
LSTCHR			:= $0216 	; Pre-shift value of last key left here by GETKEY to test auto-repeat
BINVECT         := $0218	; BASIC Input Vector
BOUTVEC			:= $021A	; BASIC Output Vector
BCTLCVC			:= $021C	; BASIC CTRL-C Check Vector
BLDVECT			:= $021E	; BASIC Load Vector
BSAVECT			:= $0220	; BASIC Save Vector
SWIDTH			:= $0222	; Screen column width-1
SLTOP			:= $0223	; Screen low byte of TOP
SHTOP			:= $0224	; Screen high byte of TOP
SLBASE			:= $0225	; Screen low byte od BASE
SHBASE			:= $0226	; Screen high byte of BASE
L0227           := $0227
L022A           := $022A
LTEXT			:= $022B	; Low byte of text-line start
HTEXT			:= $022C	; High byte of text-line start
ECDISPL			:= $022F 	; DISP edit-cursor displacement from start of editors current line;
CURCHR			:= $0230 	; Store for char beneath edit cursor;
CURSLO			:= $0231	; Contains start of edit cursors current line on screen;
CURSHI			:= $0232  	; Contains start of edit cursors current line on screen;
USERLO          := $0233	; Location of start of user routine called by machine code monitors U command;
USERHI			:= $0234 	; Location of start of user routine called by machine code monitors U command;
;
L2F44           := $2F44	;
L415A           := $415A	;
; BASIC-in-ROM addresses
LA34B           := $A34B	;
LA374           := $A374	;
LA636           := $A636	;
LBF2D           := $BF2D	; CRT routine
; Video RAM addresses;
LD08C           := $D08C
; ACIA addresses;
ACIAST			:= $F000	; ACIA Status Register;
ACIADR			:= $F001	; ACIA Data Register;

; Reserve first 256 ($F000-$F0FF) locations for I/O
        .org $F000				; peripheral space
		.byte 0					; Reserve space with placeholder - fills the following with 0's
		
;
; Start of ROM code;
		.org $F100
		
; The SDLBA registers are used like this:
;
; 31 30 29 28.27 26 25 24.23 22 21 20.19 18 17 16.15 14 13 12.11 10 09 08.07 06 05 04.03 02 01 00
;  0  0  0  0  0  0  0  0 ------- SDLBA2 --------+------- SDLBA1 --------+------- SDLBA0 -------+
;
; The end result of all this is that the addressing looks the same for SDSC and SDHC cards.
;
; SDSTATUS (RO)
;    b7     Write Data Byte can be accepted
;    b6     Read Data Byte available
;    b5     Block Busy
;    b4     Init Busy
;    b3     Unused. Read 0
;    b2     Unused. Read 0
;    b1     Unused. Read 0
;    b0     Unused. Read 0
;
; SDCONTROL (WO)
;    b7:0   0x00 Read block
;           0x01 Write block

; Prompt for sector number

PRPRPT: jsr     SCNCLR			; clear the screen;
		ldy		#0
        sty		CURDIS			;
LOOPY:	lda     LBA2PR,y		;
		jsr     OUTVEC			;
        iny						;
        cpy     #$0D			;
        bne     LOOPY			;
L4VR:	jmp		L4VR

LBA2PR:  .byte "Sector LBA2? ";
LBA1PR:  .byte "Sector LBA1? ";
LBA0PR:  .byte "Sector LBA0? ";

; Start of CEGMON code
; Original monitor started at $FF00 (RESET)

        .org $F800

LF800:  lda     $0E
        beq     LF80A
        dec     $0E
        beq     LF80A
        dec     $0E
LF80A:  lda     #$20		; SPACE char to fill screen;
        sta     OLDCHR		; $0201 OLDCHR stores current character during SCREEN
							; exits containing char beneath the cursor;
        jsr     LFF8F;
        bpl     LF82D;
        sec;
        lda     LTEXT;
        sbc     #$40;
        sta     LTEXT;
        lda     HTEXT;
        sbc     #$00;
        sta     HTEXT;
        jsr     ENDCHK;
        bcs     LF82D;
        jsr     CURHOM;
LF82D:  stx     CURDIS		; $0200 CURDIS cursor displacement on current line;
        jsr     LFF88;
        jmp     LF8D2;
SCREEN: sta     NEWCHPK		; $F836 - SCREEN - new screen handler;
							; $0202 NEWCHR park for new char for SCREEN;
        pha;
        txa;
        pha;
        tya;
        pha;
        lda     NEWCHPK		; $0202 NEWCHR park for new char for SCREEN;
        bne     LF846;
        jmp     LF8D2;
LF846:  ldy     SDELAY		; $0206 SDELAY print-delay value for SCREEN delay is delay-value times approx. 400 machine-cycles (ie times 400 micro-seconds at 1MHz);
        beq     LF84E;
        jsr     DELAY2;
LF84E:  cmp     #$5F		; Underscore;
        beq     LF800;
        cmp     #$0C		; Form Feed;
        bne     LF861;
        jsr     SCOUT;
        jsr     CURHOM;
        stx     CURDIS		; $0200 CURDIS cursor displacement on current line;
        beq     LF8CF;
LF861:  cmp     #$0A		; Line Feed character;
        beq     LF88C;
        cmp     #$1E		; Record Separator;
        beq     LF8E0;
        cmp     #$0B		; Vertical Tab;
        beq     LF87D;
        cmp     #$1A		; SUB key;
        beq     LF8D8;
        cmp     #$0D		; Carriage Return;
        bne     LF87A;
        jsr     LFF6D;
        bne     LF8D2;
LF87A:  sta     OLDCHR		; $0201 OLDCHR stores current character during SCREEN; exits containing char beneath the cursor;
LF87D:  jsr     SCOUT;
        inc     CURDIS		; $0200 CURDIS cursor displacement on current line;
        inx;
        cpx     SWIDTH;
        bmi     LF8CF;
        jsr     LFF70;
LF88C:  jsr     SCOUT;
        ldy     #$02;
        jsr     LFBD2;
        bcs     LF89E;
        ldx     #$03;
        jsr     LFDEE;
        jmp     LF8CF;
LF89E:  jsr     LFE28;
        jsr     CURHOM;
        jsr     LFDEE;
        ldx     SWIDTH;
LF8AA:  jsr     L0227;
        bpl     LF8AA;
        inx;
        jsr     LFDEE;
        ldx     #$03;
        jsr     LFDEE;
        jsr     ENDCHK;
        bcc     LF8AA;
        lda     #$20;
LF8BF:  jsr     L022A;
        bpl     LF8BF;
        ldx     #$01;
LF8C6:  lda     SLTOP,x;
        sta     $0228,x;
        dex;
        bpl     LF8C6;
LF8CF:  jsr     LFF75;
LF8D2:  pla;
        tay;
        pla;
        tax;
        pla;
        rts;
;
LF8D8:  jsr     SCNCLR		;
        sta     OLDCHR		; $0201 OLDCHR stores current character during SCREEN; exits containing char beneath the cursor;
        beq     LF904		;
LF8E0:  lda     #$20		; SPACE
        jsr     LFF8F		;
        jsr     CURHOM		;
LF8E8:  ldx     SWIDTH		;
        lda     #$20		; SPACE
LF8ED:  jsr     L022A		;
        bpl     LF8ED		;
        sta     OLDCHR		; $0201 OLDCHR stores current character during SCREEN; exits containing char beneath the cursor;
        ldy     #$02;
        jsr     LFBD2;
        bcs     LF904;
        ldx     #$03;
        jsr     LFDEE;
        jmp     LF8E8;
LF904:  jsr     CURHOM;
        stx     CURDIS		; $0200 CURDIS cursor displacement on current line;
        beq     LF8D2;
LF90C:  jsr     TWOQAD;
LF90F:  jsr     CRLF;
        jsr     QDDATD;
        jsr     SPCOUT;
        jsr     LFBE0;
        ldx     #$08;
        stx     L00FD;
LF91F:  jsr     SPCOUT;
        jsr     PRBYTE;
        jsr     NOTEND;
        bcs     LF97B;
        jsr     BUMP;
        dec     L00FD;
        bne     LF91F;
        beq     LF90F;
LF933:  jsr     TRIQAD;
        jsr     LFDE4;
        bcs     MSTART;
LF93B:  ldx     $E4			; Break table K register - stack pointer;
        txs;
        lda     $E6			; Break table PCH - high byte of program counter;
        pha;
        lda     $E5			; Break table PCL - low byte of program counter;
        pha;
        lda     $E3			; Break table P register - processor status flags, in hexadecimal form;
        pha;
        lda     $E0			; Break table A register - accumulator;
        ldx     $E1			; Break table X register;
        ldy     $E2			; Break table Y register;
        rti;
LF94E:  ldx     #$03;
LF950:  lda     LFA4B,x;
        sta     USERHI,x	; $0234 USERHI contains location of start of user routine called by machine code monitors U command;
        dex;
        bne     LF950;
        jsr     GETNEW;
        jsr     GETQDE;
        lda     (LOFROM),y	; $00FE LOFROM store current address for most routines the from address in save move;
        sta     $E7;
        tya;
        sta     (LOFROM),y	; $00FE LOFROM store current address for most routines the from address in save move;
        beq     MSTART;
LF968:  jmp     SAVEMC;
LF96B:  dec     $FB;
        bne     LF9E8;
LF96F:  beq     LF90C;
LF971:  rts;
;
LF972:  lda     $FB;
        bne     LF971;
        lda     #$3F;
        jsr     OUTVEC;
LF97B:  ldx     #$28;
        txs;
MSTART: jsr     CRLF		; $F97E MSTART entry to command/address mode;
        ldy     #$00;
        sty     $FB;
        jsr     LFBE0;
LF988:  jsr     GETNEW;
        cmp     #$4D		; 'M';
        beq     LF933;
        cmp     #$52		; 'R';
        beq     LF93B;
        cmp     #$5A		; 'Z';
        beq     LF94E;
        cmp     #$53		; 'S';
        beq     LF968;
        cmp     #$4C		; 'L';
        beq     LF96B;
        cmp     #$55		; 'U';
        bne     LF9D6;
        jmp     (USERLO);
TWOQAD: jsr     GETNEW		; $F9A6 TWOQAD - collect two addresses first stored in (FE) pair, second in (F9);
        jsr     GETQDE;
        jsr     LFBE3;
        ldx     #$00;
LF9B1:  jsr     GETNEW;
        .byte   $2C;
GETQDE: ldx     #$05		; $F9B5 GETQDE - collect address, store in (FE). Note call GETNEW first!;
        jsr     LF9C0;
        jsr     GETNEW;
        .byte   $2C;
GETPRC: ldx     #$03		; $F9BE GETPRC collect hex pair for data byte, store in FC: Note call GETNEW first!;
LF9C0:  jsr     LF9C6;
        jsr     GETNEW;
LF9C6:  cmp     #$2E;
        beq     LF988;
        cmp     #$2F;
        beq     LF9E8;
        jsr     ASCHEX;
        bmi     LF972;
        jmp     ROLSTR;
LF9D6:  cmp     #$54;
        beq     LF96F;
        jsr     GETQDE;
LF9DD:  lda     #$2F;
        jsr     OUTVEC;
        jsr     PRBYTE;
        jsr     SPCOUT;
LF9E8:  jsr     GETNEW;
        cmp     #$47;
        bne     LF9F2;
        jmp     (LOFROM)		; $00FE LOFROM store current address for most routines the from address in save move;
LF9F2:  cmp     #$2C;
        bne     LF9FC;
        jsr     BUMP;
        jmp     LF9E8;
LF9FC:  cmp     #$0A		; Line Feed;
        beq     LFA16;
        cmp     #$0D		; Carriage Return;
        beq     LFA1B;
        cmp     #$5E		; Up arrow;
        beq     LFA21;
        cmp     #$27		; Single quote;
        beq     LFA3A;
        jsr     GETPRC;
        lda     $FC;
        sta     (LOFROM),y	; $00FE LOFROM store current address for most routines the from address in save move;
LFA13:  jmp     LF9E8;
LFA16:  lda     #$0D		; Carriage Return;
        jsr     OUTVEC;
LFA1B:  jsr     BUMP;
        jmp     LFA31;
LFA21:  sec;
        lda     LOFROM		; $00FE LOFROM store current address for most routines the from address in save move;
        sbc     #$01;
        sta     LOFROM		; $00FE LOFROM store current address for most routines the from address in save move;
        lda     $FF;
        sbc     #$00;
        sta     $FF;
DATALN: jsr     CRLF		; $FA2E - DATALN entry to data-mode loop - prints current address and its contents;
LFA31:  jsr     QDDATD;
        jmp     LF9DD;
        jsr     LFEF7;
LFA3A:  jsr     GETNEW;
        cmp     #$27;
        bne     LFA46;
        jsr     LFBE3;
        bne     LFA13;
LFA46:  cmp     #$0D;
        beq     DATALN;
        .byte   $D0;
LFA4B:  .byte   $EB;
        jmp     LFA4F;
LFA4F:  sta     $E0			; Break table A register - accumulator;
        pla;
        pha;
        and     #$10;
        bne     LFA5A;
        lda     $E0			; Break table A register - accumulator;
        rti;
LFA5A:  stx     $E1			; Break table X register;
        sty     $E2			; Break table Y register;
        pla;
        sta     $E3			; Break table P register - processor status flags, in hexadecimal form;
        cld;
        sec;
        pla;
        sbc     #$02;
        sta     $E5			; Break table PCL - low byte of program counter;
        pla;
        sbc     #$00;
        sta     $E6			; Break table PCH - high byte of program counter;
        tsx;
        stx     $E4			; Break table K register - stack pointer;
        ldy     #$00;
        lda     $E7;
        sta     ($E5),y		; Break table PCL - low byte of program counter;
        lda     #$E0		; Break table A register - accumulator;
        sta     LOFROM		; $00FE LOFROM store current address for most routines the from address in save move;
        sty     $FF;
        bne     DATALN;
SAVEMC: jsr     TRIQAD		; $FA7E - SAVEMC;
        jsr     SVVEC;
        jsr     GETCHR;
        jsr     OUTVEC;
        jsr     LFFE3;
        lda     #$2F;
        jsr     OUTVEC;
        bne     LFA97;
LFA94:  jsr     BUMP;
LFA97:  jsr     PRBYTE;
        lda     #$0D;
        jsr     TAPOUT;
        jsr     NOTEND;
        bcc     LFA94;
        lda     $E4			; Break table K register - stack pointer;
        ldx     $E5			; Break table PCL - low byte of program counter;
        sta     LOFROM		; $00FE LOFROM store current address for most routines the from address in save move;
        stx     $FF;
        jsr     LFFE3;
        lda     #$47;
        jsr     OUTVEC;
        jsr     TENULL		;
        sty     BSAVEFL		; $0205 SVFLAG BASIC save flag 0=skip save, 1=enable save to ACIA;
        jmp     MSTART		; entry to command/address mode;
EDITOR: txa					; $FABD - entry to screen editor;
        pha;
        tya;
        pha;
        lda     EDFLAG		; $0204 EDFLAG Editor flag 00-disable edit cursor, ff-enabe edit cursor;
        bpl     LFB1F;
LFAC6:  ldy     ECDISPL		; $022F DISP edit-cursor displacement from start of editors current line;
        lda     CURSLO		; $0231 CURSLO contain start of edit cursors current line on screen;
        sta     $E4			; Break table K register - stack pointer;
        lda     CURSHI		; $0232 CURSHI contain start of edit cursors current line on screen;
        sta     $E5			; Break table PCL - low byte of program counter;
        lda     ($E4),y		; Break table K register - stack pointer;
        sta     CURCHR		; $0230 CURCHR store for char beneath edit cursor;
        lda     #$A1;
        sta     ($E4),y		; Break table K register - stack pointer;
        jsr     GETKEY;
        lda     CURCHR		; $0230 CURCHR store for char beneath edit cursor;
        sta     ($E4),y		; Break table K register - stack pointer;
        lda     SCRTCH		; $0215 SCRTCH returns from GETKEY with final ASCII value of key;
        cmp     #$11;
        beq     LFB13;
        cmp     #$01;
        beq     LFB0D;
        cmp     #$04;
        beq     LFB07;
        cmp     #$13;
        beq     LFB01;
        cmp     #$06;
        bne     LFB22;
        jsr     LFB7C;
        jmp     LFAC6;
LFB01:  jsr     LFE28;
        jmp     LFAC6;
LFB07:  jsr     LFB6B;
        jmp     LFAC6;
LFB0D:  jsr     LFE19;
        jmp     LFAC6;
LFB13:  lda     CURCHR		; $0230 CURCHR store for char beneath edit cursor;
        sta     SCRTCH		; $0215 SCRTCH returns from GETKEY with final ASCII value of key;
        jsr     LFB6B;
        jmp     LFB43;
LFB1F:  jsr     GETKEY;
LFB22:  cmp     #$05;
        bne     LFB43;
        lda     EDFLAG		; $0204 EDFLAG Editor flag 00-disable edit cursor, ff-enabe edit cursor;
        eor     #$FF;
        sta     EDFLAG		; $0204 EDFLAG Editor flag 00-disable edit cursor, ff-enabe edit cursor;
        bpl     LFB1F;
        lda     LTEXT;
        sta     CURSLO		; $0231 CURSLO contain start of edit cursors current line on screen;
        lda     HTEXT;
        sta     CURSHI		; $0232 CURSHI contain start of edit cursors current line on screen;
        ldx     #$00;
        stx     ECDISPL		; $022F DISP edit-cursor displacement from start of editors current line;
        beq     LFAC6;
LFB43:  jmp     LFDD3;
        bit     BLOADFL		; $FB46 - Input vector points to there??? - seems off???;
							; $0203 LDFLAG BASIC load flag 00=no load, FF-load from ACIA;
        bpl     LFB68;
LFB4B:  lda     #$FD;
        sta     $DF00;
        lda     #$10;
        bit     $DF00;
        beq     LFB61;
TAPIN:  lda     ACIAST		; TAPIN - collects char from ACIA exits via EDITOR if SPACE hit.;
        lsr     a;
        bcc     LFB4B;
        lda     ACIADR;
        rts;
;
LFB61:  lda     #$00;
        sta     $FB;
        sta     BLOADFL		; $0203 LDFLAG BASIC load flag 00=no load, FF-load from ACIA;
LFB68:  jmp     EDITOR;
LFB6B:  ldx     SWIDTH;
        cpx     ECDISPL		; $022F DISP edit-cursor displacement from start of editors current line;
        beq     LFB77;
        inc     ECDISPL		; $022F DISP edit-cursor displacement from start of editors current line;
        rts;
;
LFB77:  ldx     #$00;
        stx     ECDISPL		; $022F DISP edit-cursor displacement from start of editors current line;
LFB7C:  clc;
        lda     CURSLO		; $0231 CURSLO contain start of edit cursors current line on screen;
        adc     #$40;
        sta     CURSLO		; $0231 CURSLO contain start of edit cursors current line on screen;
        lda     CURSHI		; $0232 CURSHI contain start of edit cursors current line on screen;
        adc     #$00;
        cmp     #$D4		; DGG was $D8
        bne     LFB90;
        lda     #$D0;
LFB90:  sta     CURSHI		; $0232 CURSHI contain start of edit cursors current line on screen;
LFB93:  rts;
;
        lda     CCFLAG		; $0212 CCFLAG BASIC CTRL-C flag 00-enables CTRL-C break, 01-disables CTRL-C break;
        bne     LFB93;
        lda     #$FE;
        sta     $DF00;
        bit     $DF00;
        bvs     LFB93;
        lda     #$FB;
        sta     $DF00;
        bit     $DF00;
        bvs     LFB93;
        lda     #$03;
        jmp     LA636;
LFBB2:  lsr     $FB;
        .byte   $9B;
        .byte   $FF;
        sty     $FB,x;
LFBB8:  bvs     LFBB8;
        .byte   $7B;
        inc     $8C2F,x		; DGG was $803F
        ;bne     DISK		; $FC00 is DISK;
		.byte   $D0         ; DGG
		.byte   $CC         ; DGG
        .byte   $D3         ; DGG
        lda     LD08C,x;
        sta     LD08C,x;
        dex;
        rts;
;
        brk;
        jsr     LD08C;
        dey;
        .byte   $F9;
ENDCHK:  ldx     SWIDTH		; $FBCF ENDCHK - checks if top or base of screen overshot - it Y=0, carry clear if top overshot, if Y=2, carry set if base overshot;
LFBD2:  sec;
        lda     LTEXT;
        sbc     SLTOP,y;
        lda     HTEXT;
        sbc     SHTOP,y;
        rts;
;
LFBE0:  lda     #$3E;
        .byte   $2C;
LFBE3:  lda     #$2C;
        .byte   $2C;
SPCOUT: lda     #$20		; $FBE6 SPCOUT print ASCII space to display;
        jmp     OUTVEC;
NOTEND: sec					; $FBEB NOTEND compare (FE) with (F9) carry clear if (FE) is less;
        lda     LOFROM		; $00FE LOFROM store current address for most routines the from address in save move;
        sbc     $F9;
        lda     $FF;
        sbc     $FA;
        rts;
;
CRLF:   lda     #$0D		; $FBF5 CRLF print carriage-return/line-feed to display;
        jsr     OUTVEC;
        lda     #$0A;
        jmp     OUTVEC;
        rti;
; Disk stuff follows - may be non-sense code;
DISK:   jsr     LFC0C		; $FC00 DISK entry to disc bootstrap;
        jmp     (L00FD);
        jsr     LFC0C;
        jmp     NEWMON;
LFC0C:  ldy     #$00;
        sty     $C001;
        sty     $C000;
        ldx     #$04;
        stx     $C001;
        sty     $C003;
        dey;
        sty     $C002;
        stx     $C003;
        sty     $C002;
        lda     #$FB;
        bne     LFC33;
LFC2A:  lda     #$02;
        bit     $C000;
        beq     LFC4D;
        lda     #$FF;
LFC33:  sta     $C002;
        jsr     LFCA5;
        and     #$F7;
        sta     $C002;
        jsr     LFCA5;
        ora     #$08;
        sta     $C002;
        ldx     #$18;
        jsr     LFC91;
        beq     LFC2A;
LFC4D:  ldx     #$7F;
        stx     $C002;
        jsr     LFC91;
LFC55:  lda     $C000;
        bmi     LFC55;
LFC5A:  lda     $C000;
        bpl     LFC5A;
        lda     #$03;
        sta     $C010;
        lda     #$58;
        sta     $C010;
        jsr     LFC9C;
        sta     LOFROM		; $00FE LOFROM store current address for most routines the from address in save move;
        tax;
        jsr     LFC9C;
        sta     L00FD;
        jsr     LFC9C;
        sta     $FF;
        ldy     #$00;
LFC7B:  jsr     LFC9C;
        sta     (L00FD),y;
        iny;
        bne     LFC7B;
        inc     LOFROM		; $00FE LOFROM store current address for most routines the from address in save move;
        dec     $FF;
        bne     LFC7B;
        stx     LOFROM		; $00FE LOFROM store current address for most routines the from address in save move;
        lda     #$FF;
        sta     $C002;
        rts;
;
LFC91:  ldy     #$F8;
LFC93:  dey;
        bne     LFC93;
        eor     $FF,x;
        dex;
        bne     LFC91;
        rts;
;
LFC9C:  lda     $C010;
        lsr     a;
        bcc     LFC9C;
        lda     $C011;
LFCA5:  rts;
; Serial stuff;
RSACIA: lda     #$03		; $FCA6 - RSACIA initialize ACIA;
        sta     ACIAST;
        lda     #$11;
        sta     ACIAST;
        rts;
;
TAPOUT: pha					; $FCB1 - output to tape;
LFCB2:  lda     ACIAST;
        lsr     a;
        lsr     a;
        bcc     LFCB2;
        pla;
        sta     ACIADR;
        rts;
;
KEYWRT: eor     #$FF		; $FCBE - KEYWRT write-to-keyboard invert for C1;
        sta     $DF00;
        eor     #$FF;
        rts;
;
KEY2XR: pha					; KEY2XR - read-X-from keyboard invert for C1;
        jsr     KYREAD;
        tax;
        pla;
        dex;
        inx;
        rts;
;
KYREAD: lda     $DF00		; $FCCF - KYREAD - read-A-from-keyboard invert for C1;
        eor     #$FF;
        rts;
;
        cmp     #$5F		; underscore character;
        beq     LFCDC;
        jmp     LA374		; $A374;
LFCDC:  jmp     LA34B;
KDELAY: ldy     #$10		; $FCDF - KDELAY approx. 6500 cycle delayl exits with X and Y registers zero;
DELAY2: ldx     #$40		; $FCE1 - DELAY2 approx 400xY register cycles delay;
LFCE3:  dex;
        bne     LFCE3;
        dey;
        bne     DELAY2;
        rts;
;
PRMPT:  .byte "OSISDOS 2020  S/C/W/M?";
; Scanned keyboard code follows;
; Keyboard consists of ;
GETKEY: txa					; $FD00 - GETKEY wait till key pressed, return with ASCII value in A register;
        pha;
        tya;
        pha;
LFD04:  lda     #$80;
LFD06:  jsr     KEYWRT;
        jsr     KEY2XR;
        bne     LFD13;
        lsr     a;
        bne     LFD06;
        beq     LFD3A;
LFD13:  lsr     a;
        bcc     LFD1F;
        txa;
        and     #$20;
        beq     LFD3A;
        lda     #$1B;
        bne     LFD50;
LFD1F:  jsr     LFE86;
        tya;
        sta     SCRTCH		; $0215 SCRTCH returns from GETKEY with final ASCII value of key;
        asl     a;
        asl     a;
        asl     a;
        sec;
        sbc     SCRTCH		; $0215 SCRTCH returns from GETKEY with final ASCII value of key;
        sta     SCRTCH		; $0215 SCRTCH returns from GETKEY with final ASCII value of key;
        txa;
        lsr     a;
        asl     a;
        jsr     LFE86;
        beq     LFD47;
        lda     #$00;
LFD3A:  sta     LSTCHR		; $0216 LSTCHR pre-shift value of last key left here by GETKEY to test auto-repeat;
LFD3D:  sta     $0213;
        lda     #$02;
        sta     COUNTR		; $0214 COUNTR auto-repeat counter for GETKEY;
        bne     LFD04;
LFD47:  clc;
        tya;
        adc     SCRTCH		; $0215 SCRTCH returns from GETKEY with final ASCII value of key;
        tay;
        lda     LFF3B,y;
LFD50:  cmp     $0213;
        bne     LFD3D;
        dec     COUNTR		; $0214 COUNTR auto-repeat counter for GETKEY;
        beq     LFD5F;
        jsr     KDELAY;
        beq     LFD04;
LFD5F:  ldx     #$64;
        cmp     LSTCHR		; $0216 LSTCHR pre-shift value of last key left here by GETKEY to test auto-repeat;
        bne     LFD68;
        ldx     #$0F;
LFD68:  stx     COUNTR		; $0214 COUNTR auto-repeat counter for GETKEY;
        sta     LSTCHR		; $0216 LSTCHR pre-shift value of last key left here by GETKEY to test auto-repeat;
        cmp     #$21;
        bmi     LFDD0;
        cmp     #$5F;
        beq     LFDD0;
        lda     #$01;
        jsr     KEYWRT;
        jsr     KYREAD;
        sta     SCRTCH		; $0215 SCRTCH returns from GETKEY with final ASCII value of key;
        and     #$01;
        tax;
        lda     SCRTCH		; $0215 SCRTCH returns from GETKEY with final ASCII value of key;
        and     #$06;
        bne     LFDA2;
        bit     $0213;
        bvc     LFDBB;
        txa;
        eor     #$01;
        and     #$01;
        beq     LFDBB;
        lda     #$20;
        bit     SCRTCH		; $0215 SCRTCH returns from GETKEY with final ASCII value of key;
        bvc     LFDC3;
        lda     #$C0;
        bne     LFDC3;
LFDA2:  bit     $0213;
        bvc     LFDAA;
        txa;
        beq     LFDBB;
LFDAA:  ldy     $0213;
        cpy     #$31;
        bcc     LFDB9;
        cpy     #$3C;
        bcs     LFDB9;
        lda     #$F0;
        bne     LFDBB;
LFDB9:  lda     #$10;
LFDBB:  bit     SCRTCH		; $0215 SCRTCH returns from GETKEY with final ASCII value of key;
        bvc     LFDC3;
        clc;
        adc     #$C0;
LFDC3:  clc;
        adc     $0213;
        and     #$7F;
        bit     SCRTCH		; $0215 SCRTCH returns from GETKEY with final ASCII value of key;
        bpl     LFDD0;
        ora     #$80;
LFDD0:  sta     SCRTCH		; $0215 SCRTCH returns from GETKEY with final ASCII value of key;
LFDD3:  pla;
        tay;
        pla;
        tax;
        lda     SCRTCH		; $0215 SCRTCH returns from GETKEY with final ASCII value of key;
        rts;
;
LFDDB:  jsr     BUMP;
        inc     $E4			; Break table K register - stack pointer;
        bne     LFDE4;
        inc     $E5			; Break table PCL - low byte of program counter;
LFDE4:  lda     (LOFROM),y	; $FDE4 SWAP memory block move. Expects start address in (FE), end address in (F9), new start of block in (E4) assumes Y=0;
        sta     ($E4),y		; Break table K register - stack pointer;
        jsr     NOTEND;
        bcc     LFDDB;
        rts;
;
LFDEE:  clc;
        lda     #$40;
        adc     $0228,x;
        sta     $0228,x;
        lda     #$00;
        adc     $0229,x;
        sta     $0229,x;
        rts;
;
NEWMON: ldx     #$28		; $FE00 NEWMON entry to m/c monitor - reset stack, vectors/pointers, clear decimal mode. Recommended re-entry point for auto-load m/c tapes.;
        txs;
        cld;
        jsr     RSACIA;
        jsr     LFE40;
        nop;
        nop;
MENTRY: jsr     SCNCLR		; $FE0C MENTRY non-reset entry to m/c monitor - clear screen, zero 'current address';
        sta     OLDCHR		; $0201 OLDCHR stores current character during SCREEN; exits containing char beneath the cursor;
        sty     LOFROM		; $00FE LOFROM store current address for most routines the from address in save move;
        sty     $FF;
        jmp     MSTART;
LFE19:  ldx     ECDISPL		; $022F DISP edit-cursor displacement from start of editors current line;
        beq     LFE22;
        dec     ECDISPL		; $022F DISP edit-cursor displacement from start of editors current line;
        rts;
;
LFE22:  ldx     SWIDTH		;
        stx     ECDISPL		; $022F DISP edit-cursor displacement from start of editors current line;
LFE28:  sec					;
        lda     CURSLO		; $0231 CURSLO contain start of edit cursors current line on screen;
        sbc     #$40		;
        sta     CURSLO		; $0231 CURSLO contain start of edit cursors current line on screen;
        lda     CURSHI		; $0232 CURSHI contain start of edit cursors current line on screen;
        sbc     #$00		;
        cmp     #$CF		;
        bne     LFE3C		;
        lda     #$D3;		; DGG was $D7 - related to C1P screen size
LFE3C:  sta     CURSHI		; $0232 CURSHI contain start of edit cursors current line on screen;
        rts					;
;
LFE40:  ldy     #$1C		;
LFE42:  lda     LFBB2,y		;
        sta     BINVECT,y	;
        dey					;
        bpl     LFE42		;
        ldy     #$07		;
        lda     #$00		;
        sta     CCFLAG		; $0212 CCFLAG BASIC CTRL-C flag 00-enables CTRL-C break, 01-disables CTRL-C break;
LFE52:  sta     $01FF,y		;
        dey					;
        bne     LFE52		;
        rts					;
; Screen clear routine - fill video RAM with spaces
SCNCLR: ldy     #$00		; ($FE59) Clear entire screen; exits with X and Y registers zero.;
        sty     $F9			;
        lda     #$D0		;
        sta     $FA			;
        ldx     #$04		; DGG was $08
        lda     #$20		; SPACE character
LFE65:  sta     ($F9),y		;
        iny					;
        bne     LFE65		;
        inc     $FA			;
        dex					;
        bne     LFE65		;
        rts					;
;
        pha;
        dec     BLOADFL		; $0203 LDFLAG BASIC load flag 00=no load, FF-load from ACIA;
        lda     #$00;
LFE76:  sta     BSAVEFL		; $0205 SVFLAG BASIC save flag 0=skip save, 1=enable save to ACIA;
        pla;
        rts;
;
        pha;
        lda     #$01;
        bne     LFE76;
MCACIA: jsr     TAPIN		; $FE80 MCACIA get char from ACIA, strip off top bit before returning;
        and     #$7F;
        rts;
;
LFE86:  ldy     #$08;
LFE88:  dey;
        asl     a;
        bcc     LFE88;
        rts;
;
GETNEW: jsr     GETCHR		; $FE8D GETNEW get new char; print it to display before returning;
        jmp     OUTVEC;
ASCHEX: cmp     #$30		; $FE93 - ASCHEX strip ASCII digit to hex set to 80(base16) if not hex;
        bmi     LFEA9;
        cmp     #$3A;
        bmi     LFEA6;
        cmp     #$41;
        bmi     LFEA9;
        cmp     #$47;
        bpl     LFEA9;
        sec;
        sbc     #$07;
LFEA6:  and     #$0F;
        rts;
;
LFEA9:  lda     #$80;
        rts;
;
ADVTOD: jsr     QDDATD		; $FEAC ADVTOD print address in (FE), space, value in FC to display;
        nop;
        nop;
        jsr     SPCOUT;
        bne     PRDATD;
QDDATD: ldx     #$03		; $FEB6 QDDATD print address in (FE) to display;
        jsr     LFEBF;
        dex;
        .byte   $2C;
PRDATD: ldx     #$00		; $FEBD PRDATD print data byte in FC to display;
LFEBF:  lda     $FC,x;
        lsr     a;
        lsr     a;
        lsr     a;
        lsr     a;
        jsr     HEXOUT;
        lda     $FC,x;
HEXOUT: and     #$0F		; $FECA HEXOUT strip bute in A register to lower nibble; print nibble as ASCII hex to display;
        ora     #$30;
        cmp     #$3A;
        bmi     LFED5;
        clc;
        adc     #$07;
LFED5:  jmp     OUTVEC;
        nop;
        nop;
ROLSTR: ldy     #$04		; $FEDA ROLSRT roll new nibble into (FE) if X=2, or into FC if X=0;
        asl     a;
        asl     a;
        asl     a;
        asl     a;
LFEE0:  rol     a;
        rol     $F9,x;
        rol     $FA,x;
        dey;
        bne     LFEE0;
        rts;
;
GETCHR: lda     $FB			; $FEE9 - GETCHR get char from keyboard or ACIA;
        bne     MCACIA;
        jmp     GETKEY;
PRBYTE: lda     (LOFROM),y	; $FEF0 PRBYTE print data at current address pointed to by (FE) to display. Assumes Y=0!;
        sta     $FC;
        jmp     PRDATD;
LFEF7:  sta     (LOFROM),y	; $00FE LOFROM store current address for most routines the from address in save move;
BUMP:   inc     LOFROM		; $FEF9 BUMP increment current address at (FE);
							; $00FE LOFROM store current address for most routines the from address in save move;
        bne     LFEFF;
        inc     $FF;
LFEFF:  rts;
; Original monitor ROM started here;
RESET:  cld					; $FF00 RESET start of BREAK/RESET routine. SUPPORT ROM: Clear decimal mode;
        ldx     #$28		; Initialize stack to $28;
        txs					;
        jsr     RSACIA		; Initialize 6850 ACIA;
        jsr     LFE40		;
        jsr     SCNCLR		; clear the screen;
        sty		CURDIS		; DGG patched to match
LFF10:  lda     PRMPT,y;
        jsr     OUTVEC;
        iny					;
        cpy     #$16;
        bne     LFF10		;
							; Get S/C/W/M selection
        jsr     INVEC		; Input vector;
        and     #$DF		; Make upper case
        cmp     #'S'		; S/C/W/M selection;
        bne     LFF27		;
        jmp     PRPRPT		; DFF Jump to new handler for SD cards 
LFF27:  cmp     #'M';
        bne     LFF2E;
        jmp     NEWMON;
LFF2E:  cmp     #'W';
        bne     LFF35;
        jmp     L0000;
LFF35:  cmp     #'C';
        bne     RESET;
        .byte   $4C;
        .byte   $11;
LFF3B:  .byte   $BD;
        .byte   "P;/ ZAQ,MNBVCXKJHGFDSIUYTREW";
        .byte $00, $00, $0D, $0A, 'O';
        jmp     L002E;
        .byte   "_-:0987654321";
LFF6D:  jsr     SCOUT;
LFF70:  ldx     #$00;
        stx     CURDIS		; $0200 CURDIS cursor displacement on current line;
LFF75:  ldx     CURDIS		; $0200 CURDIS cursor displacement on current line;
        lda     #$BD;
        sta     L022A;
        jsr     L022A;
        sta     OLDCHR		; $0201 OLDCHR stores current character during SCREEN; exits containing char beneath the cursor;
        lda     #$9D;
        sta     L022A;
LFF88:  lda     #$5F;
        bne     LFF8F;
SCOUT:  lda     OLDCHR		; SCOUT - print chr at cursor location;
							; $0201 OLDCHR stores current character during SCREEN; exits containing char beneath the cursor;
LFF8F:  ldx     CURDIS		; $0200 CURDIS cursor displacement on current line;
        jmp     L022A;
        jsr     LBF2D;
        jmp     LFF9E;
        jsr     SCREEN		; $F836 is SCREEN - new screen handler;
LFF9E:  pha;
        lda     BSAVEFL		; $0205 SVFLAG BASIC save flag 0=skip save, 1=enable save to ACIA;
        beq     LFFBB;
        pla;
        jsr     TAPOUT;
        cmp     #$0D;
        bne     LFFBC;
TENULL:  pha;
        txa;
        pha;
        ldx     #$0A;
        lda     #$00;
LFFB3:  jsr     TAPOUT;
        dex;
        bne     LFFB3;
        pla;
        tax;
LFFBB:  pla;
LFFBC:  rts;
;
TRIQAD: jsr     TWOQAD		; $FFBD - TRIQAD - Collect three address, first stored in (FE) pair, second in (F9), and third in (E4);
        jsr     LFBE0		;
        ldx     #$03		;
        jsr     LF9B1		;
        lda     $FC			;
        ldx     L00FD		;
        sta     $E4			; Break table K register - stack pointer;
        stx     $E5			; Break table PCL - low byte of program counter;
        rts;
;
CURHOM: ldx     #$02		; $FFD1 CURHOM - resets TEXT line pointer to TOP - do STX $0200 to reset cursor at top;
LFFD3:  lda     SWIDTH,x		;
        sta     L0227,x		;
        sta     L022A,x		;
        dex					;
        bne     LFFD3		;
        rts					;
		.byte	$CC			; DGG - replaced stuff
		.byte	$2F
		.byte	$00
LFFE3:  lda     #$2E;
        jsr     OUTVEC;
        jmp     QDDATD;
INVEC:  jmp     (BINVECT)		; $FFEB = INVEC - normally points to INPUT $FB46;
OUTVEC: jmp     (BOUTVEC)		; $FFEE = OUTVEC - normally points to OUTPUT $FF9B;
CCVEC:  jmp     (BCTLCVC)		; $FFF1 = CCVEC - normally points to CTRLC $FB94;
LDVEC:  jmp     (BLDVECT)		; $FFF4 = LDVEC - normally points to SETLOD $FE70;
SVVEC:  jmp     (BSAVECT)		; $FFF7 = SVVEC - normally points to SETSAV $FE7B;
        .word   $0130       ; NMI vector;
        .word   RESET       ; Reset vector;
        .word   $01C0       ; BRK/IRQ vector;
