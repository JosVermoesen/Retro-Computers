ca65 V2.17 - Git de519b9
Main file   : cegmon.s
Current file: cegmon.s

000000r 1               ; Source for CEGMON monitor.;
000000r 1               ; Was generated by disassembling ROM image.;
000000r 1               ; Original content (c) 1980 George Chkintz, Richard Elen, Tom Graves;
000000r 1               ; Found on the Internet at: ;
000000r 1               ; https://raw.githubusercontent.com/jefftranter/6502/master/asm/OSI/cegmon.s;
000000r 1               ;;
000000r 1               ; DGG 2019-04-11 - Added labels from CEGMON users guide found at:;
000000r 1               ; http://uk101.sourceforge.net/docs/pdf/cegmon.pdf;
000000r 1               ; ;
000000r 1               ; Assemble using AS65 (from the CC65 suite);
000000r 1               ;	https://cc65.github.io/doc/ca65.html;
000000r 1               ; Command line:;
000000r 1               ;	retroassembler.exe cegmon.s -O=bin
000000r 1               ;
000000r 1               ; Page zero defines
000000r 1               L0000           := $0000;
000000r 1               L002E           := $002E;
000000r 1               L00FD           := $00FD;
000000r 1               L00FE           := $00FE	; $00FE LOFROM store current address for most routines the from address in save move and tabular display;
000000r 1               
000000r 1               ; CEGMON uses BASIC flags and routines for I/O;
000000r 1               CURDIS			:= $0200	; Cursor displacement on current line;
000000r 1               OLDCHR			:= $0201	; Stores current character during SCREEN; exits containing char beneath the cursor;
000000r 1               NEWCHPK			:= $0202	; Park for new char for SCREEN;
000000r 1               BLOADFL         := $0203	; BASIC Load Flag ($80 means load from tape);
000000r 1               EDFLAG			:= $0204	; EDFLAG Editor flag 00-disable edit cursor, ff-enabe edit cursor;
000000r 1               BSAVEFL         := $0205	; BASIC Save Flag (0 means not SAVE mode);
000000r 1               SDELAY 			:= $0206 	; Print-delay value for SCREEN delay is delay-value times approx. 400 machine-cycles (ie times 400 micro-seconds at 1MHz);
000000r 1               CCFLAG			:= $0212 	; BASIC CTRL-C flag 00-enables CTRL-C break, 01-disables CTRL-C break;
000000r 1               COUNTR			:= $0214 	; Auto-repeat counter for GETKEY;
000000r 1               SCRTCH			:= $0215	; Returns from GETKEY with final ASCII value of key;
000000r 1               LSTCHR			:= $0216 	; Pre-shift value of last key left here by GETKEY to test auto-repeat;
000000r 1               BINVECT         := $0218	; BASIC Input Vector;
000000r 1               BOUTVEC			:= $021A	; BASIC Output Vector;
000000r 1               BCTLCVC			:= $021C	; BASIC CTRL-C Check Vector;
000000r 1               BLDVECT			:= $021E	; BASIC Load Vector;
000000r 1               BSAVECT			:= $0220	; BASIC Save Vector;
000000r 1               L0227           := $0227
000000r 1               L022A           := $022A
000000r 1               ECDISPL			:= $022F 	; DISP edit-cursor displacement from start of editors current line;
000000r 1               CURCHR			:= $0230 	; Store for char beneath edit cursor;
000000r 1               CURSLO			:= $0231	; Contains start of edit cursors current line on screen;
000000r 1               CURSHI			:= $0232  	; Contains start of edit cursors current line on screen;
000000r 1               USERLO          := $0233	; Location of start of user routine called by machine code monitors U command;
000000r 1               USERHI			:= $01BF 	; Location of start of user routine called by machine code monitors U command;
000000r 1               ;
000000r 1               L2F44           := $2F44	;
000000r 1               L415A           := $415A	;
000000r 1               ; BASIC-in-ROM addresses
000000r 1               LA34B           := $A34B	;
000000r 1               LA374           := $A374	;
000000r 1               LA636           := $A636	;
000000r 1               LBF2D           := $BF2D	; CRT routine
000000r 1               ; Video RAM addresses;
000000r 1               LD08C           := $D08C
000000r 1               ; ACIA addresses;
000000r 1               ACIAST			:= $F000	; ACIA Status Register;
000000r 1               ACIADR			:= $F001	; ACIA Data Register;
000000r 1               
000000r 1               ; Reserve first 256 ($F000-$F0FF) locations for I/O
000000r 1                       .org $F000				; peripheral space
00F000  1  00           		.byte 0					; Reserve space with placeholder - fills the following with 0's
00F001  1               
00F001  1               ;
00F001  1               ; Start of ROM code;
00F001  1               		.org $F100
00F100  1               
00F100  1               ; The SDLBA registers are used like this:
00F100  1               ;
00F100  1               ; 31 30 29 28.27 26 25 24.23 22 21 20.19 18 17 16.15 14 13 12.11 10 09 08.07 06 05 04.03 02 01 00
00F100  1               ;  0  0  0  0  0  0  0  0 ------- SDLBA2 --------+------- SDLBA1 --------+------- SDLBA0 -------+
00F100  1               ;
00F100  1               ; The end result of all this is that the addressing looks the same for SDSC and SDHC cards.
00F100  1               ;
00F100  1               ; SDSTATUS (RO)
00F100  1               ;    b7     Write Data Byte can be accepted
00F100  1               ;    b6     Read Data Byte available
00F100  1               ;    b5     Block Busy
00F100  1               ;    b4     Init Busy
00F100  1               ;    b3     Unused. Read 0
00F100  1               ;    b2     Unused. Read 0
00F100  1               ;    b1     Unused. Read 0
00F100  1               ;    b0     Unused. Read 0
00F100  1               ;
00F100  1               ; SDCONTROL (WO)
00F100  1               ;    b7:0   0x00 Read block
00F100  1               ;           0x01 Write block
00F100  1               
00F100  1               ; Prompt for sector number
00F100  1               
00F100  1  20 59 FE     PRPRPT: jsr     SCNCLR			; clear the screen;
00F103  1  A0 00        		ldy		#0
00F105  1  8C 00 02             sty		CURDIS			;
00F108  1  B9 16 F1     LOOPY:	lda     LBA2PR,y		;
00F10B  1  20 EE FF     		jsr     OUTVEC			;
00F10E  1  C8                   iny						;
00F10F  1  C0 0D                cpy     #$0D			;
00F111  1  D0 F5                bne     LOOPY			;
00F113  1  4C 13 F1     L4VR:	jmp		L4VR
00F116  1               
00F116  1  53 65 63 74  LBA2PR:  .byte "Sector LBA2? ";
00F11A  1  6F 72 20 4C  
00F11E  1  42 41 32 3F  
00F123  1  53 65 63 74  LBA1PR:  .byte "Sector LBA1? ";
00F127  1  6F 72 20 4C  
00F12B  1  42 41 31 3F  
00F130  1  53 65 63 74  LBA0PR:  .byte "Sector LBA0? ";
00F134  1  6F 72 20 4C  
00F138  1  42 41 30 3F  
00F13D  1               
00F13D  1               ; Start of CEGMON code
00F13D  1               ; Original monitor started at $FF00 (RESET)
00F13D  1               
00F13D  1                       .org $F800
00F800  1               
00F800  1  A5 0E        LF800:  lda     $0E
00F802  1  F0 06                beq     LF80A
00F804  1  C6 0E                dec     $0E
00F806  1  F0 02                beq     LF80A
00F808  1  C6 0E                dec     $0E
00F80A  1  A9 20        LF80A:  lda     #$20		; SPACE char to fill screen;
00F80C  1  8D 01 02             sta     OLDCHR		; $0201 OLDCHR stores current character during SCREEN
00F80F  1               							; exits containing char beneath the cursor;
00F80F  1  20 8F FF             jsr     LFF8F;
00F812  1  10 19                bpl     LF82D;
00F814  1  38                   sec;
00F815  1  AD 2B 02             lda     $022B;
00F818  1  E9 40                sbc     #$40;
00F81A  1  8D 2B 02             sta     $022B;
00F81D  1  AD 2C 02             lda     $022C;
00F820  1  E9 00                sbc     #$00;
00F822  1  8D 2C 02             sta     $022C;
00F825  1  20 CF FB             jsr     ENDCHK;
00F828  1  B0 03                bcs     LF82D;
00F82A  1  20 D1 FF             jsr     CURHOM;
00F82D  1  8E 00 02     LF82D:  stx     CURDIS		; $0200 CURDIS cursor displacement on current line;
00F830  1  20 88 FF             jsr     LFF88;
00F833  1  4C D2 F8             jmp     LF8D2;
00F836  1  8D 02 02     SCREEN: sta     NEWCHPK		; $F836 - SCREEN - new screen handler;
00F839  1               							; $0202 NEWCHR park for new char for SCREEN;
00F839  1  48                   pha;
00F83A  1  8A                   txa;
00F83B  1  48                   pha;
00F83C  1  98                   tya;
00F83D  1  48                   pha;
00F83E  1  AD 02 02             lda     NEWCHPK		; $0202 NEWCHR park for new char for SCREEN;
00F841  1  D0 03                bne     LF846;
00F843  1  4C D2 F8             jmp     LF8D2;
00F846  1  AC 06 02     LF846:  ldy     SDELAY		; $0206 SDELAY print-delay value for SCREEN delay is delay-value times approx. 400 machine-cycles (ie times 400 micro-seconds at 1MHz);
00F849  1  F0 03                beq     LF84E;
00F84B  1  20 E1 FC             jsr     DELAY2;
00F84E  1  C9 5F        LF84E:  cmp     #$5F		; Underscore;
00F850  1  F0 AE                beq     LF800;
00F852  1  C9 0C                cmp     #$0C		; Form Feed;
00F854  1  D0 0B                bne     LF861;
00F856  1  20 8C FF             jsr     SCOUT;
00F859  1  20 D1 FF             jsr     CURHOM;
00F85C  1  8E 00 02             stx     CURDIS		; $0200 CURDIS cursor displacement on current line;
00F85F  1  F0 6E                beq     LF8CF;
00F861  1  C9 0A        LF861:  cmp     #$0A		; Line Feed character;
00F863  1  F0 27                beq     LF88C;
00F865  1  C9 1E                cmp     #$1E		; Record Separator;
00F867  1  F0 77                beq     LF8E0;
00F869  1  C9 0B                cmp     #$0B		; Vertical Tab;
00F86B  1  F0 10                beq     LF87D;
00F86D  1  C9 1A                cmp     #$1A		; SUB key;
00F86F  1  F0 67                beq     LF8D8;
00F871  1  C9 0D                cmp     #$0D		; Carriage Return;
00F873  1  D0 05                bne     LF87A;
00F875  1  20 6D FF             jsr     LFF6D;
00F878  1  D0 58                bne     LF8D2;
00F87A  1  8D 01 02     LF87A:  sta     OLDCHR		; $0201 OLDCHR stores current character during SCREEN; exits containing char beneath the cursor;
00F87D  1  20 8C FF     LF87D:  jsr     SCOUT;
00F880  1  EE 00 02             inc     CURDIS		; $0200 CURDIS cursor displacement on current line;
00F883  1  E8                   inx;
00F884  1  EC 22 02             cpx     $0222;
00F887  1  30 46                bmi     LF8CF;
00F889  1  20 70 FF             jsr     LFF70;
00F88C  1  20 8C FF     LF88C:  jsr     SCOUT;
00F88F  1  A0 02                ldy     #$02;
00F891  1  20 D2 FB             jsr     LFBD2;
00F894  1  B0 08                bcs     LF89E;
00F896  1  A2 03                ldx     #$03;
00F898  1  20 EE FD             jsr     LFDEE;
00F89B  1  4C CF F8             jmp     LF8CF;
00F89E  1  20 28 FE     LF89E:  jsr     LFE28;
00F8A1  1  20 D1 FF             jsr     CURHOM;
00F8A4  1  20 EE FD             jsr     LFDEE;
00F8A7  1  AE 22 02             ldx     $0222;
00F8AA  1  20 27 02     LF8AA:  jsr     L0227;
00F8AD  1  10 FB                bpl     LF8AA;
00F8AF  1  E8                   inx;
00F8B0  1  20 EE FD             jsr     LFDEE;
00F8B3  1  A2 03                ldx     #$03;
00F8B5  1  20 EE FD             jsr     LFDEE;
00F8B8  1  20 CF FB             jsr     ENDCHK;
00F8BB  1  90 ED                bcc     LF8AA;
00F8BD  1  A9 20                lda     #$20;
00F8BF  1  20 2A 02     LF8BF:  jsr     L022A;
00F8C2  1  10 FB                bpl     LF8BF;
00F8C4  1  A2 01                ldx     #$01;
00F8C6  1  BD 23 02     LF8C6:  lda     $0223,x;
00F8C9  1  9D 28 02             sta     $0228,x;
00F8CC  1  CA                   dex;
00F8CD  1  10 F7                bpl     LF8C6;
00F8CF  1  20 75 FF     LF8CF:  jsr     LFF75;
00F8D2  1  68           LF8D2:  pla;
00F8D3  1  A8                   tay;
00F8D4  1  68                   pla;
00F8D5  1  AA                   tax;
00F8D6  1  68                   pla;
00F8D7  1  60                   rts;
00F8D8  1               ;
00F8D8  1  20 59 FE     LF8D8:  jsr     SCNCLR		;
00F8DB  1  8D 01 02             sta     OLDCHR		; $0201 OLDCHR stores current character during SCREEN; exits containing char beneath the cursor;
00F8DE  1  F0 24                beq     LF904		;
00F8E0  1  A9 20        LF8E0:  lda     #$20		; SPACE
00F8E2  1  20 8F FF             jsr     LFF8F		;
00F8E5  1  20 D1 FF             jsr     CURHOM		;
00F8E8  1  AE 22 02     LF8E8:  ldx     $0222		;
00F8EB  1  A9 20                lda     #$20		; SPACE
00F8ED  1  20 2A 02     LF8ED:  jsr     L022A		;
00F8F0  1  10 FB                bpl     LF8ED		;
00F8F2  1  8D 01 02             sta     OLDCHR		; $0201 OLDCHR stores current character during SCREEN; exits containing char beneath the cursor;
00F8F5  1  A0 02                ldy     #$02;
00F8F7  1  20 D2 FB             jsr     LFBD2;
00F8FA  1  B0 08                bcs     LF904;
00F8FC  1  A2 03                ldx     #$03;
00F8FE  1  20 EE FD             jsr     LFDEE;
00F901  1  4C E8 F8             jmp     LF8E8;
00F904  1  20 D1 FF     LF904:  jsr     CURHOM;
00F907  1  8E 00 02             stx     CURDIS		; $0200 CURDIS cursor displacement on current line;
00F90A  1  F0 C6                beq     LF8D2;
00F90C  1  20 A6 F9     LF90C:  jsr     TWOQAD;
00F90F  1  20 F5 FB     LF90F:  jsr     CRLF;
00F912  1  20 B6 FE             jsr     QDDATD;
00F915  1  20 E6 FB             jsr     SPCOUT;
00F918  1  20 E0 FB             jsr     LFBE0;
00F91B  1  A2 08                ldx     #$08;
00F91D  1  86 FD                stx     L00FD;
00F91F  1  20 E6 FB     LF91F:  jsr     SPCOUT;
00F922  1  20 F0 FE             jsr     PRBYTE;
00F925  1  20 EB FB             jsr     NOTEND;
00F928  1  B0 51                bcs     LF97B;
00F92A  1  20 F9 FE             jsr     BUMP;
00F92D  1  C6 FD                dec     L00FD;
00F92F  1  D0 EE                bne     LF91F;
00F931  1  F0 DC                beq     LF90F;
00F933  1  20 BD FF     LF933:  jsr     TRIQAD;
00F936  1  20 E4 FD             jsr     LFDE4;
00F939  1  B0 43                bcs     MSTART;
00F93B  1  A6 E4        LF93B:  ldx     $E4			; Break table K register - stack pointer;
00F93D  1  9A                   txs;
00F93E  1  A5 E6                lda     $E6			; Break table PCH - high byte of program counter;
00F940  1  48                   pha;
00F941  1  A5 E5                lda     $E5			; Break table PCL - low byte of program counter;
00F943  1  48                   pha;
00F944  1  A5 E3                lda     $E3			; Break table P register - processor status flags, in hexadecimal form;
00F946  1  48                   pha;
00F947  1  A5 E0                lda     $E0			; Break table A register - accumulator;
00F949  1  A6 E1                ldx     $E1			; Break table X register;
00F94B  1  A4 E2                ldy     $E2			; Break table Y register;
00F94D  1  40                   rti;
00F94E  1  A2 03        LF94E:  ldx     #$03;
00F950  1  BD 4B FA     LF950:  lda     LFA4B,x;
00F953  1  9D BF 01             sta     USERHI,x	; $0234 USERHI contains location of start of user routine called by machine code monitors U command;
00F956  1  CA                   dex;
00F957  1  D0 F7                bne     LF950;
00F959  1  20 8D FE             jsr     GETNEW;
00F95C  1  20 B5 F9             jsr     GETQDE;
00F95F  1  B1 FE                lda     (L00FE),y	; $00FE LOFROM store current address for most routines the from address in save move;
00F961  1  85 E7                sta     $E7;
00F963  1  98                   tya;
00F964  1  91 FE                sta     (L00FE),y	; $00FE LOFROM store current address for most routines the from address in save move;
00F966  1  F0 16                beq     MSTART;
00F968  1  4C 7E FA     LF968:  jmp     SAVEMC;
00F96B  1  C6 FB        LF96B:  dec     $FB;
00F96D  1  D0 79                bne     LF9E8;
00F96F  1  F0 9B        LF96F:  beq     LF90C;
00F971  1  60           LF971:  rts;
00F972  1               ;
00F972  1  A5 FB        LF972:  lda     $FB;
00F974  1  D0 FB                bne     LF971;
00F976  1  A9 3F                lda     #$3F;
00F978  1  20 EE FF             jsr     OUTVEC;
00F97B  1  A2 28        LF97B:  ldx     #$28;
00F97D  1  9A                   txs;
00F97E  1  20 F5 FB     MSTART: jsr     CRLF		; $F97E MSTART entry to command/address mode;
00F981  1  A0 00                ldy     #$00;
00F983  1  84 FB                sty     $FB;
00F985  1  20 E0 FB             jsr     LFBE0;
00F988  1  20 8D FE     LF988:  jsr     GETNEW;
00F98B  1  C9 4D                cmp     #$4D		; 'M';
00F98D  1  F0 A4                beq     LF933;
00F98F  1  C9 52                cmp     #$52		; 'R';
00F991  1  F0 A8                beq     LF93B;
00F993  1  C9 5A                cmp     #$5A		; 'Z';
00F995  1  F0 B7                beq     LF94E;
00F997  1  C9 53                cmp     #$53		; 'S';
00F999  1  F0 CD                beq     LF968;
00F99B  1  C9 4C                cmp     #$4C		; 'L';
00F99D  1  F0 CC                beq     LF96B;
00F99F  1  C9 55                cmp     #$55		; 'U';
00F9A1  1  D0 33                bne     LF9D6;
00F9A3  1  6C 33 02             jmp     (USERLO);
00F9A6  1  20 8D FE     TWOQAD: jsr     GETNEW		; $F9A6 TWOQAD - collect two addresses first stored in (FE) pair, second in (F9);
00F9A9  1  20 B5 F9             jsr     GETQDE;
00F9AC  1  20 E3 FB             jsr     LFBE3;
00F9AF  1  A2 00                ldx     #$00;
00F9B1  1  20 8D FE     LF9B1:  jsr     GETNEW;
00F9B4  1  2C                   .byte   $2C;
00F9B5  1  A2 05        GETQDE: ldx     #$05		; $F9B5 GETQDE - collect address, store in (FE). Note call GETNEW first!;
00F9B7  1  20 C0 F9             jsr     LF9C0;
00F9BA  1  20 8D FE             jsr     GETNEW;
00F9BD  1  2C                   .byte   $2C;
00F9BE  1  A2 03        GETPRC: ldx     #$03		; $F9BE GETPRC collect hex pair for data byte, store in FC: Note call GETNEW first!;
00F9C0  1  20 C6 F9     LF9C0:  jsr     LF9C6;
00F9C3  1  20 8D FE             jsr     GETNEW;
00F9C6  1  C9 2E        LF9C6:  cmp     #$2E;
00F9C8  1  F0 BE                beq     LF988;
00F9CA  1  C9 2F                cmp     #$2F;
00F9CC  1  F0 1A                beq     LF9E8;
00F9CE  1  20 93 FE             jsr     ASCHEX;
00F9D1  1  30 9F                bmi     LF972;
00F9D3  1  4C DA FE             jmp     ROLSTR;
00F9D6  1  C9 54        LF9D6:  cmp     #$54;
00F9D8  1  F0 95                beq     LF96F;
00F9DA  1  20 B5 F9             jsr     GETQDE;
00F9DD  1  A9 2F        LF9DD:  lda     #$2F;
00F9DF  1  20 EE FF             jsr     OUTVEC;
00F9E2  1  20 F0 FE             jsr     PRBYTE;
00F9E5  1  20 E6 FB             jsr     SPCOUT;
00F9E8  1  20 8D FE     LF9E8:  jsr     GETNEW;
00F9EB  1  C9 47                cmp     #$47;
00F9ED  1  D0 03                bne     LF9F2;
00F9EF  1  6C FE 00             jmp     (L00FE)		; $00FE LOFROM store current address for most routines the from address in save move;
00F9F2  1  C9 2C        LF9F2:  cmp     #$2C;
00F9F4  1  D0 06                bne     LF9FC;
00F9F6  1  20 F9 FE             jsr     BUMP;
00F9F9  1  4C E8 F9             jmp     LF9E8;
00F9FC  1  C9 0A        LF9FC:  cmp     #$0A		; Line Feed;
00F9FE  1  F0 16                beq     LFA16;
00FA00  1  C9 0D                cmp     #$0D		; Carriage Return;
00FA02  1  F0 17                beq     LFA1B;
00FA04  1  C9 5E                cmp     #$5E		; Up arrow;
00FA06  1  F0 19                beq     LFA21;
00FA08  1  C9 27                cmp     #$27		; Single quote;
00FA0A  1  F0 2E                beq     LFA3A;
00FA0C  1  20 BE F9             jsr     GETPRC;
00FA0F  1  A5 FC                lda     $FC;
00FA11  1  91 FE                sta     (L00FE),y	; $00FE LOFROM store current address for most routines the from address in save move;
00FA13  1  4C E8 F9     LFA13:  jmp     LF9E8;
00FA16  1  A9 0D        LFA16:  lda     #$0D		; Carriage Return;
00FA18  1  20 EE FF             jsr     OUTVEC;
00FA1B  1  20 F9 FE     LFA1B:  jsr     BUMP;
00FA1E  1  4C 31 FA             jmp     LFA31;
00FA21  1  38           LFA21:  sec;
00FA22  1  A5 FE                lda     L00FE		; $00FE LOFROM store current address for most routines the from address in save move;
00FA24  1  E9 01                sbc     #$01;
00FA26  1  85 FE                sta     L00FE		; $00FE LOFROM store current address for most routines the from address in save move;
00FA28  1  A5 FF                lda     $FF;
00FA2A  1  E9 00                sbc     #$00;
00FA2C  1  85 FF                sta     $FF;
00FA2E  1  20 F5 FB     DATALN: jsr     CRLF		; $FA2E - DATALN entry to data-mode loop - prints current address and its contents;
00FA31  1  20 B6 FE     LFA31:  jsr     QDDATD;
00FA34  1  4C DD F9             jmp     LF9DD;
00FA37  1  20 F7 FE             jsr     LFEF7;
00FA3A  1  20 8D FE     LFA3A:  jsr     GETNEW;
00FA3D  1  C9 27                cmp     #$27;
00FA3F  1  D0 05                bne     LFA46;
00FA41  1  20 E3 FB             jsr     LFBE3;
00FA44  1  D0 CD                bne     LFA13;
00FA46  1  C9 0D        LFA46:  cmp     #$0D;
00FA48  1  F0 E4                beq     DATALN;
00FA4A  1  D0                   .byte   $D0;
00FA4B  1  EB           LFA4B:  .byte   $EB;
00FA4C  1  4C 4F FA             jmp     LFA4F;
00FA4F  1  85 E0        LFA4F:  sta     $E0			; Break table A register - accumulator;
00FA51  1  68                   pla;
00FA52  1  48                   pha;
00FA53  1  29 10                and     #$10;
00FA55  1  D0 03                bne     LFA5A;
00FA57  1  A5 E0                lda     $E0			; Break table A register - accumulator;
00FA59  1  40                   rti;
00FA5A  1  86 E1        LFA5A:  stx     $E1			; Break table X register;
00FA5C  1  84 E2                sty     $E2			; Break table Y register;
00FA5E  1  68                   pla;
00FA5F  1  85 E3                sta     $E3			; Break table P register - processor status flags, in hexadecimal form;
00FA61  1  D8                   cld;
00FA62  1  38                   sec;
00FA63  1  68                   pla;
00FA64  1  E9 02                sbc     #$02;
00FA66  1  85 E5                sta     $E5			; Break table PCL - low byte of program counter;
00FA68  1  68                   pla;
00FA69  1  E9 00                sbc     #$00;
00FA6B  1  85 E6                sta     $E6			; Break table PCH - high byte of program counter;
00FA6D  1  BA                   tsx;
00FA6E  1  86 E4                stx     $E4			; Break table K register - stack pointer;
00FA70  1  A0 00                ldy     #$00;
00FA72  1  A5 E7                lda     $E7;
00FA74  1  91 E5                sta     ($E5),y		; Break table PCL - low byte of program counter;
00FA76  1  A9 E0                lda     #$E0		; Break table A register - accumulator;
00FA78  1  85 FE                sta     L00FE		; $00FE LOFROM store current address for most routines the from address in save move;
00FA7A  1  84 FF                sty     $FF;
00FA7C  1  D0 B0                bne     DATALN;
00FA7E  1  20 BD FF     SAVEMC: jsr     TRIQAD		; $FA7E - SAVEMC;
00FA81  1  20 F7 FF             jsr     SVVEC;
00FA84  1  20 E9 FE             jsr     GETCHR;
00FA87  1  20 EE FF             jsr     OUTVEC;
00FA8A  1  20 E3 FF             jsr     LFFE3;
00FA8D  1  A9 2F                lda     #$2F;
00FA8F  1  20 EE FF             jsr     OUTVEC;
00FA92  1  D0 03                bne     LFA97;
00FA94  1  20 F9 FE     LFA94:  jsr     BUMP;
00FA97  1  20 F0 FE     LFA97:  jsr     PRBYTE;
00FA9A  1  A9 0D                lda     #$0D;
00FA9C  1  20 B1 FC             jsr     TAPOUT;
00FA9F  1  20 EB FB             jsr     NOTEND;
00FAA2  1  90 F0                bcc     LFA94;
00FAA4  1  A5 E4                lda     $E4			; Break table K register - stack pointer;
00FAA6  1  A6 E5                ldx     $E5			; Break table PCL - low byte of program counter;
00FAA8  1  85 FE                sta     L00FE		; $00FE LOFROM store current address for most routines the from address in save move;
00FAAA  1  86 FF                stx     $FF;
00FAAC  1  20 E3 FF             jsr     LFFE3;
00FAAF  1  A9 47                lda     #$47;
00FAB1  1  20 EE FF             jsr     OUTVEC;
00FAB4  1  20 AC FF             jsr     LFFAC;
00FAB7  1  8C 05 02             sty     BSAVEFL		; $0205 SVFLAG BASIC save flag 0=skip save, 1=enable save to ACIA;
00FABA  1  4C 7E F9             jmp     MSTART		; entry to command/address mode;
00FABD  1  8A           EDITOR: txa					; $FABD - entry to screen editor;
00FABE  1  48                   pha;
00FABF  1  98                   tya;
00FAC0  1  48                   pha;
00FAC1  1  AD 04 02             lda     EDFLAG		; $0204 EDFLAG Editor flag 00-disable edit cursor, ff-enabe edit cursor;
00FAC4  1  10 59                bpl     LFB1F;
00FAC6  1  AC 2F 02     LFAC6:  ldy     ECDISPL		; $022F DISP edit-cursor displacement from start of editors current line;
00FAC9  1  AD 31 02             lda     CURSLO		; $0231 CURSLO contain start of edit cursors current line on screen;
00FACC  1  85 E4                sta     $E4			; Break table K register - stack pointer;
00FACE  1  AD 32 02             lda     CURSHI		; $0232 CURSHI contain start of edit cursors current line on screen;
00FAD1  1  85 E5                sta     $E5			; Break table PCL - low byte of program counter;
00FAD3  1  B1 E4                lda     ($E4),y		; Break table K register - stack pointer;
00FAD5  1  8D 30 02             sta     CURCHR		; $0230 CURCHR store for char beneath edit cursor;
00FAD8  1  A9 A1                lda     #$A1;
00FADA  1  91 E4                sta     ($E4),y		; Break table K register - stack pointer;
00FADC  1  20 00 FD             jsr     GETKEY;
00FADF  1  AD 30 02             lda     CURCHR		; $0230 CURCHR store for char beneath edit cursor;
00FAE2  1  91 E4                sta     ($E4),y		; Break table K register - stack pointer;
00FAE4  1  AD 15 02             lda     SCRTCH		; $0215 SCRTCH returns from GETKEY with final ASCII value of key;
00FAE7  1  C9 11                cmp     #$11;
00FAE9  1  F0 28                beq     LFB13;
00FAEB  1  C9 01                cmp     #$01;
00FAED  1  F0 1E                beq     LFB0D;
00FAEF  1  C9 04                cmp     #$04;
00FAF1  1  F0 14                beq     LFB07;
00FAF3  1  C9 13                cmp     #$13;
00FAF5  1  F0 0A                beq     LFB01;
00FAF7  1  C9 06                cmp     #$06;
00FAF9  1  D0 27                bne     LFB22;
00FAFB  1  20 7C FB             jsr     LFB7C;
00FAFE  1  4C C6 FA             jmp     LFAC6;
00FB01  1  20 28 FE     LFB01:  jsr     LFE28;
00FB04  1  4C C6 FA             jmp     LFAC6;
00FB07  1  20 6B FB     LFB07:  jsr     LFB6B;
00FB0A  1  4C C6 FA             jmp     LFAC6;
00FB0D  1  20 19 FE     LFB0D:  jsr     LFE19;
00FB10  1  4C C6 FA             jmp     LFAC6;
00FB13  1  AD 30 02     LFB13:  lda     CURCHR		; $0230 CURCHR store for char beneath edit cursor;
00FB16  1  8D 15 02             sta     SCRTCH		; $0215 SCRTCH returns from GETKEY with final ASCII value of key;
00FB19  1  20 6B FB             jsr     LFB6B;
00FB1C  1  4C 43 FB             jmp     LFB43;
00FB1F  1  20 00 FD     LFB1F:  jsr     GETKEY;
00FB22  1  C9 05        LFB22:  cmp     #$05;
00FB24  1  D0 1D                bne     LFB43;
00FB26  1  AD 04 02             lda     EDFLAG		; $0204 EDFLAG Editor flag 00-disable edit cursor, ff-enabe edit cursor;
00FB29  1  49 FF                eor     #$FF;
00FB2B  1  8D 04 02             sta     EDFLAG		; $0204 EDFLAG Editor flag 00-disable edit cursor, ff-enabe edit cursor;
00FB2E  1  10 EF                bpl     LFB1F;
00FB30  1  AD 2B 02             lda     $022B;
00FB33  1  8D 31 02             sta     CURSLO		; $0231 CURSLO contain start of edit cursors current line on screen;
00FB36  1  AD 2C 02             lda     $022C;
00FB39  1  8D 32 02             sta     CURSHI		; $0232 CURSHI contain start of edit cursors current line on screen;
00FB3C  1  A2 00                ldx     #$00;
00FB3E  1  8E 2F 02             stx     ECDISPL		; $022F DISP edit-cursor displacement from start of editors current line;
00FB41  1  F0 83                beq     LFAC6;
00FB43  1  4C D3 FD     LFB43:  jmp     LFDD3;
00FB46  1  2C 03 02             bit     BLOADFL		; $FB46 - Input vector points to there??? - seems off???;
00FB49  1               							; $0203 LDFLAG BASIC load flag 00=no load, FF-load from ACIA;
00FB49  1  10 1D                bpl     LFB68;
00FB4B  1  A9 FD        LFB4B:  lda     #$FD;
00FB4D  1  8D 00 DF             sta     $DF00;
00FB50  1  A9 10                lda     #$10;
00FB52  1  2C 00 DF             bit     $DF00;
00FB55  1  F0 0A                beq     LFB61;
00FB57  1  AD 00 F0     TAPIN:  lda     ACIAST		; TAPIN - collects char from ACIA exits via EDITOR if SPACE hit.;
00FB5A  1  4A                   lsr     a;
00FB5B  1  90 EE                bcc     LFB4B;
00FB5D  1  AD 01 F0             lda     ACIADR;
00FB60  1  60                   rts;
00FB61  1               ;
00FB61  1  A9 00        LFB61:  lda     #$00;
00FB63  1  85 FB                sta     $FB;
00FB65  1  8D 03 02             sta     BLOADFL		; $0203 LDFLAG BASIC load flag 00=no load, FF-load from ACIA;
00FB68  1  4C BD FA     LFB68:  jmp     EDITOR;
00FB6B  1  AE 22 02     LFB6B:  ldx     $0222;
00FB6E  1  EC 2F 02             cpx     ECDISPL		; $022F DISP edit-cursor displacement from start of editors current line;
00FB71  1  F0 04                beq     LFB77;
00FB73  1  EE 2F 02             inc     ECDISPL		; $022F DISP edit-cursor displacement from start of editors current line;
00FB76  1  60                   rts;
00FB77  1               ;
00FB77  1  A2 00        LFB77:  ldx     #$00;
00FB79  1  8E 2F 02             stx     ECDISPL		; $022F DISP edit-cursor displacement from start of editors current line;
00FB7C  1  18           LFB7C:  clc;
00FB7D  1  AD 31 02             lda     CURSLO		; $0231 CURSLO contain start of edit cursors current line on screen;
00FB80  1  69 40                adc     #$40;
00FB82  1  8D 31 02             sta     CURSLO		; $0231 CURSLO contain start of edit cursors current line on screen;
00FB85  1  AD 32 02             lda     CURSHI		; $0232 CURSHI contain start of edit cursors current line on screen;
00FB88  1  69 00                adc     #$00;
00FB8A  1  C9 D4                cmp     #$D4		; DGG was $D8
00FB8C  1  D0 02                bne     LFB90;
00FB8E  1  A9 D0                lda     #$D0;
00FB90  1  8D 32 02     LFB90:  sta     CURSHI		; $0232 CURSHI contain start of edit cursors current line on screen;
00FB93  1  60           LFB93:  rts;
00FB94  1               ;
00FB94  1  AD 12 02             lda     CCFLAG		; $0212 CCFLAG BASIC CTRL-C flag 00-enables CTRL-C break, 01-disables CTRL-C break;
00FB97  1  D0 FA                bne     LFB93;
00FB99  1  A9 FE                lda     #$FE;
00FB9B  1  8D 00 DF             sta     $DF00;
00FB9E  1  2C 00 DF             bit     $DF00;
00FBA1  1  70 F0                bvs     LFB93;
00FBA3  1  A9 FB                lda     #$FB;
00FBA5  1  8D 00 DF             sta     $DF00;
00FBA8  1  2C 00 DF             bit     $DF00;
00FBAB  1  70 E6                bvs     LFB93;
00FBAD  1  A9 03                lda     #$03;
00FBAF  1  4C 36 A6             jmp     LA636;
00FBB2  1  46 FB        LFBB2:  lsr     $FB;
00FBB4  1  9B                   .byte   $9B;
00FBB5  1  FF                   .byte   $FF;
00FBB6  1  94 FB                sty     $FB,x;
00FBB8  1  70 FE        LFBB8:  bvs     LFBB8;
00FBBA  1  7B                   .byte   $7B;
00FBBB  1  FE 2F 8C             inc     $8C2F,x		; DGG was $803F
00FBBE  1                       ;bne     DISK		; $FC00 is DISK;
00FBBE  1  D0           		.byte   $D0         ; DGG
00FBBF  1  CC           		.byte   $CC         ; DGG
00FBC0  1  D3                   .byte   $D3         ; DGG
00FBC1  1  BD 8C D0             lda     LD08C,x;
00FBC4  1  9D 8C D0             sta     LD08C,x;
00FBC7  1  CA                   dex;
00FBC8  1  60                   rts;
00FBC9  1               ;
00FBC9  1  00                   brk;
00FBCA  1  20 8C D0             jsr     LD08C;
00FBCD  1  88                   dey;
00FBCE  1  F9                   .byte   $F9;
00FBCF  1  AE 22 02     ENDCHK:  ldx     $0222		; $FBCF ENDCHK - checks if top or base of screen overshot - it Y=0, carry clear if top overshot, if Y=2, carry set if base overshot;
00FBD2  1  38           LFBD2:  sec;
00FBD3  1  AD 2B 02             lda     $022B;
00FBD6  1  F9 23 02             sbc     $0223,y;
00FBD9  1  AD 2C 02             lda     $022C;
00FBDC  1  F9 24 02             sbc     $0224,y;
00FBDF  1  60                   rts;
00FBE0  1               ;
00FBE0  1  A9 3E        LFBE0:  lda     #$3E;
00FBE2  1  2C                   .byte   $2C;
00FBE3  1  A9 2C        LFBE3:  lda     #$2C;
00FBE5  1  2C                   .byte   $2C;
00FBE6  1  A9 20        SPCOUT: lda     #$20		; $FBE6 SPCOUT print ASCII space to display;
00FBE8  1  4C EE FF             jmp     OUTVEC;
00FBEB  1  38           NOTEND: sec					; $FBEB NOTEND compare (FE) with (F9) carry clear if (FE) is less;
00FBEC  1  A5 FE                lda     L00FE		; $00FE LOFROM store current address for most routines the from address in save move;
00FBEE  1  E5 F9                sbc     $F9;
00FBF0  1  A5 FF                lda     $FF;
00FBF2  1  E5 FA                sbc     $FA;
00FBF4  1  60                   rts;
00FBF5  1               ;
00FBF5  1  A9 0D        CRLF:   lda     #$0D		; $FBF5 CRLF print carriage-return/line-feed to display;
00FBF7  1  20 EE FF             jsr     OUTVEC;
00FBFA  1  A9 0A                lda     #$0A;
00FBFC  1  4C EE FF             jmp     OUTVEC;
00FBFF  1  40                   rti;
00FC00  1               ; Disk stuff follows - may be non-sense code;
00FC00  1  20 0C FC     DISK:   jsr     LFC0C		; $FC00 DISK entry to disc bootstrap;
00FC03  1  6C FD 00             jmp     (L00FD);
00FC06  1  20 0C FC             jsr     LFC0C;
00FC09  1  4C 00 FE             jmp     NEWMON;
00FC0C  1  A0 00        LFC0C:  ldy     #$00;
00FC0E  1  8C 01 C0             sty     $C001;
00FC11  1  8C 00 C0             sty     $C000;
00FC14  1  A2 04                ldx     #$04;
00FC16  1  8E 01 C0             stx     $C001;
00FC19  1  8C 03 C0             sty     $C003;
00FC1C  1  88                   dey;
00FC1D  1  8C 02 C0             sty     $C002;
00FC20  1  8E 03 C0             stx     $C003;
00FC23  1  8C 02 C0             sty     $C002;
00FC26  1  A9 FB                lda     #$FB;
00FC28  1  D0 09                bne     LFC33;
00FC2A  1  A9 02        LFC2A:  lda     #$02;
00FC2C  1  2C 00 C0             bit     $C000;
00FC2F  1  F0 1C                beq     LFC4D;
00FC31  1  A9 FF                lda     #$FF;
00FC33  1  8D 02 C0     LFC33:  sta     $C002;
00FC36  1  20 A5 FC             jsr     LFCA5;
00FC39  1  29 F7                and     #$F7;
00FC3B  1  8D 02 C0             sta     $C002;
00FC3E  1  20 A5 FC             jsr     LFCA5;
00FC41  1  09 08                ora     #$08;
00FC43  1  8D 02 C0             sta     $C002;
00FC46  1  A2 18                ldx     #$18;
00FC48  1  20 91 FC             jsr     LFC91;
00FC4B  1  F0 DD                beq     LFC2A;
00FC4D  1  A2 7F        LFC4D:  ldx     #$7F;
00FC4F  1  8E 02 C0             stx     $C002;
00FC52  1  20 91 FC             jsr     LFC91;
00FC55  1  AD 00 C0     LFC55:  lda     $C000;
00FC58  1  30 FB                bmi     LFC55;
00FC5A  1  AD 00 C0     LFC5A:  lda     $C000;
00FC5D  1  10 FB                bpl     LFC5A;
00FC5F  1  A9 03                lda     #$03;
00FC61  1  8D 10 C0             sta     $C010;
00FC64  1  A9 58                lda     #$58;
00FC66  1  8D 10 C0             sta     $C010;
00FC69  1  20 9C FC             jsr     LFC9C;
00FC6C  1  85 FE                sta     L00FE		; $00FE LOFROM store current address for most routines the from address in save move;
00FC6E  1  AA                   tax;
00FC6F  1  20 9C FC             jsr     LFC9C;
00FC72  1  85 FD                sta     L00FD;
00FC74  1  20 9C FC             jsr     LFC9C;
00FC77  1  85 FF                sta     $FF;
00FC79  1  A0 00                ldy     #$00;
00FC7B  1  20 9C FC     LFC7B:  jsr     LFC9C;
00FC7E  1  91 FD                sta     (L00FD),y;
00FC80  1  C8                   iny;
00FC81  1  D0 F8                bne     LFC7B;
00FC83  1  E6 FE                inc     L00FE		; $00FE LOFROM store current address for most routines the from address in save move;
00FC85  1  C6 FF                dec     $FF;
00FC87  1  D0 F2                bne     LFC7B;
00FC89  1  86 FE                stx     L00FE		; $00FE LOFROM store current address for most routines the from address in save move;
00FC8B  1  A9 FF                lda     #$FF;
00FC8D  1  8D 02 C0             sta     $C002;
00FC90  1  60                   rts;
00FC91  1               ;
00FC91  1  A0 F8        LFC91:  ldy     #$F8;
00FC93  1  88           LFC93:  dey;
00FC94  1  D0 FD                bne     LFC93;
00FC96  1  55 FF                eor     $FF,x;
00FC98  1  CA                   dex;
00FC99  1  D0 F6                bne     LFC91;
00FC9B  1  60                   rts;
00FC9C  1               ;
00FC9C  1  AD 10 C0     LFC9C:  lda     $C010;
00FC9F  1  4A                   lsr     a;
00FCA0  1  90 FA                bcc     LFC9C;
00FCA2  1  AD 11 C0             lda     $C011;
00FCA5  1  60           LFCA5:  rts;
00FCA6  1               ; Serial stuff;
00FCA6  1  A9 03        RSACIA: lda     #$03		; $FCA6 - RSACIA initialize ACIA;
00FCA8  1  8D 00 F0             sta     ACIAST;
00FCAB  1  A9 11                lda     #$11;
00FCAD  1  8D 00 F0             sta     ACIAST;
00FCB0  1  60                   rts;
00FCB1  1               ;
00FCB1  1  48           TAPOUT: pha					; $FCB1 - output to tape;
00FCB2  1  AD 00 F0     LFCB2:  lda     ACIAST;
00FCB5  1  4A                   lsr     a;
00FCB6  1  4A                   lsr     a;
00FCB7  1  90 F9                bcc     LFCB2;
00FCB9  1  68                   pla;
00FCBA  1  8D 01 F0             sta     ACIADR;
00FCBD  1  60                   rts;
00FCBE  1               ;
00FCBE  1  49 FF        KEYWRT: eor     #$FF		; $FCBE - KEYWRT write-to-keyboard invert for C1;
00FCC0  1  8D 00 DF             sta     $DF00;
00FCC3  1  49 FF                eor     #$FF;
00FCC5  1  60                   rts;
00FCC6  1               ;
00FCC6  1  48           KEY2XR: pha					; KEY2XR - read-X-from keyboard invert for C1;
00FCC7  1  20 CF FC             jsr     KYREAD;
00FCCA  1  AA                   tax;
00FCCB  1  68                   pla;
00FCCC  1  CA                   dex;
00FCCD  1  E8                   inx;
00FCCE  1  60                   rts;
00FCCF  1               ;
00FCCF  1  AD 00 DF     KYREAD: lda     $DF00		; $FCCF - KYREAD - read-A-from-keyboard invert for C1;
00FCD2  1  49 FF                eor     #$FF;
00FCD4  1  60                   rts;
00FCD5  1               ;
00FCD5  1  C9 5F                cmp     #$5F		; underscore character;
00FCD7  1  F0 03                beq     LFCDC;
00FCD9  1  4C 74 A3             jmp     LA374		; $A374;
00FCDC  1  4C 4B A3     LFCDC:  jmp     LA34B;
00FCDF  1  A0 10        KDELAY: ldy     #$10		; $FCDF - KDELAY approx. 6500 cycle delayl exits with X and Y registers zero;
00FCE1  1  A2 40        DELAY2: ldx     #$40		; $FCE1 - DELAY2 approx 400xY register cycles delay;
00FCE3  1  CA           LFCE3:  dex;
00FCE4  1  D0 FD                bne     LFCE3;
00FCE6  1  88                   dey;
00FCE7  1  D0 F8                bne     DELAY2;
00FCE9  1  60                   rts;
00FCEA  1               ;
00FCEA  1  4F 53 49 53  PRMPT:  .byte "OSISDOS 2020  S/C/W/M?";
00FCEE  1  44 4F 53 20  
00FCF2  1  32 30 32 30  
00FD00  1               ; Scanned keyboard code follows;
00FD00  1               ; Keyboard consists of ;
00FD00  1  8A           GETKEY: txa					; $FD00 - GETKEY wait till key pressed, return with ASCII value in A register;
00FD01  1  48                   pha;
00FD02  1  98                   tya;
00FD03  1  48                   pha;
00FD04  1  A9 80        LFD04:  lda     #$80;
00FD06  1  20 BE FC     LFD06:  jsr     KEYWRT;
00FD09  1  20 C6 FC             jsr     KEY2XR;
00FD0C  1  D0 05                bne     LFD13;
00FD0E  1  4A                   lsr     a;
00FD0F  1  D0 F5                bne     LFD06;
00FD11  1  F0 27                beq     LFD3A;
00FD13  1  4A           LFD13:  lsr     a;
00FD14  1  90 09                bcc     LFD1F;
00FD16  1  8A                   txa;
00FD17  1  29 20                and     #$20;
00FD19  1  F0 1F                beq     LFD3A;
00FD1B  1  A9 1B                lda     #$1B;
00FD1D  1  D0 31                bne     LFD50;
00FD1F  1  20 86 FE     LFD1F:  jsr     LFE86;
00FD22  1  98                   tya;
00FD23  1  8D 15 02             sta     SCRTCH		; $0215 SCRTCH returns from GETKEY with final ASCII value of key;
00FD26  1  0A                   asl     a;
00FD27  1  0A                   asl     a;
00FD28  1  0A                   asl     a;
00FD29  1  38                   sec;
00FD2A  1  ED 15 02             sbc     SCRTCH		; $0215 SCRTCH returns from GETKEY with final ASCII value of key;
00FD2D  1  8D 15 02             sta     SCRTCH		; $0215 SCRTCH returns from GETKEY with final ASCII value of key;
00FD30  1  8A                   txa;
00FD31  1  4A                   lsr     a;
00FD32  1  0A                   asl     a;
00FD33  1  20 86 FE             jsr     LFE86;
00FD36  1  F0 0F                beq     LFD47;
00FD38  1  A9 00                lda     #$00;
00FD3A  1  8D 16 02     LFD3A:  sta     LSTCHR		; $0216 LSTCHR pre-shift value of last key left here by GETKEY to test auto-repeat;
00FD3D  1  8D 13 02     LFD3D:  sta     $0213;
00FD40  1  A9 02                lda     #$02;
00FD42  1  8D 14 02             sta     COUNTR		; $0214 COUNTR auto-repeat counter for GETKEY;
00FD45  1  D0 BD                bne     LFD04;
00FD47  1  18           LFD47:  clc;
00FD48  1  98                   tya;
00FD49  1  6D 15 02             adc     SCRTCH		; $0215 SCRTCH returns from GETKEY with final ASCII value of key;
00FD4C  1  A8                   tay;
00FD4D  1  B9 3B FF             lda     LFF3B,y;
00FD50  1  CD 13 02     LFD50:  cmp     $0213;
00FD53  1  D0 E8                bne     LFD3D;
00FD55  1  CE 14 02             dec     COUNTR		; $0214 COUNTR auto-repeat counter for GETKEY;
00FD58  1  F0 05                beq     LFD5F;
00FD5A  1  20 DF FC             jsr     KDELAY;
00FD5D  1  F0 A5                beq     LFD04;
00FD5F  1  A2 64        LFD5F:  ldx     #$64;
00FD61  1  CD 16 02             cmp     LSTCHR		; $0216 LSTCHR pre-shift value of last key left here by GETKEY to test auto-repeat;
00FD64  1  D0 02                bne     LFD68;
00FD66  1  A2 0F                ldx     #$0F;
00FD68  1  8E 14 02     LFD68:  stx     COUNTR		; $0214 COUNTR auto-repeat counter for GETKEY;
00FD6B  1  8D 16 02             sta     LSTCHR		; $0216 LSTCHR pre-shift value of last key left here by GETKEY to test auto-repeat;
00FD6E  1  C9 21                cmp     #$21;
00FD70  1  30 5E                bmi     LFDD0;
00FD72  1  C9 5F                cmp     #$5F;
00FD74  1  F0 5A                beq     LFDD0;
00FD76  1  A9 01                lda     #$01;
00FD78  1  20 BE FC             jsr     KEYWRT;
00FD7B  1  20 CF FC             jsr     KYREAD;
00FD7E  1  8D 15 02             sta     SCRTCH		; $0215 SCRTCH returns from GETKEY with final ASCII value of key;
00FD81  1  29 01                and     #$01;
00FD83  1  AA                   tax;
00FD84  1  AD 15 02             lda     SCRTCH		; $0215 SCRTCH returns from GETKEY with final ASCII value of key;
00FD87  1  29 06                and     #$06;
00FD89  1  D0 17                bne     LFDA2;
00FD8B  1  2C 13 02             bit     $0213;
00FD8E  1  50 2B                bvc     LFDBB;
00FD90  1  8A                   txa;
00FD91  1  49 01                eor     #$01;
00FD93  1  29 01                and     #$01;
00FD95  1  F0 24                beq     LFDBB;
00FD97  1  A9 20                lda     #$20;
00FD99  1  2C 15 02             bit     SCRTCH		; $0215 SCRTCH returns from GETKEY with final ASCII value of key;
00FD9C  1  50 25                bvc     LFDC3;
00FD9E  1  A9 C0                lda     #$C0;
00FDA0  1  D0 21                bne     LFDC3;
00FDA2  1  2C 13 02     LFDA2:  bit     $0213;
00FDA5  1  50 03                bvc     LFDAA;
00FDA7  1  8A                   txa;
00FDA8  1  F0 11                beq     LFDBB;
00FDAA  1  AC 13 02     LFDAA:  ldy     $0213;
00FDAD  1  C0 31                cpy     #$31;
00FDAF  1  90 08                bcc     LFDB9;
00FDB1  1  C0 3C                cpy     #$3C;
00FDB3  1  B0 04                bcs     LFDB9;
00FDB5  1  A9 F0                lda     #$F0;
00FDB7  1  D0 02                bne     LFDBB;
00FDB9  1  A9 10        LFDB9:  lda     #$10;
00FDBB  1  2C 15 02     LFDBB:  bit     SCRTCH		; $0215 SCRTCH returns from GETKEY with final ASCII value of key;
00FDBE  1  50 03                bvc     LFDC3;
00FDC0  1  18                   clc;
00FDC1  1  69 C0                adc     #$C0;
00FDC3  1  18           LFDC3:  clc;
00FDC4  1  6D 13 02             adc     $0213;
00FDC7  1  29 7F                and     #$7F;
00FDC9  1  2C 15 02             bit     SCRTCH		; $0215 SCRTCH returns from GETKEY with final ASCII value of key;
00FDCC  1  10 02                bpl     LFDD0;
00FDCE  1  09 80                ora     #$80;
00FDD0  1  8D 15 02     LFDD0:  sta     SCRTCH		; $0215 SCRTCH returns from GETKEY with final ASCII value of key;
00FDD3  1  68           LFDD3:  pla;
00FDD4  1  A8                   tay;
00FDD5  1  68                   pla;
00FDD6  1  AA                   tax;
00FDD7  1  AD 15 02             lda     SCRTCH		; $0215 SCRTCH returns from GETKEY with final ASCII value of key;
00FDDA  1  60                   rts;
00FDDB  1               ;
00FDDB  1  20 F9 FE     LFDDB:  jsr     BUMP;
00FDDE  1  E6 E4                inc     $E4			; Break table K register - stack pointer;
00FDE0  1  D0 02                bne     LFDE4;
00FDE2  1  E6 E5                inc     $E5			; Break table PCL - low byte of program counter;
00FDE4  1  B1 FE        LFDE4:  lda     (L00FE),y	; $FDE4 SWAP memory block move. Expects start address in (FE), end address in (F9), new start of block in (E4) assumes Y=0;
00FDE6  1  91 E4                sta     ($E4),y		; Break table K register - stack pointer;
00FDE8  1  20 EB FB             jsr     NOTEND;
00FDEB  1  90 EE                bcc     LFDDB;
00FDED  1  60                   rts;
00FDEE  1               ;
00FDEE  1  18           LFDEE:  clc;
00FDEF  1  A9 40                lda     #$40;
00FDF1  1  7D 28 02             adc     $0228,x;
00FDF4  1  9D 28 02             sta     $0228,x;
00FDF7  1  A9 00                lda     #$00;
00FDF9  1  7D 29 02             adc     $0229,x;
00FDFC  1  9D 29 02             sta     $0229,x;
00FDFF  1  60                   rts;
00FE00  1               ;
00FE00  1  A2 28        NEWMON: ldx     #$28		; $FE00 NEWMON entry to m/c monitor - reset stack, vectors/pointers, clear decimal mode. Recommended re-entry point for auto-load m/c tapes.;
00FE02  1  9A                   txs;
00FE03  1  D8                   cld;
00FE04  1  20 A6 FC             jsr     RSACIA;
00FE07  1  20 40 FE             jsr     LFE40;
00FE0A  1  EA                   nop;
00FE0B  1  EA                   nop;
00FE0C  1  20 59 FE     MENTRY: jsr     SCNCLR		; $FE0C MENTRY non-reset entry to m/c monitor - clear screen, zero 'current address';
00FE0F  1  8D 01 02             sta     OLDCHR		; $0201 OLDCHR stores current character during SCREEN; exits containing char beneath the cursor;
00FE12  1  84 FE                sty     L00FE		; $00FE LOFROM store current address for most routines the from address in save move;
00FE14  1  84 FF                sty     $FF;
00FE16  1  4C 7E F9             jmp     MSTART;
00FE19  1  AE 2F 02     LFE19:  ldx     ECDISPL		; $022F DISP edit-cursor displacement from start of editors current line;
00FE1C  1  F0 04                beq     LFE22;
00FE1E  1  CE 2F 02             dec     ECDISPL		; $022F DISP edit-cursor displacement from start of editors current line;
00FE21  1  60                   rts;
00FE22  1               ;
00FE22  1  AE 22 02     LFE22:  ldx     $0222;
00FE25  1  8E 2F 02             stx     ECDISPL		; $022F DISP edit-cursor displacement from start of editors current line;
00FE28  1  38           LFE28:  sec;
00FE29  1  AD 31 02             lda     CURSLO		; $0231 CURSLO contain start of edit cursors current line on screen;
00FE2C  1  E9 40                sbc     #$40;
00FE2E  1  8D 31 02             sta     CURSLO		; $0231 CURSLO contain start of edit cursors current line on screen;
00FE31  1  AD 32 02             lda     CURSHI		; $0232 CURSHI contain start of edit cursors current line on screen;
00FE34  1  E9 00                sbc     #$00;
00FE36  1  C9 CF                cmp     #$CF;
00FE38  1  D0 02                bne     LFE3C;
00FE3A  1  A9 D3                lda     #$D3;		; DGG was $D7
00FE3C  1  8D 32 02     LFE3C:  sta     CURSHI		; $0232 CURSHI contain start of edit cursors current line on screen;
00FE3F  1  60                   rts;
00FE40  1               ;
00FE40  1  A0 1C        LFE40:  ldy     #$1C;
00FE42  1  B9 B2 FB     LFE42:  lda     LFBB2,y;
00FE45  1  99 18 02             sta     BINVECT,y		;
00FE48  1  88                   dey;
00FE49  1  10 F7                bpl     LFE42;
00FE4B  1  A0 07                ldy     #$07;
00FE4D  1  A9 00                lda     #$00;
00FE4F  1  8D 12 02             sta     CCFLAG		; $0212 CCFLAG BASIC CTRL-C flag 00-enables CTRL-C break, 01-disables CTRL-C break;
00FE52  1  99 FF 01     LFE52:  sta     $01FF,y;
00FE55  1  88                   dey;
00FE56  1  D0 FA                bne     LFE52;
00FE58  1  60                   rts;
00FE59  1               ;
00FE59  1  A0 00        SCNCLR: ldy     #$00		; SCNCLR $FE59 Clear entire screen; exits with X and Y registers zero.;
00FE5B  1  84 F9                sty     $F9;
00FE5D  1  A9 D0                lda     #$D0;
00FE5F  1  85 FA                sta     $FA;
00FE61  1  A2 04                ldx     #$04		; DGG was $08
00FE63  1  A9 20                lda     #$20;
00FE65  1  91 F9        LFE65:  sta     ($F9),y;
00FE67  1  C8                   iny;
00FE68  1  D0 FB                bne     LFE65;
00FE6A  1  E6 FA                inc     $FA;
00FE6C  1  CA                   dex;
00FE6D  1  D0 F6                bne     LFE65;
00FE6F  1  60                   rts;
00FE70  1               ;
00FE70  1  48                   pha;
00FE71  1  CE 03 02             dec     BLOADFL		; $0203 LDFLAG BASIC load flag 00=no load, FF-load from ACIA;
00FE74  1  A9 00                lda     #$00;
00FE76  1  8D 05 02     LFE76:  sta     BSAVEFL		; $0205 SVFLAG BASIC save flag 0=skip save, 1=enable save to ACIA;
00FE79  1  68                   pla;
00FE7A  1  60                   rts;
00FE7B  1               ;
00FE7B  1  48                   pha;
00FE7C  1  A9 01                lda     #$01;
00FE7E  1  D0 F6                bne     LFE76;
00FE80  1  20 57 FB     MCACIA: jsr     TAPIN		; $FE80 MCACIA get char from ACIA, strip off top bit before returning;
00FE83  1  29 7F                and     #$7F;
00FE85  1  60                   rts;
00FE86  1               ;
00FE86  1  A0 08        LFE86:  ldy     #$08;
00FE88  1  88           LFE88:  dey;
00FE89  1  0A                   asl     a;
00FE8A  1  90 FC                bcc     LFE88;
00FE8C  1  60                   rts;
00FE8D  1               ;
00FE8D  1  20 E9 FE     GETNEW: jsr     GETCHR		; $FE8D GETNEW get new char; print it to display before returning;
00FE90  1  4C EE FF             jmp     OUTVEC;
00FE93  1  C9 30        ASCHEX: cmp     #$30		; $FE93 - ASCHEX strip ASCII digit to hex set to 80(base16) if not hex;
00FE95  1  30 12                bmi     LFEA9;
00FE97  1  C9 3A                cmp     #$3A;
00FE99  1  30 0B                bmi     LFEA6;
00FE9B  1  C9 41                cmp     #$41;
00FE9D  1  30 0A                bmi     LFEA9;
00FE9F  1  C9 47                cmp     #$47;
00FEA1  1  10 06                bpl     LFEA9;
00FEA3  1  38                   sec;
00FEA4  1  E9 07                sbc     #$07;
00FEA6  1  29 0F        LFEA6:  and     #$0F;
00FEA8  1  60                   rts;
00FEA9  1               ;
00FEA9  1  A9 80        LFEA9:  lda     #$80;
00FEAB  1  60                   rts;
00FEAC  1               ;
00FEAC  1  20 B6 FE     ADVTOD: jsr     QDDATD		; $FEAC ADVTOD print address in (FE), space, value in FC to display;
00FEAF  1  EA                   nop;
00FEB0  1  EA                   nop;
00FEB1  1  20 E6 FB             jsr     SPCOUT;
00FEB4  1  D0 07                bne     PRDATD;
00FEB6  1  A2 03        QDDATD: ldx     #$03		; $FEB6 QDDATD print address in (FE) to display;
00FEB8  1  20 BF FE             jsr     LFEBF;
00FEBB  1  CA                   dex;
00FEBC  1  2C                   .byte   $2C;
00FEBD  1  A2 00        PRDATD: ldx     #$00		; $FEBD PRDATD print data byte in FC to display;
00FEBF  1  B5 FC        LFEBF:  lda     $FC,x;
00FEC1  1  4A                   lsr     a;
00FEC2  1  4A                   lsr     a;
00FEC3  1  4A                   lsr     a;
00FEC4  1  4A                   lsr     a;
00FEC5  1  20 CA FE             jsr     HEXOUT;
00FEC8  1  B5 FC                lda     $FC,x;
00FECA  1  29 0F        HEXOUT: and     #$0F		; $FECA HEXOUT strip bute in A register to lower nibble; print nibble as ASCII hex to display;
00FECC  1  09 30                ora     #$30;
00FECE  1  C9 3A                cmp     #$3A;
00FED0  1  30 03                bmi     LFED5;
00FED2  1  18                   clc;
00FED3  1  69 07                adc     #$07;
00FED5  1  4C EE FF     LFED5:  jmp     OUTVEC;
00FED8  1  EA                   nop;
00FED9  1  EA                   nop;
00FEDA  1  A0 04        ROLSTR: ldy     #$04		; $FEDA ROLSRT roll new nibble into (FE) if X=2, or into FC if X=0;
00FEDC  1  0A                   asl     a;
00FEDD  1  0A                   asl     a;
00FEDE  1  0A                   asl     a;
00FEDF  1  0A                   asl     a;
00FEE0  1  2A           LFEE0:  rol     a;
00FEE1  1  36 F9                rol     $F9,x;
00FEE3  1  36 FA                rol     $FA,x;
00FEE5  1  88                   dey;
00FEE6  1  D0 F8                bne     LFEE0;
00FEE8  1  60                   rts;
00FEE9  1               ;
00FEE9  1  A5 FB        GETCHR: lda     $FB			; $FEE9 - GETCHR get char from keyboard or ACIA;
00FEEB  1  D0 93                bne     MCACIA;
00FEED  1  4C 00 FD             jmp     GETKEY;
00FEF0  1  B1 FE        PRBYTE: lda     (L00FE),y	; $FEF0 PRBYTE print data at current address pointed to by (FE) to display. Assumes Y=0!;
00FEF2  1  85 FC                sta     $FC;
00FEF4  1  4C BD FE             jmp     PRDATD;
00FEF7  1  91 FE        LFEF7:  sta     (L00FE),y	; $00FE LOFROM store current address for most routines the from address in save move;
00FEF9  1  E6 FE        BUMP:   inc     L00FE		; $FEF9 BUMP increment current address at (FE);
00FEFB  1               							; $00FE LOFROM store current address for most routines the from address in save move;
00FEFB  1  D0 02                bne     LFEFF;
00FEFD  1  E6 FF                inc     $FF;
00FEFF  1  60           LFEFF:  rts;
00FF00  1               ; Original monitor ROM started here;
00FF00  1  D8           RESET:  cld					; $FF00 RESET start of BREAK/RESET routine. SUPPORT ROM: Clear decimal mode;
00FF01  1  A2 28                ldx     #$28		; Initialize stack to $28;
00FF03  1  9A                   txs					;
00FF04  1  20 A6 FC             jsr     RSACIA		; Initialize 6850 ACIA;
00FF07  1  20 40 FE             jsr     LFE40		;
00FF0A  1  20 59 FE             jsr     SCNCLR		; clear the screen;
00FF0D  1  8C 00 02             sty		CURDIS		; DGG patched to match
00FF10  1  B9 EA FC     LFF10:  lda     PRMPT,y;
00FF13  1  20 EE FF             jsr     OUTVEC;
00FF16  1  C8                   iny					;
00FF17  1  C0 16                cpy     #$16;
00FF19  1  D0 F5                bne     LFF10		;
00FF1B  1               							; Get S/C/W/M selection
00FF1B  1  20 EB FF             jsr     INVEC		; Input vector;
00FF1E  1  29 DF                and     #$DF		; Make upper case
00FF20  1  C9 53                cmp     #'S'		; S/C/W/M selection;
00FF22  1  D0 03                bne     LFF27		;
00FF24  1  4C 00 F1             jmp     PRPRPT		; DFF Jump to new handler for SD cards
00FF27  1  C9 4D        LFF27:  cmp     #'M';
00FF29  1  D0 03                bne     LFF2E;
00FF2B  1  4C 00 FE             jmp     NEWMON;
00FF2E  1  C9 57        LFF2E:  cmp     #'W';
00FF30  1  D0 03                bne     LFF35;
00FF32  1  4C 00 00             jmp     L0000;
00FF35  1  C9 43        LFF35:  cmp     #'C';
00FF37  1  D0 C7                bne     RESET;
00FF39  1  4C                   .byte   $4C;
00FF3A  1  11                   .byte   $11;
00FF3B  1  BD           LFF3B:  .byte   $BD;
00FF3C  1  50 3B 2F 20          .byte   "P;/ ZAQ,MNBVCXKJHGFDSIUYTREW";
00FF40  1  5A 41 51 2C  
00FF44  1  4D 4E 42 56  
00FF58  1  00 00 0D 0A          .byte $00, $00, $0D, $0A, 'O';
00FF5C  1  4F           
00FF5D  1  4C 2E 00             jmp     L002E;
00FF60  1  5F 2D 3A 30          .byte   "_-:0987654321";
00FF64  1  39 38 37 36  
00FF68  1  35 34 33 32  
00FF6D  1  20 8C FF     LFF6D:  jsr     SCOUT;
00FF70  1  A2 00        LFF70:  ldx     #$00;
00FF72  1  8E 00 02             stx     CURDIS		; $0200 CURDIS cursor displacement on current line;
00FF75  1  AE 00 02     LFF75:  ldx     CURDIS		; $0200 CURDIS cursor displacement on current line;
00FF78  1  A9 BD                lda     #$BD;
00FF7A  1  8D 2A 02             sta     L022A;
00FF7D  1  20 2A 02             jsr     L022A;
00FF80  1  8D 01 02             sta     OLDCHR		; $0201 OLDCHR stores current character during SCREEN; exits containing char beneath the cursor;
00FF83  1  A9 9D                lda     #$9D;
00FF85  1  8D 2A 02             sta     L022A;
00FF88  1  A9 5F        LFF88:  lda     #$5F;
00FF8A  1  D0 03                bne     LFF8F;
00FF8C  1  AD 01 02     SCOUT:  lda     OLDCHR		; SCOUT - print chr at cursor location;
00FF8F  1               							; $0201 OLDCHR stores current character during SCREEN; exits containing char beneath the cursor;
00FF8F  1  AE 00 02     LFF8F:  ldx     CURDIS		; $0200 CURDIS cursor displacement on current line;
00FF92  1  4C 2A 02             jmp     L022A;
00FF95  1  20 2D BF             jsr     LBF2D;
00FF98  1  4C 9E FF             jmp     LFF9E;
00FF9B  1  20 36 F8             jsr     SCREEN		; $F836 is SCREEN - new screen handler;
00FF9E  1  48           LFF9E:  pha;
00FF9F  1  AD 05 02             lda     BSAVEFL		; $0205 SVFLAG BASIC save flag 0=skip save, 1=enable save to ACIA;
00FFA2  1  F0 17                beq     LFFBB;
00FFA4  1  68                   pla;
00FFA5  1  20 B1 FC             jsr     TAPOUT;
00FFA8  1  C9 0D                cmp     #$0D;
00FFAA  1  D0 10                bne     LFFBC;
00FFAC  1  48           LFFAC:  pha;
00FFAD  1  8A                   txa;
00FFAE  1  48                   pha;
00FFAF  1  A2 0A                ldx     #$0A;
00FFB1  1  A9 00                lda     #$00;
00FFB3  1  20 B1 FC     LFFB3:  jsr     TAPOUT;
00FFB6  1  CA                   dex;
00FFB7  1  D0 FA                bne     LFFB3;
00FFB9  1  68                   pla;
00FFBA  1  AA                   tax;
00FFBB  1  68           LFFBB:  pla;
00FFBC  1  60           LFFBC:  rts;
00FFBD  1               ;
00FFBD  1  20 A6 F9     TRIQAD: jsr     TWOQAD		; $FFBD - TRIQAD - Collect three address, first stored in (FE) pair, second in (F9), and third in (E4);
00FFC0  1  20 E0 FB             jsr     LFBE0		;
00FFC3  1  A2 03                ldx     #$03		;
00FFC5  1  20 B1 F9             jsr     LF9B1		;
00FFC8  1  A5 FC                lda     $FC			;
00FFCA  1  A6 FD                ldx     L00FD		;
00FFCC  1  85 E4                sta     $E4			; Break table K register - stack pointer;
00FFCE  1  86 E5                stx     $E5			; Break table PCL - low byte of program counter;
00FFD0  1  60                   rts;
00FFD1  1               ;
00FFD1  1  A2 02        CURHOM: ldx     #$02		; CURHOM - resets TEXT line pointer to TOP - do STX $0200 to reset cursor at top;
00FFD3  1  BD 22 02     LFFD3:  lda     $0222,x		;
00FFD6  1  9D 27 02             sta     L0227,x		;
00FFD9  1  9D 2A 02             sta     L022A,x		;
00FFDC  1  CA                   dex					;
00FFDD  1  D0 F4                bne     LFFD3		;
00FFDF  1  60                   rts					;
00FFE0  1  CC           		.byte	$CC			; DGG - replaced stuff
00FFE1  1  2F           		.byte	$2F
00FFE2  1  00           		.byte	$00
00FFE3  1  A9 2E        LFFE3:  lda     #$2E;
00FFE5  1  20 EE FF             jsr     OUTVEC;
00FFE8  1  4C B6 FE             jmp     QDDATD;
00FFEB  1  6C 18 02     INVEC:  jmp     (BINVECT)		; $FFEB = INVEC - normally points to INPUT $FB46;
00FFEE  1  6C 1A 02     OUTVEC: jmp     (BOUTVEC)		; $FFEE = OUTVEC - normally points to OUTPUT $FF9B;
00FFF1  1  6C 1C 02     CCVEC:  jmp     (BCTLCVC)		; $FFF1 = CCVEC - normally points to CTRLC $FB94;
00FFF4  1  6C 1E 02     LDVEC:  jmp     (BLDVECT)		; $FFF4 = LDVEC - normally points to SETLOD $FE70;
00FFF7  1  6C 20 02     SVVEC:  jmp     (BSAVECT)		; $FFF7 = SVVEC - normally points to SETSAV $FE7B;
00FFFA  1  30 01                .word   $0130       ; NMI vector;
00FFFC  1  00 FF                .word   RESET       ; Reset vector;
00FFFE  1  C0 01                .word   $01C0       ; BRK/IRQ vector;
00FFFE  1               
