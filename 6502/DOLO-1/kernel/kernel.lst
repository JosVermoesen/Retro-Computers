AS65 Assembler for R6502 [1.42].                                     Page    1
------------------------------ kernel\kernel.s -------------------------------

14641 lines read, no errors in pass 1.
                        ;*****************************************************
                        ;*
                        ;*	DOLO-1 HOMEBREW COMPUTER
                        ;*	Hardware and software design by Dolo Miah
                        ;*	Copyright 2014-18
                        ;*  Free to use for any non-commercial purpose subject
                        ;*  full credit of original my authorship please!
                        ;*
                        ;*  KERNEL.S
                        ;*  This is the main controller of the entire system b
                        ;*  at build and run time.  All core modules are inclu
                        ;*  the right order by this file, plus the 65c02 start
                        ;*  code.
                        ;*  When the system starts up, it executes the initial
                        ;*  code at the reset vector location.  This basically
                        ;*  initialises all the devices, clears memory and ena
                        ;*  interrupts.  The BBC keyboard DIP settings are rea
                        ;*  determine whether the computer should use the seri
                        ;*  for IO (or keyboard / screen) and whether to start
                        ;*  or 40 column mode.
                        ;*  It then passes control to the 'main' user program.
                        ;*
                        ;*****************************************************
                        
                        	
                        ;****************************************
                        ;*	Set 6502 default vectors	*
                        ;****************************************
                        	data			; Set vectors
fffa =                  	org 0xfffa		; Vectors like at addresses
fffa : 4bfb             	fcw nmi			; 0xfffa : NMI Vector
fffc : a8fa             	fcw init		; 0xfffc : Reset Vector
fffe : f5fa             	fcw irq			; 0xfffe : IRQ Vector
                        	
                        	; ROM code
                        	code			;  
c000 =                  	org 0xc000		; Start of ROM
                        
                        ;* Include all definition and code files in the right 
                        	include "inc\includes.i"
                        ;*****************************************************
                        ;*
                        ;*	DOLO-1 HOMEBREW COMPUTER
                        ;*	Hardware and software design by Dolo Miah
                        ;*	Copyright 2014-18
                        ;*  Free to use for any non-commercial purpose subject
                        ;*  full credit of original my authorship please!
                        ;*
                        ;*  INCLUDES.S
                        ;*  Main include file for key definitions and macros.
                        ;*  Many of the settings here are exremely machine dep
                        ;*  Defines : IO block addresses, VIA port usage, SD c
                        ;*  settings, useful macros, sound chip registers, VIA
                        ;*  VDP registers, ACIA registers.
                        ;*
                        ;*****************************************************
                        
                        ;* The IO block is at 0xb000 and decodes up to
                        ;* eight IO addresses, at 0x0200 intervals
                        ;* All eight are not used at the present time:
                        ;* - 0 : VIA 1 (Keyboard)
AS65 Assembler for R6502 [1.42].                                     Page    2
------------------------------ kernel\kernel.s -------------------------------

                        ;* - 1 : VIA 2 (Sound and SD card interface)
                        ;* - 2 : VDP (Video)
                        ;* - 3 : ACIA (Serial)
b000 =                  IO_0		= 0xb000
b200 =                  IO_1		= 0xb200
b400 =                  IO_2		= 0xb400
b600 =                  IO_3		= 0xb600
b800 =                  IO_4		= 0xb800
ba00 =                  IO_5		= 0xba00
bc00 =                  IO_6		= 0xbc00
be00 =                  IO_7		= 0xbe00
                        
                        ;* VDP is accessed through IO_2
b400 =                  VDP_MODE0	= IO_2
b401 =                  VDP_MODE1	= IO_2+1
b401 =                  VDP_STATUS	= IO_2+1
b401 =                  VDP_ADDR	= IO_2+1
b400 =                  VDP_VRAM	= IO_2
                        
                        ;* This structure defines the key information
                        ;* kepts about the VDP current mode
0000 =                  	struct vdp_addr_struct
0000 =                  	dw vdp_addr_nme				;* Address of name table
0002 =                  	dw vdp_addr_col				;* Address of colour table
0004 =                  	dw vdp_addr_pat				;* Address of pattern table
0006 =                  	dw vdp_addr_spa				;* Address of sprite pattern table
0008 =                  	dw vdp_addr_spp				;* Address of sprite position tabl
000a =                  	db vdp_bord_col				;* Value of border colour
                        	end struct
                        
                        ;* Standard definitions of 6522 registers
                        ;* As found in the datasheets
0000 =                  PRB			= 0x00
0001 =                  PRA			= 0x01
0002 =                  DDRB		= 0x02
0003 =                  DDRA		= 0x03
0004 =                  T1CL		= 0x04
0005 =                  T1CH		= 0x05
0006 =                  T1LL		= 0x06
0007 =                  T1LH		= 0x07
0008 =                  T2CL		= 0x08
0009 =                  T2CH		= 0x09
000a =                  SR			= 0x0a
000b =                  ACR			= 0x0b
000c =                  PCR			= 0x0c
000d =                  IFR			= 0x0d
000e =                  IER			= 0x0e
000f =                  PRAH		= 0x0f
                        
0001 =                  IFR_CA2		= 0x01
0002 =                  IFR_CA1		= 0x02
                        
                        ;* AY-3-8910 definitions
                        ;* The sound chip is accessed through VIA 2
b201 =                  SND_ADBUS	= IO_1+PRA
b200 =                  SND_MODE	= IO_1+PRB
                        
0040 =                  SND_SELREAD			= 0x40
0002 =                  SND_SELWRITE		= 0x02
0042 =                  SND_SELSETADDR		= (SND_SELREAD|SND_SELWRITE)
00bd =                  SND_DESELECT_MASK	= (0xff-SND_SELREAD-SND_SELWRITE)
                        
AS65 Assembler for R6502 [1.42].                                     Page    3
------------------------------ kernel\kernel.s -------------------------------

0000 =                  SND_REG_CHAPL	= 0x00
0001 =                  SND_REG_CHAPH	= 0x01
0002 =                  SND_REG_CHBPL	= 0x02
0003 =                  SND_REG_CHBPH	= 0x03
0004 =                  SND_REG_CHCPL	= 0x04
0005 =                  SND_REG_CHCPH	= 0x05
0006 =                  SND_REG_CHNP	= 0x06
0007 =                  SND_REG_CTL		= 0x07
0008 =                  SND_REG_CHAVOL	= 0x08
0009 =                  SND_REG_CHBVOL	= 0x09
000a =                  SND_REG_CHBVOL	= 0x0a
000b =                  SND_REG_ENVPL	= 0x0b
000c =                  SND_REG_ENVPH	= 0x0c
000d =                  SND_REG_ENVCYC	= 0x0d
                        
000e =                  SND_REG_IOA	= 0x0e
000f =                  SND_REG_IOB	= 0x0f
                        
                        ;* 6551 ACIA definitions
                        ;* As found in the datasheets
b600 =                  SER_DATA	= (IO_3+0)
b601 =                  SER_STATUS	= (IO_3+1)
b601 =                  SER_RESET	= (IO_3+1)
b602 =                  SER_CMD		= (IO_3+2)
b603 =                  SER_CTL		= (IO_3+3)
                        
0080 =                  SER_IRQ		= 0x80
0040 =                  SER_DSRB	= 0x40
0020 =                  SER_DCDB	= 0x20
0010 =                  SER_TDRE	= 0x10
0008 =                  SER_RDRF	= 0x08
0004 =                  SER_OVRN	= 0x04
0002 =                  SER_FE		= 0x02
0001 =                  SER_PE		= 0x01
0080 =                  SER_SBN		= 0x80
0040 =                  SER_WL1		= 0x40
0020 =                  SER_WL0		= 0x20
0060 =                  SER_WL		= (SER_WL1|SER_WL0)
0010 =                  SER_RCS		= 0x10
0008 =                  SER_SBR3	= 0x08
0004 =                  SER_SBR2	= 0x04
0002 =                  SER_SBR1	= 0x02
0001 =                  SER_SBR0	= 0x01
000f =                  SER_SBR		= (SER_SBR3|SER_SBR2|SER_SBR1|SER_SBR0)
000f =                  SER_19200B	= (SER_SBR3|SER_SBR2|SER_SBR1|SER_SBR0)
000e =                  SER_9600B	= (SER_SBR3|SER_SBR2|SER_SBR1)
0080 =                  SER_PMC1	= 0x80
0040 =                  SER_PMC0	= 0x40
00c0 =                  SER_PMC		= (SER_PMC1|SER_PMC0)
0020 =                  SER_PME		= 0x20
0010 =                  SER_REM		= 0x10
0008 =                  SER_TIC1	= 0x08
0004 =                  SER_TIC0	= 0x04
000c =                  SER_TIC		= (SER_TIC1|SER_TIC0)
0002 =                  SER_IRD		= 0x02
0001 =                  SER_DTR		= 0x01
                        
                        ;* BBC keyboard definitions
                        ;* The keyboard is accessed through VIA 1
0080 =                  KB_EN		= 0x80
0001 =                  KB_ROWA		= 0x01
0002 =                  KB_ROWB		= 0x02
AS65 Assembler for R6502 [1.42].                                     Page    4
------------------------------ kernel\kernel.s -------------------------------

0004 =                  KB_ROWC		= 0x04
0008 =                  KB_COLA		= 0x08
0010 =                  KB_COLB		= 0x10
0020 =                  KB_COLC		= 0x20
0040 =                  KB_COLD		= 0x40
0001 =                  KB_W		= 0x01
0002 =                  KB_LED0		= 0x02
0004 =                  KB_LED1		= 0x04
0008 =                  KB_LED2		= 0x08
0001 =                  KB_CAPSLK	= 0x01
0002 =                  KB_SHIFTLK	= 0x02
                        
0005 =                  KB_REP_TIM	= 5				; Number of VB periods for the repea
001e =                  KB_REP_DEL	= 30			; Number of VB periods before repeat
0003 =                  KB_DEBOUNCE	=  3			; Number of VB periods before debou
                        
0003 =                  UTF_ETX		= 0x03			; Break character
0007 =                  UTF_BEL		= 0x07
0008 =                  CRSR_LEFT	= 0x08
0009 =                  CRSR_RIGHT	= 0x09
000a =                  CRSR_DOWN	= 0x0a
000b =                  CRSR_UP		= 0x0b
0006 =                  UTF_ACK		= 0x06			; Used for the copy key in this impl
000c =                  UTF_FF		= 0x0c
000d =                  UTF_CR		= 0x0d
007f =                  UTF_DEL		= 0x7f
0020 =                  UTF_SPECIAL = 0x20
                        
                        ;* SD Card interface definitions
                        ;* The card is accessed through port B of VIA 2
0004 =                  SD_CD		= 0x04
0008 =                  SD_CS		= 0x08
0010 =                  SD_DI		= 0x10
0080 =                  SD_DO		= 0x80
0001 =                  SD_CLK		= 0x01
                        
0010 =                  SD_MOSI		= SD_DI
0080 =                  SD_MISO		= SD_DO
b200 =                  SD_REG		= IO_1+PRB
                        
0000 =                  CMD_ERR_NOERROR			= 0x00
0001 =                  CMD_ERR_NOTFOUND		= 0x01
0002 =                  CMD_ERR_PARM			= 0x02
0003 =                  CMD_ERR_VAL				= 0x03
                        
                        ;* Number formats for conversion routines
0000 =                  NUM_ANY		= 0x00
0001 =                  NUM_DEC		= 0x01
0002 =                  NUM_HEX		= 0x02
0003 =                  NUM_BIN		= 0x03
                        
                        	
                        ;* SD Card Master Boot Record (MBR) definitions
                        ;* The MBR contains the essential information
                        ;* needed to access the data on the card
                        ;* MBR is usually sector 0, but not always
                        ;* however the card I am using does work ok.
0000 =                  MBR_Code				=	0x0000
0003 =                  MBR_OEMName				=	0x0003
000b =                  MBR_BytesPerSect		=	0x000b
000d =                  MBR_SectPerClust		=	0x000d
000e =                  MBR_ResvSect			=	0x000e
AS65 Assembler for R6502 [1.42].                                     Page    5
------------------------------ kernel\kernel.s -------------------------------

0010 =                  MBR_FATCopies			=	0x0010
0011 =                  MBR_RootEntries			=	0x0011
0013 =                  MBR_SmlSect				=	0x0013
0015 =                  MBR_MediaDesc			=	0x0015
0016 =                  MBR_SectPerFAT			=	0x0016
0018 =                  MBR_SectPerTrk			=	0x0018
001a =                  MBR_NumHeads			=	0x001a
001c =                  MBR_NumHidSect			=	0x001c
0020 =                  MBR_NumSect				=	0x0020
0024 =                  MBR_DrvNum				=	0x0024
0026 =                  MBR_ExtSig				=	0x0026
0027 =                  MBR_SerNo				=	0x0027
002b =                  MBR_VolName				=	0x002b
0036 =                  MBR_FATName				=	0x0036
003e =                  MBR_ExeCode				=	0x003e
01fe =                  MBR_ExeMark				=	0x01fe
                        
                        ;* FAT16 definitions - these are offsets
                        ;* in to a FAT table entry which is
                        ;* 32 bytes in length.
0000 =                  FAT_Name				= 	0x00
0008 =                  FAT_Ext					=	0x08
000b =                  FAT_Attr				=	0x0b
000c =                  FAT_Resv				=	0x0c
000d =                  FAT_Createms			=	0x0d
000e =                  FAT_CreateTime			=	0x0e
0010 =                  FAT_CreateDate			=	0x10
0012 =                  FAT_AccessDate			=	0x12
0014 =                  FAT_EAIndex				=	0x14
0016 =                  FAT_ModTime				=	0x16
0018 =                  FAT_ModDate				=	0x18
001a =                  FAT_FirstClust			=	0x1a
001c =                  FAT_FileSize			=	0x1c
                        
                        ;* The FileHandle stucture is key to
                        ;* accessing the file system
0000 =                  	struct FileHandle
0000 =                  	ds FH_Name, 13			; 8 name, 3 extension, 1 separator, 
000d =                  	ds FH_Size, 4
0011 =                  	ds FH_Attr, 1
0012 =                  	ds FH_CurrClust, 2
0014 =                  	ds FH_SectCounter, 1
0015 =                  	ds FH_CurrSec, 4
0019 =                   	ds FH_Pointer, 4
001d =                  	ds FH_DirSect, 4
0021 =                  	ds FH_DirOffset, 2
0023 =                  	ds FH_FirstClust, 2
0025 =                  	ds FH_LastClust, 2
0027 =                  	ds FH_FileMode, 1
                        	end struct
                        
0001 =                  FS_BLK_FLG_LOAD		 	= 	0x01		; On next byte, load block
0002 =                  FS_BLK_FLG_FLUSH		=	0x02		; Block has changed, needs f
                        	
0001 =                  FS_ERR_EOF				=	0x01
                        
                        
                        ;* USEFUL MACROS HERE
                        
                        ;* Software break to throw errors
                        ;* use like this : SWBRK XX
                        ;* Where XX is the error code
AS65 Assembler for R6502 [1.42].                                     Page    6
------------------------------ kernel\kernel.s -------------------------------

                        SWBRK macro sig
                        	brk
                        	db sig
                        	endm
                        
                        _pushAXY macro
                        	pha
                        	phx
                        	phy
                        	endm
                        
                        _pullAXY macro
                        	ply
                        	plx
                        	pla
                        	endm
                        
                        _println macro msg
                        	_pushAXY
                        	ldx #lo(msg)
                        	lda #hi(msg)
                        	jsr io_print_line
                        	_pullAXY
                        	endm
                        
                        _printmsgA macro msg
                        	phx
                        	phy
                        	pha
                        	ldx #lo(msg)
                        	lda #hi(msg)
                        	jsr io_print_line
                        	pla
                        	pha
                        	jsr str_a_to_x
                        	jsr io_put_ch
                        	txa
                        	jsr io_put_ch
                        	lda #UTF_CR
                        	jsr io_put_ch
                        	pla
                        	ply
                        	plx
                        	endm
                        
                        _printA macro
                        	phx
                        	phy
                        	pha
                        	jsr str_a_to_x
                        	jsr io_put_ch
                        	txa
                        	jsr io_put_ch
                        	pla
                        	ply
                        	plx
                        	endm
                        
                        _printCRLF macro
                        	pha
                        	lda #UTF_CR
                        	jsr put_byte
AS65 Assembler for R6502 [1.42].                                     Page    7
------------------------------ kernel\kernel.s -------------------------------

                        	pla
                        	endm
                        
                        _printC macro ch
                        	pha
                        	lda #ch
                        	jsr put_byte
                        	pla
                        	endm
                        
                        _sendcmd macro cmd
                        	_pushAXY
                        	ldx #lo(cmd)
                        	lda #hi(cmd)
                        	jsr sd_sendcmd
                        	_pullAXY
                        	endm
                        
                        _incZPWord macro wordp
                        	inc wordp
                        	db	0xd0, 0x02
                        	inc wordp+1
                        	endm
                        
                        _decZPWord macro wordp
                        	pha
                        	sec
                        	lda wordp
                        	sbc #1
                        	sta wordp
                        	lda wordp+1
                        	sbc #0
                        	sta wordp+1
                        	pla
                        	endm
                        
                        _cpyZPWord macro worda,wordb
                        	lda worda
                        	sta wordb
                        	lda worda+1
                        	sta wordb+1
                        	endm
                        	
                        _addZPWord macro worda, wordb
                        	clc
                        	lda worda
                        	adc wordb
                        	sta worda
                        	lda worda+1
                        	adc wordb+1
                        	sta worda+1
                        	endm
                        
                        _subZPWord macro worda, wordb
                        	sec
                        	lda worda
                        	sbc wordb
                        	sta worda
                        	lda worda+1
                        	sbc wordb+1
                        	sta worda+1
                        	endm
AS65 Assembler for R6502 [1.42].                                     Page    8
------------------------------ kernel\kernel.s -------------------------------

                        	
                        _adcZPWord macro worda,const
                        	clc
                        	lda worda
                        	adc #const
                        	sta worda
                        	lda worda+1
                        	adc #0
                        	sta worda+1
                        	endm
                        
                        
                        	include "inc\graph.i"
                        ;*****************************************************
                        ;*
                        ;*	DOLO-1 HOMEBREW COMPUTER
                        ;*	Hardware and software design by Dolo Miah
                        ;*	Copyright 2014-18
                        ;*  Free to use for any non-commercial purpose subject
                        ;*  full credit of original my authorship please!
                        ;*
                        ;*  GRAPH.I
                        ;*  This is the definition file for graphics, specific
                        ;*  The graphics screen handling module.  It is just a
                        ;*  structure definition - but this structure is used 
                        ;*  record the important attributes of a text screen.
                        ;*  Needed because there is both a 40 and 32 columns m
                        ;*  supported by the VDP, and the screens are not in t
                        ;*  same location.
                        ;*
                        ;*****************************************************
                        
0000 =                  	struct gr_screen
0000 =                  	dw gr_screen_start			;* Start of screen memory in VDP
0002 =                  	dw gr_screen_size			;* Number of bytes screen occupie
0004 =                  	db gr_screen_w				;* Number of columns
0005 =                  	db gr_screen_h				;* Number of rows
0006 =                  	dw gr_screen_ptr			;* VDP dddress of cursor
0008 =                  	db gr_cur_x					;* Current X position of cursor
0009 =                  	db gr_cur_y					;* Current Y position of cursor					
                        	end struct
                        	include "io\io.i"
                        ;*****************************************************
                        ;*
                        ;*	DOLO-1 HOMEBREW COMPUTER
                        ;*	Hardware and software design by Dolo Miah
                        ;*	Copyright 2014-18
                        ;*  Free to use for any non-commercial purpose subject
                        ;*  full credit of original my authorship please!
                        ;*
                        ;*  IO.I
                        ;*  Definitions file for the IO module.  The key struc
                        ;*  used by the IO system is defined here.
                        ;*
                        ;*****************************************************
                        
                        ;* General IO structure allows the system to swap in
                        ;* different IO devices by using indirect calls to
                        ;* the appropriate routines.
0000 =                  	struct io_struct
0000 =                  	ds	io_get_byte,	2			;* Address of get byte
0002 =                  	ds	io_put_byte,	2			;* Address of put byte
AS65 Assembler for R6502 [1.42].                                     Page    9
------------------------------ kernel\kernel.s -------------------------------

0004 =                  	ds	io_open_r,		2			;* Address of open file for read
0006 =                  	ds	io_open_w,		2			;* Address of open file for write
0008 =                  	ds	io_close_f,		2			;* Address of close file
000a =                  	ds	io_del_f,		2			;* Address of delete file
000c =                  	ds	io_ext1,		2			;* Address of extended function 1
000e =                  	ds	io_ext2,		2			;* Address of extended function 2
                        	end struct
                        	include "dflat\dflat.i"
                        ;*****************************************************
                        ;*
                        ;*	DOLO-1 HOMEBREW COMPUTER
                        ;*	Hardware and software design by Dolo Miah
                        ;*	Copyright 2014-18
                        ;*  Free to use for any non-commercial purpose subject
                        ;*  full credit of original my authorship please!
                        ;*
                        ;*  DFLAT.I
                        ;*  This is the main definitions file for dflat.  The 
                        ;*  definitions are in here to access the data structu
                        ;*  used by dflat.
                        ;*
                        ;*****************************************************
                        
                        ;* Start dflat program memory
08b8 =                  DF_PROGSTART=	mem_start
                        ;* This is the top of usable dflat memory plus 1
b000 =                  DF_MEMTOP	=	0xb000
                        
                        ;* Offset in to tokenised line of length and line numb
0000 =                  DFTK_LINLEN	=	0x00
0001 =                  DFTK_LINNUM	=	0x01
                        
                        ;* Flags for token, escape value for data types and li
0080 =                  DFTK_TOKEN	=	0x80
0020 =                  DFTK_ESCVAL	=	0x20
0000 =                  DFTK_EOL	=	0x00
                        
                        ;* Numeric constants are encoded based on size and ori
                        ;* user representation.
                        ;* For example the decimal value 16 will be encoded as
                        ;* DFTK_INTDEC followed by the bytes 0 and 16 to form 
                        ;* The same value in binary will be encoded as DFTK_IN
                        ;* followed by the same 0 and 16 bytes.  This is to al
                        ;* tokenised value to be displayed in original represe
                        ;* So in the two examples, they will be shown as '16' 
                        ;* '0x0010' respectively.
0000 =                  DFTK_CHR	=	0x00
0001 =                  DFTK_RESV1	=	0x01
0002 =                  DFTK_RESV2	=	0x02
0003 =                  DFTK_RESV3	=	0x03
0004 =                  DFTK_RESV4	=	0x04
0005 =                  DFTK_BYTDEC	=	0x05
0006 =                  DFTK_BYTHEX = 	0x06
0007 =                  DFTK_BYTBIN =	0x07
0008 =                  DFTK_RESV8	=	0x08
0009 =                  DFTK_INTDEC	=	0x09
000a =                  DFTK_INTHEX =	0x0a
000b =                  DFTK_INTBIN	=	0x0b
000c =                  DFTK_RESVC	=	0x0c
000d =                  DFTK_RESVD	=	0x0d
000e =                  DFTK_RESVE	=	0x0e
000f =                  DFTK_RESVF	=	0x0f
AS65 Assembler for R6502 [1.42].                                     Page   10
------------------------------ kernel\kernel.s -------------------------------

                        
                        ;* String constant, variable and procedure tokens
0010 =                  DFTK_STRLIT	=	0x10
0011 =                  DFTK_VAR	=	0x11
0012 =                  DFTK_PROC	=	0x12
001f =                  DFTK_STEND	=	0x1f
                        
                        ;* Qualifier for non-local parameters passed to a proc
0026 =                  DFTK_VARPARM=	'&'
                        
                        ;* Variable Value Table (VVT) definitions
                        ;* The VVT records the values of variables defined in
                        ;* the Variable Name Table (VNT).  When a variable is
                        ;* used, it is added to the VNT, and the position in
                        ;* VNT is used as an index in to the VVT.
                        ;* Every VVT entry is 8 bytes - so the VNT index is
                        ;* shifted left 3 bits to get the VVT offset.
                        ;* The VNT grows from top of memory down, the VVT
                        ;* grows from start of VNT down.
                        
                        ;* Index in to each entry of the VVT
0000 =                  DFVVT_TYPE	=	0x00
0001 =                  DFVVT_LO	=	0x01
0002 =                  DFVVT_HI	=	0x02
0003 =                  DFVVT_DIM1	=	0x03
0004 =                  DFVVT_DIM2	=	0x04
0008 =                  DFVVT_SZ	=	0x08	;VVT is aligned to 8 byte blocks
                        
                        ;* The meaning of the DFVVT_TYPE entry
0001 =                  DFVVT_INT	=	0x01
0002 =                  DFVVT_BYT	=	0x02
0004 =                  DFVVT_STR	=	0x04
0008 =                  DFVVT_FLT	=	0x08
0040 =                  DFVVT_PROC	=	0x40
0080 =                  DFVVT_ARRY	=	0x80
                        
                        ;* Flags indicating the meaning of a token
                        ;* A token has the top bit set (0x80), then the
                        ;* remaining bits indicate what it represents.
0001 =                  DFTK_KW		=	0x01
0002 =                  DFTK_FN		=	0x02
0004 =                  DFTK_STROP	=	0x04
0008 =                  DFTK_OP		=	0x08
0010 =                  DFTK_INT	=	0x10
0020 =                  DFTK_BYT	=	0x20
0040 =                  DFTK_STR	=	0x40
0080 =                  DFTK_FLT	=	0x80
0007 =                  DFTK_OPMSK	=	0x07
00f8 =                  DFTK_RTMSK	= 	0xf8
                        
                        ;* Defines what type of value is on the parameter stac
                        ;* All numerics are stored as INT, all STR
                        ;* are pointers to the actual string, thus
                        ;* all entries in the parmeter stack are 3 bytes
0001 =                  DFST_INT	=	0x01
0080 =                  DFST_STR	=	0x80
                        
                        ;* Token values of specific commands, used during
                        ;* command processing.
                        ;* ANY CHANGE TO THE ORDER OF KEYWORDS NEEDS TO REFLEC
0085 =                  DFRT_DEF	=	0x85
0086 =                  DFRT_ENDDEF	=	0x86
AS65 Assembler for R6502 [1.42].                                     Page   11
------------------------------ kernel\kernel.s -------------------------------

0087 =                  DFRT_RETURN	=	0x87
008a =                  DFRT_REPEAT	=	0x8a
008c =                  DFRT_FOR	=	0x8c
008d =                  DFRT_NEXT	=	0x8d
008e =                  DFRT_WHILE	=	0x8e
008f =                  DFRT_WEND	=	0x8f
0090 =                  DFRT_IF		=	0x90
0091 =                  DFRT_ELSE	=	0x91
0092 =                  DFRT_ENDIF	=	0x92
0093 =                  DFRT_ELSEIF	=	0x93
0094 =                  DFRT_DATA	=	0x94
                        
                        	include "kernel\zeropage.s"
                        ;*****************************************************
                        ;*
                        ;*	DOLO-1 HOMEBREW COMPUTER
                        ;*	Hardware and software design by Dolo Miah
                        ;*	Copyright 2014-18
                        ;*  Free to use for any non-commercial purpose subject
                        ;*  full credit of original my authorship please!
                        ;*
                        ;*  ZEROPAGE.S
                        ;*  This module name is misleading it is not only zero
                        ;*  allocations, but also page 2, 3, 4, 5, 6, 7 and be
                        ;*  Basically, this module defines:
                        ;*  - All zero page variables for system and dflat
                        ;*  - Page 1 is stack so no need to worry about that h
                        ;*  - Page 2 is the serial IO buffer for the 6551 ACIA
                        ;*  - Page 3 and 4 is a 512 buffer for SD card sector 
                        ;*  - Page 5 onwards is mainly for dflat working stora
                        ;*    but also non-zero page storage for general IO, f
                        ;*    system and scratch usage.
                        ;*  memstart is a handy label that indicates the first
                        ;*  location that we can store dflat programs from.
                        ;*  Zero page is a valuable asset as the 6502 can acce
                        ;*  this page one cycle quicker than the rest of memor
                        ;*  and infact some addressing modes can only use ZP.
                        ;*  Due to the value of zero page, a lot of system and
                        ;*  dflat variables are put here.  But we don't have t
                        ;*  luxury for single use variables - so you will also
                        ;*  see a lot of temporary sounding names which are
                        ;*  have multiple used across the code base.
                        ;*
                        ;*****************************************************
                        
                        	; Zero page declarations
                        	bss
0000 =                  	org 0x0000
0000 =                  vdp_st		ds	1		; VDP status
0001 =                  cia0_ifr 	ds	1		; CIA0 ICR status
0002 =                  cia1_ifr 	ds	1		; CIA1 ICR status
0003 =                  acia_st		ds	1		; ACIA status
                        
0004 =                  vdp_cnt		ds	1		; VDP interrupt counter
0005 =                  vdp_cnt_hi 	ds	1		; VDP counter high
0006 =                  vdp_cnt_hi2	ds	1		; VDP counter high 2
0007 =                  vdp_curoff	ds	1		; Cursor off (0 = On)
0008 =                  vdp_curstat	ds	1		; Cursor status
0009 =                  vdp_curval	ds	1		; Cursor value on screen
000a =                  vdp_blank	ds	1		; Screen blank value normally 32
                        
000b =                  kb_raw  	ds	1		; Raw keyboard code
AS65 Assembler for R6502 [1.42].                                     Page   12
------------------------------ kernel\kernel.s -------------------------------

000c =                  kb_last		ds	1		; Raw code of last key
000d =                  kb_code 	ds	1		; Converted keyboard code
000e =                  kb_stat		ds	1		; Keyboard status for caps and shift lo
000f =                  kb_deb		ds	1		; VB periods since last KB spike
0010 =                  kb_rep		ds	1		; Keyboard repeat timer
0011 =                  kb_rep_tim 	ds	1		; Default repeat speed
0012 =                  kb_rep_del 	ds	1		; Default repeat delay timing
0013 =                  kb_debounce ds	1		; Default repeat debounce
                        
0014 =                  tmp_alo 	ds	1		; VDP addresses lo
0015 =                  tmp_ahi 	ds	1		; VDP addresses hi
0016 =                  tmp_blo 	ds	1		; Temp address lo
0017 =                  tmp_bhi		ds	1		; Temp address hi
0018 =                  tmp_clo		ds	1		; Temp address lo
0019 =                  tmp_chi		ds	1		; Temp address hi
001a =                  tmp_a		ds	1		; Temp storage a
                        
                        
001b =                  buf_lo		ds	1		; Line buffer address low
001c =                  buf_hi		ds	1		; Line buffer address high
001d =                  buf_sz		ds	1		; Buffer size
001e =                  buf_ef		ds	1		; End file / line marker
                        
001f =                  sd_slo		ds	1		; Sector pointer low
0020 =                  sd_shi		ds	1		; Sector pointer high
                        ; SD card driver parameters
0021 =                  sd_sect		ds 4		; SD Card sector address
0025 =                  sd_addr		ds 4		; SD Card byte address
                        
                        ; File system parameters
0029 =                  fs_bootsect	ds 4		; Start of partition (usually 0x0000
002d =                  fs_fatsect	ds 4		; Start of FAT tables
0031 =                  fs_rootsect	ds 4		; Start of Root Directory
0035 =                  fs_datasect	ds 4		; Start of Data Area
0039 =                  fs_dirsect	ds 4		; Current directory
                        
003d =                  cmd_lo		ds	1		; Command address lo
003e =                  cmd_hi		ds	1		; Command address hi
003f =                  cmd_mem		ds	1		; Command memory type
0040 =                  cmd_tmplo	ds	1		; Command temp pointer/storage
0041 =                  cmd_tmphi	ds	1		; Command temp pointer/storage
                        
0042 =                  fh_temp		ds	4		; File handling temporary storage
                        
                        ; ** Integer function storage **
0046 =                  num_a		ds	4		; 4 byte primary accumulator
004a =                  num_b		ds	4		; 4 byte secondary accumulator
004e =                  num_x		ds	4		; 4 byte x register
0052 =                  num_tmp		ds	4		; 4 byte temp space
0056 =                  num_buf		ds	8		; 8 byte string buffer
                        
                        ;
                        ; **** INTERPRETER ZERO PAGE ****
                        ;
005e =                  errno		ds	1		; General error condition status
005f =                  df_immed	ds	1		; Immediate mode (0 = not immediate)
0060 =                  df_sp		ds	1		; Stack pointer after error to restore to
0061 =                  df_pc		ds	2		; PC after error to return to
0063 =                  df_brkpc	ds	2		; PC pushed on the stack for BRK
0065 =                  df_brkval	ds	1		; Byte after BRK instruction
0066 =                  df_prgstrt	ds	2		; Start of program code
0068 =                  df_prgend	ds	2		; End of program code
AS65 Assembler for R6502 [1.42].                                     Page   13
------------------------------ kernel\kernel.s -------------------------------

006a =                  df_vntstrt	ds	2		; Variable name table start
006c =                  df_vntend	ds	2		; Variable name table end
006e =                  df_vvtstrt	ds	2		; Variable value table start
0070 =                  df_vvtend	ds	2		; Variable value table end
0072 =                  df_varcnt	ds	1		; Variable counter
0073 =                  df_starstrt	ds	2		; String and array table start
0075 =                  df_starend	ds	2		; String and array table end
0077 =                  df_rtstop	ds	1		; Runtime stack pointer
0078 =                  df_parmtop	ds	1		; Top of parameter stack (grows up)
0079 =                  df_strbuff	ds	1		; String expression buffer
007a =                  df_stridx	ds	1		; Top of string buffer (grows down)
007b =                  df_sevalptr	ds	2		; Pointer to next free char in strin
                        
007d =                  df_linoff	ds	1		; Offset in to line buffer
007e =                  df_tokoff	ds	1		; Offset in to tokenised buffer
007f =                  df_eolidx	ds	1		; End of line index (i.e length)
0080 =                  df_tokstidx	ds	1		; Offset to the next statement offse
0081 =                  df_curstidx	ds	1		; Offset to the start of currently e
0082 =                  df_symtab	ds	2		; Pointer to next free symtab entry
0084 =                  df_symoff	ds	1		; Offset in to token table
0085 =                  df_symini	ds	2		; Start of symtab
0087 =                  df_currlin	ds	2		; Execution current line pointer
0089 =                  df_exeoff	ds	1		; Execution line buffer offset
008a =                  df_nextlin	ds	2		; Next line to execute
008c =                  df_tmpptra	ds	2		; Temp pointer a
008e =                  df_tmpptrb	ds	2		; Temp pointer b
0090 =                  df_tmpptrc	ds	2		; Temp pointer c
0092 =                  df_tmpptrd	ds	2		; Temp pointer d
0094 =                  df_tmpptre	ds	2		; Temp pointer e
0096 =                  df_procmode	ds	1		; Only used during tokenisation
0097 =                  df_procargs	ds	1		; Only used during tokenisation
0098 =                  df_procloc	ds	1		; Counts the number of local paramete
0099 =                  df_procptr	ds	2		; Pointer to proc vvt slot
009b =                  df_lineptr	ds	2		; Pointer to line during searches
009d =                  df_lineidx	ds	1		; Pointer to line index during search
009e =                  df_ifnest	ds	1		; Global nested if counter
009f =                  df_currdat	ds	2		; Data current line pointer
00a1 =                  df_datoff	ds	1		; Data line buffer offset
00a2 =                  df_rnd		ds	1		; Random number seed
                        
                        ; File handle parameters
00a3 =                  fh_handle	ds	FileHandle
                        
                        ; vdp settings
00cb =                  vdp_base	ds	vdp_addr_struct
                        
                        ; Screen geometry
00d6 =                  gr_scrngeom	ds	gr_screen
                        
                        
                        
                        ;***** END OF ZERO PAGE *****
00e0 =                  _end_zero_page
                        
0200 =                  	org 0x0200			; Non-zero page (page 2 onwards)
0200 =                  ser_buf		ds	256		; Serial input / output line buffer
                        
0300 =                  	org 0x0300			; SD Card data buffer (page 3 and 4)
0300 =                  sd_buf		ds	512
                        
0500 =                  	org 0x0500			; Page 5 = dflat space
0500 =                  df_linbuff
AS65 Assembler for R6502 [1.42].                                     Page   14
------------------------------ kernel\kernel.s -------------------------------

0500 =                  df_raw		ds	128		; untokenised input line
0580 =                  df_tokbuff
0580 =                  df_tok		ds 	128		; tokenised output line
                        
0600 =                  	org 0x0600			; Page 6 = fixed space for runtime stack
0600 =                  df_rtstck
0600 =                  df_rtspace	ds	256
                        
0700 =                  	org 0x0700			; Page 7 = 1/2 page fixed space for oper
0700 =                  df_opstck
0700 =                  df_opspace	ds	128
                        
                        ;***** NON-ZERO PAGE VARIABLES *****
                        
                        ; Acticve IO device settings
0780 =                  io_block	ds	io_struct
                        
                        ; File entry current dir entry
0790 =                  fh_dir		ds	FileHandle
                        
                        ; Scratch area
07b8 =                  scratch		ds	256
                        
                        ;***** THIS IS THE START OF FREE SPACE **
08b8 =                  mem_start
                        
                        
                        	include "serial\serial.s"
                        ;*****************************************************
                        ;*
                        ;*	DOLO-1 HOMEBREW COMPUTER
                        ;*	Hardware and software design by Dolo Miah
                        ;*	Copyright 2014-18
                        ;*  Free to use for any non-commercial purpose subject
                        ;*  full credit of original my authorship please!
                        ;*
                        ;*  SERIAL.S
                        ;*  Serial input/output handler - driving a 6551 ACIA.
                        ;*
                        ;*****************************************************
                        
                        	; ROM code
                        	code
                        
                        
                        ;****************************************
                        ;* get_byte
                        ;* Get a byte (wait forever or just check)
                        ;* Input : C = 1 for synchronous, 0 for async
                        ;* Output : A = Byte code, C = 0 means A is invalid
                        ;* Regs affected : P, A
                        ;****************************************
c000 :                  get_byte
c000 : ad01b6           	lda SER_STATUS			; Check status register
c003 : 2908             	and #SER_RDRF			; Is Receive Data Register Full bit s
c005 : d004             	bne got_byte
c007 : b0f7             	bcs get_byte			; If C then keep waiting
c009 : 38               	sec						; Indicate byte was not got
c00a : 60               	rts						; If not C then return immediately
c00b :                  got_byte
c00b : 18               	clc						; Indicate byte was got
c00c : ad00b6           	lda SER_DATA			; Read data
AS65 Assembler for R6502 [1.42].                                     Page   15
------------------------------ kernel\kernel.s -------------------------------

                        	
c00f : 60               	rts
                        
                        ;****************************************
                        ;* put_byte
                        ;* Put a byte out
                        ;* Input : A = Byte to put
                        ;* Output : None
                        ;* Regs affected : None
                        ;****************************************
c010 :                  put_byte
c010 : 48               	pha						; Remember the byte to put
c011 :                  put_byte_wait
c011 : ad01b6           	lda SER_STATUS			; Check status
c014 : 2910             	and #SER_TDRE			; Is transmit register empty
c016 : f0f9             	beq put_byte_wait		; wait if not
c018 : 68               	pla						; Pull byte to write
c019 : 8d00b6           	sta SER_DATA			; Write the data
c01c : 60               	rts
                        
                        
                        ;****************************************
                        ;* init_acia
                        ;* ACIA initialisation (this is IO_2)
                        ;* Input : None
                        ;* Output : None
                        ;* Regs affected : X
                        ;****************************************
c01d :                  init_acia
c01d : a21f             	ldx #0b00011111			; 19200 baud, 8 bits, 1 stop bit, i
c01f : 8e03b6           	stx SER_CTL
c022 : a20b             	ldx #0b00001011			; No parity, no TX int plus RTS low
c024 : 8e02b6           	stx SER_CMD
c027 : ae01b6           	ldx SER_STATUS			; Read status reg to clear stuff
                        
c02a : 60               	rts
                        
                        	include "cia\cia.s"
                        ;*****************************************************
                        ;*
                        ;*	DOLO-1 HOMEBREW COMPUTER
                        ;*	Hardware and software design by Dolo Miah
                        ;*	Copyright 2014-18
                        ;*  Free to use for any non-commercial purpose subject
                        ;*  full credit of original my authorship please!
                        ;*
                        ;*  CIA.S
                        ;*  Code to initialise and utilise the two WDC65c22 VI
                        ;*  VIA1 is used to interface to the BBC keyboard
                        ;*  VIA2 is used to interface to the AY-3-8910 sound c
                        ;*  This file is called cia.s because the original des
                        ;*  used a MOS 6526 from a CMB64.  However I updated t
                        ;*  design to use two 6522 chips, but never got around
                        ;*  renaming the file ;-)
                        ;*
                        ;*****************************************************
                        
                        
                        	; ROM code
                        	code
                        	
                        ;********************************
AS65 Assembler for R6502 [1.42].                                     Page   16
------------------------------ kernel\kernel.s -------------------------------

                        ;* set_leds
                        ;* Set the LEDS
                        ;* Input : A - Led pattern to set (1 = on, 0 = off)
                        ;* Output : None
                        ;* Regs affected : None
                        ;****************************************
c02b :                  set_leds
c02b : 48               	pha							; Save A
c02c : 490e             	eor #0x0e					; Invert bits
c02e : 8d00b0           	sta IO_0 + PRB				; Set the leds
c031 : 68               	pla							; Restore A
c032 : 60               	rts
                        
                        ;********************************
                        ;* set_led0
                        ;* Set the LED0 (cassette motor)
                        ;* Input : C = status (1 = on, 0 = off)
                        ;* Output : None
                        ;* Regs affected : None
                        ;****************************************
c033 :                  set_led0
c033 : 48               	pha							; Save A
c034 : ad00b0           	lda IO_0 + PRB				; Get current led status
c037 : 0902             	ora #KB_LED0					; Initially assume off
c039 : 9002             	bcc skip_led0_on
c03b : 4902             	eor #KB_LED0					; Switch on if C=1
c03d :                  skip_led0_on
c03d : 8d00b0           	sta IO_0 + PRB				; Set the leds
c040 : 68               	pla							; Restore A
c041 : 60               	rts
                        
                        ;********************************
                        ;* set_led1
                        ;* Set the LED1 (caps lock)
                        ;* Input : C = status (1 = on, 0 = off)
                        ;* Output : None
                        ;* Regs affected : None
                        ;****************************************
c042 :                  set_led1
c042 : 48               	pha							; Save A
c043 : ad00b0           	lda IO_0 + PRB				; Get current led status
c046 : 0904             	ora #KB_LED1				; Initially assume off
c048 : 9002             	bcc skip_led1_on
c04a : 4904             	eor #KB_LED1				; Switch on if C=1
c04c :                  skip_led1_on
c04c : 8d00b0           	sta IO_0 + PRB				; Set the leds
c04f : 68               	pla							; Restore A
c050 : 60               	rts
                        
                        ;********************************
                        ;* set_led2
                        ;* Set the LED2 (caps lock)
                        ;* Input : C = status (1 = on, 0 = off)
                        ;* Output : None
                        ;* Regs affected : None
                        ;****************************************
c051 :                  set_led2
c051 : 48               	pha							; Save A
c052 : ad00b0           	lda IO_0 + PRB				; Get current led status
c055 : 0908             	ora #KB_LED2				; Initially assume off
c057 : 9002             	bcc skip_led2_on
c059 : 4908             	eor #KB_LED2				; Switch on if C=1
AS65 Assembler for R6502 [1.42].                                     Page   17
------------------------------ kernel\kernel.s -------------------------------

c05b :                  skip_led2_on
c05b : 8d00b0           	sta IO_0 + PRB				; Set the leds
c05e : 68               	pla							; Restore A
c05f : 60               	rts
                        
                        ;****************************************
                        ;* init_cia0
                        ;* Initialise cia 0, controls the BBC keyboard
                        ;* Input : None
                        ;* Output : None
                        ;* Regs affected : A
                        ;****************************************
c060 :                  init_cia0
c060 : a97f             	lda #0x7f					; Disable all interrupts
c062 : 8d0eb0           	sta IO_0 + IER
c065 : a97f             	lda #0x7f					; Clear IFR
c067 : 8d0db0           	sta IO_0 + IFR				; Set IFR to clear flags
                        	
                        
c06a : a9ff             	lda #0xff			
c06c : 8d03b0           	sta IO_0 + DDRA				; Port A all output
                        
c06f : a90e             	lda #0x0e			
c071 : 8d02b0           	sta IO_0 + DDRB				; Port B 3, 2, 1 output
                        
c074 : a900             	lda #0x00					; Init control register - nothing doing
c076 : 8d0bb0           	sta IO_0 + ACR
c079 : a902             	lda #0x02					; CA2 independent interrupt
c07b : 8d0cb0           	sta IO_0 + PCR
                        
c07e : a980             	lda #KB_EN 					; Set KB_EN bit to allow h/w strobe
c080 : 8d01b0           	sta IO_0 + PRA
                        	
c083 : a902             	lda #KB_LED0				; Keep LED0 on but 1 and 2 off
c085 : 202bc0           	jsr set_leds
                        
c088 : 60               	rts							; return from sub
                        	
                        ;****************************************
                        ;* init_cia1
                        ;* Initialise cia 1, controls the sound chip
                        ;* Input : None
                        ;* Output : None
                        ;* Regs affected : A
                        ;****************************************
c089 :                  init_cia1
c089 : a97f             	lda #0x7f					; Disable all interrupts
c08b : 8d0eb2           	sta IO_1 + IER
                        	
c08e : a9ff             	lda #0xff					; Port A all output (AY-3 data bus)
c090 : 8d03b2           	sta IO_1 + DDRA
                        	
c093 : a95b             	lda #0b01011011				; Set Port B output = PB0, PB1, PB
c095 : 8d02b2           	sta IO_1+DDRB
                        	
c098 : a900             	lda #0x00					; Init control register - nothing doing
c09a : 8d0bb2           	sta IO_1 + ACR
c09d : 8d0cb2           	sta IO_1 + PCR
                        
c0a0 : a97f             	lda #0x7f					; Clear IFR
c0a2 : 8d0db2           	sta IO_1 + IFR				; Read ICR to clear flags
                        	
AS65 Assembler for R6502 [1.42].                                     Page   18
------------------------------ kernel\kernel.s -------------------------------

c0a5 : 60               	rts							; return from sub
                        
                        	include "keyboard\keyboard.s"
                        ;*****************************************************
                        ;*
                        ;*	DOLO-1 HOMEBREW COMPUTER
                        ;*	Hardware and software design by Dolo Miah
                        ;*	Copyright 2014-18
                        ;*  Free to use for any non-commercial purpose subject
                        ;*  full credit of original my authorship please!
                        ;*
                        ;*  KEYBOARD.S
                        ;*  This is the keyboard module to enable interfacing 
                        ;*  BBC keyboard using a 65c22.  The BBC keyboard is c
                        ;*  in that it provides a signal to know if something 
                        ;*  pressed in hardware, so the more cycle heavy code 
                        ;*  actually check which key etc can be done only when
                        ;*  necessary.  Debouncing is necessary to not scan to
                        ;*  often, with the timing for this happening during t
                        ;*  interrupt cycle.
                        ;*
                        ;*****************************************************
                        
                        	; ROM code
                        	code
                        
                        ;****************************************
                        ;* init_keyboard
                        ;* Initialise the keyboard settings
                        ;****************************************
c0a6 :                  init_keyboard
c0a6 : a91e             	lda #KB_REP_DEL
c0a8 : 8512             	sta kb_rep_del
c0aa : a905             	lda #KB_REP_TIM
c0ac : 8511             	sta kb_rep_tim
c0ae : a903             	lda #KB_DEBOUNCE
c0b0 : 8513             	sta kb_debounce
c0b2 : 640e             	stz kb_stat
c0b4 : 60               	rts
                        	
                        
                        ;****************************************
                        ;* int_kb_handler
                        ;* Keyboard interrupt handler
                        ;****************************************
c0b5 :                  int_kb_handler	
c0b5 : a50f             	lda kb_deb				; If keyboard pressed is debounce 0?
c0b7 : d00a             	bne int_skip_scan		; If not zero, then don't check ke
c0b9 : a501             	lda cia0_ifr			; Check status register CIA0
c0bb : 2901             	and #IFR_CA2			; Keyboard pressed?
c0bd : f005             	beq int_keys_up
c0bf :                  int_do_read
c0bf : a513             	lda kb_debounce			; Set debounce
c0c1 : 850f             	sta kb_deb
c0c3 :                  int_skip_scan
c0c3 : 60               	rts
c0c4 :                  int_keys_up					; No key pressed
c0c4 : 640b             	stz kb_raw				; Using 65c02 stz opcode
c0c6 : 640c             	stz kb_last
c0c8 : 640d             	stz kb_code
c0ca : 640f             	stz kb_deb
c0cc : 6410             	stz kb_rep
AS65 Assembler for R6502 [1.42].                                     Page   19
------------------------------ kernel\kernel.s -------------------------------

c0ce : 60               	rts
                        	
                        ;****************************************
                        ;* kb_read_raw
                        ;* Read keyboard (not shift+ctrl)
                        ;* X = Keyboard code
                        ;* Carry = 1 means key found, 0 = no keys found
                        ;****************************************
c0cf :                  kb_read_raw
c0cf : 48               	pha
c0d0 : 5a               	phy
                        
c0d1 : a080             	ldy #KB_EN				; Enable h/w strobe
c0d3 : 8c01b0           	sty IO_0 + PRA
                        	
c0d6 : a50f             	lda kb_deb				; Don't scan if on debounce
c0d8 : f01c             	beq kb_no_key
                        	
c0da : a901             	lda #KB_W				; This is the mask to look for
c0dc : a000             	ldy #0					; Start at row 1, column 0, KB_EN is low
c0de :                  kb_check_w_col
c0de : a207             	ldx #7					; Only 7 rows as row zero is skipped
c0e0 : c8               	iny						; Increment past row 0
c0e1 :                  kb_check_w_key
c0e1 : 8c01b0           	sty IO_0 + PRA			; Set the row and column with KB_EN 
c0e4 : 2c00b0           	bit IO_0 + PRB			; Bit test for the W status
c0e7 : d011             	bne got_key				; Found key
c0e9 : c8               	iny						; Advance row
c0ea : ca               	dex						; Do each row
c0eb : d0f4             	bne kb_check_w_key
c0ed : c050             	cpy #0b01010000			; If not got to column 10 then cont
c0ef : d0ed             	bne kb_check_w_col
                        
                        	; no key found
c0f1 : a080             	ldy #KB_EN				; Re-enable h/w strobe
c0f3 : 8c01b0           	sty IO_0 + PRA
                        
c0f6 :                  kb_no_key
c0f6 : 18               	clc						; Clear carry flag = no keys found
                        	
c0f7 : 7a               	ply
c0f8 : 68               	pla
c0f9 : 60               	rts
                        
c0fa :                  got_key
c0fa : 840b             	sty kb_raw				; Save the raw key code
c0fc : beccc1           	ldx kb_table_std,y		; Load up standard key code mappi
c0ff : a900             	lda #0b00000000			; Check shift pressed (row=0, col=0
c101 : 8d01b0           	sta IO_0 + PRA
c104 : ad00b0           	lda IO_0 + PRB			; Read w
c107 : 2901             	and #KB_W
c109 : d006             	bne do_shifted_key
c10b : a50e             	lda kb_stat
c10d : 2902             	and #KB_SHIFTLK			; Check shift lock
c10f : f003             	beq skip_shifted_key	
c111 :                  do_shifted_key
c111 : be1dc2           	ldx kb_table_shift,y	; Overwrite X with shifted key c
c114 :                  skip_shifted_key
c114 : a908             	lda #0b00001000			; Check ctrl pressed (row=0, col=1)
c116 : 8d01b0           	sta IO_0 + PRA
c119 : ad00b0           	lda IO_0 + PRB			; Read w
c11c : 2901             	and #KB_W
AS65 Assembler for R6502 [1.42].                                     Page   20
------------------------------ kernel\kernel.s -------------------------------

c11e : f006             	beq skip_ctrl_key
c120 : 8a               	txa						; If ctrl pressed then only take bottom 5 bi
c121 : 291f             	and #0x1f				; Which will result in codes 0 to 31
c123 : aa               	tax
c124 : 8012             	bra skip_caps_lock		; no point in checking caps lock
c126 :                  skip_ctrl_key
c126 : a50e             	lda kb_stat				; Check caps lock
c128 : 2901             	and #KB_CAPSLK
c12a : f00c             	beq skip_caps_lock
c12c : 8a               	txa						; Easier to modify in A
c12d : c961             	cmp #'a'				; If < 'a' then skip
c12f : 9007             	bcc skip_caps_lock
c131 : c97b             	cmp #'z'+1				; If > 'z' then skip
c133 : b003             	bcs skip_caps_lock
c135 : 4920             	eor #0x20				; Switch off bit 0x20
c137 : aa               	tax						; to make upper case
c138 :                  skip_caps_lock
c138 : 860d             	stx kb_code				; Store mapped key code
c13a : a080             	ldy #KB_EN				; Re-enable h/w strobe
c13c : 8c01b0           	sty IO_0 + PRA
c13f : 38               	sec						; Set carry flag = key found
                        	
c140 : 7a               	ply
c141 : 68               	pla
c142 : 60               	rts
                        	
                        ;****************************************
                        ;* kb_scan_options
                        ;* Scans options dip switch
                        ;* A = Options code for all 8 bits
                        ;****************************************
c143 :                  kb_scan_options
c143 : 5a               	phy
                        
c144 : a000             	ldy #0
c146 : 641a             	stz tmp_a
c148 :                  kb_check_option
c148 : b96ec2           	lda kb_option_code, y	; Binary option code, row = 0, 
c14b : 8d01b0           	sta IO_0 + PRA
c14e : ad00b0           	lda IO_0 + PRB			; Read w
c151 : 2901             	and #KB_W
c153 : f007             	beq kb_skip_option
c155 : a51a             	lda tmp_a
c157 : 1976c2           	ora kb_option_bit, y	; Set the bit if option on
c15a : 851a             	sta tmp_a
c15c :                  kb_skip_option
c15c : c8               	iny
c15d : c008             	cpy #8
c15f : d0e7             	bne kb_check_option
c161 : a51a             	lda tmp_a
                        
c163 : 7a               	ply
c164 : 60               	rts
                        	
                        	
                        ;****************************************
                        ;* kb_scan_key
                        ;* Scans for a key, returns zero for no key found
                        ;* Processes caps and shift lock but these don't count
                        ;* A = Key code
                        ;****************************************
c165 :                  kb_scan_key
AS65 Assembler for R6502 [1.42].                                     Page   21
------------------------------ kernel\kernel.s -------------------------------

c165 : 5a               	phy
c166 : da               	phx
                        	
c167 : a412             	ldy kb_rep_del			; Initially, assuming normal repeat 
c169 : 20cfc0           	jsr kb_read_raw			; H/W scan of keyboard
c16c : 9010             	bcc kb_scan_nothing		; C clear means nothing found
c16e : e080             	cpx #0x80				; Was it a special key (caps/shift lock)
c170 : b01a             	bcs kb_special			; If so process
c172 : a50b             	lda kb_raw
c174 : c50c             	cmp kb_last
c176 : d00b             	bne kb_return_code		; This key different from last ke
c178 : a411             	ldy kb_rep_tim
c17a : a610             	ldx kb_rep				; If repeat timer is zero then emit cod
c17c : f005             	beq kb_return_code
                        
c17e :                  kb_scan_nothing
c17e : fa               	plx
c17f : 7a               	ply
                        	
c180 : a900             	lda #0					; 0 = no key
                        	
c182 : 60               	rts
c183 :                  kb_return_code				; Return a key because raw != last
c183 : 8410             	sty kb_rep				; Delay before the same key is emitted 
c185 : 850c             	sta kb_last				; Now make last = raw
                        	
c187 : fa               	plx
c188 : 7a               	ply
                        	
c189 : a50d             	lda kb_code				; Get the actual code
                        	
c18b : 60               	rts
                        
c18c :                  kb_special					; Process special keys
c18c : e40c             	cpx kb_last				; If last is not zero then don't proce
c18e : f0ee             	beq kb_scan_nothing		; special keys don't obey repeat
c190 : 860c             	stx kb_last				; Update last
c192 : e08a             	cpx #0x8a				; CAPS?
c194 : f015             	beq kb_caps_lock		; Yes
c196 : e08b             	cpx #0x8b				; Shift Lock?
c198 : d0e4             	bne kb_scan_nothing		; No, then found nothing (F keys
                        	;Process shift lock
c19a : a50e             	lda kb_stat
c19c : 4902             	eor #KB_SHIFTLK
c19e : 850e             	sta kb_stat
c1a0 : 18               	clc
c1a1 : 2902             	and #KB_SHIFTLK
c1a3 : f001             	beq kb_skip_shiftlk
c1a5 : 38               	sec
c1a6 :                  kb_skip_shiftlk
c1a6 : 2051c0           	jsr set_led2
c1a9 : 80d3             	bra kb_scan_nothing
                        	;Process caps lock
c1ab :                  kb_caps_lock
c1ab : a50e             	lda kb_stat
c1ad : 4901             	eor #KB_CAPSLK
c1af : 850e             	sta kb_stat
c1b1 : 18               	clc
c1b2 : 2901             	and #KB_CAPSLK
c1b4 : f001             	beq kb_skip_capslk
c1b6 : 38               	sec
c1b7 :                  kb_skip_capslk
AS65 Assembler for R6502 [1.42].                                     Page   22
------------------------------ kernel\kernel.s -------------------------------

c1b7 : 2042c0           	jsr set_led1
c1ba : 80c2             	bra kb_scan_nothing
                        
                        ;****************************************
                        ;* kb_get_key
                        ;* Waits for a key press, C=1 synchronous
                        ;* A = Key code
                        ;****************************************
c1bc :                  kb_get_key
c1bc : 08               	php
c1bd : 2065c1           	jsr kb_scan_key
c1c0 : c900             	cmp #0
c1c2 : d005             	bne kb_scan_got_key
c1c4 : 28               	plp						; No key, so check C
c1c5 : b0f5             	bcs kb_get_key			; Keep looking if C
c1c7 : 38               	sec						; Indicate key not got
c1c8 : 60               	rts
c1c9 :                  kb_scan_got_key
c1c9 : 28               	plp						; Pull stack
c1ca : 18               	clc						; Indicate key valid
c1cb : 60               	rts
                        	
                        ;****************************************
                        ;* kb_table_std (no shift)
                        ;* Keyboard table - zero indicates nothing
                        ;****************************************
c1cc :                  kb_table_std
c1cc : 00               	db 0x00								; Zero entry means nothing
c1cd : 7180318a8b091b   	db 'q',0x80, '1',0x8a,0x8b,   9, 27	; Q, F0, 1, CAPSL
c1d4 : 00               	db 0x00								; Skip row 0
c1d5 : 33773261737a81   	db '3', 'w', '2', 'a', 's', 'z',0x81; 3, W, 2, A, S, 
c1dc : 00               	db 0x00								; Skip row 0
c1dd : 34656478632082   	db '4', 'e', 'd', 'x', 'c', ' ',0x82; 4, E, D, X, C, 
c1e4 : 00               	db 0x00								; Skip row 0
c1e5 : 35747266677683   	db '5', 't', 'r', 'f', 'g', 'v',0x83; 5, T, R, F, G, 
c1ec : 00               	db 0x00								; Skip row 0
c1ed : 84373679686285   	db 0x84,'7', '6', 'y', 'h', 'b',0x85; F4, 7, 6, Y, H,
c1f4 : 00               	db 0x00								; Skip row 0
c1f5 : 3869756a6e6d86   	db '8', 'i', 'u', 'j', 'n', 'm',0x86; 8, I, U, J, N, 
c1fc : 00               	db 0x00								; Skip row 0
c1fd : 87396f6b6c2c88   	db 0x87,'9', 'o', 'k', 'l', ',',0x88; F7, 9, O, K, L,
c204 : 00               	db 0x00								; Skip row 0
c205 : 2d3070403b2e89   	db '-', '0', 'p', '@', ';', '.',0x89; -, 0, P, @, ;, 
c20c : 00               	db 0x00								; Skip row 0
c20d : 5e5f5b3a5d2f5c   	db '^', '_', '[', ':', ']', '/', 92	; ^, _, [, :, ], 
c214 : 00               	db 0x00								; Skip row 0
c215 : 080a0b0d7f0609   	db   8,  10,  11,  13, 127,   6,  9	; Left, Down, Up,
c21c : 00               	db 0x00								; Skip row 0
                        
                        ;****************************************
                        ;* kb_table_shift (with shift)
                        ;* Keyboard table - zero indicates nothing
                        ;****************************************
c21d :                  kb_table_shift
c21d : 00               	db 0x00					; Zero entry means nothing
c21e : 5180218a8b091b   	db 'Q',0x80, '!',0x8a,0x8b,   9, 27	; Q, F0, 1, CAPSL
c225 : 00               	db 0x00					; Skip row 0
c226 : 23572241535a81   	db '#', 'W', '"', 'A', 'S', 'Z',0x81; 3, W, 2, A, S, 
c22d : 00               	db 0x00					; Skip row 0
c22e : 24454458432082   	db '$', 'E', 'D', 'X', 'C', ' ',0x82; 4, E, D, X, C, 
c235 : 00               	db 0x00					; Skip row 0
c236 : 25545246475683   	db '%', 'T', 'R', 'F', 'G', 'V',0x83; 5, T, R, F, G, 
AS65 Assembler for R6502 [1.42].                                     Page   23
------------------------------ kernel\kernel.s -------------------------------

c23d : 00               	db 0x00					; Skip row 0
c23e : 84272659484285   	db 0x84, 39, '&', 'Y', 'H', 'B',0x85; F4, 7, 6, Y, H,
c245 : 00               	db 0x00					; Skip row 0
c246 : 2849554a4e4d86   	db '(', 'I', 'U', 'J', 'N', 'M',0x86; 8, I, U, J, N, 
c24d : 00               	db 0x00					; Skip row 0
c24e : 87294f4b4c3c88   	db 0x87,')', 'O', 'K', 'L', '<',0x88; F7, 9, O, K, L,
c255 : 00               	db 0x00					; Skip row 0
c256 : 3d3050402b3e89   	db '=', '0', 'P', '@', '+', '>',0x89; -, 0, P, @, ;, 
c25d : 00               	db 0x00					; Skip row 0
c25e : 7e607b2a7d3f7c   	db '~', 96, '{', '*', '}', '?', '|'	; ^, _, [, :, ], 
c265 : 00               	db 0x00					; Skip row 0
c266 : 080a0b0d7f0609   	db   8,  10,  11,  13, 127,   6,  9	; Left, Down, Up,
c26d : 00               	db 0x00					; Skip row 0
                        
                        ; Option switches
c26e :                  kb_option_code
c26e : 10               	db 0b00010000
c26f : 18               	db 0b00011000
c270 : 20               	db 0b00100000
c271 : 28               	db 0b00101000
c272 : 30               	db 0b00110000
c273 : 38               	db 0b00111000
c274 : 40               	db 0b01000000
c275 : 48               	db 0b01001000
c276 :                  kb_option_bit
c276 : 8040201008040201 	db 0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01
                        	
                        
                        	include "sound\sound.s"
                        ;*****************************************************
                        ;*
                        ;*	DOLO-1 HOMEBREW COMPUTER
                        ;*	Hardware and software design by Dolo Miah
                        ;*	Copyright 2014-18
                        ;*  Free to use for any non-commercial purpose subject
                        ;*  full credit of original my authorship please!
                        ;*
                        ;*  SOUND.S
                        ;*  Sound driver module - routines to access the AY-3-
                        ;*  This sound chip was found in a number of popular m
                        ;*  in the early to mid 80s, including my first comput
                        ;*  the Oric-1, as well as the MSX range.  Interfacing
                        ;*  chip is through port A of VIA 2 because it cannot 
                        ;*  connected directly to the 6502 bus.  This means th
                        ;*  is a bit clunky to drive, but this is how the Oric
                        ;*  did it, so I guess I can't be too wrong with this
                        ;*  approach.
                        ;*  The AY doesn't only produce sound, it also has a c
                        ;*  of 8 bit IO port - one of them I am using for joys
                        ;*
                        ;*****************************************************
                        
                        
                        	; ROM code
                        	code
                        
                        ;****************************************
                        ;* snd_set
                        ;* Set AY register X to value Y
                        ;* Input : X = Reg no, Y = Value
                        ;* Output : None
                        ;* Regs affected : None
AS65 Assembler for R6502 [1.42].                                     Page   24
------------------------------ kernel\kernel.s -------------------------------

                        ;****************************************
c27e :                  snd_set
c27e : 48               	pha
                        
c27f : a9ff             	lda #0xff				; Set Port A to output
c281 : 8d03b2           	sta IO_1 + DDRA
                        
c284 : 8e01b2           	stx SND_ADBUS			; Put X on the sound bus (X = reg add
                        
c287 : ad00b2           	lda SND_MODE			; Need to preserve contents of other b
c28a : 29bd             	and #SND_DESELECT_MASK	; Mask off mode bits
c28c : 0942             	ora #SND_SELSETADDR		; Select AY mode to latch addres
c28e : 8d00b2           	sta SND_MODE			; This write will process the data in 
                        
c291 : 29bd             	and #SND_DESELECT_MASK	; Mask off mode bits
c293 : 8d00b2           	sta SND_MODE			; This write will deselect the AY read
                        	
c296 : 8c01b2           	sty SND_ADBUS			; Put Y on the sound bus (Y = value)
c299 : 0902             	ora #SND_SELWRITE		; Select mode for writing data
c29b : 8d00b2           	sta SND_MODE			; This write will process the data in 
                        	
c29e : 29bd             	and #SND_DESELECT_MASK	; Mask off mode bits
c2a0 : 8d00b2           	sta SND_MODE			; This write will deselect the AY read
                        
c2a3 : 68               	pla
                        	
c2a4 : 60               	rts
                        
                        ;****************************************
                        ;* snd_get
                        ;* Get AY register X to Y
                        ;* Input : X = Reg no
                        ;* Output : Y = Value
                        ;* Regs affected : None
                        ;****************************************
c2a5 :                  snd_get
c2a5 : 48               	pha
                        
c2a6 : a9ff             	lda #0xff				; Set Port A to output
c2a8 : 8d03b2           	sta IO_1 + DDRA
                        
c2ab : 8e01b2           	stx SND_ADBUS			; Put X on the sound bus (X = reg add
                        
c2ae : ad00b2           	lda SND_MODE			; Need to preserve contents of other b
c2b1 : 29bd             	and #SND_DESELECT_MASK	; Mask off mode bits
c2b3 : 0942             	ora #SND_SELSETADDR		; Select AY mode to latch addres
c2b5 : 8d00b2           	sta SND_MODE			; This write will process the data in 
                        
c2b8 : 29bd             	and #SND_DESELECT_MASK	; Mask off mode bits
c2ba : 8d00b2           	sta SND_MODE			; This write will deselect the AY read
                        
c2bd : a900             	lda #0x00				; Set Port A to input
c2bf : 8d03b2           	sta IO_1 + DDRA
                        
c2c2 : ad00b2           	lda SND_MODE			; Need to preserve contents of other b
c2c5 : 29bd             	and #SND_DESELECT_MASK	; Mask off mode bits
c2c7 : 0940             	ora #SND_SELREAD		; Select mode for reading data
c2c9 : 8d00b2           	sta SND_MODE			; This write will process the data in 
                        
c2cc : ac01b2           	ldy SND_ADBUS			; Get value in to Y
                        	
c2cf : 29bd             	and #SND_DESELECT_MASK	; Mask off mode bits
AS65 Assembler for R6502 [1.42].                                     Page   25
------------------------------ kernel\kernel.s -------------------------------

c2d1 : 8d00b2           	sta SND_MODE			; This write will deselect the AY read
                        
c2d4 : 68               	pla
                        	
c2d5 : 60               	rts
                        
                        ;****************************************
                        ;* snd_get_joy0
                        ;* Return value of joystick 0
                        ;* Input : None
                        ;* Output : Y = Value
                        ;* Regs affected : X
                        ;****************************************
c2d6 :                  snd_get_joy0
c2d6 : a20f             	ldx #SND_REG_IOB		; Joystick is plugged in to IOB
c2d8 : 20a5c2           	jsr snd_get				; Get IOB, result in Y
c2db : 60               	rts
                        
                        	
                        ;****************************************
                        ;* init_snd
                        ;* Initialise sound - after cia 1 has been initialised
                        ;* Input : None
                        ;* Output : None
                        ;* Regs affected : All
                        ;****************************************
c2dc :                  init_snd
c2dc : a200             	ldx #0x00
c2de :                  init_snd_regs
c2de : bceac2           	ldy snd_init_tab,x
c2e1 : 207ec2           	jsr snd_set				; Set X to Y
c2e4 : e8               	inx
c2e5 : e010             	cpx #16					; Done 16?
c2e7 : d0f5             	bne init_snd_regs		; Nope	
                        	
c2e9 : 60               	rts						; return from sub
                        
                        	; Register array initialisation values
c2ea :                  snd_init_tab
c2ea : 80               	db 0x80				; R0 = Channel A Tone Low
c2eb : 00               	db 0x00				; R1 = Channel A Tone High
c2ec : 00               	db 0x00				; R2 = Channel B Tone Low
c2ed : 01               	db 0x01				; R3 = Channel B Tone High
c2ee : 00               	db 0x00				; R4 = Channel C Tone Low
c2ef : 02               	db 0x02				; R5 = Channel C Tone High
c2f0 : 00               	db 0x00				; R6 = Noise period
c2f1 : 3e               	db 0b00111110		; R7 = Control : IOB input, IOA input,
c2f2 : 1f               	db 0x1f				; R8 = Channel A Vol
c2f3 : 1f               	db 0x1f				; R9 = Channel B Vol
c2f4 : 1f               	db 0x1f				; R10 = Channel C Vol
c2f5 : 00               	db 0x00				; R11 = Envelope Period Low
c2f6 : 09               	db 0x09				; R12 = Envelope Period High
c2f7 : 00               	db 0b00000000		; R13 = Envelope Shape : 0000
c2f8 : 00               	db 0x00				; R14 = IO Port A
c2f9 : 00               	db 0x00				; R15 = IO Port B ; Initialise to 0
                        
c2fa :                  snd_music_tab
c2fa : 050a             	dw 2565				; C		0
c2fc : 7509             	dw 2421				; C#	1
c2fe : ee08             	dw 2286				; D		2
c300 : 6d08             	dw 2157				; D#	3
c302 : f407             	dw 2036				; E		4
AS65 Assembler for R6502 [1.42].                                     Page   26
------------------------------ kernel\kernel.s -------------------------------

c304 : 8207             	dw 1922				; F		5
c306 : 1607             	dw 1814				; F#	6
c308 : b006             	dw 1712				; G		7
c30a : 5006             	dw 1616				; G#	8
c30c : f505             	dw 1525				; A		9
c30e : a005             	dw 1440				; A#	10
c310 : 4f05             	dw 1359				; B		11
                        	
c312 : 0305             	dw 1283				; C
c314 : bb04             	dw 1211				; C#
c316 : 7704             	dw 1143				; D
c318 : 3704             	dw 1079				; D#
c31a : fa03             	dw 1018				; E
c31c : c103             	dw 961 				; F
c31e : 8b03             	dw 907 				; F#
c320 : 5803             	dw 856 				; G
c322 : 2803             	dw 808 				; G#
c324 : fb02             	dw 763 				; A
c326 : d002             	dw 720 				; A#
c328 : a702             	dw 679 				; B
                        
c32a : 8102             	dw 641				; C
c32c : 5d02             	dw 605				; C#
c32e : 3b02             	dw 571				; D
c330 : 1b02             	dw 539				; D#
c332 : fd01             	dw 509				; E
c334 : e001             	dw 480				; F
c336 : c501             	dw 453				; F#
c338 : ac01             	dw 428				; G
c33a : 9401             	dw 404				; G#
c33c : 7d01             	dw 381				; A
c33e : 6801             	dw 360				; A#
c340 : 5401             	dw 340				; B
                        
c342 : 4101             	dw 321				; C
c344 : 2f01             	dw 303				; C#
c346 : 1e01             	dw 286				; D
c348 : 0e01             	dw 270				; D#
c34a : fe00             	dw 254				; E
c34c : f000             	dw 240				; F
c34e : e300             	dw 227				; F#
c350 : d600             	dw 214				; G
c352 : ca00             	dw 202				; G#
c354 : bf00             	dw 191				; A
c356 : b400             	dw 180				; A#
c358 : aa00             	dw 170				; B
                        
c35a : a000             	dw 160				; C
c35c : 9700             	dw 151				; C#
c35e : 8f00             	dw 143				; D
c360 : 8700             	dw 135				; D#
c362 : 7f00             	dw 127				; E
c364 : 7800             	dw 120				; F
c366 : 7100             	dw 113				; F#
c368 : 6b00             	dw 107				; G
c36a : 6500             	dw 101				; G#
c36c : 5f00             	dw 95 				; A
c36e : 5a00             	dw 90 				; A#
c370 : 5500             	dw 85 				; B
                        
c372 : 5000             	dw 80				; C
c374 : 4c00             	dw 76				; C#
AS65 Assembler for R6502 [1.42].                                     Page   27
------------------------------ kernel\kernel.s -------------------------------

c376 : 4700             	dw 71				; D
c378 : 4300             	dw 67				; D#
c37a : 4000             	dw 64				; E
c37c : 3c00             	dw 60				; F
c37e : 3900             	dw 57				; F#
c380 : 3600             	dw 54				; G
c382 : 3300             	dw 51				; G#
c384 : 3000             	dw 48				; A
c386 : 2d00             	dw 45				; A#
c388 : 2a00             	dw 42				; B
                        
c38a : 2800             	dw 40				; C
c38c : 2600             	dw 38				; C#
c38e : 2400             	dw 36				; D
c390 : 2200             	dw 34				; D#
c392 : 2000             	dw 32				; E
c394 : 1e00             	dw 30				; F
c396 : 1c00             	dw 28				; F#
c398 : 1b00             	dw 27				; G
c39a : 1900             	dw 25				; G#
c39c : 1800             	dw 24				; A
c39e : 1600             	dw 22				; A#
c3a0 : 1500             	dw 21				; B
                        
                        	include "vdp\vdp.s"
                        ;*****************************************************
                        ;*
                        ;*	DOLO-1 HOMEBREW COMPUTER
                        ;*	Hardware and software design by Dolo Miah
                        ;*	Copyright 2014-18
                        ;*  Free to use for any non-commercial purpose subject
                        ;*  full credit of original my authorship please!
                        ;*
                        ;*  VDP.S
                        ;*  This module implements the drivers of the VDP, whi
                        ;*  a TMS9918a.  The VDP is interfaced to the 6502 bus
                        ;*  through a memory mapped IO (that's how the 6502 li
                        ;*  There are only two bytes in the IO space that are 
                        ;*  and the 6502 needs to poke or read from these with
                        ;*  delay to allow the VDP to detect and respond to th
                        ;*  request.  It's interesting that delays are needed 
                        ;*  MSX computer also used a TMS9918a but with Z80a as
                        ;*  CPU, which actually didn't need delays.  The 6502 
                        ;*  a simple processor but a write instruction only ne
                        ;*  4 cycles, hence needing delays.
                        ;*  Considering it came out in the late 70s, the TMS99
                        ;*  series of VDP are pretty impressive - 2 text modes
                        ;*  a hires mode too ('a' variant).  Plus 32 hardware
                        ;*  sprites and 15 colours - very good indeed. Also th
                        ;*  uses its own memory so doesn't eat 6502 space.
                        ;*  Downside to having its own memory is that it can b
                        ;*  slow to do large updates e.g. scrolling.  Ok sure 
                        ;*  column screen can be scrolled and it looks ok, but
                        ;*  no way would I try to scroll a hires screen.  Henc
                        ;*  why many games on the MSX didn't do smooth scrolli
                        ;*
                        ;*****************************************************
                        
                        
                        	; ROM code
                        	code
                        	include "vdp\font.s"
AS65 Assembler for R6502 [1.42].                                     Page   28
------------------------------ kernel\kernel.s -------------------------------

                        ;*****************************************************
                        ;*
                        ;*	DOLO-1 HOMEBREW COMPUTER
                        ;*	Hardware and software design by Dolo Miah
                        ;*	Copyright 2014-18
                        ;*  Free to use for any non-commercial purpose subject
                        ;*  full credit of original my authorship please!
                        ;*
                        ;*  FONT.S
                        ;*  This is the font definition, used to initialise th
                        ;*  character set.  The normal char 1 is either a diam
                        ;*  but I have set the default to be a little space in
                        ;*  This character set is a combination of the MSX for
                        ;*  special characters outside of the normal ASCII ran
                        ;*  and Oric-1 for letters, numbers, punctuation etc.
                        ;*  Oric was my first computer hence the nostalgia tri
                        ;*
                        ;*****************************************************
                        
c3a2 :                  vdp_font
                        ; char 0
c3a2 : 00               	db %00000000
c3a3 : 00               	db %00000000
c3a4 : 00               	db %00000000
c3a5 : 00               	db %00000000
c3a6 : 00               	db %00000000
c3a7 : 00               	db %00000000
c3a8 : 00               	db %00000000
c3a9 : 00               	db %00000000
                        ; char 1 standard
                        ;	db %00000000
                        ;	db %00100000
                        ;	db %01110000
                        ;	db %11111000
                        ;	db %01110000
                        ;	db %00100000
                        ;	db %00000000
                        ;	db %00000000
                        ; char 1 space invader
c3aa : 18               	db %00011000
c3ab : 3c               	db %00111100
c3ac : 7e               	db %01111110
c3ad : db               	db %11011011
c3ae : ff               	db %11111111
c3af : 24               	db %00100100
c3b0 : 5a               	db %01011010
c3b1 : a5               	db %10100101
                        ; char 2
c3b2 : a8               	db %10101000
c3b3 : 54               	db %01010100
c3b4 : a8               	db %10101000
c3b5 : 54               	db %01010100
c3b6 : a8               	db %10101000
c3b7 : 54               	db %01010100
c3b8 : a8               	db %10101000
c3b9 : 54               	db %01010100
                        ; char 3
c3ba : 20               	db %00100000
c3bb : 70               	db %01110000
c3bc : a8               	db %10101000
c3bd : 20               	db %00100000
c3be : 20               	db %00100000
AS65 Assembler for R6502 [1.42].                                     Page   29
------------------------------ kernel\kernel.s -------------------------------

c3bf : 20               	db %00100000
c3c0 : 20               	db %00100000
c3c1 : 00               	db %00000000
                        ; char 4
c3c2 : 20               	db %00100000
c3c3 : 20               	db %00100000
c3c4 : 20               	db %00100000
c3c5 : 20               	db %00100000
c3c6 : a8               	db %10101000
c3c7 : 70               	db %01110000
c3c8 : 20               	db %00100000
c3c9 : 00               	db %00000000
                        ; char 5
c3ca : 00               	db %00000000
c3cb : 20               	db %00100000
c3cc : 40               	db %01000000
c3cd : f8               	db %11111000
c3ce : 40               	db %01000000
c3cf : 20               	db %00100000
c3d0 : 00               	db %00000000
c3d1 : 00               	db %00000000
                        ; char 6
c3d2 : 00               	db %00000000
c3d3 : 20               	db %00100000
c3d4 : 10               	db %00010000
c3d5 : f8               	db %11111000
c3d6 : 10               	db %00010000
c3d7 : 20               	db %00100000
c3d8 : 00               	db %00000000
c3d9 : 00               	db %00000000
                        ; char 7
c3da : 60               	db %01100000
c3db : 90               	db %10010000
c3dc : 90               	db %10010000
c3dd : 60               	db %01100000
c3de : 00               	db %00000000
c3df : 00               	db %00000000
c3e0 : 00               	db %00000000
c3e1 : 00               	db %00000000
                        ; char 8
c3e2 : 20               	db %00100000
c3e3 : 20               	db %00100000
c3e4 : f8               	db %11111000
c3e5 : 20               	db %00100000
c3e6 : 20               	db %00100000
c3e7 : 00               	db %00000000
c3e8 : f8               	db %11111000
c3e9 : 00               	db %00000000
                        ; char 9
c3ea : 00               	db %00000000
c3eb : 00               	db %00000000
c3ec : 00               	db %00000000
c3ed : 00               	db %00000000
c3ee : 00               	db %00000000
c3ef : 00               	db %00000000
c3f0 : a8               	db %10101000
c3f1 : 00               	db %00000000
                        ; char 10
c3f2 : 00               	db %00000000
c3f3 : 00               	db %00000000
c3f4 : 08               	db %00001000
c3f5 : 10               	db %00010000
AS65 Assembler for R6502 [1.42].                                     Page   30
------------------------------ kernel\kernel.s -------------------------------

c3f6 : a0               	db %10100000
c3f7 : 40               	db %01000000
c3f8 : 00               	db %00000000
c3f9 : 00               	db %00000000
                        ; char 11
c3fa : 30               	db %00110000
c3fb : 30               	db %00110000
c3fc : 30               	db %00110000
c3fd : f0               	db %11110000
c3fe : f0               	db %11110000
c3ff : 00               	db %00000000
c400 : 00               	db %00000000
c401 : 00               	db %00000000
                        ; char 12
c402 : 00               	db %00000000
c403 : 00               	db %00000000
c404 : 00               	db %00000000
c405 : f0               	db %11110000
c406 : f0               	db %11110000
c407 : 30               	db %00110000
c408 : 30               	db %00110000
c409 : 30               	db %00110000
                        ; char 13
c40a : 00               	db %00000000
c40b : 00               	db %00000000
c40c : 00               	db %00000000
c40d : 3c               	db %00111100
c40e : 3c               	db %00111100
c40f : 30               	db %00110000
c410 : 30               	db %00110000
c411 : 30               	db %00110000
                        ; char 14
c412 : 30               	db %00110000
c413 : 30               	db %00110000
c414 : 30               	db %00110000
c415 : 3c               	db %00111100
c416 : 3c               	db %00111100
c417 : 00               	db %00000000
c418 : 00               	db %00000000
c419 : 00               	db %00000000
                        ; char 15
c41a : 30               	db %00110000
c41b : 30               	db %00110000
c41c : 30               	db %00110000
c41d : fc               	db %11111100
c41e : fc               	db %11111100
c41f : 30               	db %00110000
c420 : 30               	db %00110000
c421 : 30               	db %00110000
                        ; char 16
c422 : fc               	db %11111100
c423 : fc               	db %11111100
c424 : 00               	db %00000000
c425 : 00               	db %00000000
c426 : 00               	db %00000000
c427 : 00               	db %00000000
c428 : 00               	db %00000000
c429 : 00               	db %00000000
                        ; char 17
c42a : 00               	db %00000000
c42b : 00               	db %00000000
c42c : fc               	db %11111100
AS65 Assembler for R6502 [1.42].                                     Page   31
------------------------------ kernel\kernel.s -------------------------------

c42d : fc               	db %11111100
c42e : 00               	db %00000000
c42f : 00               	db %00000000
c430 : 00               	db %00000000
c431 : 00               	db %00000000
                        ; char 18
c432 : 00               	db %00000000
c433 : 00               	db %00000000
c434 : 00               	db %00000000
c435 : fc               	db %11111100
c436 : fc               	db %11111100
c437 : 00               	db %00000000
c438 : 00               	db %00000000
c439 : 00               	db %00000000
                        ; char 19
c43a : 00               	db %00000000
c43b : 00               	db %00000000
c43c : 00               	db %00000000
c43d : 00               	db %00000000
c43e : fc               	db %11111100
c43f : fc               	db %11111100
c440 : 00               	db %00000000
c441 : 00               	db %00000000
                        ; char 20
c442 : 00               	db %00000000
c443 : 00               	db %00000000
c444 : 00               	db %00000000
c445 : 00               	db %00000000
c446 : 00               	db %00000000
c447 : 00               	db %00000000
c448 : fc               	db %11111100
c449 : fc               	db %11111100
                        ; char 21
c44a : 30               	db %00110000
c44b : 30               	db %00110000
c44c : 30               	db %00110000
c44d : 3c               	db %00111100
c44e : 3c               	db %00111100
c44f : 30               	db %00110000
c450 : 30               	db %00110000
c451 : 30               	db %00110000
                        ; char 22
c452 : 30               	db %00110000
c453 : 30               	db %00110000
c454 : 30               	db %00110000
c455 : f0               	db %11110000
c456 : f0               	db %11110000
c457 : 30               	db %00110000
c458 : 30               	db %00110000
c459 : 30               	db %00110000
                        ; char 23
c45a : 30               	db %00110000
c45b : 30               	db %00110000
c45c : 30               	db %00110000
c45d : fc               	db %11111100
c45e : fc               	db %11111100
c45f : 00               	db %00000000
c460 : 00               	db %00000000
c461 : 00               	db %00000000
                        ; char 24
c462 : 00               	db %00000000
c463 : 00               	db %00000000
AS65 Assembler for R6502 [1.42].                                     Page   32
------------------------------ kernel\kernel.s -------------------------------

c464 : 00               	db %00000000
c465 : fc               	db %11111100
c466 : fc               	db %11111100
c467 : 30               	db %00110000
c468 : 30               	db %00110000
c469 : 30               	db %00110000
                        ; char 25
c46a : 30               	db %00110000
c46b : 30               	db %00110000
c46c : 30               	db %00110000
c46d : 30               	db %00110000
c46e : 30               	db %00110000
c46f : 30               	db %00110000
c470 : 30               	db %00110000
c471 : 30               	db %00110000
                        ; char 26
c472 : 08               	db %00001000
c473 : 30               	db %00110000
c474 : c0               	db %11000000
c475 : 30               	db %00110000
c476 : 08               	db %00001000
c477 : 00               	db %00000000
c478 : f8               	db %11111000
c479 : 00               	db %00000000
                        ; char 27
c47a : 80               	db %10000000
c47b : 60               	db %01100000
c47c : 18               	db %00011000
c47d : 60               	db %01100000
c47e : 80               	db %10000000
c47f : 00               	db %00000000
c480 : f8               	db %11111000
c481 : 00               	db %00000000
                        ; char 28
c482 : 00               	db %00000000
c483 : 00               	db %00000000
c484 : f8               	db %11111000
c485 : 50               	db %01010000
c486 : 50               	db %01010000
c487 : 50               	db %01010000
c488 : 98               	db %10011000
c489 : 00               	db %00000000
                        ; char 29
c48a : 10               	db %00010000
c48b : 10               	db %00010000
c48c : f8               	db %11111000
c48d : 20               	db %00100000
c48e : f8               	db %11111000
c48f : 40               	db %01000000
c490 : 40               	db %01000000
c491 : 00               	db %00000000
                        ; char 30
c492 : 30               	db %00110000
c493 : 48               	db %01001000
c494 : 40               	db %01000000
c495 : e0               	db %11100000
c496 : 40               	db %01000000
c497 : 48               	db %01001000
c498 : b0               	db %10110000
c499 : 00               	db %00000000
                        ; char 31
c49a : 00               	db %00000000
AS65 Assembler for R6502 [1.42].                                     Page   33
------------------------------ kernel\kernel.s -------------------------------

c49b : 00               	db %00000000
c49c : 00               	db %00000000
c49d : 20               	db %00100000
c49e : 00               	db %00000000
c49f : 00               	db %00000000
c4a0 : 00               	db %00000000
c4a1 : 00               	db %00000000
                        ; char 32
c4a2 : 00               	db %00000000
c4a3 : 00               	db %00000000
c4a4 : 00               	db %00000000
c4a5 : 00               	db %00000000
c4a6 : 00               	db %00000000
c4a7 : 00               	db %00000000
c4a8 : 00               	db %00000000
c4a9 : 00               	db %00000000
                        ; char 33
c4aa : 20               	db %00100000
c4ab : 20               	db %00100000
c4ac : 20               	db %00100000
c4ad : 20               	db %00100000
c4ae : 20               	db %00100000
c4af : 00               	db %00000000
c4b0 : 20               	db %00100000
c4b1 : 00               	db %00000000
                        ; char 34
c4b2 : 50               	db %01010000
c4b3 : 50               	db %01010000
c4b4 : 50               	db %01010000
c4b5 : 00               	db %00000000
c4b6 : 00               	db %00000000
c4b7 : 00               	db %00000000
c4b8 : 00               	db %00000000
c4b9 : 00               	db %00000000
                        ; char 35
c4ba : 50               	db %01010000
c4bb : 50               	db %01010000
c4bc : f8               	db %11111000
c4bd : 50               	db %01010000
c4be : f8               	db %11111000
c4bf : 50               	db %01010000
c4c0 : 50               	db %01010000
c4c1 : 00               	db %00000000
                        ; char 36
c4c2 : 20               	db %00100000
c4c3 : 78               	db %01111000
c4c4 : a0               	db %10100000
c4c5 : 70               	db %01110000
c4c6 : 28               	db %00101000
c4c7 : f0               	db %11110000
c4c8 : 20               	db %00100000
c4c9 : 00               	db %00000000
                        ; char 37
c4ca : c0               	db %11000000
c4cb : c8               	db %11001000
c4cc : 10               	db %00010000
c4cd : 20               	db %00100000
c4ce : 40               	db %01000000
c4cf : 98               	db %10011000
c4d0 : 18               	db %00011000
c4d1 : 00               	db %00000000
                        ; char 38
AS65 Assembler for R6502 [1.42].                                     Page   34
------------------------------ kernel\kernel.s -------------------------------

c4d2 : 40               	db %01000000
c4d3 : a0               	db %10100000
c4d4 : a0               	db %10100000
c4d5 : 40               	db %01000000
c4d6 : a8               	db %10101000
c4d7 : 90               	db %10010000
c4d8 : 68               	db %01101000
c4d9 : 00               	db %00000000
                        ; char 39
c4da : 20               	db %00100000
c4db : 20               	db %00100000
c4dc : 20               	db %00100000
c4dd : 00               	db %00000000
c4de : 00               	db %00000000
c4df : 00               	db %00000000
c4e0 : 00               	db %00000000
c4e1 : 00               	db %00000000
                        ; char 40
c4e2 : 20               	db %00100000
c4e3 : 40               	db %01000000
c4e4 : 80               	db %10000000
c4e5 : 80               	db %10000000
c4e6 : 80               	db %10000000
c4e7 : 40               	db %01000000
c4e8 : 20               	db %00100000
c4e9 : 00               	db %00000000
                        ; char 41
c4ea : 20               	db %00100000
c4eb : 10               	db %00010000
c4ec : 08               	db %00001000
c4ed : 08               	db %00001000
c4ee : 08               	db %00001000
c4ef : 10               	db %00010000
c4f0 : 20               	db %00100000
c4f1 : 00               	db %00000000
                        ; char 42
c4f2 : 20               	db %00100000
c4f3 : a8               	db %10101000
c4f4 : 70               	db %01110000
c4f5 : 20               	db %00100000
c4f6 : 70               	db %01110000
c4f7 : a8               	db %10101000
c4f8 : 20               	db %00100000
c4f9 : 00               	db %00000000
                        ; char 43
c4fa : 00               	db %00000000
c4fb : 20               	db %00100000
c4fc : 20               	db %00100000
c4fd : f8               	db %11111000
c4fe : 20               	db %00100000
c4ff : 20               	db %00100000
c500 : 00               	db %00000000
c501 : 00               	db %00000000
                        ; char 44
c502 : 00               	db %00000000
c503 : 00               	db %00000000
c504 : 00               	db %00000000
c505 : 00               	db %00000000
c506 : 00               	db %00000000
c507 : 20               	db %00100000
c508 : 20               	db %00100000
c509 : 40               	db %01000000
AS65 Assembler for R6502 [1.42].                                     Page   35
------------------------------ kernel\kernel.s -------------------------------

                        ; char 45
c50a : 00               	db %00000000
c50b : 00               	db %00000000
c50c : 00               	db %00000000
c50d : f8               	db %11111000
c50e : 00               	db %00000000
c50f : 00               	db %00000000
c510 : 00               	db %00000000
c511 : 00               	db %00000000
                        ; char 46
c512 : 00               	db %00000000
c513 : 00               	db %00000000
c514 : 00               	db %00000000
c515 : 00               	db %00000000
c516 : 00               	db %00000000
c517 : 10               	db %00010000
c518 : 00               	db %00000000
c519 : 00               	db %00000000
                        ; char 47
c51a : 00               	db %00000000
c51b : 08               	db %00001000
c51c : 10               	db %00010000
c51d : 20               	db %00100000
c51e : 40               	db %01000000
c51f : 80               	db %10000000
c520 : 00               	db %00000000
c521 : 00               	db %00000000
                        ; char 48
c522 : 70               	db %01110000
c523 : 88               	db %10001000
c524 : 98               	db %10011000
c525 : a8               	db %10101000
c526 : c8               	db %11001000
c527 : 88               	db %10001000
c528 : 70               	db %01110000
c529 : 00               	db %00000000
                        ; char 49
c52a : 20               	db %00100000
c52b : 60               	db %01100000
c52c : 20               	db %00100000
c52d : 20               	db %00100000
c52e : 20               	db %00100000
c52f : 20               	db %00100000
c530 : 70               	db %01110000
c531 : 00               	db %00000000
                        ; char 50
c532 : 70               	db %01110000
c533 : 88               	db %10001000
c534 : 08               	db %00001000
c535 : 10               	db %00010000
c536 : 20               	db %00100000
c537 : 40               	db %01000000
c538 : f8               	db %11111000
c539 : 00               	db %00000000
                        ; char 51
c53a : f8               	db %11111000
c53b : 08               	db %00001000
c53c : 10               	db %00010000
c53d : 30               	db %00110000
c53e : 08               	db %00001000
c53f : 88               	db %10001000
c540 : 70               	db %01110000
AS65 Assembler for R6502 [1.42].                                     Page   36
------------------------------ kernel\kernel.s -------------------------------

c541 : 00               	db %00000000
                        ; char 52
c542 : 10               	db %00010000
c543 : 30               	db %00110000
c544 : 50               	db %01010000
c545 : 90               	db %10010000
c546 : f8               	db %11111000
c547 : 10               	db %00010000
c548 : 10               	db %00010000
c549 : 00               	db %00000000
                        ; char 53
c54a : f8               	db %11111000
c54b : 80               	db %10000000
c54c : f0               	db %11110000
c54d : 08               	db %00001000
c54e : 08               	db %00001000
c54f : 88               	db %10001000
c550 : 70               	db %01110000
c551 : 00               	db %00000000
                        ; char 54
c552 : 30               	db %00110000
c553 : 40               	db %01000000
c554 : 80               	db %10000000
c555 : f0               	db %11110000
c556 : 88               	db %10001000
c557 : 88               	db %10001000
c558 : 70               	db %01110000
c559 : 00               	db %00000000
                        ; char 55
c55a : f8               	db %11111000
c55b : 08               	db %00001000
c55c : 10               	db %00010000
c55d : 20               	db %00100000
c55e : 40               	db %01000000
c55f : 40               	db %01000000
c560 : 40               	db %01000000
c561 : 00               	db %00000000
                        ; char 56
c562 : 70               	db %01110000
c563 : 88               	db %10001000
c564 : 88               	db %10001000
c565 : 70               	db %01110000
c566 : 88               	db %10001000
c567 : 88               	db %10001000
c568 : 70               	db %01110000
c569 : 00               	db %00000000
                        ; char 57
c56a : 70               	db %01110000
c56b : 88               	db %10001000
c56c : 88               	db %10001000
c56d : 78               	db %01111000
c56e : 08               	db %00001000
c56f : 10               	db %00010000
c570 : 60               	db %01100000
c571 : 00               	db %00000000
                        ; char 58
c572 : 00               	db %00000000
c573 : 00               	db %00000000
c574 : 20               	db %00100000
c575 : 00               	db %00000000
c576 : 00               	db %00000000
c577 : 20               	db %00100000
AS65 Assembler for R6502 [1.42].                                     Page   37
------------------------------ kernel\kernel.s -------------------------------

c578 : 00               	db %00000000
c579 : 00               	db %00000000
                        ; char 59
c57a : 00               	db %00000000
c57b : 00               	db %00000000
c57c : 20               	db %00100000
c57d : 00               	db %00000000
c57e : 00               	db %00000000
c57f : 20               	db %00100000
c580 : 20               	db %00100000
c581 : 40               	db %01000000
                        ; char 60
c582 : 10               	db %00010000
c583 : 20               	db %00100000
c584 : 40               	db %01000000
c585 : 80               	db %10000000
c586 : 40               	db %01000000
c587 : 20               	db %00100000
c588 : 10               	db %00010000
c589 : 00               	db %00000000
                        ; char 61
c58a : 00               	db %00000000
c58b : 00               	db %00000000
c58c : f8               	db %11111000
c58d : 00               	db %00000000
c58e : f8               	db %11111000
c58f : 00               	db %00000000
c590 : 00               	db %00000000
c591 : 00               	db %00000000
                        ; char 62
c592 : 40               	db %01000000
c593 : 20               	db %00100000
c594 : 10               	db %00010000
c595 : 08               	db %00001000
c596 : 10               	db %00010000
c597 : 20               	db %00100000
c598 : 40               	db %01000000
c599 : 00               	db %00000000
                        ; char 63
c59a : 70               	db %01110000
c59b : 88               	db %10001000
c59c : 10               	db %00010000
c59d : 20               	db %00100000
c59e : 20               	db %00100000
c59f : 00               	db %00000000
c5a0 : 20               	db %00100000
c5a1 : 00               	db %00000000
                        ; char 64
c5a2 : 70               	db %01110000
c5a3 : 88               	db %10001000
c5a4 : a8               	db %10101000
c5a5 : b8               	db %10111000
c5a6 : b0               	db %10110000
c5a7 : 80               	db %10000000
c5a8 : 78               	db %01111000
c5a9 : 00               	db %00000000
c5aa :                  vdp_font_a
                        ; char 65
c5aa : 20               	db %00100000
c5ab : 50               	db %01010000
c5ac : 88               	db %10001000
c5ad : 88               	db %10001000
AS65 Assembler for R6502 [1.42].                                     Page   38
------------------------------ kernel\kernel.s -------------------------------

c5ae : f8               	db %11111000
c5af : 88               	db %10001000
c5b0 : 88               	db %10001000
c5b1 : 00               	db %00000000
                        ; char 66
c5b2 : f0               	db %11110000
c5b3 : 88               	db %10001000
c5b4 : 88               	db %10001000
c5b5 : f0               	db %11110000
c5b6 : 88               	db %10001000
c5b7 : 88               	db %10001000
c5b8 : f0               	db %11110000
c5b9 : 00               	db %00000000
                        ; char 67
c5ba : 70               	db %01110000
c5bb : 88               	db %10001000
c5bc : 80               	db %10000000
c5bd : 80               	db %10000000
c5be : 80               	db %10000000
c5bf : 88               	db %10001000
c5c0 : 70               	db %01110000
c5c1 : 00               	db %00000000
                        ; char 68
c5c2 : f0               	db %11110000
c5c3 : 88               	db %10001000
c5c4 : 88               	db %10001000
c5c5 : 88               	db %10001000
c5c6 : 88               	db %10001000
c5c7 : 88               	db %10001000
c5c8 : f0               	db %11110000
c5c9 : 00               	db %00000000
                        ; char 69
c5ca : f8               	db %11111000
c5cb : 80               	db %10000000
c5cc : 80               	db %10000000
c5cd : f0               	db %11110000
c5ce : 80               	db %10000000
c5cf : 80               	db %10000000
c5d0 : f8               	db %11111000
c5d1 : 00               	db %00000000
                        ; char 70
c5d2 : f8               	db %11111000
c5d3 : 80               	db %10000000
c5d4 : 80               	db %10000000
c5d5 : f0               	db %11110000
c5d6 : 80               	db %10000000
c5d7 : 80               	db %10000000
c5d8 : 80               	db %10000000
c5d9 : 00               	db %00000000
                        ; char 71
c5da : 78               	db %01111000
c5db : 80               	db %10000000
c5dc : 80               	db %10000000
c5dd : 80               	db %10000000
c5de : 98               	db %10011000
c5df : 88               	db %10001000
c5e0 : 78               	db %01111000
c5e1 : 00               	db %00000000
                        ; char 72
c5e2 : 88               	db %10001000
c5e3 : 88               	db %10001000
c5e4 : 88               	db %10001000
AS65 Assembler for R6502 [1.42].                                     Page   39
------------------------------ kernel\kernel.s -------------------------------

c5e5 : f8               	db %11111000
c5e6 : 88               	db %10001000
c5e7 : 88               	db %10001000
c5e8 : 88               	db %10001000
c5e9 : 00               	db %00000000
                        ; char 73
c5ea : 70               	db %01110000
c5eb : 20               	db %00100000
c5ec : 20               	db %00100000
c5ed : 20               	db %00100000
c5ee : 20               	db %00100000
c5ef : 20               	db %00100000
c5f0 : 70               	db %01110000
c5f1 : 00               	db %00000000
                        ; char 74
c5f2 : 08               	db %00001000
c5f3 : 08               	db %00001000
c5f4 : 08               	db %00001000
c5f5 : 08               	db %00001000
c5f6 : 08               	db %00001000
c5f7 : 88               	db %10001000
c5f8 : 70               	db %01110000
c5f9 : 00               	db %00000000
                        ; char 75
c5fa : 88               	db %10001000
c5fb : 90               	db %10010000
c5fc : a0               	db %10100000
c5fd : c0               	db %11000000
c5fe : a0               	db %10100000
c5ff : 90               	db %10010000
c600 : 88               	db %10001000
c601 : 00               	db %00000000
                        ; char 76
c602 : 80               	db %10000000
c603 : 80               	db %10000000
c604 : 80               	db %10000000
c605 : 80               	db %10000000
c606 : 80               	db %10000000
c607 : 80               	db %10000000
c608 : f8               	db %11111000
c609 : 00               	db %00000000
                        ; char 77
c60a : 88               	db %10001000
c60b : d8               	db %11011000
c60c : a8               	db %10101000
c60d : a8               	db %10101000
c60e : 88               	db %10001000
c60f : 88               	db %10001000
c610 : 88               	db %10001000
c611 : 00               	db %00000000
                        ; char 78
c612 : 88               	db %10001000
c613 : 88               	db %10001000
c614 : c8               	db %11001000
c615 : a8               	db %10101000
c616 : 98               	db %10011000
c617 : 88               	db %10001000
c618 : 88               	db %10001000
c619 : 00               	db %00000000
                        ; char 79
c61a : 70               	db %01110000
c61b : 88               	db %10001000
AS65 Assembler for R6502 [1.42].                                     Page   40
------------------------------ kernel\kernel.s -------------------------------

c61c : 88               	db %10001000
c61d : 88               	db %10001000
c61e : 88               	db %10001000
c61f : 88               	db %10001000
c620 : 70               	db %01110000
c621 : 00               	db %00000000
                        ; char 80
c622 : f0               	db %11110000
c623 : 88               	db %10001000
c624 : 88               	db %10001000
c625 : f0               	db %11110000
c626 : 80               	db %10000000
c627 : 80               	db %10000000
c628 : 80               	db %10000000
c629 : 00               	db %00000000
                        ; char 81
c62a : 70               	db %01110000
c62b : 88               	db %10001000
c62c : 88               	db %10001000
c62d : 88               	db %10001000
c62e : a8               	db %10101000
c62f : 90               	db %10010000
c630 : 68               	db %01101000
c631 : 00               	db %00000000
                        ; char 82
c632 : f0               	db %11110000
c633 : 88               	db %10001000
c634 : 88               	db %10001000
c635 : f0               	db %11110000
c636 : a0               	db %10100000
c637 : 90               	db %10010000
c638 : 88               	db %10001000
c639 : 00               	db %00000000
                        ; char 83
c63a : 70               	db %01110000
c63b : 88               	db %10001000
c63c : 80               	db %10000000
c63d : 70               	db %01110000
c63e : 08               	db %00001000
c63f : 88               	db %10001000
c640 : 70               	db %01110000
c641 : 00               	db %00000000
                        ; char 84
c642 : f8               	db %11111000
c643 : 20               	db %00100000
c644 : 20               	db %00100000
c645 : 20               	db %00100000
c646 : 20               	db %00100000
c647 : 20               	db %00100000
c648 : 20               	db %00100000
c649 : 00               	db %00000000
                        ; char 85
c64a : 88               	db %10001000
c64b : 88               	db %10001000
c64c : 88               	db %10001000
c64d : 88               	db %10001000
c64e : 88               	db %10001000
c64f : 88               	db %10001000
c650 : 70               	db %01110000
c651 : 00               	db %00000000
                        ; char 86
c652 : 88               	db %10001000
AS65 Assembler for R6502 [1.42].                                     Page   41
------------------------------ kernel\kernel.s -------------------------------

c653 : 88               	db %10001000
c654 : 88               	db %10001000
c655 : 88               	db %10001000
c656 : 88               	db %10001000
c657 : 50               	db %01010000
c658 : 20               	db %00100000
c659 : 00               	db %00000000
                        ; char 87
c65a : 88               	db %10001000
c65b : 88               	db %10001000
c65c : 88               	db %10001000
c65d : a8               	db %10101000
c65e : a8               	db %10101000
c65f : d8               	db %11011000
c660 : 88               	db %10001000
c661 : 00               	db %00000000
                        ; char 88
c662 : 88               	db %10001000
c663 : 88               	db %10001000
c664 : 50               	db %01010000
c665 : 20               	db %00100000
c666 : 50               	db %01010000
c667 : 88               	db %10001000
c668 : 88               	db %10001000
c669 : 00               	db %00000000
                        ; char 89
c66a : 88               	db %10001000
c66b : 88               	db %10001000
c66c : 50               	db %01010000
c66d : 20               	db %00100000
c66e : 20               	db %00100000
c66f : 20               	db %00100000
c670 : 20               	db %00100000
c671 : 00               	db %00000000
                        ; char 90
c672 : f8               	db %11111000
c673 : 08               	db %00001000
c674 : 10               	db %00010000
c675 : 20               	db %00100000
c676 : 40               	db %01000000
c677 : 80               	db %10000000
c678 : f8               	db %11111000
c679 : 00               	db %00000000
                        ; char 91
c67a : 78               	db %01111000
c67b : 40               	db %01000000
c67c : 40               	db %01000000
c67d : 40               	db %01000000
c67e : 40               	db %01000000
c67f : 40               	db %01000000
c680 : 78               	db %01111000
c681 : 00               	db %00000000
                        ; char 92
c682 : 00               	db %00000000
c683 : 80               	db %10000000
c684 : 40               	db %01000000
c685 : 20               	db %00100000
c686 : 10               	db %00010000
c687 : 08               	db %00001000
c688 : 00               	db %00000000
c689 : 00               	db %00000000
                        ; char 93
AS65 Assembler for R6502 [1.42].                                     Page   42
------------------------------ kernel\kernel.s -------------------------------

c68a : f0               	db %11110000
c68b : 10               	db %00010000
c68c : 10               	db %00010000
c68d : 10               	db %00010000
c68e : 10               	db %00010000
c68f : 10               	db %00010000
c690 : f0               	db %11110000
c691 : 00               	db %00000000
                        ; char 94
c692 : 20               	db %00100000
c693 : 50               	db %01010000
c694 : a8               	db %10101000
c695 : 20               	db %00100000
c696 : 20               	db %00100000
c697 : 20               	db %00100000
c698 : 20               	db %00100000
c699 : 00               	db %00000000
                        ; char 95
c69a : 00               	db %00000000
c69b : 00               	db %00000000
c69c : 00               	db %00000000
c69d : 00               	db %00000000
c69e : 00               	db %00000000
c69f : 00               	db %00000000
c6a0 : f8               	db %11111000
c6a1 : 00               	db %00000000
                        ; char 96
c6a2 : 38               	db %00111000
c6a3 : 40               	db %01000000
c6a4 : 40               	db %01000000
c6a5 : 40               	db %01000000
c6a6 : f0               	db %11110000
c6a7 : 40               	db %01000000
c6a8 : f8               	db %11111000
c6a9 : 00               	db %00000000
                        ; char 97
c6aa : 00               	db %00000000
c6ab : 00               	db %00000000
c6ac : 70               	db %01110000
c6ad : 08               	db %00001000
c6ae : 78               	db %01111000
c6af : 88               	db %10001000
c6b0 : 78               	db %01111000
c6b1 : 00               	db %00000000
                        ; char 98
c6b2 : 80               	db %10000000
c6b3 : 80               	db %10000000
c6b4 : f0               	db %11110000
c6b5 : 88               	db %10001000
c6b6 : 88               	db %10001000
c6b7 : 88               	db %10001000
c6b8 : f0               	db %11110000
c6b9 : 00               	db %00000000
                        ; char 99
c6ba : 00               	db %00000000
c6bb : 00               	db %00000000
c6bc : 78               	db %01111000
c6bd : 80               	db %10000000
c6be : 80               	db %10000000
c6bf : 80               	db %10000000
c6c0 : 78               	db %01111000
c6c1 : 00               	db %00000000
AS65 Assembler for R6502 [1.42].                                     Page   43
------------------------------ kernel\kernel.s -------------------------------

                        ; char 100
c6c2 : 08               	db %00001000
c6c3 : 08               	db %00001000
c6c4 : 78               	db %01111000
c6c5 : 88               	db %10001000
c6c6 : 88               	db %10001000
c6c7 : 88               	db %10001000
c6c8 : 78               	db %01111000
c6c9 : 00               	db %00000000
                        ; char 101
c6ca : 00               	db %00000000
c6cb : 00               	db %00000000
c6cc : 70               	db %01110000
c6cd : 88               	db %10001000
c6ce : f8               	db %11111000
c6cf : 80               	db %10000000
c6d0 : 78               	db %01111000
c6d1 : 00               	db %00000000
                        ; char 102
c6d2 : 30               	db %00110000
c6d3 : 48               	db %01001000
c6d4 : 40               	db %01000000
c6d5 : f0               	db %11110000
c6d6 : 40               	db %01000000
c6d7 : 40               	db %01000000
c6d8 : 40               	db %01000000
c6d9 : 00               	db %00000000
                        ; char 103
c6da : 00               	db %00000000
c6db : 00               	db %00000000
c6dc : 70               	db %01110000
c6dd : 88               	db %10001000
c6de : 88               	db %10001000
c6df : 78               	db %01111000
c6e0 : 08               	db %00001000
c6e1 : 70               	db %01110000
                        ; char 104
c6e2 : 80               	db %10000000
c6e3 : 80               	db %10000000
c6e4 : f0               	db %11110000
c6e5 : 88               	db %10001000
c6e6 : 88               	db %10001000
c6e7 : 88               	db %10001000
c6e8 : 88               	db %10001000
c6e9 : 00               	db %00000000
                        ; char 105
c6ea : 20               	db %00100000
c6eb : 00               	db %00000000
c6ec : 60               	db %01100000
c6ed : 20               	db %00100000
c6ee : 20               	db %00100000
c6ef : 20               	db %00100000
c6f0 : 70               	db %01110000
c6f1 : 00               	db %00000000
                        ; char 106
c6f2 : 10               	db %00010000
c6f3 : 00               	db %00000000
c6f4 : 30               	db %00110000
c6f5 : 10               	db %00010000
c6f6 : 10               	db %00010000
c6f7 : 10               	db %00010000
c6f8 : 90               	db %10010000
AS65 Assembler for R6502 [1.42].                                     Page   44
------------------------------ kernel\kernel.s -------------------------------

c6f9 : 60               	db %01100000
                        ; char 107
c6fa : 80               	db %10000000
c6fb : 80               	db %10000000
c6fc : 88               	db %10001000
c6fd : 90               	db %10010000
c6fe : e0               	db %11100000
c6ff : 90               	db %10010000
c700 : 88               	db %10001000
c701 : 00               	db %00000000
                        ; char 108
c702 : 60               	db %01100000
c703 : 20               	db %00100000
c704 : 20               	db %00100000
c705 : 20               	db %00100000
c706 : 20               	db %00100000
c707 : 20               	db %00100000
c708 : 70               	db %01110000
c709 : 00               	db %00000000
                        ; char 109
c70a : 00               	db %00000000
c70b : 00               	db %00000000
c70c : d8               	db %11011000
c70d : a8               	db %10101000
c70e : a8               	db %10101000
c70f : a8               	db %10101000
c710 : 88               	db %10001000
c711 : 00               	db %00000000
                        ; char 110
c712 : 00               	db %00000000
c713 : 00               	db %00000000
c714 : f0               	db %11110000
c715 : 88               	db %10001000
c716 : 88               	db %10001000
c717 : 88               	db %10001000
c718 : 88               	db %10001000
c719 : 00               	db %00000000
                        ; char 111
c71a : 00               	db %00000000
c71b : 00               	db %00000000
c71c : 70               	db %01110000
c71d : 88               	db %10001000
c71e : 88               	db %10001000
c71f : 88               	db %10001000
c720 : 70               	db %01110000
c721 : 00               	db %00000000
                        ; char 112
c722 : 00               	db %00000000
c723 : 00               	db %00000000
c724 : f0               	db %11110000
c725 : 88               	db %10001000
c726 : 88               	db %10001000
c727 : f0               	db %11110000
c728 : 80               	db %10000000
c729 : 80               	db %10000000
                        ; char 113
c72a : 00               	db %00000000
c72b : 00               	db %00000000
c72c : 78               	db %01111000
c72d : 88               	db %10001000
c72e : 88               	db %10001000
c72f : 78               	db %01111000
AS65 Assembler for R6502 [1.42].                                     Page   45
------------------------------ kernel\kernel.s -------------------------------

c730 : 08               	db %00001000
c731 : 08               	db %00001000
                        ; char 114
c732 : 00               	db %00000000
c733 : 00               	db %00000000
c734 : b8               	db %10111000
c735 : c0               	db %11000000
c736 : 80               	db %10000000
c737 : 80               	db %10000000
c738 : 80               	db %10000000
c739 : 00               	db %00000000
                        ; char 115
c73a : 00               	db %00000000
c73b : 00               	db %00000000
c73c : 78               	db %01111000
c73d : 80               	db %10000000
c73e : 70               	db %01110000
c73f : 08               	db %00001000
c740 : f0               	db %11110000
c741 : 00               	db %00000000
                        ; char 116
c742 : 40               	db %01000000
c743 : 40               	db %01000000
c744 : f0               	db %11110000
c745 : 40               	db %01000000
c746 : 40               	db %01000000
c747 : 48               	db %01001000
c748 : 30               	db %00110000
c749 : 00               	db %00000000
                        ; char 117
c74a : 00               	db %00000000
c74b : 00               	db %00000000
c74c : 88               	db %10001000
c74d : 88               	db %10001000
c74e : 88               	db %10001000
c74f : 98               	db %10011000
c750 : 68               	db %01101000
c751 : 00               	db %00000000
                        ; char 118
c752 : 00               	db %00000000
c753 : 00               	db %00000000
c754 : 88               	db %10001000
c755 : 88               	db %10001000
c756 : 88               	db %10001000
c757 : 50               	db %01010000
c758 : 20               	db %00100000
c759 : 00               	db %00000000
                        ; char 119
c75a : 00               	db %00000000
c75b : 00               	db %00000000
c75c : 88               	db %10001000
c75d : 88               	db %10001000
c75e : a8               	db %10101000
c75f : a8               	db %10101000
c760 : d8               	db %11011000
c761 : 00               	db %00000000
                        ; char 120
c762 : 00               	db %00000000
c763 : 00               	db %00000000
c764 : 88               	db %10001000
c765 : 50               	db %01010000
c766 : 20               	db %00100000
AS65 Assembler for R6502 [1.42].                                     Page   46
------------------------------ kernel\kernel.s -------------------------------

c767 : 50               	db %01010000
c768 : 88               	db %10001000
c769 : 00               	db %00000000
                        ; char 121
c76a : 00               	db %00000000
c76b : 00               	db %00000000
c76c : 88               	db %10001000
c76d : 88               	db %10001000
c76e : 88               	db %10001000
c76f : 78               	db %01111000
c770 : 08               	db %00001000
c771 : 70               	db %01110000
                        ; char 122
c772 : 00               	db %00000000
c773 : 00               	db %00000000
c774 : f8               	db %11111000
c775 : 10               	db %00010000
c776 : 20               	db %00100000
c777 : 40               	db %01000000
c778 : f8               	db %11111000
c779 : 00               	db %00000000
                        ; char 123
c77a : 38               	db %00111000
c77b : 60               	db %01100000
c77c : 60               	db %01100000
c77d : c0               	db %11000000
c77e : 60               	db %01100000
c77f : 60               	db %01100000
c780 : 38               	db %00111000
c781 : 00               	db %00000000
                        ; char 124
c782 : 20               	db %00100000
c783 : 20               	db %00100000
c784 : 20               	db %00100000
c785 : 20               	db %00100000
c786 : 20               	db %00100000
c787 : 20               	db %00100000
c788 : 20               	db %00100000
c789 : 20               	db %00100000
                        ; char 125
c78a : e0               	db %11100000
c78b : 30               	db %00110000
c78c : 30               	db %00110000
c78d : 18               	db %00011000
c78e : 30               	db %00110000
c78f : 30               	db %00110000
c790 : e0               	db %11100000
c791 : 00               	db %00000000
                        ; char 126
c792 : 00               	db %00000000
c793 : 00               	db %00000000
c794 : 40               	db %01000000
c795 : a8               	db %10101000
c796 : 10               	db %00010000
c797 : 00               	db %00000000
c798 : 00               	db %00000000
c799 : 00               	db %00000000
                        ; char 127
c79a : f8               	db %11111000
c79b : f8               	db %11111000
c79c : f8               	db %11111000
c79d : f8               	db %11111000
AS65 Assembler for R6502 [1.42].                                     Page   47
------------------------------ kernel\kernel.s -------------------------------

c79e : f8               	db %11111000
c79f : f8               	db %11111000
c7a0 : f8               	db %11111000
c7a1 : 00               	db %00000000
                        	
                        	
                        
                        ;****************************************
                        ;* int_vdp_handler
                        ;* VDP interrupt handler
                        ;****************************************
c7a2 :                  int_vdp_handler
c7a2 : a500             	lda vdp_st
c7a4 : 2980             	and #0x80			; Check if it is the VDP interrupt
c7a6 : f029             	beq int_vdp_fin
c7a8 : 204cfb           	jsr update_timers	; If it is then update system timer
c7ab : a507             	lda vdp_curoff		; Is cursor enabled?
c7ad : d022             	bne int_vdp_fin		; Skip if so
c7af : a920             	lda #0x20			; Check bit 5 of low timer
c7b1 : 2504             	and vdp_cnt
c7b3 : c508             	cmp vdp_curstat		; Same as curent state?
c7b5 : f01a             	beq int_vdp_fin		; If so no change required
c7b7 : 8508             	sta vdp_curstat		; Save new state
c7b9 : a6dc             	ldx gr_scrngeom+gr_screen_ptr
c7bb : a5dd             	lda gr_scrngeom+gr_screen_ptr+1
c7bd : a8               	tay					; Save address high for later
c7be : 20ecc7           	jsr vdp_rd_addr		; Read current screen position
c7c1 : 2002c8           	jsr vdp_rd_vram
c7c4 : 4980             	eor	#0x80			; EOR top bit (inverse)
c7c6 : 8509             	sta vdp_curval		; Save cursor value
c7c8 : 98               	tya					; Get address hi back, X and A contain addres
c7c9 : 20e1c7           	jsr vdp_wr_addr		; Write current screen position
c7cc : a509             	lda vdp_curval		; Write cursor value
c7ce : 200fc8           	jsr vdp_wr_vram
c7d1 :                  int_vdp_fin	
c7d1 : 60               	rts
                        
                        ;****************************************
                        ;* vdp_rd_stat
                        ;* Read status register value in A
                        ;* Input : None
                        ;* Output : A - VDP Status Register Contents
                        ;* Regs affected : P, A
                        ;****************************************
c7d2 :                  vdp_rd_stat_old
c7d2 : ad01b4           	lda VDP_STATUS
c7d5 : 60               	rts
                        	
                        
                        ;****************************************
                        ;* vdp_wr_reg
                        ;* Write to Register A the value X
                        ;* Input : A - Register Number, X - Data
                        ;* Output : None
                        ;* Regs affected : P
                        ;****************************************
c7d6 :                  vdp_wr_reg
c7d6 : 8e01b4           	stx VDP_MODE1
c7d9 : 0980             	ora #0x80
c7db : 8d01b4           	sta VDP_MODE1
c7de : 4980             	eor #0x80
c7e0 : 60               	rts
AS65 Assembler for R6502 [1.42].                                     Page   48
------------------------------ kernel\kernel.s -------------------------------

                        	
                        ;****************************************
                        ;* vdp_wr_addr
                        ;* Write to address in X (low) and A (high) - for writ
                        ;* Input : A - Address high byte, X - Address low byte
                        ;* Output : None
                        ;* Regs affected : P
                        ;****************************************
c7e1 :                  vdp_wr_addr
c7e1 : 8e01b4           	stx VDP_MODE1
c7e4 : 0940             	ora #0x40		; Required by VDP
c7e6 : 8d01b4           	sta VDP_MODE1
c7e9 : 4940             	eor #0x40		; Undo that bit
                        	
c7eb : 60               	rts
                        
                        ;****************************************
                        ;* vdp_rd_addr
                        ;* Write to address in X (low) and A (high) - for read
                        ;* Input : A - Address high byte, X - Address low byte
                        ;* Output : None
                        ;* Regs affected : None
                        ;****************************************
c7ec :                  vdp_rd_addr
c7ec : 8e01b4           	stx VDP_MODE1
c7ef : 8d01b4           	sta VDP_MODE1
                        	
c7f2 : ea               	nop
c7f3 : ea               	nop
c7f4 : ea               	nop
c7f5 : ea               	nop
c7f6 : ea               	nop
c7f7 : ea               	nop
c7f8 : ea               	nop
c7f9 : ea               	nop
                        	
c7fa : 60               	rts
                        ;* Fast version of the above
c7fb :                  vdp_rd_addr_fast
c7fb : 8e01b4           	stx VDP_MODE1
c7fe : 8d01b4           	sta VDP_MODE1
                        
c801 : 60               	rts
                        	
                        ;****************************************
                        ;* vdp_rd_vram
                        ;* Read VRAM byte, result in A
                        ;* Input : None
                        ;* Output : A - Byte from VRAM
                        ;* Regs affected : P
                        ;****************************************
c802 :                  vdp_rd_vram
c802 : ad00b4           	lda VDP_VRAM;
                        
c805 : ea               	nop
c806 : ea               	nop
c807 : ea               	nop
c808 : ea               	nop
c809 : ea               	nop
                        
c80a : 60               	rts
                        ;* Fast version of the above
AS65 Assembler for R6502 [1.42].                                     Page   49
------------------------------ kernel\kernel.s -------------------------------

c80b :                  vdp_rd_vram_fast
c80b : ad00b4           	lda VDP_VRAM;
                        
c80e : 60               	rts
                        
                        	
                        ;****************************************
                        ;* vdp_wr_vram
                        ;* Write VRAM byte in A
                        ;* Input : A - Byte to write
                        ;* Output : None
                        ;* Regs affected : None
                        ;****************************************
c80f :                  vdp_wr_vram
c80f : 8d00b4           	sta VDP_VRAM
                        
c812 : ea               	nop
c813 : ea               	nop
c814 : ea               	nop
c815 : ea               	nop
c816 : ea               	nop
                        	
c817 : 60               	rts
                        ;* Fast version of the above
c818 :                  vdp_wr_vram_fast
c818 : 8d00b4           	sta VDP_VRAM
                        
c81b : 60               	rts
                        
                        ;****************************************
                        ;* vdp_poke
                        ;* Write VRAM byte in A, X = Low Add,Y = High Address
                        ;* Input : A - Byte to write
                        ;* Output : None
                        ;* Regs affected : None
                        ;****************************************
c81c :                  vdp_poke
c81c : 48               	pha
c81d : 98               	tya
c81e : 78               	sei
c81f : 20e1c7           	jsr vdp_wr_addr
c822 : 68               	pla
c823 : 200fc8           	jsr vdp_wr_vram
c826 : 58               	cli
c827 : 60               	rts
                        
                        ;****************************************
                        ;* vdp_peek
                        ;* Get VRAM byte in X = Low Add,A = High Address
                        ;* Output : A = byte read
                        ;* Regs affected : None
                        ;****************************************
c828 :                  vdp_peek
c828 : 78               	sei
c829 : 20ecc7           	jsr vdp_rd_addr
c82c : 2002c8           	jsr vdp_rd_vram
c82f : 58               	cli
c830 : 60               	rts
                        
                        ;****************************************
                        ;* vdp_set_base
                        ;* Copy vdp addresses
AS65 Assembler for R6502 [1.42].                                     Page   50
------------------------------ kernel\kernel.s -------------------------------

                        ;* Input : X = Offset in to tables
                        ;* Output : None
                        ;* Regs affected : All
                        ;****************************************
c831 :                  vdp_set_base
c831 : a000             	ldy #0
c833 :                  vdp_set_base_copy
c833 : bd9bc9           	lda vdp_base_table,x
c836 : 99cb00           	sta vdp_base,y
c839 : e8               	inx
c83a : c8               	iny
c83b : c00b             	cpy #vdp_addr_struct
c83d : d0f4             	bne vdp_set_base_copy
c83f : 60               	rts
                        
                        ;****************************************
                        ;* vdp_translate_addr
                        ;* Shift an address X,A by Y bits to the right
                        ;* Result in tmp_alo,tmp_ahi
                        ;****************************************
c840 :                  vdp_translate_addr
c840 : 8614             	stx tmp_alo
c842 : 8515             	sta tmp_ahi
c844 :                  vdp_translate_addr_bit
c844 : 4615             	lsr tmp_ahi
c846 : 6614             	ror tmp_alo
c848 : 88               	dey
c849 : d0f9             	bne vdp_translate_addr_bit
c84b : 60               	rts
                        
                        ;****************************************
                        ;* vdp_init_mode
                        ;* Initialise video processor to required mode and add
                        ;* Input : Y = Register 0 value, X = Register 1 value
                        ;* Output : None
                        ;* Regs affected : All
                        ;****************************************
c84c :                  vdp_init_mode
c84c : 78               	sei
                        	; use mode value in X for reg 1
c84d : a901             	lda #1
c84f : 20d6c7           	jsr vdp_wr_reg
                        
                        	; Reg 0 is taken from Y
c852 : 98               	tya
c853 : aa               	tax
c854 : a900             	lda #0
c856 : 20d6c7           	jsr vdp_wr_reg
                        
                        	; vdp_addr_nme >> 10
c859 : a6cb             	ldx vdp_base+vdp_addr_nme
c85b : a5cc             	lda vdp_base+vdp_addr_nme+1
c85d : a00a             	ldy #10
c85f : 2040c8           	jsr vdp_translate_addr
c862 : a902             	lda #2
c864 : a614             	ldx tmp_alo
c866 : 20d6c7           	jsr vdp_wr_reg
                        
                        	; vdp_addr_col >> 6
c869 : a6cd             	ldx vdp_base+vdp_addr_col
c86b : a5ce             	lda vdp_base+vdp_addr_col+1
c86d : a006             	ldy #6
AS65 Assembler for R6502 [1.42].                                     Page   51
------------------------------ kernel\kernel.s -------------------------------

c86f : 2040c8           	jsr vdp_translate_addr
c872 : a903             	lda #3
c874 : a614             	ldx tmp_alo
c876 : 20d6c7           	jsr vdp_wr_reg
                        
                        	; vdp_addr_pat >> 11
c879 : a6cf             	ldx vdp_base+vdp_addr_pat
c87b : a5d0             	lda vdp_base+vdp_addr_pat+1
c87d : a00b             	ldy #11
c87f : 2040c8           	jsr vdp_translate_addr
c882 : a904             	lda #4
c884 : a614             	ldx tmp_alo
c886 : 20d6c7           	jsr vdp_wr_reg
                        
                        	; vdp_addr_spa >> 7
c889 : a6d1             	ldx vdp_base+vdp_addr_spa
c88b : a5d2             	lda vdp_base+vdp_addr_spa+1
c88d : a007             	ldy #7
c88f : 2040c8           	jsr vdp_translate_addr
c892 : a905             	lda #5
c894 : a614             	ldx tmp_alo
c896 : 20d6c7           	jsr vdp_wr_reg
                        	
                        	; vdp_addr_spp >> 11
c899 : a6d3             	ldx vdp_base+vdp_addr_spp
c89b : a5d4             	lda vdp_base+vdp_addr_spp+1
c89d : a00b             	ldy #11
c89f : 2040c8           	jsr vdp_translate_addr
c8a2 : a906             	lda #6
c8a4 : a614             	ldx tmp_alo
c8a6 : 20d6c7           	jsr vdp_wr_reg
                        	
c8a9 : a6d5             	ldx vdp_base+vdp_bord_col
c8ab : a907             	lda #7
c8ad : 20d6c7           	jsr vdp_wr_reg
                        
c8b0 : 58               	cli
c8b1 : 60               	rts
                        
                        ;****************************************
                        ;* vdp_set_txt_mode
                        ;* Set up text mode
                        ;* Input : None
                        ;* Output : None
                        ;* Regs affected : All
                        ;****************************************
c8b2 :                  vdp_set_txt_mode
                        
c8b2 : a216             	ldx #vdp_base_table_txt-vdp_base_table
c8b4 : 2031c8           	jsr vdp_set_base
                        
c8b7 : a000             	ldy #0				; VDP R0
c8b9 : a2f0             	ldx #%11110000		; 16k, enable display, interrupts ena
c8bb : 204cc8           	jsr vdp_init_mode
                        	
c8be : 4c5bc9           	jmp init_fonts
                        	
                        ;****************************************
                        ;* vdp_set_g1_mode
                        ;* Set up G1 mode
                        ;* Input : None
                        ;* Output : None
AS65 Assembler for R6502 [1.42].                                     Page   52
------------------------------ kernel\kernel.s -------------------------------

                        ;* Regs affected : All
                        ;****************************************
c8c1 :                  vdp_set_g1_mode
c8c1 : a200             	ldx #vdp_base_table_g1-vdp_base_table
c8c3 : 2031c8           	jsr vdp_set_base
                        
c8c6 : a000             	ldy	#0				; VDP R0
c8c8 : a2e0             	ldx #%11100000		; 16k, enable display, interrupts ena
c8ca : 204cc8           	jsr vdp_init_mode
c8cd : 4c5bc9           	jmp init_fonts
                        
                        ;****************************************
                        ;* vdp_set_hires
                        ;* Set up HI mode
                        ;* Input : None
                        ;* Output : None
                        ;* Regs affected : All
                        ;****************************************
c8d0 :                  vdp_set_hires
c8d0 : a20b             	ldx #vdp_base_table_hi-vdp_base_table
c8d2 : 2031c8           	jsr vdp_set_base
                        	
c8d5 : 78               	sei
                        
                        	; Point at name table
c8d6 : a6cb             	ldx vdp_base+vdp_addr_nme
c8d8 : a5cc             	lda vdp_base+vdp_addr_nme+1
c8da : 20e1c7           	jsr vdp_wr_addr
                        	
                        	; set name for 3 pages (768)
c8dd : a200             	ldx #0
c8df : a003             	ldy #3
c8e1 :                  vdp_set_hires_fill_nme
c8e1 : 8a               	txa						; Name table is 0..255 for 3 pages
c8e2 : 200fc8           	jsr vdp_wr_vram
c8e5 : e8               	inx
c8e6 : d0f9             	bne vdp_set_hires_fill_nme
c8e8 : 88               	dey
c8e9 : d0f6             	bne vdp_set_hires_fill_nme
                        	
c8eb : 58               	cli
                        
c8ec : a002             	ldy	#%00000010		; VDP R0
c8ee : a2e0             	ldx #%11100000		; 16k, enable display, interrupts ena
c8f0 : 204cc8           	jsr vdp_init_mode
                        
                        	; Override colour table with 0xFF else hires doesn't 
                        	; Override pattern table with 0x03 else hires doesn't
c8f3 : 78               	sei
c8f4 : a903             	lda #3
c8f6 : a2ff             	ldx #0xff
c8f8 : 20d6c7           	jsr vdp_wr_reg
c8fb : a904             	lda #4
c8fd : a203             	ldx #0x03
c8ff : 20d6c7           	jsr vdp_wr_reg
c902 : 58               	cli
                        	
c903 : 60               	rts
                        
                        	
                        ;****************************************
                        ;* init_vdp_g1
AS65 Assembler for R6502 [1.42].                                     Page   53
------------------------------ kernel\kernel.s -------------------------------

                        ;* Initialise video processor graphics 1
                        ;* Input : None
                        ;* Output : None
                        ;* Regs affected : All
                        ;***************************************
c904 :                  init_vdp_g1
c904 : 20c1c8           	jsr vdp_set_g1_mode
c907 : 2068c9           	jsr init_sprtpat_g1
c90a : 2035c9           	jsr init_colours_g1
c90d : 2048c9           	jsr init_sprites_g1
c910 : 60               	rts
                        
                        ;****************************************
                        ;* init_vdp_hires
                        ;* Initialise video processor graphics 1
                        ;* Input : None
                        ;* Output : None
                        ;* Regs affected : All
                        ;***************************************
c911 :                  init_vdp_hires
c911 : 20d0c8           	jsr vdp_set_hires
c914 : 2068c9           	jsr init_sprtpat_g1
c917 : 4c48c9           	jmp init_sprites_g1
                        
                        
                        ;****************************************
                        ;* init_vdp_txt
                        ;* Initialise video processor text mode
                        ;* Input : None
                        ;* Output : None
                        ;* Regs affected : All
                        ;***************************************
c91a :                  init_vdp_txt
c91a : 8096             	jmp vdp_set_txt_mode
                        	
                        
                        ;****************************************
                        ;* fill_vram
                        ;* Fill a number of VRAM bytes with a value
                        ;* Input : X,Y = Fill length (lo,hi), A = Value
                        ;* Output : None
                        ;* Regs affected : All
                        ;* ASSUMES vdp_wr_vram already called
                        ;* Works for < 256 bytes as long as Y=1
                        ;* Else only use for WHOLE pages at a time so X must b
                        ;* INTERRUPTS MUST HAVE BEEN DISABLED BY THE CALLER!!!
                        ;****************************************
c91c :                  vdp_fill_vram
c91c : 2018c8           	jsr vdp_wr_vram_fast
c91f : ca               	dex
c920 : d0fa             	bne vdp_fill_vram
c922 : 88               	dey
c923 : d0f7             	bne vdp_fill_vram
c925 : 60               	rts
                        
                        ;****************************************
                        ;* clear_vram
                        ;* Set all 16k VDP vram to 0x00
                        ;* Input : None
                        ;* Output : None
                        ;* Regs affected : All
                        ;****************************************
AS65 Assembler for R6502 [1.42].                                     Page   54
------------------------------ kernel\kernel.s -------------------------------

c926 :                  clear_vram
c926 : 78               	sei
c927 : a200             	ldx #0x00			; Low byte of address
c929 : a900             	lda #0x00			; High byte of address
c92b : 20e1c7           	jsr vdp_wr_addr		; Write address to VDP
                        
c92e : a040             	ldy #0x40			; 0x40 pages = 16k (X already zero)
c930 : 201cc9           	jsr vdp_fill_vram
c933 : 58               	cli
c934 : 60               	rts
                        	
                        ;****************************************
                        ;* init_colours_g1
                        ;* Initialise colour table for graphics 1
                        ;* Input : None
                        ;* Output : None
                        ;* Regs affected : All
                        ;****************************************
c935 :                  init_colours_g1
c935 : 78               	sei
c936 : a6cd             	ldx vdp_base+vdp_addr_col
c938 : a5ce             	lda vdp_base+vdp_addr_col+1
c93a : 20e1c7           	jsr vdp_wr_addr				; Set VDP address
                        	
c93d : a220             	ldx #0x20					; 32 bytes to fill	
c93f : a001             	ldy #0x01					; Only 1 pass through
c941 : a5d5             	lda vdp_base+vdp_bord_col	; Border colour
c943 : 201cc9           	jsr vdp_fill_vram
c946 : 58               	cli
c947 : 60               	rts
                        
                        ;****************************************
                        ;* init_sprites_g1
                        ;* Initialise sprite attribute table for graphics 1
                        ;* Input : None
                        ;* Output : None
                        ;* Regs affected : All
                        ;****************************************
c948 :                  init_sprites_g1
c948 : 78               	sei
c949 : a6d1             	ldx vdp_base+vdp_addr_spa
c94b : a5d2             	lda vdp_base+vdp_addr_spa+1
c94d : 20e1c7           	jsr vdp_wr_addr				; Set VDP address
                        	
c950 : a280             	ldx #0x80					; 128 bytes of attribute to fill
c952 : a001             	ldy #0x01					; Only 1 pass
c954 : a9d0             	lda #0xd0					; Sprite terminator
c956 : 201cc9           	jsr vdp_fill_vram
c959 : 58               	cli
c95a : 60               	rts
                        
                        ;****************************************
                        ;* init_fonts
                        ;* Initialise fonts 
                        ;* Input : None
                        ;* Output : None
                        ;* Regs affected : All
                        ;****************************************
c95b :                  init_fonts
c95b : 78               	sei
c95c : a6cf             	ldx vdp_base+vdp_addr_pat
c95e : a5d0             	lda vdp_base+vdp_addr_pat+1
AS65 Assembler for R6502 [1.42].                                     Page   55
------------------------------ kernel\kernel.s -------------------------------

c960 : 20e1c7           	jsr vdp_wr_addr				; Write the address
c963 : 2075c9           	jsr init_fonts_sub
c966 : 58               	cli
c967 : 60               	rts
                        
                        ;****************************************
                        ;* init_sprtpat_g1
                        ;* Initialise fonts for sprites
                        ;* Input : None
                        ;* Output : None
                        ;* Regs affected : All
                        ;****************************************
c968 :                  init_sprtpat_g1
c968 : 78               	sei
c969 : a6d3             	ldx vdp_base+vdp_addr_spp
c96b : a5d4             	lda vdp_base+vdp_addr_spp+1
c96d : 20e1c7           	jsr vdp_wr_addr				; Write the address
c970 : 2075c9           	jsr init_fonts_sub
c973 : 58               	cli
c974 : 60               	rts
                        	
                        ;****************************************
                        ;* init_fonts_sub
                        ;* Initialise fonts common subroutine
                        ;* Input : None
                        ;* Output : None
                        ;* Regs affected : All
                        ;* INTERRUPTS MUST HAVE BEEN DISABLED BY CALLER!!!
                        ;****************************************
c975 :                  init_fonts_sub
c975 : a900             	lda #0x00				; XOR with zero = no change
c977 : 851a             	sta tmp_a
c979 :                  init_write_fonts
c979 : a9a2             	lda #lo(vdp_font)		; Low byte of fonts source
c97b : 8514             	sta tmp_alo
c97d : a9c3             	lda #hi(vdp_font)		; High byte of fonts source
c97f : 8515             	sta tmp_ahi
c981 : a204             	ldx #0x04				; 4 pages = 1024 bytes
c983 :                  init_pattern
c983 : b114             	lda (tmp_alo),y			; Get byte from font table
c985 : 451a             	eor tmp_a				; Invert if tmp_a is 0xff
c987 : 200fc8           	jsr vdp_wr_vram			; Write the byte to VRAM
c98a : c8               	iny
c98b : d0f6             	bne init_pattern		; keep going for 1 page
c98d : e615             	inc tmp_ahi				; only need to increment high byte of 
c98f : ca               	dex						; page counter
c990 : d0f1             	bne init_pattern		; keep going for 4 pages
c992 : a51a             	lda tmp_a				; get the current eor mask
c994 : 49ff             	eor	#0xff				; Invert the EOR mask
c996 : 851a             	sta tmp_a				; And save for next go around
c998 : d0df             	bne init_write_fonts
                        	
c99a : 60               	rts
                        
                        ;**** BASE TABLES ****
c99b :                  vdp_base_table
c99b :                  vdp_base_table_g1
c99b : 0010             	dw	0x1000			; Name table
c99d : 8013             	dw	0x1380			; Colour table
c99f : 0000             	dw	0x0000			; Pattern table
c9a1 : 0013             	dw	0x1300			; Sprite attribute table
c9a3 : 0008             	dw	0x0800			; Sprite pattern table
AS65 Assembler for R6502 [1.42].                                     Page   56
------------------------------ kernel\kernel.s -------------------------------

c9a5 : f4               	db	%11110100		; White f/gnd, blue background
c9a6 :                  vdp_base_table_hi
c9a6 : 0038             	dw	0x3800			; Name table
c9a8 : 0020             	dw	0x2000			; Colour table
c9aa : 0000             	dw	0x0000			; Pattern table
c9ac : 003b             	dw	0x3b00			; Sprite attribute table
c9ae : 0018             	dw	0x1800			; Sprite pattern table
c9b0 : f4               	db	%11110100		; White f/gnd, blue background
c9b1 :                  vdp_base_table_txt
c9b1 : 0008             	dw	0x0800			; Name table
c9b3 : 0000             	dw	0				; Colour table NA
c9b5 : 0000             	dw	0x0000			; Pattern table
c9b7 : 0000             	dw	0				; Sprite attribute table NA
c9b9 : 0000             	dw	0				; Sprite pattern table NA
c9bb : f4               	db	%11110100		; White f/gnd, blue background
                        
                        	include "vdp\graph.s"
                        ;*****************************************************
                        ;*
                        ;*	DOLO-1 HOMEBREW COMPUTER
                        ;*	Hardware and software design by Dolo Miah
                        ;*	Copyright 2014-18
                        ;*  Free to use for any non-commercial purpose subject
                        ;*  full credit of original my authorship please!
                        ;*
                        ;*  GRAPH.S
                        ;*  This is the graphics module, to handle text and hi
                        ;*  graphics.  On startup, the BBC DIP settings define
                        ;*  whether the computer will go in to 32 or 40 column
                        ;*  screen mode.  The kernel code calls the right
                        ;*  initialisation code.
                        ;*  For text modes, this module keeps track of where t
                        ;*  next put a character, and also takes care of wrapp
                        ;*  to the next line as well as scrolling the contents
                        ;*  when the cursor has reached the bottom right.  Thi
                        ;*  module also enables text input which is echoed to 
                        ;*  screen, to allow interactive input and editing.
                        ;*
                        ;*****************************************************
                        
                        	; ROM code
                        	code
                        
                        ;****************************************
                        ;* gr_init_screen_common
                        ;* Common screen initialisation code
                        ;* A = Blank character
                        ;****************************************
c9bc :                  gr_init_screen_common
                        	; Store blank char
c9bc : 850a             	sta vdp_blank
                        	
                        	; VRAM address of screen data
c9be : a5cb             	lda vdp_base+vdp_addr_nme
c9c0 : 85d6             	sta gr_scrngeom+gr_screen_start
c9c2 : a5cc             	lda vdp_base+vdp_addr_nme+1
c9c4 : 85d7             	sta gr_scrngeom+gr_screen_start+1
                        
                        	; Cursor pointer in to screen
c9c6 : a5d6             	lda gr_scrngeom+gr_screen_start
c9c8 : 85dc             	sta gr_scrngeom+gr_screen_ptr
c9ca : a5d7             	lda gr_scrngeom+gr_screen_start+1
AS65 Assembler for R6502 [1.42].                                     Page   57
------------------------------ kernel\kernel.s -------------------------------

c9cc : 85dd             	sta gr_scrngeom+gr_screen_ptr+1
                        
                        	; Top left cursor position 0,0
c9ce : 64de             	stz gr_scrngeom+gr_cur_x
c9d0 : 64df             	stz gr_scrngeom+gr_cur_y
                        	
c9d2 : 2045ca           	jsr gr_cls
                        	
c9d5 : 60               	rts
                        
                        ;****************************************
                        ;* gr_init_screen_g1
                        ;* initialise the screen in graphic mode 1
                        ;****************************************
c9d6 :                  gr_init_screen_g1
c9d6 : 2004c9           	jsr init_vdp_g1
                        
                        	; Size of screen in bytes
c9d9 : a900             	lda #lo(768)					
c9db : 85d8             	sta gr_scrngeom+gr_screen_size
c9dd : a903             	lda #hi(768)	
c9df : 85d9             	sta gr_scrngeom+gr_screen_size+1
                        
                        	; Width and height
c9e1 : a920             	lda #32
c9e3 : 85da             	sta gr_scrngeom+gr_screen_w
c9e5 : a918             	lda #24
c9e7 : 85db             	sta gr_scrngeom+gr_screen_h
                        
c9e9 : a920             	lda #' '						; Blank is SPACE
c9eb : 20bcc9           	jsr gr_init_screen_common
c9ee : 60               	rts
                        
                        ;****************************************
                        ;* gr_init_screen_txt
                        ;* initialise the screen in text mode
                        ;****************************************
c9ef :                  gr_init_screen_txt
c9ef : 201ac9           	jsr init_vdp_txt
                        
                        	; Size of screen in bytes
c9f2 : a9c0             	lda #lo(960)					
c9f4 : 85d8             	sta gr_scrngeom+gr_screen_size
c9f6 : a903             	lda #hi(960)	
c9f8 : 85d9             	sta gr_scrngeom+gr_screen_size+1
                        
                        	; Width and height
c9fa : a928             	lda #40
c9fc : 85da             	sta gr_scrngeom+gr_screen_w
c9fe : a918             	lda #24
ca00 : 85db             	sta gr_scrngeom+gr_screen_h
                        
ca02 : a920             	lda #' '						; Blank is SPACE
ca04 : 20bcc9           	jsr gr_init_screen_common
                        
ca07 : 60               	rts
                        
                        ;****************************************
                        ;* gr_init_screen_hires
                        ;* Input : X = Colour table fill value
                        ;* initialise the screen in hires mode
                        ;****************************************
AS65 Assembler for R6502 [1.42].                                     Page   58
------------------------------ kernel\kernel.s -------------------------------

ca08 :                  gr_init_screen_hires
ca08 : da               	phx
                        
ca09 : e607             	inc vdp_curoff
                        	
ca0b : 2011c9           	jsr init_vdp_hires
                        
                        	; Size of screen in bytes
ca0e : a900             	lda #lo(6144)					
ca10 : 85d8             	sta gr_scrngeom+gr_screen_size
ca12 : a918             	lda #hi(6144)	
ca14 : 85d9             	sta gr_scrngeom+gr_screen_size+1
                        
                        	; Width and height
ca16 : a920             	lda #32
ca18 : 85da             	sta gr_scrngeom+gr_screen_w
ca1a : a9c0             	lda #192
ca1c : 85db             	sta gr_scrngeom+gr_screen_h
                        
ca1e : 78               	sei
                        	; point to colour table
ca1f : a6cd             	ldx vdp_base+vdp_addr_col
ca21 : a5ce             	lda vdp_base+vdp_addr_col+1
ca23 : 20e1c7           	jsr vdp_wr_addr
                        	; set colour for 0x18 pages (6144) bytes
ca26 : 68               	pla							; Get the saved value from stack
ca27 : a200             	ldx #0
ca29 : a018             	ldy #0x18
ca2b : 201cc9           	jsr vdp_fill_vram
                        
ca2e : 58               	cli
                        	
                        	; Now point screen at pattern for HIRES
ca2f : a5cf             	lda vdp_base+vdp_addr_pat
ca31 : 85cb             	sta vdp_base+vdp_addr_nme
ca33 : a5d0             	lda vdp_base+vdp_addr_pat+1
ca35 : 85cc             	sta vdp_base+vdp_addr_nme+1
                        	
ca37 : a900             	lda #0							; Blank is ZERO
ca39 : 20bcc9           	jsr gr_init_screen_common
                        	
                        
ca3c : 60               	rts
                        
                        ;****************************************
                        ;* gr_init_screen
                        ;* A = Mode (0 = text, Not zero = graphic)
                        ;* initialise the screen in text mode
                        ;****************************************
ca3d :                  gr_init_screen
ca3d : c900             	cmp #0
ca3f : d002             	bne gr_init_skip_txt
ca41 : 80ac             	jmp gr_init_screen_txt
ca43 :                  gr_init_skip_txt
ca43 : 8091             	jmp gr_init_screen_g1
                        
                        ;****************************************
                        ;* gr_cls
                        ;* Clear the screen
                        ;****************************************
ca45 :                  gr_cls
ca45 : 48               	pha
AS65 Assembler for R6502 [1.42].                                     Page   59
------------------------------ kernel\kernel.s -------------------------------

ca46 : da               	phx
ca47 : 5a               	phy
                        	
                        	; Set VDP Address
ca48 : 78               	sei
ca49 : a6d6             	ldx gr_scrngeom+gr_screen_start
ca4b : a5d7             	lda gr_scrngeom+gr_screen_start+1
ca4d : 20e1c7           	jsr vdp_wr_addr
                        
                        	; X and Y count bytes to fill
ca50 : a200             	ldx #0
ca52 : a000             	ldy #0
ca54 : a50a             	lda vdp_blank
ca56 :                  gr_cls_loop
ca56 : 2018c8           	jsr vdp_wr_vram_fast
ca59 : e8               	inx
ca5a : d001             	bne gr_cls_skipy
ca5c : c8               	iny
ca5d :                  gr_cls_skipy
ca5d : e4d8             	cpx gr_scrngeom+gr_screen_size
ca5f : d0f5             	bne gr_cls_loop
ca61 : c4d9             	cpy gr_scrngeom+gr_screen_size+1
ca63 : d0f1             	bne gr_cls_loop
                        	
ca65 : 58               	cli
                        	
ca66 : 7a               	ply
ca67 : fa               	plx
ca68 : 68               	pla
                        	
ca69 : 60               	rts
                        	
                        ;****************************************
                        ;* gr_plot
                        ;* Write a byte in the current cursor pos
                        ;* Input : A = Byte to put
                        ;* Output : None
                        ;* Regs affected : None
                        ;****************************************
ca6a :                  gr_plot
                        	_pushAXY
                        
ca6d : a6dc             	ldx gr_scrngeom+gr_screen_ptr
ca6f : a4dd             	ldy gr_scrngeom+gr_screen_ptr+1
ca71 : 8509             	sta vdp_curval					; Update cursor value
ca73 : 201cc8           	jsr vdp_poke
                        	_pullAXY
                        
ca79 : 60               	rts
                        
                        ;****************************************
                        ;* gr_point
                        ;* Write a point to the X,Y coordinates with mode A
                        ;* Input : X,Y = coord, A = mode (0,1,2)
                        ;* Output : None
                        ;* Regs affected : None
                        ;****************************************
ca7a :                  gr_point
                        	; Save A and X for later
ca7a : 48               	pha
ca7b : da               	phx
                        	; Low byte = X&F8 | Y&07
AS65 Assembler for R6502 [1.42].                                     Page   60
------------------------------ kernel\kernel.s -------------------------------

ca7c : 8a               	txa
ca7d : 29f8             	and #0xf8
ca7f : 8514             	sta tmp_alo
ca81 : 98               	tya
ca82 : 2907             	and #0x07
ca84 : 0514             	ora tmp_alo
ca86 : 8514             	sta tmp_alo
                        	; High byte = Y>>3
ca88 : 98               	tya
ca89 : 4a               	lsr a
ca8a : 4a               	lsr a
ca8b : 4a               	lsr a
ca8c : 8515             	sta tmp_ahi
                        	; Get the current VRAM byte (address in X,A)
ca8e : a614             	ldx tmp_alo
ca90 : 2028c8           	jsr vdp_peek
                        	; Save in temp
ca93 : 8516             	sta tmp_blo
                        	; Get X back and mask off 3 LSBs
ca95 : 68               	pla
ca96 : 2907             	and #0x07
                        	; Use this to find the bit number mask and save in te
ca98 : aa               	tax
ca99 : bdb9ca           	lda gr_point_mask,x
ca9c : 8517             	sta tmp_bhi
                        	; Get the mode number in to X
ca9e : fa               	plx
                        	; load VRAM byte
ca9f : a516             	lda tmp_blo
                        	; first assume that we want to set a bit - OR with VR
caa1 : 0517             	ora tmp_bhi
                        	; if that is correct then done
caa3 : e001             	cpx #1
caa5 : f00a             	beq gr_point_done
                        	; now assume that actually we want to erase but - EOR
caa7 : 4517             	eor tmp_bhi
                        	; if that is correct then done
caa9 : e000             	cpx #0
caab : f004             	beq gr_point_done
                        	; else we want to really just do an eor of VRAM with 
caad : a516             	lda tmp_blo
caaf : 4517             	eor tmp_bhi
                        	; so now we have the VRAM bit set properly in temp - 
cab1 :                  gr_point_done
cab1 : a614             	ldx tmp_alo
cab3 : a415             	ldy tmp_ahi
cab5 : 201cc8           	jsr vdp_poke
cab8 : 60               	rts
cab9 :                  gr_point_mask
cab9 : 8040201008040201 	db 0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01
                        
                        ;****************************************
                        ;* gr_line
                        ;* Draw a line from x0,y0 -> x1,y1 in mode A
                        ;* Input :	num_a   = x0
                        ;*			num_a+1 = y0
                        ;*			num_a+2 = x1
                        ;*			num_a+3 = y1
                        ;*			A = mode (0,1,2)
                        ;* Output : None
                        ;* Regs affected : None
                        ;****************************************
AS65 Assembler for R6502 [1.42].                                     Page   61
------------------------------ kernel\kernel.s -------------------------------

cac1 :                  gr_line
                        
0046 =                  grl_x0 	= (num_a)
0047 =                  grl_y0 	= (num_a+1)
0048 =                  grl_x1 	= (num_a+2)
0049 =                  grl_y1 	= (num_a+3)
004a =                  grl_m	= (num_b)
004b =                  grl_dx	= (num_b+1)
004c =                  grl_dy	= (num_b+2)
004d =                  grl_xyyx= (num_b+3)
004e =                  grl_2dx	= (num_x)
0050 =                  grl_2dy	= (num_x+2)
0052 =                  grl_2dxy= (num_tmp)
0054 =                  grl_inx	= (num_tmp+2)
0055 =                  grl_iny = (num_tmp+3)
0056 =                  grl_p	= (num_buf)
                        
cac1 : 854a             	sta grl_m					; Save mode for later
cac3 : 644d             	stz grl_xyyx				; Assume normal xy axis
                        	
                        ;    int dx, dy, p, x, y;
                        	; check if abs(dy)>abs(dx) if so need to swap xy
                        	; num_b = abs(x), num_b+1 = abs(dy)
cac5 : 38               	sec
cac6 : a548             	lda grl_x1
cac8 : e546             	sbc grl_x0
caca : b003             	bcs gr_line_skip_dx_neg
cacc : 49ff             	eor #0xff
cace : 1a               	inc a
cacf :                  gr_line_skip_dx_neg
cacf : 854b             	sta grl_dx
cad1 : 38               	sec
cad2 : a549             	lda grl_y1
cad4 : e547             	sbc grl_y0
cad6 : b003             	bcs gr_line_skip_dy_neg
cad8 : 49ff             	eor #0xff
cada : 1a               	inc a
cadb :                  gr_line_skip_dy_neg
cadb : 854c             	sta grl_dy
cadd : c54b             	cmp grl_dx
cadf : 901a             	bcc gr_line_skip_xy_swap
                        	; swap xy axes and also dx and dy
cae1 : a546             	lda grl_x0					; swap x0 and y0
cae3 : a647             	ldx grl_y0
cae5 : 8547             	sta grl_y0
cae7 : 8646             	stx grl_x0
cae9 : a548             	lda grl_x1					; swap x1 and y1
caeb : a649             	ldx grl_y1
caed : 8549             	sta grl_y1
caef : 8648             	stx grl_x1
caf1 : a54b             	lda grl_dx					; swap dy and dx
caf3 : a64c             	ldx grl_dy
caf5 : 854c             	sta grl_dy
caf7 : 864b             	stx grl_dx
caf9 : e64d             	inc grl_xyyx				; set flag to Not Z to know about axi
                        	
cafb :                  gr_line_skip_xy_swap	
                        	; assume going from left to right
cafb : a901             	lda #1
cafd : 8554             	sta grl_inx
caff : a546             	lda grl_x0
cb01 : c548             	cmp grl_x1
AS65 Assembler for R6502 [1.42].                                     Page   62
------------------------------ kernel\kernel.s -------------------------------

cb03 : 9004             	bcc gr_line_skip_x_swap
cb05 : a9ff             	lda #0xff					; make x increment negative
cb07 : 8554             	sta grl_inx
                        	
cb09 :                  gr_line_skip_x_swap
                        	; assume going from top to bottom
cb09 : a901             	lda #1
cb0b : 8555             	sta grl_iny
cb0d : a547             	lda grl_y0
cb0f : c549             	cmp grl_y1
cb11 : 9004             	bcc gr_line_skip_y_up
cb13 : a9ff             	lda #0xff					; make y increment negative
cb15 : 8555             	sta grl_iny
                        
cb17 :                  gr_line_skip_y_up
cb17 : a54b             	lda grl_dx
cb19 : 0a               	asl a
cb1a : 854e             	sta grl_2dx					; 2*dx (word)
cb1c : 644f             	stz grl_2dx+1
cb1e : 264f             	rol grl_2dx+1
                        
cb20 : a54c             	lda grl_dy
cb22 : 0a               	asl a
cb23 : 8550             	sta grl_2dy					; 2*dy (word)
cb25 : 6451             	stz grl_2dy+1
cb27 : 2651             	rol grl_2dy+1
                        	
                        ;    p=2*dy-dx;					; p (word)
cb29 : 38               	sec
cb2a : a550             	lda grl_2dy
cb2c : e54b             	sbc grl_dx
cb2e : 8556             	sta grl_p
cb30 : a551             	lda grl_2dy+1
cb32 : e900             	sbc #0
cb34 : 8557             	sta grl_p+1
                        	
                        ;   2*(dy-dx)					; num_tmp+2 = 2*(dy-dx)
cb36 : 38               	sec
cb37 : a550             	lda grl_2dy
cb39 : e54e             	sbc grl_2dx
cb3b : 8552             	sta grl_2dxy
cb3d : a551             	lda grl_2dy+1
cb3f : e54f             	sbc grl_2dx+1
cb41 : 8553             	sta grl_2dxy+1
                        
cb43 :                  gr_line_pixel
                        	; plot the current pixel position
cb43 : a646             	ldx grl_x0
cb45 : a447             	ldy grl_y0
cb47 : a54d             	lda grl_xyyx				; is xy swapped?
cb49 : f004             	beq gr_skip_xy_swap2
cb4b : a647             	ldx grl_y0
cb4d : a446             	ldy grl_x0	
cb4f :                  gr_skip_xy_swap2
cb4f : a54a             	lda grl_m
cb51 : 207aca           	jsr gr_point
                        	
cb54 : a546             	lda grl_x0					; Check if done
cb56 : c548             	cmp grl_x1
cb58 : f030             	beq gr_line_done
                        
                        	; check sign of p
AS65 Assembler for R6502 [1.42].                                     Page   63
------------------------------ kernel\kernel.s -------------------------------

cb5a : a557             	lda grl_p+1
cb5c : 3016             	bmi gr_line_neg_p
                        
                        	; if p >=0
                        	
                        	; y=y+increment
cb5e : 18               	clc
cb5f : a547             	lda grl_y0
cb61 : 6555             	adc grl_iny
cb63 : 8547             	sta grl_y0
                        
                        	; p=p+2*dy-2*dx
                        	_addZPWord grl_p,grl_2dxy
                        
cb72 : 800d             	bra gr_line_incx
                        
cb74 :                  gr_line_neg_p
                        	; if p < 0
                        	; p=p+2*dy
                        	_addZPWord grl_p,grl_2dy
                        
                        	
cb81 :                  gr_line_incx
cb81 : 18               	clc
cb82 : a546             	lda grl_x0
cb84 : 6554             	adc grl_inx
cb86 : 8546             	sta grl_x0
cb88 : 80b9             	bra gr_line_pixel
cb8a :                  gr_line_done
cb8a : 60               	rts
                        	
                        
                        ;    while(x<x1)
                        ;    {
                        ;        if(p>=0)
                        ;        {
                        ;            putpixel(x,y,7);
                        ;            y=y+1;
                        ;            p=p+2*dy-2*dx;
                        ;        }
                        ;        else
                        ;        {
                        ;            putpixel(x,y,7);
                        ;            p=p+2*dy;
                        ;        }
                        ;        x=x+1;
                        ;    }
                        
                        
                        ;****************************************
                        ;* gr_scroll_up
                        ;* Scroll screen one line up
                        ;****************************************
cb8b :                  gr_scroll_up
cb8b : 48               	pha
cb8c : da               	phx
cb8d : 5a               	phy
                        
                        	
                        	; Get VDP Address of line + 1 line (source addr)
cb8e : 18               	clc
cb8f : a5d6             	lda gr_scrngeom+gr_screen_start
AS65 Assembler for R6502 [1.42].                                     Page   64
------------------------------ kernel\kernel.s -------------------------------

cb91 : 65da             	adc gr_scrngeom+gr_screen_w
cb93 : 8514             	sta tmp_alo
cb95 : a5d7             	lda gr_scrngeom+gr_screen_start+1
cb97 : 6900             	adc #0
cb99 : 8515             	sta tmp_ahi
                        	
                        	; Get destinaton address = first line of screen
cb9b : a5d6             	lda gr_scrngeom+gr_screen_start
cb9d : 8516             	sta tmp_blo
cb9f : a5d7             	lda gr_scrngeom+gr_screen_start+1
cba1 : 8517             	sta tmp_bhi
                        	
cba3 : a4db             	ldy gr_scrngeom+gr_screen_h
cba5 : 88               	dey
cba6 : 78               	sei
                        
                        	; Cursor off
cba7 : e607             	inc vdp_curoff
cba9 :                  gr_scroll_cpy_ln
                        	; Set VDP with source address to read
cba9 : a614             	ldx tmp_alo
cbab : a515             	lda tmp_ahi
cbad : 20ecc7           	jsr vdp_rd_addr
                        
                        	; Read in a line worth of screen
cbb0 : a6da             	ldx gr_scrngeom+gr_screen_w
cbb2 :                  gr_scroll_read_ln
cbb2 : 200bc8           	jsr vdp_rd_vram_fast
cbb5 : 9db807           	sta scratch,x
cbb8 : ca               	dex
cbb9 : ea               	nop
cbba : ea               	nop
cbbb : d0f5             	bne gr_scroll_read_ln
                        
                        	; Set VDP with destinaton to write
cbbd : a616             	ldx tmp_blo
cbbf : a517             	lda tmp_bhi
cbc1 : 20e1c7           	jsr vdp_wr_addr
                        	
                        	; Write out a line worth of screen
cbc4 : a6da             	ldx gr_scrngeom+gr_screen_w
cbc6 :                  gr_scroll_write_ln
cbc6 : bdb807           	lda scratch,x
cbc9 : 2018c8           	jsr vdp_wr_vram_fast
cbcc : ca               	dex
cbcd : d0f7             	bne gr_scroll_write_ln
                        
                        	; Update source address
cbcf : 18               	clc
cbd0 : a514             	lda tmp_alo
cbd2 : 65da             	adc gr_scrngeom+gr_screen_w
cbd4 : 8514             	sta tmp_alo
cbd6 : a515             	lda tmp_ahi
cbd8 : 6900             	adc #0
cbda : 8515             	sta tmp_ahi
                        	; Update destinaton address
cbdc : 18               	clc
cbdd : a516             	lda tmp_blo
cbdf : 65da             	adc gr_scrngeom+gr_screen_w
cbe1 : 8516             	sta tmp_blo
cbe3 : a517             	lda tmp_bhi
cbe5 : 6900             	adc #0
AS65 Assembler for R6502 [1.42].                                     Page   65
------------------------------ kernel\kernel.s -------------------------------

cbe7 : 8517             	sta tmp_bhi
                        
                        	; One line complete
cbe9 : 88               	dey
cbea : d0bd             	bne gr_scroll_cpy_ln
                        	
                        	; VDP is pointing at last line
                        	; Needs to be filled with blank
cbec : a50a             	lda vdp_blank
cbee : a6da             	ldx gr_scrngeom+gr_screen_w
cbf0 :                  gr_scroll_erase_ln
cbf0 : 2018c8           	jsr vdp_wr_vram_fast
cbf3 : ca               	dex
cbf4 : d0fa             	bne gr_scroll_erase_ln
                        
                        	; Cursor on
cbf6 : c607             	dec vdp_curoff
                        	
cbf8 : 58               	cli
                        	
cbf9 : 7a               	ply
cbfa : fa               	plx
cbfb : 68               	pla
                        	
cbfc : 60               	rts
                        	
                        ;****************************************
                        ;* gr_set_cur_pos
                        ;* Set the cursor position
                        ;* Input : X, Y = position
                        ;* Output : None
                        ;* Regs affected : None
                        ;****************************************
cbfd :                  gr_set_cur_pos
cbfd : 48               	pha
cbfe : da               	phx
cbff : 5a               	phy
                        
                        	; Initialise pointer to start of screen
                        ;	lda gr_scrngeom+gr_screen_start
                        ;	sta gr_scrngeom+gr_screen_ptr
                        ;	lda gr_scrngeom+gr_screen_start+1
                        ;	sta gr_scrngeom+gr_screen_ptr+1
                        	
                        	; 32 or 40 columns table selection
cc00 : a5da             	lda gr_scrngeom+gr_screen_w
cc02 : c928             	cmp #40
cc04 : d011             	bne gr_set_skip_40
                        
cc06 : 18               	clc
cc07 : b914cd           	lda gr_offset_40lo, y
cc0a : 65d6             	adc gr_scrngeom+gr_screen_start
cc0c : 85dc             	sta gr_scrngeom+gr_screen_ptr
cc0e : b92ccd           	lda gr_offset_40hi, y
cc11 : 65d7             	adc gr_scrngeom+gr_screen_start+1
cc13 : 85dd             	sta gr_scrngeom+gr_screen_ptr+1
cc15 : 800f             	bra gr_add_x_offset
                        
cc17 :                  gr_set_skip_40
cc17 : 18               	clc
cc18 : b944cd           	lda gr_offset_32lo, y
cc1b : 65d6             	adc gr_scrngeom+gr_screen_start
AS65 Assembler for R6502 [1.42].                                     Page   66
------------------------------ kernel\kernel.s -------------------------------

cc1d : 85dc             	sta gr_scrngeom+gr_screen_ptr
cc1f : b95ccd           	lda gr_offset_32hi, y
cc22 : 65d7             	adc gr_scrngeom+gr_screen_start+1
cc24 : 85dd             	sta gr_scrngeom+gr_screen_ptr+1
                        
cc26 :                  gr_add_x_offset	
cc26 : 18               	clc
cc27 : 8a               	txa
cc28 : 65dc             	adc gr_scrngeom+gr_screen_ptr
cc2a : 85dc             	sta gr_scrngeom+gr_screen_ptr
cc2c : a5dd             	lda gr_scrngeom+gr_screen_ptr+1
cc2e : 6900             	adc #0
cc30 : 85dd             	sta gr_scrngeom+gr_screen_ptr+1
                        
                        	; Update cursor x,y position
cc32 : 86de             	stx gr_scrngeom+gr_cur_x
cc34 : 84df             	sty gr_scrngeom+gr_cur_y
                        
                        	; A already contains high byte of pointer
cc36 : 78               	sei
cc37 : a6dc             	ldx gr_scrngeom+gr_screen_ptr	; Load low byte of poin
cc39 : 20ecc7           	jsr vdp_rd_addr
cc3c : 200bc8           	jsr vdp_rd_vram_fast			; Read contents of new positio
cc3f : 8509             	sta vdp_curval					; Update current value
cc41 : 58               	cli
                        	
cc42 : 7a               	ply
cc43 : fa               	plx
cc44 : 68               	pla
                        	
cc45 : 60               	rts
                        
                        ;****************************************
                        ;* gr_cur_right
                        ;* Advance cursor position (do after a vdp_wr_vram)
                        ;* to keep system parameters up to date
                        ;* Input : None
                        ;* Output : None
                        ;* Regs affected : None
                        ;****************************************
cc46 :                  gr_cur_right
cc46 : 48               	pha
cc47 : da               	phx
cc48 : 5a               	phy
                        
                        	; Load cursor x,y position
cc49 : a6de             	ldx gr_scrngeom+gr_cur_x
cc4b : a4df             	ldy gr_scrngeom+gr_cur_y
                        
                        	
                        	; Move cursor right
cc4d : e8               	inx
                        	; Check if reached past edge of line
cc4e : e4da             	cpx gr_scrngeom+gr_screen_w
cc50 : d00b             	bne gr_adv_skip_nl
                        	; If got here then wrap to next line
cc52 : a200             	ldx #0
cc54 : c8               	iny
cc55 : c4db             	cpy gr_scrngeom+gr_screen_h
cc57 : d004             	bne gr_adv_skip_nl
                        	; If got here then screen needs to scroll
cc59 : 88               	dey
AS65 Assembler for R6502 [1.42].                                     Page   67
------------------------------ kernel\kernel.s -------------------------------

cc5a : 208bcb           	jsr gr_scroll_up
cc5d :                  gr_adv_skip_nl
cc5d : 20fdcb           	jsr gr_set_cur_pos
                        	
cc60 : 7a               	ply
cc61 : fa               	plx
cc62 : 68               	pla
                        	
cc63 : 60               	rts
                        
                        ;****************************************
                        ;* gr_cur_left
                        ;* Advance cursor left (do after a vdp_wr_vram)
                        ;* to keep system parameters up to date
                        ;* Input : None
                        ;* Output : None
                        ;* Regs affected : None
                        ;****************************************
cc64 :                  gr_cur_left
cc64 : da               	phx
cc65 : 5a               	phy
                        
                        	; Load cursor x,y position, load X last to check for 
cc66 : a4df             	ldy gr_scrngeom+gr_cur_y
cc68 : a6de             	ldx gr_scrngeom+gr_cur_x
                        	
                        	; Decrement screen pointer
                        	; Move cursor left
cc6a : d007             	bne gr_cur_skip_at_left		; If already at the left
cc6c : c000             	cpy #0						; If already at the top left
cc6e : f007             	beq gr_cur_skip_at_tl
cc70 : 88               	dey
cc71 : a6da             	ldx gr_scrngeom+gr_screen_w
cc73 :                  gr_cur_skip_at_left
cc73 : ca               	dex
cc74 : 20fdcb           	jsr gr_set_cur_pos
                        
cc77 :                  gr_cur_skip_at_tl	
                        	
cc77 : 7a               	ply
cc78 : fa               	plx
                        	
cc79 : 60               	rts
                        
                        ;****************************************
                        ;* gr_cur_up
                        ;* Advance cursor up (do after a vdp_wr_vram)
                        ;* to keep system parameters up to date
                        ;* Input : None
                        ;* Output : None
                        ;* Regs affected : None
                        ;****************************************
cc7a :                  gr_cur_up
cc7a : da               	phx
cc7b : 5a               	phy
                        
                        	; Load cursor x,y position, load Y last to check for 
cc7c : a6de             	ldx gr_scrngeom+gr_cur_x
cc7e : a4df             	ldy gr_scrngeom+gr_cur_y
                        	
cc80 : f004             	beq gr_cur_skip_at_top	; If already at the top, don't
cc82 : 88               	dey
AS65 Assembler for R6502 [1.42].                                     Page   68
------------------------------ kernel\kernel.s -------------------------------

cc83 : 20fdcb           	jsr gr_set_cur_pos
                        
cc86 :                  gr_cur_skip_at_top
cc86 : 7a               	ply
cc87 : fa               	plx
                        	
cc88 : 60               	rts
                        
                        ;****************************************
                        ;* gr_cur_down
                        ;* Advance cursor down (do after a vdp_wr_vram)
                        ;* to keep system parameters up to date
                        ;* Input : None
                        ;* Output : None
                        ;* Regs affected : None
                        ;****************************************
cc89 :                  gr_cur_down
cc89 : da               	phx
cc8a : 5a               	phy
                        
                        	; Load cursor x,y position
cc8b : a6de             	ldx gr_scrngeom+gr_cur_x
cc8d : a4df             	ldy gr_scrngeom+gr_cur_y
cc8f : c8               	iny
cc90 : c4db             	cpy gr_scrngeom+gr_screen_h			; If already at  bottom
cc92 : f003             	beq gr_cur_skip_at_bot				; then don't do anything
                        	
cc94 : 20fdcb           	jsr gr_set_cur_pos
                        
cc97 :                  gr_cur_skip_at_bot
                        	
cc97 : 7a               	ply
cc98 : fa               	plx
                        	
cc99 : 60               	rts
                        
                        
                        ;****************************************
                        ;* gr_new_ln
                        ;* Carry out a new line
                        ;* Input : None
                        ;* Output : None
                        ;* Regs affected : None
                        ;****************************************
cc9a :                  gr_new_ln
cc9a : da               	phx
cc9b : 5a               	phy
                        
                        	; X pos is zero, Y needs to increment
cc9c : a200             	ldx #0
cc9e : a4df             	ldy gr_scrngeom+gr_cur_y
cca0 : c8               	iny
cca1 : c4db             	cpy gr_scrngeom+gr_screen_h
cca3 : d004             	bne gr_nl_skip_nl
                        	; If got here then screen needs to scroll
cca5 : 88               	dey
cca6 : 208bcb           	jsr gr_scroll_up
cca9 :                  gr_nl_skip_nl
cca9 : 20fdcb           	jsr gr_set_cur_pos
                        	
ccac : 7a               	ply
ccad : fa               	plx
AS65 Assembler for R6502 [1.42].                                     Page   69
------------------------------ kernel\kernel.s -------------------------------

                        	
ccae : 60               	rts
                        	
                        ;****************************************
                        ;* gr_del
                        ;* Action del
                        ;* Input : None
                        ;* Output : None
                        ;* Regs affected : None
                        ;****************************************
ccaf :                  gr_del
ccaf : 48               	pha
ccb0 : 2064cc           	jsr gr_cur_left
ccb3 : a920             	lda #' '							; Put a space
ccb5 : 206aca           	jsr gr_plot
ccb8 : 68               	pla
ccb9 : 60               	rts
                        
                        
                        ;****************************************
                        ;* gr_get_key
                        ;* Waits for a key press, C=1 synchronous
                        ;* A = Key code
                        ;****************************************
ccba :                  gr_get_key
ccba : 20bcc1           	jsr kb_get_key
ccbd : b009             	bcs gr_key_no_key
ccbf : c906             	cmp #UTF_ACK						; Copy key pressed?
ccc1 : d004             	bne gr_not_copy
ccc3 : a509             	lda vdp_curval						; If yes the get char under curso
ccc5 : 297f             	and #0x7f							; Make it standard ASCII range
ccc7 :                  gr_not_copy
ccc7 : 18               	clc
ccc8 :                  gr_key_no_key
ccc8 : 60               	rts	
                        	
                        ;****************************************
                        ;* gr_put_byte
                        ;* Put a byte out
                        ;* Input : A = Byte to put
                        ;* Output : None
                        ;* Regs affected : None
                        ;****************************************
ccc9 :                  gr_put_byte
ccc9 : da               	phx
ccca : 48               	pha
                        
cccb : c97f             	cmp #UTF_DEL			; Del key
cccd : f004             	beq gr_process_special
cccf : c920             	cmp #32					; Special char?
ccd1 : b038             	bcs gr_pb_notspecial	; >=32 == carry clear
                        
ccd3 :                  gr_process_special
                        	; Restore char under cursor
ccd3 : a509             	lda vdp_curval
ccd5 : 297f             	and #0x7f
ccd7 : 206aca           	jsr gr_plot
ccda : 68               	pla
ccdb : fa               	plx
                        	
ccdc : c90d             	cmp #UTF_CR				; New line?
ccde : d002             	bne gr_skip_new_ln
AS65 Assembler for R6502 [1.42].                                     Page   70
------------------------------ kernel\kernel.s -------------------------------

cce0 : 80b8             	jmp gr_new_ln
cce2 :                  gr_skip_new_ln
cce2 : c97f             	cmp #UTF_DEL			; Delete?
cce4 : d002             	bne gr_skip_del
cce6 : 80c7             	jmp gr_del
cce8 :                  gr_skip_del
cce8 : c908             	cmp #CRSR_LEFT
ccea : d003             	bne gr_skip_left
ccec : 4c64cc           	jmp gr_cur_left
ccef :                  gr_skip_left
ccef : c909             	cmp #CRSR_RIGHT
ccf1 : d003             	bne gr_skip_right
ccf3 : 4c46cc           	jmp gr_cur_right
ccf6 :                  gr_skip_right
ccf6 : c90b             	cmp #CRSR_UP
ccf8 : d003             	bne gr_skip_up
ccfa : 4c7acc           	jmp gr_cur_up
ccfd :                  gr_skip_up
ccfd : c90a             	cmp #CRSR_DOWN
ccff : d002             	bne gr_skip_down
cd01 : 8086             	jmp gr_cur_down
cd03 :                  gr_skip_down
cd03 : c90c             	cmp #UTF_FF
cd05 : d003             	bne gr_skip_cls
cd07 : 4c45ca           	jmp gr_cls
cd0a :                  gr_skip_cls
cd0a : 60               	rts
                        
                        ;	Normal caracter processing here.
cd0b :                  gr_pb_notspecial
                        	; Load current cursor position
cd0b : 206aca           	jsr gr_plot
cd0e : 2046cc           	jsr gr_cur_right
                        
cd11 : 68               	pla
cd12 : fa               	plx
                        
cd13 : 60               	rts
                        
                        ;* These tables are to speed up calculating the 
                        ;* offset for plot commands, rather than using
                        ;* a series of left shifts and additions.
                        ;* Not sure if it is worth the 96 bytes :-O
cd14 :                  gr_offset_40lo
cd14 : 00285078         	db lo(0*40), lo(1*40), lo(2*40), lo(3*40)
cd18 : a0c8f018         	db lo(4*40), lo(5*40), lo(6*40), lo(7*40)
cd1c : 406890b8         	db lo(8*40), lo(9*40), lo(10*40), lo(11*40)
cd20 : e0083058         	db lo(12*40), lo(13*40), lo(14*40), lo(15*40)
cd24 : 80a8d0f8         	db lo(16*40), lo(17*40), lo(18*40), lo(19*40)
cd28 : 20487098         	db lo(20*40), lo(21*40), lo(22*40), lo(23*40)
cd2c :                  gr_offset_40hi
cd2c : 00000000         	db hi(0*40), hi(1*40), hi(2*40), hi(3*40)
cd30 : 00000001         	db hi(4*40), hi(5*40), hi(6*40), hi(7*40)
cd34 : 01010101         	db hi(8*40), hi(9*40), hi(10*40), hi(11*40)
cd38 : 01020202         	db hi(12*40), hi(13*40), hi(14*40), hi(15*40)
cd3c : 02020202         	db hi(16*40), hi(17*40), hi(18*40), hi(19*40)
cd40 : 03030303         	db hi(20*40), hi(21*40), hi(22*40), hi(23*40)
cd44 :                  gr_offset_32lo
cd44 : 00204060         	db lo(0*32), lo(1*32), lo(2*32), lo(3*32)
cd48 : 80a0c0e0         	db lo(4*32), lo(5*32), lo(6*32), lo(7*32)
cd4c : 00204060         	db lo(8*32), lo(9*32), lo(10*32), lo(11*32)
cd50 : 80a0c0e0         	db lo(12*32), lo(13*32), lo(14*32), lo(15*32)
AS65 Assembler for R6502 [1.42].                                     Page   71
------------------------------ kernel\kernel.s -------------------------------

cd54 : 00204060         	db lo(16*32), lo(17*32), lo(18*32), lo(19*32)
cd58 : 80a0c0e0         	db lo(20*32), lo(21*32), lo(22*32), lo(23*32)
cd5c :                  gr_offset_32hi
cd5c : 00000000         	db hi(0*32), hi(1*32), hi(2*32), hi(3*32)
cd60 : 00000000         	db hi(4*32), hi(5*32), hi(6*32), hi(7*32)
cd64 : 01010101         	db hi(8*32), hi(9*32), hi(10*32), hi(11*32)
cd68 : 01010101         	db hi(12*32), hi(13*32), hi(14*32), hi(15*32)
cd6c : 02020202         	db hi(16*32), hi(17*32), hi(18*32), hi(19*32)
cd70 : 02020202         	db hi(20*32), hi(21*32), hi(22*32), hi(23*32)
                        	
                        	include "kernel\misc.s"
                        ;*****************************************************
                        ;*
                        ;*	DOLO-1 HOMEBREW COMPUTER
                        ;*	Hardware and software design by Dolo Miah
                        ;*	Copyright 2014-18
                        ;*  Free to use for any non-commercial purpose subject
                        ;*  full credit of original my authorship please!
                        ;*
                        ;*  MISC.S
                        ;*  Miscellaneous module for commmon utility functions
                        ;*
                        ;*****************************************************
                        
                        	; ROM code
                        	code
                        
                        ;****************************************
                        ;* long_delay
                        ;* Long delay (X decremented every 0.125ms)
                        ;* Input : X = number of 0.125ms ticks to wait (max wa
                        ;* Output : None
                        ;* Regs affected : None
                        ;****************************************
cd74 :                  long_delay
cd74 : 08               	php
                        	_pushAXY
                        
                        	
cd78 : a000             	ldy #0x00
cd7a :                  long_delay_1
cd7a : ea               	nop
cd7b : ea               	nop
cd7c : ea               	nop
cd7d : ea               	nop
cd7e : 88               	dey
cd7f : d0f9             	bne long_delay_1
cd81 : ca               	dex
cd82 : d0f6             	bne long_delay_1
                        
                        	_pullAXY
                        
cd87 : 28               	plp
                        	
cd88 : 60               	rts
                        
                        
                        	include "utils\utils.s"
                        ;*****************************************************
                        ;*
                        ;*	DOLO-1 HOMEBREW COMPUTER
                        ;*	Hardware and software design by Dolo Miah
AS65 Assembler for R6502 [1.42].                                     Page   72
------------------------------ kernel\kernel.s -------------------------------

                        ;*	Copyright 2014-18
                        ;*  Free to use for any non-commercial purpose subject
                        ;*  full credit of original my authorship please!
                        ;*
                        ;*  UTILS.S
                        ;*  This module implements various utility functions, 
                        ;*  converting from ASCII to binary form for numbers a
                        ;*  vice-versa to allow humans to actually be able to 
                        ;*  and read numbers in their prefered form!
                        ;*
                        ;*****************************************************
                        
                        	; ROM code
                        	code
                        
cd89 :                  jsrPrintA
                        	_printA
                        
cd99 : 60               	rts
                        
                        ;****************************************
                        ;* util_clr_mem
                        ;* Clear a block of main ram
                        ;* Input : X, A = Block start, Y = Block size
                        ;* Regs affected : P
                        ;****************************************
cd9a :                  util_clr_mem
cd9a : 48               	pha
cd9b : 5a               	phy
cd9c : 8614             	stx tmp_alo
cd9e : 8515             	sta tmp_ahi
cda0 :                  mem_clr_byte
cda0 : 88               	dey
cda1 : 9114             	sta (tmp_alo),y
cda3 : d0fb             	bne mem_clr_byte
cda5 : 7a               	ply
cda6 : 68               	pla
cda7 : 60               	rts
                        
                        ;****************************************
                        ;* str_a_to_x
                        ;* Convert accumulator to hex string
                        ;* Input : A = Byte to convert
                        ;* Output : A = High Char, X = Low Char
                        ;* Regs affected : P
                        ;****************************************
cda8 :                  str_a_to_x
cda8 : 48               	pha					; Save the byte using later on
cda9 : 290f             	and #0x0f			; Mask low nibble
cdab : 18               	clc
cdac : 6930             	adc #'0'			; Convert to UTF
cdae : c93a             	cmp #('9'+1)		; If A greater than '9' then
cdb0 : 9002             	bcc skip_a_f_1		; skip a-f adjustment
cdb2 : 6926             	adc #0x26			; Add 27 (6+C) to get in to A-F range
cdb4 :                  skip_a_f_1
cdb4 : aa               	tax					; Low char is in X
cdb5 : 68               	pla					; Get byte back
cdb6 : 4a               	lsr a				; Make high nibble low
cdb7 : 4a               	lsr a
cdb8 : 4a               	lsr a
cdb9 : 4a               	lsr a
cdba : 18               	clc
AS65 Assembler for R6502 [1.42].                                     Page   73
------------------------------ kernel\kernel.s -------------------------------

cdbb : 6930             	adc #'0'			; Convert to UTF
cdbd : c93a             	cmp #('9'+1)		; If A greater than '9' then
cdbf : 9002             	bcc skip_a_f_2		; skip a-f adjustment
cdc1 : 6926             	adc #0x26			; Add 27 (6+C) to get in to A-F range
cdc3 :                  skip_a_f_2
                        
cdc3 : 18               	clc					; No error
cdc4 : 60               	rts					; A high nibble
                        
                        ;****************************************
                        ;* str_x_to_a
                        ;* Convert hex string to accumulator
                        ;* Input : A = High Char, X = Low Char
                        ;* Output : A = Value
                        ;* Regs affected : P
                        ;****************************************
cdc5 :                  str_x_to_a
cdc5 : 0920             	ora #0x20			; Make alpha in to lower case
cdc7 : 38               	sec					; Process high char in A
cdc8 : e930             	sbc #'0'			; Convert to hex nibble
cdca : c90a             	cmp #10				; If A < 10 then
cdcc : 9002             	bcc skip_x_f_1		; skip a-f adjustment
cdce : e927             	sbc #0x27			; Sub 7 to get in to A-F range
cdd0 :                  skip_x_f_1
cdd0 : c910             	cmp #0x10			; Nibble should be <= 0x0f
cdd2 : b01d             	bcs	str_x_to_a_err	; Error if not
                        
cdd4 : 0a               	asl a				; This is the high nibble
cdd5 : 0a               	asl a
cdd6 : 0a               	asl a
cdd7 : 0a               	asl a
cdd8 : 48               	pha					; Save the high nibble
cdd9 : 8a               	txa					; Now process the low char in X
cdda : 0920             	ora #0x20			; Make alpha in to lower case
cddc : 38               	sec
cddd : e930             	sbc #'0'			; Convert to hex nibble
cddf : c90a             	cmp #10				; If A < 10 then
cde1 : 9002             	bcc skip_x_f_2		; skip a-f adjustment
cde3 : e927             	sbc #0x27			; Sub 7 to get in to A-F range
cde5 :                  skip_x_f_2
cde5 : c910             	cmp #0x10			; Nibble should be <= 0x0f
cde7 : b007             	bcs	str_x_to_a_errl	; Error if not
                        
cde9 : 8546             	sta num_a			; Store low nibble in temp
cdeb : 68               	pla					; Get high nibble
cdec : 0546             	ora num_a			; OR with low nibble
                        
cdee : 18               	clc					; No error
cdef : 60               	rts					; A contains value
                        
cdf0 :                  str_x_to_a_errl
cdf0 : 68               	pla
cdf1 :                  str_x_to_a_err
                        	SWBRK CMD_ERR_VAL
                        
                        
                        ;****************************************
                        ;* con_n_to_a
                        ;* Convert numeric string to accumulator (unsigned)
                        ;* Input : Pointer to string (X=L, A=H), Y = Source ty
                        ;* Output : num_a, num_a+1 contains word, X=number of 
                        ;* A = Source type detected
AS65 Assembler for R6502 [1.42].                                     Page   74
------------------------------ kernel\kernel.s -------------------------------

                        ;* Regs affected : CS = Error
                        ;****************************************
cdf3 :                  con_n_to_a
cdf3 : 8652             	stx num_tmp
cdf5 : 8553             	sta num_tmp+1
cdf7 : 6446             	stz num_a
cdf9 : 6447             	stz num_a+1
cdfb : c000             	cpy #NUM_ANY
cdfd : f014             	beq con_n_to_a_detect
cdff : 88               	dey
ce00 : d003             	bne con_n_not_dec
ce02 :                  con_dec_jmp
ce02 : 4c96ce           	jmp con_dec_to_a_int
ce05 :                  con_n_not_dec
ce05 : 88               	dey
ce06 : d003             	bne con_n_not_hex
ce08 :                  con_hex_jmp
ce08 : 4c2dce           	jmp con_hex_to_a_int
ce0b :                  con_n_not_hex
ce0b : 88               	dey
ce0c : d003             	bne con_n_err
ce0e :                  con_bin_jmp
ce0e : 4c6cce           	jmp con_bin_to_a_int
ce11 :                  con_n_err
ce11 : 38               	sec
ce12 : 60               	rts
ce13 :                  con_n_to_a_detect
ce13 : b252             	lda (num_tmp)
ce15 : c930             	cmp #'0'
ce17 : d0e9             	bne con_dec_jmp
ce19 : a001             	ldy #1
ce1b : b152             	lda (num_tmp),y
ce1d : 0920             	ora #0x20
ce1f : c978             	cmp #'x'
ce21 : f0e5             	beq con_hex_jmp
ce23 : c962             	cmp #'b'
ce25 : f0e7             	beq con_bin_jmp
ce27 : 80d9             	bra con_dec_jmp
                        
                        ;****************************************
                        ;* con_hex_to_a
                        ;* Convert hex string to accumulator (unsigned)
                        ;* Input : Pointer to string (X=L, A=H)
                        ;* Output : num_a, num_a+1 contains word, X=number of 
                        ;* Regs affected : CS = Error
                        ;****************************************
ce29 :                  con_hex_to_a
ce29 : 8652             	stx num_tmp
ce2b : 8553             	sta num_tmp+1
ce2d :                  con_hex_to_a_int
ce2d : a205             	ldx #5			; > 4 digits will cause error
ce2f : a002             	ldy #2			; start at first digit
ce31 :                  con_hex_digit
ce31 : b152             	lda (num_tmp),y
ce33 : 0920             	ora #0x20					; Make alpha in to lower case
ce35 : 38               	sec							; Process high char in A
ce36 : e930             	sbc #'0'					; Convert to hex nibble
ce38 : c90a             	cmp #10						; If A < 10 then
ce3a : 9002             	bcc con_hex_skip_x_f_1		; skip a-f adjustment
ce3c : e927             	sbc #0x27					; Sub 7 to get in to A-F range
ce3e :                  con_hex_skip_x_f_1
ce3e : c910             	cmp #0x10					; Nibble should be <= 0x0f
AS65 Assembler for R6502 [1.42].                                     Page   75
------------------------------ kernel\kernel.s -------------------------------

ce40 : b01c             	bcs	con_hex_done			; Potentially done if not
ce42 : 48               	pha
                        	; make room for lo nibble
ce43 : 0646             	asl num_a
ce45 : 2647             	rol num_a+1
ce47 : 0646             	asl num_a
ce49 : 2647             	rol num_a+1
ce4b : 0646             	asl num_a
ce4d : 2647             	rol num_a+1
ce4f : 0646             	asl num_a
ce51 : 2647             	rol num_a+1
                        	; save in low nibble
ce53 : 68               	pla
ce54 : 0546             	ora num_a
ce56 : 8546             	sta num_a
ce58 : c8               	iny
ce59 : ca               	dex
ce5a : d0d5             	bne con_hex_digit
                        	; if got to a 5th digit then error
ce5c :                  con_hex_err
ce5c : 38               	sec
ce5d : 60               	rts
                        	; found a non-hex digit
ce5e :                  con_hex_done
                        	; if no digits processed then error
ce5e : c002             	cpy #2
ce60 : f0fa             	beq con_hex_err
                        	; move y to x for digits processed
ce62 : 98               	tya
ce63 : aa               	tax
ce64 : a902             	lda #NUM_HEX
ce66 : 18               	clc
ce67 : 60               	rts
                        
                        ;****************************************
                        ;* con_bin_to_a
                        ;* Convert hex string to accumulator (unsigned)
                        ;* Input : Pointer to string (X=L, A=H)
                        ;* Output : num_a, num_a+1 contains word, X=number of 
                        ;* Regs affected : CS = Error
                        ;****************************************
ce68 :                  con_bin_to_a
ce68 : 8652             	stx num_tmp
ce6a : 8553             	sta num_tmp+1
ce6c :                  con_bin_to_a_int
ce6c : a002             	ldy #2
ce6e : a211             	ldx #17						; Max 16 binary digits allowed
ce70 :                  con_bin_digit
ce70 : b152             	lda (num_tmp),y
ce72 : c930             	cmp #'0'
ce74 : 9010             	bcc con_bin_done
ce76 : c932             	cmp #'1'+1
ce78 : b00c             	bcs con_bin_done
                        	; sets C if '1' else resets C
ce7a : 69cf             	adc #0xff-'0'
                        	; shift in digit
ce7c : 2646             	rol num_a
ce7e : 2647             	rol num_a+1
ce80 : c8               	iny
ce81 : ca               	dex
ce82 : d0ec             	bne con_bin_digit
                        	; on the 17th digit is too much, error
AS65 Assembler for R6502 [1.42].                                     Page   76
------------------------------ kernel\kernel.s -------------------------------

ce84 : 800a             	bra con_bin_err
ce86 :                  con_bin_done
                        	; didn't process any digit = error
ce86 : c002             	cpy #2
ce88 : f006             	beq con_bin_err
                        	; put digits processed in to X
ce8a : 98               	tya
ce8b : aa               	tax
ce8c : a903             	lda #NUM_BIN
ce8e : 18               	clc
ce8f : 60               	rts
ce90 :                  con_bin_err
ce90 : 38               	sec
ce91 : 60               	rts
                        
                        ;****************************************
                        ;* con_d_to_a
                        ;* Convert decimal string to accumulator (unsigned)
                        ;* Input : Pointer to string (X=L, A=H)
                        ;* Output : num_a, num_a+1 contains word, X=number of 
                        ;* Regs affected : CS = Error
                        ;****************************************
ce92 :                  con_dec_to_a
ce92 : 8652             	stx num_tmp
ce94 : 8553             	sta num_tmp+1
ce96 :                  con_dec_to_a_int
ce96 : a000             	ldy #0
ce98 :                  str_d_find_end
ce98 : b152             	lda (num_tmp),y
ce9a : c930             	cmp #'0'
ce9c : 9007             	bcc str_d_found_end
ce9e : c93a             	cmp #'9'+1
cea0 : b003             	bcs str_d_found_end
cea2 : c8               	iny
cea3 : 80f3             	bra str_d_find_end
cea5 :                  str_d_found_end
cea5 : c006             	cpy #6
cea7 : b033             	bcs str_d_error
cea9 : 8455             	sty num_tmp+3
ceab : 6454             	stz num_tmp+2
cead : 6446             	stz num_a
ceaf : 6447             	stz num_a+1
ceb1 :                  str_d_process_digit
ceb1 : 88               	dey
ceb2 : 3022             	bmi str_d_digits_done
ceb4 : 38               	sec
ceb5 : b152             	lda (num_tmp),y
ceb7 : e930             	sbc #'0'
                        	; Convert digit to number
                        	; and then offset in to
                        	; look up table of powers
ceb9 : 18               	clc
ceba : 0a               	asl a
cebb : 6554             	adc num_tmp+2
                        	; X contains index to powers
cebd : aa               	tax
cebe : a546             	lda num_a
cec0 : 7ddece           	adc str_d_powers,x
cec3 : 8546             	sta num_a
cec5 : a547             	lda num_a+1
cec7 : 7ddfce           	adc str_d_powers+1,x
ceca : 8547             	sta num_a+1
AS65 Assembler for R6502 [1.42].                                     Page   77
------------------------------ kernel\kernel.s -------------------------------

cecc : b00e             	bcs str_d_error
                        	; Move to next power of 10 index
cece : a554             	lda num_tmp+2
ced0 : 6914             	adc #20
ced2 : 8554             	sta num_tmp+2
ced4 : 80db             	bra str_d_process_digit
ced6 :                  str_d_digits_done	
ced6 : a655             	ldx num_tmp+3
ced8 : a901             	lda #NUM_DEC
ceda : 18               	clc
cedb : 60               	rts
cedc :                  str_d_error
cedc : 38               	sec
cedd : 60               	rts
                        
cede :                  str_d_powers
cede : 00000100020003.. 	dw	0, 1, 2, 3, 4, 5, 6, 7, 8, 9
cef2 : 00000a0014001e.. 	dw	0, 10, 20, 30, 40, 50, 60, 70, 80, 90
cf06 : 00006400c8002c.. 	dw	0, 100, 200, 300, 400, 500, 600, 700, 800, 900
cf1a : 0000e803d007b8.. 	dw	0, 1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000,
cf2e : 00001027204e30.. 	dw	0, 10000, 20000, 30000, 40000, 50000, 60000, 65535
                        	
                        
                        
                        ;****************************************
                        ;* hex_to_bcd
                        ;* Convert accumulator,X to BCD
                        ;* Input : X = Low byte, A = High Byte to convert
                        ;* Output : 3 bytes of num_a is updated
                        ;* Regs affected : P
                        ;****************************************
cf42 :                  hex_to_bcd
cf42 : 08               	php
cf43 : 48               	pha
cf44 : da               	phx
                        	
cf45 : 8652             	stx num_tmp
cf47 : 8553             	sta num_tmp+1
cf49 : 6446             	stz num_a
cf4b : 6447             	stz num_a+1
cf4d : 6448             	stz num_a+2
cf4f : 6449             	stz num_a+3
cf51 : a210             	ldx #16
cf53 : f8               	sed
cf54 :                  bin_to_bcd_bit
cf54 : 0652             	asl num_tmp
cf56 : 2653             	rol num_tmp+1
cf58 : a546             	lda num_a
cf5a : 6546             	adc num_a
cf5c : 8546             	sta num_a
cf5e : a547             	lda num_a+1
cf60 : 6547             	adc num_a+1
cf62 : 8547             	sta num_a+1
cf64 : a548             	lda num_a+2
cf66 : 6548             	adc num_a+2
cf68 : 8548             	sta num_a+2
cf6a : ca               	dex
cf6b : d0e7             	bne bin_to_bcd_bit
                        	
cf6d : fa               	plx
cf6e : 68               	pla
cf6f : 28               	plp
AS65 Assembler for R6502 [1.42].                                     Page   78
------------------------------ kernel\kernel.s -------------------------------

cf70 : 60               	rts
                        	
                        ;****************************************
                        ;* bcd_to_str
                        ;* Convert num_buf to chars
                        ;* Input : num_a in BCD format
                        ;* Output : num_buf in ASCII 6 digits
                        ;* Output is big endian, input is not
                        ;* Regs affected : P
                        ;****************************************
cf71 :                  bcd_to_str
cf71 : 48               	pha
cf72 : da               	phx
cf73 : 5a               	phy
                        
cf74 : a205             	ldx #5						; Index in to string
cf76 : a000             	ldy #0						; Current BCD digit
cf78 :                  bcd_str
cf78 : b94600           	lda num_a,y
                        	; Convert 1s digit of byte
cf7b : 48               	pha
cf7c : 290f             	and #0xf
cf7e : 18               	clc
cf7f : 6930             	adc #0x30
cf81 : 9556             	sta num_buf,x
                        	; Convert 10s digit of byte
cf83 : 68               	pla
cf84 : 4a               	lsr a
cf85 : 4a               	lsr a
cf86 : 4a               	lsr a
cf87 : 4a               	lsr a
cf88 : 18               	clc
cf89 : 6930             	adc #0x30					; Convert to ASCII
cf8b : 9555             	sta num_buf-1,x
cf8d : ca               	dex
cf8e : ca               	dex
cf8f : c8               	iny
cf90 : c003             	cpy #3						; 3 BCD digits max
cf92 : d0e4             	bne bcd_str
                        
cf94 : 7a               	ply
cf95 : fa               	plx
cf96 : 68               	pla
cf97 : 60               	rts
                        	
                        ;****************************************
                        ;* out_bcd
                        ;* Output a bcd string in num_buf
                        ;* Input : num_buf has the ASCII
                        ;* Input : C=1 print leading zeros else not
                        ;* Output : num_buf in ASCII 6 digits
                        ;* Output is big endian, input is not, Y=digits printe
                        ;* Regs affected : P
                        ;****************************************
cf98 :                  out_bcd
cf98 : 48               	pha
cf99 : da               	phx
cf9a : 08               	php
cf9b : a000             	ldy #0						; How many digits printed
cf9d : a200             	ldx #0						; Index in to string
cf9f :                  out_bcd_digit
cf9f : b556             	lda num_buf,x
AS65 Assembler for R6502 [1.42].                                     Page   79
------------------------------ kernel\kernel.s -------------------------------

cfa1 : c000             	cpy #0						; If not in leading zero mode
cfa3 : d008             	bne out_bcd_print			; No then go print
                        
cfa5 : c930             	cmp #'0'					; else check if zero
cfa7 : d004             	bne out_bcd_print			; No then go print
                        
cfa9 : 28               	plp
cfaa : 08               	php
cfab : 9004             	bcc out_bcd_next			; If C=0 go to next digit, else pr
cfad :                  out_bcd_print
cfad : c8               	iny
cfae : 2029d9           	jsr io_put_ch
cfb1 :                  out_bcd_next
cfb1 : e8               	inx
cfb2 : e006             	cpx #6
cfb4 : d0e9             	bne out_bcd_digit
cfb6 : c000             	cpy #0						; If nothing printed
cfb8 : d006             	bne out_bcd_fin
cfba : a930             	lda #'0'					; Need to put out 1 zero
cfbc : 2029d9           	jsr io_put_ch
cfbf : c8               	iny
cfc0 :                  out_bcd_fin
cfc0 : 28               	plp
cfc1 : fa               	plx
cfc2 : 68               	pla
cfc3 : 18               	clc
cfc4 : 60               	rts
                        	
                        		
                        	
                        ;****************************************
                        ;* print_a_to_d
                        ;* Convert X,A to decimal string
                        ;* Input : X,A = number Low,High
                        ;* Input : C=1 print leading zeros else not
                        ;* Output : num_buf in ASCII max 6 digits
                        ;* Output is big endian, input is not
                        ;* Regs affected : P
                        ;****************************************
cfc5 :                  print_a_to_d
cfc5 : 08               	php
cfc6 : 2042cf           	jsr hex_to_bcd				; Convert to BCD
cfc9 : 2071cf           	jsr bcd_to_str				; Convert BCD to string
cfcc : 28               	plp
cfcd : 2098cf           	jsr out_bcd					; Print a string
cfd0 : 60               	rts
                        	
                        	include "utils\intmath.s"
                        ;*****************************************************
                        ;*
                        ;*	DOLO-1 HOMEBREW COMPUTER
                        ;*	Hardware and software design by Dolo Miah
                        ;*	Copyright 2014-18
                        ;*  Free to use for any non-commercial purpose subject
                        ;*  full credit of original my authorship please!
                        ;*
                        ;*  INTMATH.S
                        ;*  Core module for integer maths supported by dflat.
                        ;*  Uses the intmath registers: num_a, num_b, num_x, n
                        ;*  Most inputs are through num_a and num_b, with resu
                        ;*  num_a.
                        ;*  Operations: add, sub, swap, 8 bit mult, mult, divi
AS65 Assembler for R6502 [1.42].                                     Page   80
------------------------------ kernel\kernel.s -------------------------------

                        ;*
                        ;*****************************************************
                        
                        	; ROM code
                        	code
                        
                        ;****************************************
                        ;* Add : A + B result in A
                        ;****************************************
cfd1 :                  int_add
cfd1 : 18               	clc
cfd2 : a546             	lda num_a
cfd4 : 654a             	adc num_b
cfd6 : 8546             	sta num_a
cfd8 : a547             	lda num_a+1
cfda : 654b             	adc num_b+1
cfdc : 8547             	sta num_a+1
cfde : 60               	rts
                        	
                        ;****************************************
                        ;* Sub : A - B result in A
                        ;****************************************
cfdf :                  int_sub
cfdf : 38               	sec
cfe0 : a546             	lda num_a
cfe2 : e54a             	sbc num_b
cfe4 : 8546             	sta num_a
cfe6 : a547             	lda num_a+1
cfe8 : 654b             	adc num_b+1
cfea : 8547             	sta num_a+1
cfec : 60               	rts
                        	
                        ;****************************************
                        ;* Swp : A <-> B 
                        ;****************************************
cfed :                  int_swp
cfed : a546             	lda num_a
cfef : a64a             	ldx num_b
cff1 : 854a             	sta num_b
cff3 : 8646             	stx num_a
cff5 : a547             	lda num_a+1
cff7 : a64b             	ldx num_b+1
cff9 : 854b             	sta num_b+1
cffb : 8647             	stx num_a+1
cffd : 60               	rts
                        	
                        ;****************************************
                        ;* Mult : A * B result in A
                        ;* B assumed to be an 8 bit quantity 
                        ;****************************************
cffe :                  int_fast_mult
                        	_cpyZPWord num_a,num_tmp
                        
d006 : 6446             	stz num_a
d008 : 6447             	stz num_a+1
d00a : a008             	ldy #8
d00c :                  int_fast_mult_cycle
d00c : 464a             	lsr num_b
d00e : 900d             	bcc int_fast_mult_next
d010 : 18               	clc
d011 : a546             	lda num_a
d013 : 6552             	adc num_tmp
AS65 Assembler for R6502 [1.42].                                     Page   81
------------------------------ kernel\kernel.s -------------------------------

d015 : 8546             	sta num_a
d017 : a547             	lda num_a+1
d019 : 6553             	adc num_tmp+1
d01b : 8547             	sta num_a+1
d01d :                  int_fast_mult_next
d01d : 0652             	asl num_tmp
d01f : 2653             	rol num_tmp+1
d021 : 88               	dey
d022 : d0e8             	bne int_fast_mult_cycle
d024 : 60               	rts
                        	
                        ;****************************************
                        ;* Mult : A * B result in A
                        ;****************************************
d025 :                  int_mult
                        	_cpyZPWord num_a,num_tmp
                        
d02d : 6446             	stz num_a
d02f : 6447             	stz num_a+1
d031 : a010             	ldy #16
d033 :                  int_mult_cycle
d033 : 464b             	lsr num_b+1
d035 : 664a             	ror num_b
d037 : 900d             	bcc int_mult_next
d039 : 18               	clc
d03a : a546             	lda num_a
d03c : 6552             	adc num_tmp
d03e : 8546             	sta num_a
d040 : a547             	lda num_a+1
d042 : 6553             	adc num_tmp+1
d044 : 8547             	sta num_a+1
d046 :                  int_mult_next
d046 : 0652             	asl num_tmp
d048 : 2653             	rol num_tmp+1
d04a : 88               	dey
d04b : d0e6             	bne int_mult_cycle
d04d : 60               	rts
                        
                        ;****************************************
                        ;* Mult : A / B result in A
                        ;****************************************
d04e :                  int_div
                        	; x is the remainder
d04e : 644e             	stz num_x
d050 : 644f             	stz num_x+1
                        	; 16 bit division
d052 : a010             	ldy #16
d054 :                  int_div_cycle
                        	; shift a left 1 bit
d054 : 0646             	asl num_a
d056 : 2647             	rol num_a+1
                        	; shift in to remainder
d058 : 264e             	rol num_x
d05a : 264f             	rol num_x+1
                        	; try and subtract b from remainder
d05c : 38               	sec
d05d : a54e             	lda num_x
d05f : e54a             	sbc num_b
d061 : aa               	tax
d062 : a54f             	lda num_x+1
d064 : e54b             	sbc num_b+1
d066 : 9006             	bcc int_div_skip
AS65 Assembler for R6502 [1.42].                                     Page   82
------------------------------ kernel\kernel.s -------------------------------

                        	; so b did fit in to remainder, save it
d068 : 864e             	stx num_x
d06a : 854f             	sta num_x+1
d06c : e646             	inc num_a
d06e :                  int_div_skip
                        	; carry on for 16 bits
d06e : 88               	dey
d06f : d0e3             	bne int_div_cycle
                        	; result in a, remainder in x
d071 : 60               	rts
                        	
                        	include "kernel\main.s"
                        ;*****************************************************
                        ;*
                        ;*	DOLO-1 HOMEBREW COMPUTER
                        ;*	Hardware and software design by Dolo Miah
                        ;*	Copyright 2014-18
                        ;*  Free to use for any non-commercial purpose subject
                        ;*  full credit of original my authorship please!
                        ;*
                        ;*  MAIN.S
                        ;*  This is where the main user program is executed by
                        ;*  the 'kernel' once the system is initialised and re
                        ;*  Today, main does very little - first shows the sys
                        ;*  boot up message, and then passes control to dflat.
                        ;*
                        ;*****************************************************
                        
                        	; ROM code
                        	code  
                        
d072 :                  main
                        	_println msg_hello_world
                        
                        
d07f :                  infinity
d07f : 20abe5           	jsr df_pg_dflat
d082 : 80fb             	jmp infinity
                        
d084 :                  msg_hello_world
                        	;* build.s is generate by the assemble.bat file
                        	;* all it does is echo an assembler line to
                        	;* including the build date in the message.
                        	include "kernel\build.s"
d084 : 4275696c64203a..  db "Build : 18/02/2018\r" 
                        
d097 : 444f4c4f2d3120.. 	db "DOLO-1 Microcomputer\r"
d0ac : 48617264776172.. 	db "Hardware & Software Design\r"
d0c7 : 427920446f6c6f.. 	db "By Dolo Miah\r"
d0d4 : 436f7079726967.. 	db "Copyright (c) 2015-18\r\r",0
                        	
                        
                        ;	include "monitor\cmd.s"
                        	include "sdcard\sdcard.s"
                        ;*****************************************************
                        ;*
                        ;*	DOLO-1 HOMEBREW COMPUTER
                        ;*	Hardware and software design by Dolo Miah
                        ;*	Copyright 2014-18
                        ;*  Free to use for any non-commercial purpose subject
                        ;*  full credit of original my authorship please!
                        ;*
AS65 Assembler for R6502 [1.42].                                     Page   83
------------------------------ kernel\kernel.s -------------------------------

                        ;*  SDCARD.S
                        ;*  Low level SD card driver routines.  This module im
                        ;*  software bit banging through VIA 2 port B of an SD
                        ;*  interface.  So the card is clocked in software whi
                        ;*  not great for performance but fast enough for my
                        ;*  purposes.  I think we can get around 8.5KB/s raw s
                        ;*  read/write speed, translating to around 5.5KB/s of
                        ;*  throughput using the filesystem.
                        ;*
                        ;*****************************************************
                        
                        	; ROM code
                        	code
                        
                        ;****************************************
                        ;* init_sdcard
                        ;* Initialise SD card interface after CIA2!
                        ;* Input : None
                        ;* Output : None
                        ;* Regs affected : None
                        ;****************************************
d0ec :                  init_sdcard
                        	_println sd_msg_initialising
                        
                        
d0f9 : a908             	lda #SD_CS						; Unselect device
d0fb : 0c00b2           	tsb SD_REG
d0fe : a901             	lda #SD_CLK						; Set clock low
d100 : 1c00b2           	trb SD_REG
d103 : a910             	lda #SD_MOSI					; DI/MOSI high
d105 : 0c00b2           	tsb SD_REG
d108 : a208             	ldx #8							; 8*0.125ms = 1ms
d10a : 2074cd           	jsr long_delay
                        
d10d : a208             	ldx #8							; 10 bytes of 0xff
d10f : a9ff             	lda #0xff
d111 :                  init_sd_pulse
d111 : 204bd1           	jsr sd_sendbyte					; Send the 0xff byte
d114 : ca               	dex
d115 : d0fa             	bne init_sd_pulse
d117 : a908             	lda #SD_CS						; Unselect device
d119 : 0c00b2           	tsb SD_REG
                        
d11c :                  init_cmd0
d11c : 2004d2           	jsr sd_sendcmd0
d11f : c9ff             	cmp #0xff						; 0xff is not a valid response
d121 : d002             	bne init_acmd41
d123 : 80c7             	bra init_sdcard
                        	
d125 :                  init_acmd41
                        
d125 : 2026d2           	jsr sd_sendcmd55
                        
d128 : 2048d2           	jsr sd_sendcmd41
                        	
d12b : c900             	cmp #0							; Was R1 = 0
d12d : d0f6             	bne init_acmd41					; Retry if not
                        	
d12f :                  init_cmd16
d12f : 206ad2           	jsr sd_sendcmd16
                        	
d132 : 60               	rts
AS65 Assembler for R6502 [1.42].                                     Page   84
------------------------------ kernel\kernel.s -------------------------------

                        
                        ;****************************************
                        ;* sd_startcmd
                        ;* Start a cmd frame by sending CS high to low
                        ;* Input : None
                        ;* Output : None
                        ;* Regs affected : None
                        ;****************************************
d133 :                  sd_startcmd
d133 : 48               	pha
d134 : a9ff             	lda #0xff						; Send 0xff
d136 : 204bd1           	jsr sd_sendbyte					; Delay / synch pulses
d139 : 204bd1           	jsr sd_sendbyte					; With CS not asserted
                        
d13c : a908             	lda #SD_CS						; Chip select bit
d13e : 1c00b2           	trb SD_REG						; Now set it low
d141 : 68               	pla
d142 : 60               	rts
                        
                        ;****************************************
                        ;* sd_endcmd
                        ;* End a cmd frame by sending CS high
                        ;* Input : None
                        ;* Output : None
                        ;* Regs affected : None
                        ;****************************************
d143 :                  sd_endcmd
d143 : 48               	pha
d144 : a908             	lda #SD_CS						; Chip select bit
d146 : 0c00b2           	tsb SD_REG						; First set it high
d149 : 68               	pla
d14a : 60               	rts
                        
                        ;****************************************
                        ;* sd_sendbyte
                        ;* Low level byte send routine
                        ;* Input : A = byte to send
                        ;* Output : None
                        ;* Regs affected : None
                        ;****************************************
d14b :                  sd_sendbyte
d14b : 48               	pha
d14c : 5a               	phy
                        
d14d : 851a             	sta tmp_a						; For shifting out
d14f : a008             	ldy #8							; 8 bits to shift out
d151 : ad00b2           	lda SD_REG						; Load the SD register to A
d154 :                  sd_shiftoutbit
d154 : 0910             	ora #SD_MOSI					; And initially set output bit to '1
d156 : 061a             	asl tmp_a						; Unless the bit to transmit is '0'
d158 : b002             	bcs sd_shiftskiplo				; so then EOR the bit back to 0
d15a : 4910             	eor #SD_MOSI
d15c :                  sd_shiftskiplo
d15c : 8d00b2           	sta SD_REG						; Save data bit first, it seems, befo
                        	
d15f : ee00b2           	inc SD_REG
d162 : ce00b2           	dec SD_REG
                        
d165 : 88               	dey								; Count bits
d166 : d0ec             	bne sd_shiftoutbit				; Until no more bits to send
                        
d168 : 7a               	ply
AS65 Assembler for R6502 [1.42].                                     Page   85
------------------------------ kernel\kernel.s -------------------------------

d169 : 68               	pla
                        
d16a : 60               	rts
                        
                        ;****************************************
                        ;* sd_getbyte
                        ;* Low level get a byte
                        ;* Input : A = response byte received
                        ;* Output : None
                        ;* Regs affected : None
                        ;****************************************
                        
d16b :                  sd_getbyte
d16b : 5a               	phy
d16c : da               	phx
                        
d16d : ad00b2           	lda SD_REG
d170 : 0910             	ora #SD_MOSI					; Set MOSI high
d172 : 8d00b2           	sta SD_REG
d175 : a8               	tay								; Same as A with clock high
d176 : c8               	iny
d177 : aa               	tax								; Same as A with clock low
                        	
                        	; Unroll the code almost 20% faster than slow version
                        	; bit 7
d178 : 8c00b2           	sty SD_REG
d17b : ad00b2           	lda SD_REG						; Sample SD card lines (MISO is the M
d17e : 8e00b2           	stx SD_REG
d181 : c980             	cmp #SD_MISO					; Trial subtract A-MISO, C=1 if A >=
d183 : 261a             	rol tmp_a						; Rotate carry state in to tmp_a
                        	; bit 6
d185 : 8c00b2           	sty SD_REG
d188 : ad00b2           	lda SD_REG						; Sample SD card lines (MISO is the M
d18b : 8e00b2           	stx SD_REG
d18e : c980             	cmp #SD_MISO					; Trial subtract A-MISO, C=1 if A >=
d190 : 261a             	rol tmp_a						; Rotate carry state in to tmp_a
                        	; bit 5
d192 : 8c00b2           	sty SD_REG
d195 : ad00b2           	lda SD_REG						; Sample SD card lines (MISO is the M
d198 : 8e00b2           	stx SD_REG
d19b : c980             	cmp #SD_MISO					; Trial subtract A-MISO, C=1 if A >=
d19d : 261a             	rol tmp_a						; Rotate carry state in to tmp_a
                        	; bit 4
d19f : 8c00b2           	sty SD_REG
d1a2 : ad00b2           	lda SD_REG						; Sample SD card lines (MISO is the M
d1a5 : 8e00b2           	stx SD_REG
d1a8 : c980             	cmp #SD_MISO					; Trial subtract A-MISO, C=1 if A >=
d1aa : 261a             	rol tmp_a						; Rotate carry state in to tmp_a
                        	; bit 3
d1ac : 8c00b2           	sty SD_REG
d1af : ad00b2           	lda SD_REG						; Sample SD card lines (MISO is the M
d1b2 : 8e00b2           	stx SD_REG
d1b5 : c980             	cmp #SD_MISO					; Trial subtract A-MISO, C=1 if A >=
d1b7 : 261a             	rol tmp_a						; Rotate carry state in to tmp_a
                        	; bit 2
d1b9 : 8c00b2           	sty SD_REG
d1bc : ad00b2           	lda SD_REG						; Sample SD card lines (MISO is the M
d1bf : 8e00b2           	stx SD_REG
d1c2 : c980             	cmp #SD_MISO					; Trial subtract A-MISO, C=1 if A >=
d1c4 : 261a             	rol tmp_a						; Rotate carry state in to tmp_a
                        	; bit 1
d1c6 : 8c00b2           	sty SD_REG
AS65 Assembler for R6502 [1.42].                                     Page   86
------------------------------ kernel\kernel.s -------------------------------

d1c9 : ad00b2           	lda SD_REG						; Sample SD card lines (MISO is the M
d1cc : 8e00b2           	stx SD_REG
d1cf : c980             	cmp #SD_MISO					; Trial subtract A-MISO, C=1 if A >=
d1d1 : 261a             	rol tmp_a						; Rotate carry state in to tmp_a
                        	; bit 0
d1d3 : 8c00b2           	sty SD_REG
d1d6 : ad00b2           	lda SD_REG						; Sample SD card lines (MISO is the M
d1d9 : 8e00b2           	stx SD_REG
d1dc : c980             	cmp #SD_MISO					; Trial subtract A-MISO, C=1 if A >=
d1de : 261a             	rol tmp_a						; Rotate carry state in to tmp_a
                        
d1e0 : a51a             	lda tmp_a						; Return response in A
                        
d1e2 : fa               	plx
d1e3 : 7a               	ply
                        
d1e4 : 60               	rts
                        
                        ;sd_getbyte							; OLD and SLOW version
                        ;	phy
                        ;
                        ;	lda SD_REG
                        ;	ora #SD_MOSI					; Set MOSI high
                        ;	sta SD_REG
                        ;	
                        ;	ldy #8							; Shift in the 8 bits
                        ;sd_shiftinbit
                        ;	inc SD_REG
                        ;	lda SD_REG						; Sample SD card lines (MISO is the 
                        ;	dec SD_REG
                        ;	cmp #SD_MISO					; Trial subtract A-MISO, C=1 if A >
                        ;	rol tmp_a						; Rotate carry state in to tmp_a
                        ;	dey								; Next bit
                        ;	bne sd_shiftinbit
                        ;
                        ;	lda tmp_a						; Return response in A
                        ;	
                        ;	ply
                        ;
                        ;	rts
                        
                        ;****************************************
                        ;* sd_getrespbyte
                        ;* Low level get response routine
                        ;* Input : A = response byte received
                        ;* Output : None
                        ;* Regs affected : None
                        ;****************************************
d1e5 :                  sd_getrespbyte
d1e5 : da               	phx
d1e6 : a200             	ldx #0							; Try up to 256 times
d1e8 :                  sd_respff
d1e8 : e8               	inx								; Retry counter
d1e9 : f007             	beq sd_resptimeout
d1eb : 206bd1           	jsr sd_getbyte
d1ee : c9ff             	cmp #0xff						; Keep reading MISO until not FF
d1f0 : f0f6             	beq sd_respff
d1f2 :                  sd_resptimeout
d1f2 : fa               	plx
d1f3 : 60               	rts
                        
                        ;****************************************
AS65 Assembler for R6502 [1.42].                                     Page   87
------------------------------ kernel\kernel.s -------------------------------

                        ;* sd_busy
                        ;* Low level busy check routine
                        ;* Input : None
                        ;* Output : None
                        ;* Regs affected : None
                        ;****************************************
d1f4 :                  sd_busy
d1f4 : 48               	pha
d1f5 :                  sd_isbusy
d1f5 : 206bd1           	jsr sd_getbyte
d1f8 : c9ff             	cmp #0xff						; Keep reading MISO until FF
d1fa : d0f9             	bne sd_isbusy
d1fc : 68               	pla
d1fd : 60               	rts
                        
                        ;****************************************
                        ;* sd_waitforn0byte
                        ;* Low level routine waits for card to be ready
                        ;* Input : None
                        ;* Output : None
                        ;* Regs affected : None
                        ;****************************************
d1fe :                  sd_waitforn0byte
d1fe : 20e5d1           	jsr sd_getrespbyte
d201 : f0fb             	beq sd_waitforn0byte					; Zero byte means not ready
d203 : 60               	rts
                        
                        ;****************************************
                        ;* sd_sendcmd0
                        ;* Send CMD0
                        ;* Input : None
                        ;* Output : None
                        ;* Regs affected : None
                        ;****************************************
d204 :                  sd_sendcmd0
d204 : 2033d1           	jsr sd_startcmd
                        
                        	; Send 0x40, 0x00, 0x00, 0x00, 0x00, 0x95
d207 : a940             	lda #0x40
d209 : 204bd1           	jsr sd_sendbyte
d20c : a900             	lda #0x00
d20e : 204bd1           	jsr sd_sendbyte
d211 : 204bd1           	jsr sd_sendbyte
d214 : 204bd1           	jsr sd_sendbyte
d217 : 204bd1           	jsr sd_sendbyte
d21a : a995             	lda #0x95						; Checksum needs to be right
d21c : 204bd1           	jsr sd_sendbyte
                        
d21f : 2090d2           	jsr sd_getrespR1				; Get the response
                        
d222 : 2043d1           	jsr sd_endcmd
                        	
d225 : 60               	rts
                        
                        ;****************************************
                        ;* sd_sendcmd55
                        ;* Send CMD55
                        ;* Input : None
                        ;* Output : None
                        ;* Regs affected : None
                        ;****************************************
d226 :                  sd_sendcmd55
AS65 Assembler for R6502 [1.42].                                     Page   88
------------------------------ kernel\kernel.s -------------------------------

d226 : 2033d1           	jsr sd_startcmd
                        
                        	; Send 0x40+55, 0x00, 0x00, 0x00, 0x00, 0x95
d229 : a977             	lda #0x40+55
d22b : 204bd1           	jsr sd_sendbyte
d22e : a900             	lda #0x00
d230 : 204bd1           	jsr sd_sendbyte
d233 : 204bd1           	jsr sd_sendbyte
d236 : 204bd1           	jsr sd_sendbyte
d239 : 204bd1           	jsr sd_sendbyte
d23c : a995             	lda #0x95						; Checksum needs to be right
d23e : 204bd1           	jsr sd_sendbyte
                        
d241 : 2090d2           	jsr sd_getrespR1				; Get the response
                        
d244 : 2043d1           	jsr sd_endcmd
                        	
d247 : 60               	rts
                        
                        ;****************************************
                        ;* sd_sendcmd41
                        ;* Send ACMD41
                        ;* Input : None
                        ;* Output : None
                        ;* Regs affected : None
                        ;****************************************
d248 :                  sd_sendcmd41
d248 : 2033d1           	jsr sd_startcmd
                        
                        	; Send 0x40+41, 0x00, 0x00, 0x00, 0x00, 0x95
d24b : a969             	lda #0x40+41
d24d : 204bd1           	jsr sd_sendbyte
d250 : a900             	lda #0x00
d252 : 204bd1           	jsr sd_sendbyte
d255 : 204bd1           	jsr sd_sendbyte
d258 : 204bd1           	jsr sd_sendbyte
d25b : 204bd1           	jsr sd_sendbyte
d25e : a995             	lda #0x95						; Checksum needs to be right
d260 : 204bd1           	jsr sd_sendbyte
                        
d263 : 2090d2           	jsr sd_getrespR1				; Get the response
                        
d266 : 2043d1           	jsr sd_endcmd
                        	
d269 : 60               	rts
                        
                        ;****************************************
                        ;* sd_sendcmd16
                        ;* Send CMD16
                        ;* Input : None
                        ;* Output : None
                        ;* Regs affected : None
                        ;****************************************
d26a :                  sd_sendcmd16
d26a : 2033d1           	jsr sd_startcmd
                        
                        	; Send 0x40+16, 0x00, 0x00, 0x02, 0x00, 0x95
d26d : a950             	lda #0x40+16
d26f : 204bd1           	jsr sd_sendbyte
d272 : a900             	lda #0x00
d274 : 204bd1           	jsr sd_sendbyte
d277 : 204bd1           	jsr sd_sendbyte
AS65 Assembler for R6502 [1.42].                                     Page   89
------------------------------ kernel\kernel.s -------------------------------

d27a : a902             	lda #0x02						; 0x200 block size = 512 bytes
d27c : 204bd1           	jsr sd_sendbyte
d27f : a900             	lda #0x00
d281 : 204bd1           	jsr sd_sendbyte
d284 : a995             	lda #0x95						; Checksum needs to be right
d286 : 204bd1           	jsr sd_sendbyte
                        
d289 : 2090d2           	jsr sd_getrespR1				; Get the response
                        
d28c : 2043d1           	jsr sd_endcmd
                        	
d28f : 60               	rts
                        
                        ;****************************************
                        ;* sd_getrespR1
                        ;* Low level get response R1
                        ;* Input : A = response byte received
                        ;* Output : None
                        ;* Regs affected : None
                        ;****************************************
d290 :                  sd_getrespR1
d290 : 20e5d1           	jsr sd_getrespbyte
d293 : 60               	rts
                        
                        ;****************************************
                        ;* sd_sendcmd17
                        ;* Send CMD17
                        ;* Input : sd_sect = 4 bytes of sector offset little e
                        ;* Output : None
                        ;* Regs affected : None
                        ;****************************************
d294 :                  sd_sendcmd17
d294 : da               	phx
d295 : 48               	pha								; A is the page to write to
                        	
d296 : 2033d1           	jsr sd_startcmd
                        
                        	; Convert sector address to byte address
                        	; Sector address is little endian
                        	; Byte address is big endian
d299 : 6428             	stz sd_addr+3					; LSB of address is always 0
d29b : a521             	lda sd_sect+0					; LSB of sector goes to address+1
d29d : 8527             	sta sd_addr+2					; Equivalent of * 256
d29f : a522             	lda sd_sect+1
d2a1 : 8526             	sta sd_addr+1
d2a3 : a523             	lda sd_sect+2
d2a5 : 8525             	sta sd_addr+0
d2a7 : 18               	clc								; Now addr*2 so equiv to sect*512
d2a8 : 0628             	asl sd_addr+3
d2aa : 2627             	rol sd_addr+2
d2ac : 2626             	rol sd_addr+1
d2ae : 2625             	rol sd_addr+0
                        
d2b0 :                  sd_cmd17addr
                        	; Send 0x40+17, 0xA3, 0xA2, 0xA1, 0xA0, 0x95
d2b0 : a951             	lda #0x40+17
d2b2 : 204bd1           	jsr sd_sendbyte
d2b5 : a525             	lda sd_addr+0
d2b7 : 204bd1           	jsr sd_sendbyte
d2ba : a526             	lda sd_addr+1
d2bc : 204bd1           	jsr sd_sendbyte
d2bf : a527             	lda sd_addr+2
AS65 Assembler for R6502 [1.42].                                     Page   90
------------------------------ kernel\kernel.s -------------------------------

d2c1 : 204bd1           	jsr sd_sendbyte
d2c4 : a528             	lda sd_addr+3
d2c6 : 204bd1           	jsr sd_sendbyte
d2c9 : a995             	lda #0x95						; Checksum needs to be right
d2cb : 204bd1           	jsr sd_sendbyte
                        
d2ce : 20e5d1           	jsr sd_getrespbyte
d2d1 : aa               	tax								; Save response in X for return
                        
d2d2 : 68               	pla								; Get the A param
d2d3 : 20dfd2           	jsr sd_getrespR17				; Get the response
                        
d2d6 : 20f4d1           	jsr sd_busy						; Wait for card to be ready
                        	
d2d9 : 2043d1           	jsr sd_endcmd
                        
d2dc : 8a               	txa								; Restore the response byte
d2dd : fa               	plx
                        	
d2de : 60               	rts
                        
                        ;****************************************
                        ;* sd_getrespR17
                        ;* Low level get response R17
                        ;* Input : A = R1 response byte received
                        ;* Output : None
                        ;* Regs affected : None
                        ;****************************************
d2df :                  sd_getrespR17
d2df : 48               	pha
d2e0 : 5a               	phy
                        
d2e1 : 8515             	sta tmp_ahi						; Page to read in to
d2e3 : 6414             	stz tmp_alo						; Always a page boundary
d2e5 :                  sd_getrespR17token
d2e5 : 206bd1           	jsr sd_getbyte					; Get a byte
d2e8 : c9fe             	cmp #0xfe						; Is it the token?
d2ea : d0f9             	bne sd_getrespR17token			; No
                        	
d2ec : a000             	ldy #0							; read 1st 256 bytes
d2ee :                  sd_getrespR17block1
d2ee : 206bd1           	jsr sd_getbyte					; get a byte
d2f1 : 9114             	sta (tmp_alo),y					; Save the byte
d2f3 : c8               	iny								; Keep going
d2f4 : d0f8             	bne sd_getrespR17block1			; Until all bytes read
                        
d2f6 : e615             	inc tmp_ahi						; Next page
d2f8 :                  sd_getrespR17block2
d2f8 : 206bd1           	jsr sd_getbyte					; get a byet
d2fb : 9114             	sta (tmp_alo),y					; Save the byte
d2fd : c8               	iny								; Keep going
d2fe : d0f8             	bne sd_getrespR17block2			; Until all bytes read
                        
d300 : 206bd1           	jsr sd_getbyte					; CRC
d303 : 206bd1           	jsr sd_getbyte					; CRC
                        	
d306 : 7a               	ply
d307 : 68               	pla
                        
d308 : 60               	rts
                        	
                        
AS65 Assembler for R6502 [1.42].                                     Page   91
------------------------------ kernel\kernel.s -------------------------------

                        ;****************************************
                        ;* sd_sendcmd24
                        ;* Send CMD24
                        ;* Input : sd_sect = 4 bytes of sector offset little e
                        ;* Output : None
                        ;* Regs affected : None
                        ;****************************************
d309 :                  sd_sendcmd24
d309 : 5a               	phy
d30a : 48               	pha
                        
d30b : 2033d1           	jsr sd_startcmd
                        
                        	; Convert sector address to byte address
                        	; Sector address is little endian
                        	; Byte address is big endian
d30e : 6428             	stz sd_addr+3					; LSB of address is always 0
d310 : a521             	lda sd_sect+0					; LSB of sector goes to address+1
d312 : 8527             	sta sd_addr+2					; Equivalent of * 256
d314 : a522             	lda sd_sect+1
d316 : 8526             	sta sd_addr+1
d318 : a524             	lda sd_sect+3
d31a : 8525             	sta sd_addr+0
d31c : 18               	clc								; Now addr*2 so equiv to sect*512
d31d : 0628             	asl sd_addr+3
d31f : 2627             	rol sd_addr+2
d321 : 2626             	rol sd_addr+1
d323 : 2625             	rol sd_addr+0
                        
                        	; Send 0x40+24, 0xA0, 0xA1, 0xA2, 0xA3, 0x95
d325 : a958             	lda #0x40+24
d327 : 204bd1           	jsr sd_sendbyte
d32a : a525             	lda sd_addr+0
d32c : 204bd1           	jsr sd_sendbyte
d32f : a526             	lda sd_addr+1
d331 : 204bd1           	jsr sd_sendbyte
d334 : a527             	lda sd_addr+2
d336 : 204bd1           	jsr sd_sendbyte
d339 : a528             	lda sd_addr+3
d33b : 204bd1           	jsr sd_sendbyte
d33e : a995             	lda #0x95					; Checksum needs to be right
d340 : 204bd1           	jsr sd_sendbyte
                        
d343 : 20e5d1           	jsr sd_getrespbyte			; Get response
                        
d346 : 206bd1           	jsr sd_getbyte
                        	
d349 : a9fe             	lda #0xfe					; Start of data token
d34b : 204bd1           	jsr sd_sendbyte
                        
d34e : 68               	pla							; Retrieve the address high byte
d34f : 8515             	sta tmp_ahi
d351 : 6414             	stz tmp_alo					; Address is always page boundary
                        
d353 : a000             	ldy #00
d355 :                  sd_writeblock_1					; Send first 256 bytes
d355 : b114             	lda (tmp_alo), y
d357 : 204bd1           	jsr sd_sendbyte
d35a : c8               	iny
d35b : d0f8             	bne sd_writeblock_1
d35d : e615             	inc tmp_ahi					; Next page for second 256 bytes
d35f :                  sd_writeblock_2					; Send second 256 bytes
AS65 Assembler for R6502 [1.42].                                     Page   92
------------------------------ kernel\kernel.s -------------------------------

d35f : b114             	lda (tmp_alo), y
d361 : 204bd1           	jsr sd_sendbyte
d364 : c8               	iny
d365 : d0f8             	bne sd_writeblock_2
                        
d367 : a9aa             	lda #0xaa					; Arbitrary CRC bytes
d369 : 204bd1           	jsr sd_sendbyte
d36c : 204bd1           	jsr sd_sendbyte
                        
d36f : 206bd1           	jsr sd_getbyte				; Get data response byte
d372 : 48               	pha							; Save it to return
                        
d373 :                  sd_waitforwritecomplete
d373 : 20f4d1           	jsr sd_busy					; Wait for card to be ready
                        	
d376 : 2043d1           	jsr sd_endcmd				; Release the card
                        
d379 : 68               	pla
d37a : 7a               	ply
d37b : 60               	rts
                        
                        	
d37c :                  sd_msg_initialising
d37c : 0d496e69746961.. 	db "\rInitialising SD Card\r", 0
                        
d393 :                  sd_cmd55
d393 : 770000000095     	db (0x40+55), 0x00, 0x00, 0x00, 0x00, 0x95
d399 :                  sd_cmd58
d399 : 7a0000000095     	db (0x40+58), 0x00, 0x00, 0x00, 0x00, 0x95
d39f :                  sd_acmd41
d39f : 690000000095     	db (0x40+41), 0x00, 0x00, 0x00, 0x00, 0x95
                        	
                        
                        	include "sdcard\sd_fs.s"
                        ;*****************************************************
                        ;*
                        ;*	DOLO-1 HOMEBREW COMPUTER
                        ;*	Hardware and software design by Dolo Miah
                        ;*	Copyright 2014-18
                        ;*  Free to use for any non-commercial purpose subject
                        ;*  full credit of original my authorship please!
                        ;*
                        ;*  SD_FS.S
                        ;*  FAT16 filesystem module.  Implements a basic FAT16
                        ;*  filesystem to enable mass storage support.
                        ;*  I've been a bit naughty in that I have assumed a 1
                        ;*  sd card size and sector 0 is the MBR.  This is not
                        ;*  always the case, but it works for me so I couldn't
                        ;*  the time be asked to sort it out. I may fix this f
                        ;*  more general use at some point..
                        ;*  The filesystem doesn't support sub directories and
                        ;*  implements the folling:
                        ;*  - load a file
                        ;*  - save a file
                        ;*  - delete a file from the card
                        ;*  - perform a directory listing
                        ;*  I have to say I am pretty pleased with this, took 
                        ;*  of reading and research!
                        ;*
                        ;*****************************************************
                        
                        
AS65 Assembler for R6502 [1.42].                                     Page   93
------------------------------ kernel\kernel.s -------------------------------

                        	; ROM code
                        	code
                        
                        ;****************************************
                        ;* init_fs
                        ;* Initialise filesystem - after sd card!
                        ;* Input : None
                        ;* Output : None
                        ;* Regs affected : None
                        ;****************************************
d3a5 :                  init_fs
                        	_println msg_initialising_fs
                        
                        
d3b2 : a203             	ldx #0x03					; Init sector to 0
d3b4 :                  init_fs_clr_sect
d3b4 : 7421             	stz sd_sect,x
d3b6 : ca               	dex
d3b7 : 10fb             	bpl init_fs_clr_sect
                        
d3b9 : a903             	lda #hi(sd_buf)				; Read in to the buffer
d3bb : 2094d2           	jsr sd_sendcmd17			; Call read block
                        
                        	;Extract data from boot record
d3be : a203             	ldx #0x03					; Assuming boot sector 0
d3c0 :                  init_fs_clr_boot
d3c0 : 7429             	stz fs_bootsect,x
d3c2 : ca               	dex
d3c3 : 10fb             	bpl init_fs_clr_boot
                        
                        	; Calculate start of FAT tables
                        	; Assumeing there are about 64k clusters
                        	; Each cluster assumed to be 32k sectors
                        	; Giving 64k x 32k x 0.5 ~ 1GB storage
d3c5 : 18               	clc
d3c6 : a529             	lda fs_bootsect
d3c8 : 6d0e03           	adc sd_buf+MBR_ResvSect
d3cb : 852d             	sta fs_fatsect
d3cd : a52a             	lda fs_bootsect+1
d3cf : 6d0f03           	adc sd_buf+MBR_ResvSect+1
d3d2 : 852e             	sta fs_fatsect+1
d3d4 : 642f             	stz fs_fatsect+2
d3d6 : 6430             	stz fs_fatsect+3
                        	
                        	; Calculate start of Root Directory
d3d8 : ad1603           	lda sd_buf+MBR_SectPerFAT	; Initialise to 1 * SectPer
d3db : 8531             	sta fs_rootsect
d3dd : ad1703           	lda sd_buf+MBR_SectPerFAT+1
d3e0 : 8532             	sta fs_rootsect+1
d3e2 : 18               	clc							; Add again = *2
d3e3 : ad1603           	lda sd_buf+MBR_SectPerFAT
d3e6 : 6531             	adc fs_rootsect
d3e8 : 8531             	sta fs_rootsect
d3ea : ad1703           	lda sd_buf+MBR_SectPerFAT+1
d3ed : 6532             	adc fs_rootsect+1
d3ef : 8532             	sta fs_rootsect+1
d3f1 : 6433             	stz fs_rootsect+2
d3f3 : 6434             	stz fs_rootsect+3
                        
                        	; Now add FAT offset
d3f5 : 18               	clc
d3f6 : a200             	ldx #0x00
AS65 Assembler for R6502 [1.42].                                     Page   94
------------------------------ kernel\kernel.s -------------------------------

d3f8 : a004             	ldy #0x04
d3fa :                  fs_init_add_fat
d3fa : b52d             	lda fs_fatsect,x
d3fc : 7531             	adc fs_rootsect,x
d3fe : 9531             	sta fs_rootsect,x
d400 : e8               	inx
d401 : 88               	dey
d402 : d0f6             	bne fs_init_add_fat
                        	
                        	; Calculate start of data area
                        	; Assuming 512 root dir entries!
d404 : a901             	lda #1						; 512/512 = 1
d406 : 8535             	sta fs_datasect
d408 : 6436             	stz fs_datasect+1
d40a : 6437             	stz fs_datasect+2
d40c : 6438             	stz fs_datasect+3
                        	
d40e : a005             	ldy #5						; Multiply by 32 to get root dir size in 
d410 :                  fs_rootmult1
d410 : 18               	clc
d411 : 0635             	asl fs_datasect
d413 : 2636             	rol fs_datasect+1
d415 : 2637             	rol fs_datasect+2
d417 : 2638             	rol fs_datasect+3
d419 : 88               	dey
d41a : d0f4             	bne fs_rootmult1
                        
                        	; Now add root directory offset
d41c : 18               	clc
d41d : a200             	ldx #0x00
d41f : a004             	ldy #0x04
d421 :                  fs_init_data
d421 : b531             	lda fs_rootsect,x
d423 : 7535             	adc fs_datasect,x
d425 : 9535             	sta fs_datasect,x
d427 : e8               	inx
d428 : 88               	dey
d429 : d0f6             	bne fs_init_data
                        
d42b : 38               	sec							; Now subtract 2 clusters worth of sector
d42c : a535             	lda fs_datasect+0			; to enable easy use of clusters 
d42e : e940             	sbc #0x40					; FS handling routines
d430 : 8535             	sta fs_datasect+0			; Each cluster = 32 sectors
d432 : a536             	lda fs_datasect+1			; Therefore take off 0x40 sectors
d434 : e900             	sbc #0
d436 : 8536             	sta fs_datasect+1
d438 : a537             	lda fs_datasect+2
d43a : e900             	sbc #0
d43c : 8537             	sta fs_datasect+2
d43e : a538             	lda fs_datasect+3
d440 : e900             	sbc #0
d442 : 8538             	sta fs_datasect+3
                        
                        	; Current directory = root dir
d444 : a203             	ldx #0x03
d446 :                  fs_init_dir_sect
d446 : b531             	lda fs_rootsect,x
d448 : 9539             	sta fs_dirsect,x
d44a : ca               	dex
d44b : 10f9             	bpl fs_init_dir_sect
                        	
d44d : 60               	rts
AS65 Assembler for R6502 [1.42].                                     Page   95
------------------------------ kernel\kernel.s -------------------------------

                        
                        ;****************************************
                        ;* fs_getbyte_sd_buf
                        ;* Given a populated SD buffer, get byte
                        ;* Indexed by X,Y (X=lo,Y=hi) 
                        ;* Input : X,Y make 9 bit index
                        ;* Output : A=Byte
                        ;* Regs affected : None
                        ;****************************************
d44e :                  fs_getbyte_sd_buf
d44e : 98               	tya
d44f : 2901             	and #1
d451 : d004             	bne fs_getbyte_sd_buf_hi
d453 : bd0003           	lda sd_buf,x
d456 : 60               	rts
d457 :                  fs_getbyte_sd_buf_hi
d457 : bd0004           	lda sd_buf+0x100,x
d45a : 60               	rts
                        
                        ;****************************************
                        ;* fs_putbyte_sd_buf
                        ;* Given a populated SD buffer, put byte
                        ;* Indexed by X,Y (X=lo,Y=hi), A=Val 
                        ;* Input : X,Y make 9 bit index, A=byte
                        ;* Output : None
                        ;* Regs affected : None
                        ;****************************************
d45b :                  fs_putbyte_sd_buf
d45b : 48               	pha
d45c : 98               	tya
d45d : 2901             	and #1
d45f : d005             	bne fs_putbyte_sd_buf_hi
d461 : 68               	pla
d462 : 9d0003           	sta sd_buf,x
d465 : 60               	rts
d466 :                  fs_putbyte_sd_buf_hi
d466 : 68               	pla
d467 : 9d0004           	sta sd_buf+0x100,x
d46a : 60               	rts
                        
                        ;****************************************
                        ;* fs_getword_sd_buf
                        ;* Given a populated SD buffer, get word
                        ;* Indexed by Y which is word aligned 
                        ;* Input : Y=Word offset in to sd_buf
                        ;* Output : X,A=Word
                        ;* Regs affected : None
                        ;****************************************
d46b :                  fs_getword_sd_buf
d46b : 98               	tya
d46c : 0a               	asl a
d46d : aa               	tax
d46e : b009             	bcs fs_getword_sd_buf_hi
d470 : bd0003           	lda sd_buf,x
d473 : 48               	pha
d474 : bd0103           	lda sd_buf+1,x
d477 : fa               	plx
d478 : 60               	rts
d479 :                  fs_getword_sd_buf_hi
d479 : bd0004           	lda sd_buf+0x100,x
d47c : 48               	pha
d47d : bd0104           	lda sd_buf+0x100+1,x
AS65 Assembler for R6502 [1.42].                                     Page   96
------------------------------ kernel\kernel.s -------------------------------

d480 : fa               	plx
d481 : 60               	rts
                        
                        ;****************************************
                        ;* fs_putword_sd_buf
                        ;* Given a populated SD buffer, put word
                        ;* Indexed by Y which is word aligned 
                        ;* Input : Y=Word offset in to sd_buf
                        ;* Output : X,A=Word
                        ;* Regs affected : None
                        ;****************************************
d482 :                  fs_putword_sd_buf
d482 : 5a               	phy
d483 : 48               	pha
d484 : da               	phx
d485 : 98               	tya
d486 : 0a               	asl a
d487 : a8               	tay
d488 : b00b             	bcs fs_putword_sd_buf_hi
d48a : 68               	pla
d48b : aa               	tax
d48c : 990003           	sta sd_buf,y
d48f : 68               	pla
d490 : 990103           	sta sd_buf+1,y
d493 : 7a               	ply
d494 : 60               	rts
d495 :                  fs_putword_sd_buf_hi
d495 : 68               	pla
d496 : aa               	tax
d497 : 990004           	sta sd_buf+0x100,y
d49a : 68               	pla
d49b : 990104           	sta sd_buf+0x100+1,y
d49e : 7a               	ply
d49f : 60               	rts
                        
                        
                        ;****************************************
                        ;* fs_dir_root_start
                        ;* Initialise ready to read root directory
                        ;* Input : dirsect is current directory pointer
                        ;* Output : None
                        ;* Regs affected : None
                        ;****************************************
d4a0 :                  fs_dir_root_start
d4a0 : 48               	pha
d4a1 : da               	phx
                        
                        	; Set SD sector to root directory
d4a2 : a203             	ldx #0x03
d4a4 :                  fs_dir_set_sd
d4a4 : b539             	lda fs_dirsect,x
d4a6 : 9521             	sta sd_sect,x
d4a8 : ca               	dex
d4a9 : 10f9             	bpl fs_dir_set_sd
                        
                        	; SD buffer is where blocks will be read to
d4ab : 641f             	stz sd_slo
d4ad : a903             	lda #hi(sd_buf)
d4af : 8520             	sta sd_shi
                        
                        	; Load up first sector in to SD buf
d4b1 : a903             	lda #hi(sd_buf)
AS65 Assembler for R6502 [1.42].                                     Page   97
------------------------------ kernel\kernel.s -------------------------------

d4b3 : 2094d2           	jsr sd_sendcmd17
                        
d4b6 : fa               	plx
d4b7 : 68               	pla
d4b8 : 60               	rts
                        
                        ;****************************************
                        ;* fs_dir_find_entry
                        ;* Read directory entry
                        ;* Input : sd_slo, sd_shi : Pointer to directory entry
                        ;* Input : C = 0 only find active files.  C = 1 find f
                        ;* Output : None
                        ;* Regs affected : None
                        ;****************************************
d4b9 :                  fs_dir_find_entry
d4b9 : 48               	pha
d4ba : da               	phx
d4bb : 5a               	phy
d4bc : 08               	php							; Save C state for checking later
d4bd :                  fs_dir_check_entry
                        	; Not LFN aware
d4bd : a00b             	ldy #FAT_Attr				; Check attribute
d4bf : a95e             	lda #0x5e					; Any of H, S, V, D, I then skip
d4c1 : 311f             	and (sd_slo),y
d4c3 : d01a             	bne fs_dir_invalid_entry
d4c5 : a000             	ldy #FAT_Name				; Examine 1st byte of name
d4c7 : b11f             	lda (sd_slo),y
d4c9 : 28               	plp							; Check C
d4ca : 08               	php
d4cb : 900a             	bcc	fs_find_active_slot		; Looking to find an active 
d4cd : c900             	cmp #0						; Else looking for 0 or 0xe5
d4cf : f017             	beq fs_dir_found_entry
d4d1 : c9e5             	cmp #0xe5
d4d3 : f013             	beq fs_dir_found_entry
d4d5 : 8008             	bra fs_dir_invalid_entry	; Else not an entry we're in
d4d7 :                  fs_find_active_slot
d4d7 : c900             	cmp #0
d4d9 : f009             	beq fs_dir_done				; If zero then no more entries
d4db : c9e5             	cmp #0xe5					; Deleted entry?
d4dd : d009             	bne fs_dir_found_entry
d4df :                  fs_dir_invalid_entry
d4df : 20f4d4           	jsr fs_dir_next_entry		; Advance read for next iterat
d4e2 : 80d9             	bra fs_dir_check_entry
                        
                        	; Found a valid entry or finished
d4e4 :                  fs_dir_done						; No more entries
d4e4 : 28               	plp							; Remove temp P from stack
d4e5 : 38               	sec							; Set carry to indicate no more
d4e6 : 8008             	bra fs_dir_fin
d4e8 :                  fs_dir_found_entry
d4e8 : 28               	plp							; Remove temp P from stack
d4e9 : 2026d5           	jsr fs_dir_copy_entry		; Copy the important entry det
d4ec : 20f4d4           	jsr fs_dir_next_entry		; Advance read for next iterat
d4ef : 18               	clc							; Clear carry to indicate found
d4f0 :                  fs_dir_fin						; Finalise
d4f0 : 7a               	ply
d4f1 : fa               	plx
d4f2 : 68               	pla
d4f3 : 60               	rts
                        	
                        ;****************************************
                        ;* fs_dir_next_entry
AS65 Assembler for R6502 [1.42].                                     Page   98
------------------------------ kernel\kernel.s -------------------------------

                        ;* Jump to next directory entry (32 bytes)
                        ;* Load next sector if required
                        ;* Input : sd_slo, sd_shi : Pointer to directory entry
                        ;* Output : None
                        ;* Regs affected : None
                        ;****************************************
d4f4 :                  fs_dir_next_entry
d4f4 : 48               	pha
d4f5 : da               	phx
d4f6 : 5a               	phy
                        	
d4f7 : 18               	clc							; Jump to next 32 byte entry
d4f8 : a51f             	lda sd_slo					; Update sd_slo, sd_shi
d4fa : 6920             	adc #32
d4fc : 851f             	sta sd_slo
d4fe : a520             	lda sd_shi
d500 : 6900             	adc #0
d502 : 8520             	sta sd_shi
d504 : c905             	cmp #5						; If not at end of sector (page 5)
d506 : d01a             	bne fs_dir_next_done		; then don't load next sector
                        
                        	; Advance the sector
d508 : a200             	ldx #0x00
d50a : a004             	ldy #0x04
d50c : 38               	sec
d50d :                  fs_dir_inc_sect
d50d : b521             	lda sd_sect,x
d50f : 6900             	adc #0
d511 : 9521             	sta sd_sect,x
d513 : e8               	inx
d514 : 88               	dey
d515 : d0f6             	bne fs_dir_inc_sect
                        	
                        	; Reset SD buffer  where blocks will be read to
d517 : 641f             	stz sd_slo
d519 : a903             	lda #hi(sd_buf)
d51b : 8520             	sta sd_shi
                        
d51d : a903             	lda #hi(sd_buf)				; Goes in to sd_buf
d51f : 2094d2           	jsr sd_sendcmd17			; Load it
                        
d522 :                  fs_dir_next_done
d522 : 7a               	ply
d523 : fa               	plx
d524 : 68               	pla
d525 : 60               	rts
                        	
                        
                        ;****************************************
                        ;* fs_dir_copy_entry
                        ;* Copy directory entry
                        ;* Input : sd_slo, sd_shi : Pointer to directory entry
                        ;* Input : C = 0 for an active entry (copy loaded dire
                        ;* Input : C = 1 for an empty entry (don't copy size, 
                        ;* Output : None
                        ;* Regs affected : None
                        ;****************************************
d526 :                  fs_dir_copy_entry
d526 : 48               	pha
d527 : da               	phx
d528 : 5a               	phy
d529 : b04a             	bcs fs_dir_empty_slot		; If an empty slot, then most 
AS65 Assembler for R6502 [1.42].                                     Page   99
------------------------------ kernel\kernel.s -------------------------------

                        
                        	;Normal processing of an entry loaded from the direct
d52b : a200             	ldx #FH_Name				; Point to where name will go
d52d : a000             	ldy #FAT_Name
d52f :                  fs_dir_get_name_ch
d52f : b11f             	lda (sd_slo),y				; Get name char
d531 : c920             	cmp #' '					; Don't copy space
d533 : f010             	beq	fs_dir_skip_name_ch
d535 : c008             	cpy #FAT_Ext				; At extension?
d537 : d008             	bne fs_dir_skip_ext_ch
d539 : 48               	pha							; Save A
d53a : a92e             	lda #'.'					; Inject '.'
d53c : 9d9007           	sta fh_dir,x				; Copy byte
d53f : 68               	pla							; Restore A
d540 : e8               	inx							; Advance
d541 :                  fs_dir_skip_ext_ch
d541 : 9d9007           	sta fh_dir,x				; Copy byte
d544 : e8               	inx							; Advance
d545 :                  fs_dir_skip_name_ch
d545 : c8               	iny							; Next SD dir entry
d546 : c00b             	cpy #FAT_Attr				; Passed end of name?
d548 : d0e5             	bne fs_dir_get_name_ch	
d54a :                  fs_dir_entry_pad_name
d54a : e00d             	cpx #FH_Size				; End of FH name space?
d54c : f006             	beq fs_dir_entry_size		; Yes, then copy size
d54e : 9e9007           	stz fh_dir,x				; Else put 0
d551 : e8               	inx
d552 : 80f6             	bra fs_dir_entry_pad_name
                        
d554 :                  fs_dir_entry_size
d554 : a20d             	ldx #FH_Size				; Point to where size will go
d556 : a01c             	ldy #FAT_FileSize			; Point to get size from
d558 : 208dd5           	jsr fs_dir_util_copy		; Copy 4 bytes
d55b : 208dd5           	jsr fs_dir_util_copy
d55e : 208dd5           	jsr fs_dir_util_copy
d561 : 208dd5           	jsr fs_dir_util_copy
                        	
d564 :                  fs_dir_entry_attr
d564 : a211             	ldx #FH_Attr				; Point to where attributes go
d566 : a00b             	ldy #FAT_Attr				; Point from where to get attributes
d568 : 208dd5           	jsr fs_dir_util_copy		; Copy 1 byte
                        
d56b :                  fs_dir_entry_clust
d56b : a223             	ldx #FH_FirstClust
d56d : a01a             	ldy	#FAT_FirstClust
d56f : 208dd5           	jsr fs_dir_util_copy		; Copy 2 bytes
d572 : 208dd5           	jsr fs_dir_util_copy
                        
                        	; Empty slot data goes here
d575 :                  fs_dir_empty_slot
d575 :                  fs_dir_entry_dirsect			; Directory sector in which FH 
d575 : a203             	ldx #0x03
d577 :                  fs_dir_copy_sd_sect
d577 : b521             	lda sd_sect,x
d579 : 9dad07           	sta fh_dir+FH_DirSect,x
d57c : ca               	dex
d57d : 10f8             	bpl fs_dir_copy_sd_sect
                        	
d57f :                  fs_dir_entry_diroffset			; Offset in to directory sect
d57f : a51f             	lda sd_slo
d581 : 8db107           	sta fh_dir+FH_DirOffset
d584 : a520             	lda sd_shi
AS65 Assembler for R6502 [1.42].                                     Page  100
------------------------------ kernel\kernel.s -------------------------------

d586 : 8db207           	sta fh_dir+FH_DirOffset+1
                        	
d589 : 7a               	ply
d58a : fa               	plx
d58b : 68               	pla
                        	
d58c : 60               	rts
                        	
                        
                        ;****************************************
                        ;* fs_dir_util_copy
                        ;* Copy SD bytes to directory entry area
                        ;* Input 	: y = offset in to sd directory
                        ;*		 	: x = offset in to dir entry
                        ;* Output 	: None
                        ;* Regs affected : All
                        ;****************************************
d58d :                  fs_dir_util_copy
d58d : 48               	pha
d58e : b11f             	lda (sd_slo),y
d590 : 9d9007           	sta fh_dir,x
d593 : c8               	iny
d594 : e8               	inx
d595 : 68               	pla
d596 : 60               	rts
                        
                        
                        
                        ;****************************************
                        ;* fs_get_next_cluster
                        ;* Given current cluster, find the next
                        ;* Input : fh_handle
                        ;* Output : 
                        ;* Regs affected : None
                        ;****************************************
d597 :                  fs_get_next_cluster
d597 : 48               	pha
d598 : da               	phx
d599 : 5a               	phy
                        
                        	; Get the FAT sector that current clust is in
d59a : 20f3d6           	jsr fs_get_FAT_clust_sect
                        
                        	; Get next from this cluster index need low byte only
                        	; as each FAT cluster contains 256 cluster entries
d59d : a4b5             	ldy fh_handle+FH_CurrClust
                        	; X = Low byte, A = High byte of cluster
d59f : 206bd4           	jsr fs_getword_sd_buf
                        	; Make this the current cluster
d5a2 : 86b5             	stx fh_handle+FH_CurrClust
d5a4 : 85b6             	sta fh_handle+FH_CurrClust+1
                        	
                        	; Calculate the sector address
d5a6 : 202ad6           	jsr fs_get_start_sect_data
d5a9 : a920             	lda #0x20					; 32 sector per cluster countdown			
d5ab : 85b7             	sta fh_handle+FH_SectCounter
                        
d5ad : 7a               	ply
d5ae : fa               	plx
d5af : 68               	pla
d5b0 : 60               	rts
                        	
AS65 Assembler for R6502 [1.42].                                     Page  101
------------------------------ kernel\kernel.s -------------------------------

                        ;****************************************
                        ;* fs_IsEOF
                        ;* End of File check (compare file pointer to file siz
                        ;* Input : fh_handle
                        ;* Output : 
                        ;* Regs affected : None
                        ;****************************************
d5b1 :                  fs_isEOF
d5b1 : 48               	pha
d5b2 : da               	phx
                        	
d5b3 : a203             	ldx #0x03
d5b5 :                  fs_is_eof_cmp
d5b5 : b5bc             	lda fh_handle+FH_Pointer,x
d5b7 : d5b0             	cmp fh_handle+FH_Size,x
d5b9 : d007             	bne fs_notEOF
d5bb : ca               	dex
d5bc : 10f7             	bpl fs_is_eof_cmp
                        
d5be : fa               	plx
d5bf : 68               	pla
d5c0 : 38               	sec							; C = 1 for EOF
d5c1 : 60               	rts
                        
d5c2 :                  fs_notEOF	
d5c2 : fa               	plx
d5c3 : 68               	pla
d5c4 : 18               	clc							; C = 0 for not EOF
d5c5 : 60               	rts
                        
                        	
                        ;****************************************
                        ;* fs_inc_pointer
                        ;* Increment file point, loading sectors and clusters 
                        ;* This results in sd_buf containing the sector that t
                        ;* Input : fh_handle
                        ;* Output : 
                        ;* Regs affected : None
                        ;****************************************
d5c6 :                  fs_inc_pointer
d5c6 : 48               	pha
d5c7 : da               	phx
d5c8 : 5a               	phy
                        	
                        	;Increment pointer
d5c9 : a200             	ldx #0x00
d5cb : a004             	ldy #0x04
d5cd : 38               	sec									; Always adds 1 first
d5ce :                  fs_inc_fh_pointer
d5ce : b5bc             	lda fh_handle+FH_Pointer,x
d5d0 : 6900             	adc #0x00
d5d2 : 95bc             	sta fh_handle+FH_Pointer,x
d5d4 : e8               	inx
d5d5 : 88               	dey
d5d6 : d0f6             	bne fs_inc_fh_pointer
                        
d5d8 : a5bc             	lda fh_handle+FH_Pointer			; If low order == 0
d5da : f004             	beq fs_inc_sector_ov				; Then sector 8 bits has over
d5dc :                  fs_inc_fin
d5dc : 7a               	ply
d5dd : fa               	plx
d5de : 68               	pla
AS65 Assembler for R6502 [1.42].                                     Page  102
------------------------------ kernel\kernel.s -------------------------------

                        	
d5df : 60               	rts
d5e0 :                  fs_inc_sector_ov						; Check if sector bit 8 has over
d5e0 : a5bd             	lda fh_handle+FH_Pointer+1			; Load up next highest b
d5e2 : 2901             	and #1								; If bit zero = 0 then must have
d5e4 : d0f6             	bne fs_inc_fin						; overflowed.
                        	;Sector change required
d5e6 : a200             	ldx #0x00
d5e8 : a004             	ldy #0x04
d5ea : 38               	sec									; Always adds 1 first
d5eb :                  fs_inc_fh_sect
d5eb : b5b8             	lda fh_handle+FH_CurrSec,x
d5ed : 6900             	adc #0x00
d5ef : 95b8             	sta fh_handle+FH_CurrSec,x
d5f1 : e8               	inx
d5f2 : 88               	dey
d5f3 : d0f6             	bne fs_inc_fh_sect
d5f5 :                  fs_inc_skip_sec_wrap
d5f5 : c6b7             	dec fh_handle+FH_SectCounter		; If reached the end of
d5f7 : d006             	bne fs_inc_load_sector				; Then get next cluster
                        	; Cluster change required
d5f9 : 2097d5           	jsr fs_get_next_cluster				; Get next cluster based o
d5fc : 205ad6           	jsr fs_load_curr_sect				; Load it
d5ff :                  fs_inc_load_sector
d5ff : 20b1d5           	jsr fs_isEOF						; Check not EOF
d602 : b003             	bcs fs_skip_load_sect				; if so then don't load sect
d604 : 205ad6           	jsr fs_load_curr_sect				; Load the sector
d607 :                  fs_skip_load_sect
d607 : 7a               	ply
d608 : fa               	plx
d609 : 68               	pla
d60a : 60               	rts
                        
                        
                        	
                        ;****************************************
                        ;* fs_get_next_byte
                        ;* Get a byte
                        ;* Input : fh_handle
                        ;* Output : A = char, C = 1 (EOF)
                        ;* Regs affected : None
                        ;****************************************
d60b :                  fs_get_next_byte
d60b : da               	phx
d60c : 5a               	phy
                        
d60d : 20b1d5           	jsr fs_isEOF						; If at EOF then error
d610 : 9008             	bcc fs_get_skip_EOF
                        
d612 : a901             	lda #FS_ERR_EOF
d614 : 855e             	sta errno
d616 : 38               	sec
d617 : 7a               	ply
d618 : fa               	plx
d619 : 60               	rts
                        
d61a :                  fs_get_skip_EOF
d61a : a6bc             	ldx fh_handle+FH_Pointer			; Low 8 bits of sector ind
d61c : a4bd             	ldy fh_handle+FH_Pointer+1			; Which half of sector?
                        	; A=SD buffer byte
d61e : 204ed4           	jsr fs_getbyte_sd_buf
d621 : 20c6d5           	jsr fs_inc_pointer					; Increment file pointers
AS65 Assembler for R6502 [1.42].                                     Page  103
------------------------------ kernel\kernel.s -------------------------------

                        
d624 : 18               	clc									; No error
d625 : 645e             	stz errno
d627 : 7a               	ply
d628 : fa               	plx
d629 : 60               	rts
                        	
                        
                        
                        ;****************************************
                        ; Find the sector given the data cluster
                        ; Given clust in LoX,HiA
                        ; Outputs to fh_handle->FH_CurrSec
                        ;****************************************
d62a :                  fs_get_start_sect_data
d62a : 48               	pha
d62b : da               	phx
d62c : 5a               	phy
                        	
d62d : 86b5             	stx fh_handle+FH_CurrClust
d62f : 85b6             	sta fh_handle+FH_CurrClust+1
                        	
                        	; Initialise to input sector
d631 : 86b8             	stx fh_handle+FH_CurrSec+0
d633 : 85b9             	sta fh_handle+FH_CurrSec+1
d635 : 64ba             	stz fh_handle+FH_CurrSec+2
d637 : 64bb             	stz fh_handle+FH_CurrSec+3
                        	
                        	; Sector = Cluster * 32
                        	; Shift left 5 times
d639 : a005             	ldy #5
d63b :                  fs_get_data_sect_m5
d63b : 18               	clc
d63c : 06b8             	asl fh_handle+FH_CurrSec+0
d63e : 26b9             	rol fh_handle+FH_CurrSec+1
d640 : 26ba             	rol fh_handle+FH_CurrSec+2
d642 : 26bb             	rol fh_handle+FH_CurrSec+3
d644 : 88               	dey
d645 : d0f4             	bne fs_get_data_sect_m5
                        
                        	; Add data sector offset
d647 : a200             	ldx #0x00
d649 : a004             	ldy #0x04
d64b : 18               	clc
d64c :                  fs_get_start_data
d64c : b5b8             	lda fh_handle+FH_CurrSec,x
d64e : 7535             	adc fs_datasect,x
d650 : 95b8             	sta fh_handle+FH_CurrSec,x
d652 : e8               	inx
d653 : 88               	dey
d654 : d0f6             	bne fs_get_start_data
                        
d656 : 7a               	ply
d657 : fa               	plx
d658 : 68               	pla
d659 : 60               	rts
                        	
                        ;****************************************
                        ; Load the current sector in FH
                        ;****************************************
d65a :                  fs_load_curr_sect
d65a : 48               	pha
AS65 Assembler for R6502 [1.42].                                     Page  104
------------------------------ kernel\kernel.s -------------------------------

d65b : da               	phx
                        
d65c : a203             	ldx #0x03
d65e :                  fs_load_cpy_sect
d65e : b5b8             	lda fh_handle+FH_CurrSec,x
d660 : 9521             	sta sd_sect,x
d662 : ca               	dex
d663 : 10f9             	bpl fs_load_cpy_sect
d665 : a903             	lda #hi(sd_buf)
d667 : 2094d2           	jsr sd_sendcmd17
                        
d66a : fa               	plx
d66b : 68               	pla
d66c : 60               	rts
                        
                        ;****************************************
                        ; Flush the current sector
                        ;****************************************
d66d :                  fs_flush_curr_sect
d66d : 48               	pha
d66e : da               	phx
                        
d66f : a203             	ldx #0x03
d671 :                  fs_flush_cpy_sect
d671 : b5b8             	lda fh_handle+FH_CurrSec,x
d673 : 9521             	sta sd_sect,x
d675 : ca               	dex
d676 : 10f9             	bpl fs_flush_cpy_sect
d678 : a903             	lda #hi(sd_buf)				; Sending data in sd_buf
d67a : 2009d3           	jsr sd_sendcmd24
                        	
d67d : fa               	plx
d67e : 68               	pla
d67f : 60               	rts
                        
                        
                        ;****************************************
                        ;* fs_copy_dir_to_fh
                        ;* Copy directory entry (fh) to file handle
                        ;* Input : fh_dir contains directory entry
                        ;* Output : None
                        ;* Regs affected : None
                        ;****************************************
d680 :                  fs_copy_dir_to_fh
d680 : 48               	pha
d681 : da               	phx
d682 : a200             	ldx #FH_Name			; By default copy all
d684 : 9002             	bcc fs_copy_dir_to_fh_byte
d686 : a20d             	ldx #FH_Size			; But skip name if new file
d688 :                  fs_copy_dir_to_fh_byte
d688 : bd9007           	lda fh_dir,x
d68b : 95a3             	sta fh_handle,x
d68d : e8               	inx
d68e : e028             	cpx #FileHandle
d690 : d0f6             	bne fs_copy_dir_to_fh_byte
d692 : fa               	plx
d693 : 68               	pla
d694 : 60               	rts
                        
                        ;****************************************
                        ;* fs_find_empty_clust
                        ;* Find an empty cluster to write to
AS65 Assembler for R6502 [1.42].                                     Page  105
------------------------------ kernel\kernel.s -------------------------------

                        ;* Input : None
                        ;* Output : fh_handle->FH_CurrClust is the empty clust
                        ;* Regs affected : None
                        ;****************************************
d695 :                  fs_find_empty_clust
d695 : 48               	pha
d696 : da               	phx
d697 : 5a               	phy
                        
                        	; Starting at cluster 0x0002
d698 : a902             	lda #02
d69a : 85b5             	sta fh_handle+FH_CurrClust
d69c : 64b6             	stz fh_handle+FH_CurrClust+1
                        
                        	
                        	; Start at the first FAT sector
d69e : a203             	ldx #0x03
d6a0 :                  fs_find_init_fat
d6a0 : b52d             	lda fs_fatsect,x
d6a2 : 95b8             	sta fh_handle+FH_CurrSec,x
d6a4 : ca               	dex
d6a5 : 10f9             	bpl fs_find_init_fat
                        
                        	; There is only enough room for 512/2 = 256 cluster e
                        	; There are 256 sectors of FAT entries
                        
d6a7 :                  fs_check_empty_sector
d6a7 : 205ad6           	jsr fs_load_curr_sect			; Load a FAT sector
d6aa :                  fs_check_curr_clust
d6aa : a4b5             	ldy fh_handle+FH_CurrClust		; Index in to this FAT se
d6ac : 206bd4           	jsr fs_getword_sd_buf
d6af : e000             	cpx #0
d6b1 : d01b             	bne fs_next_fat_entry
d6b3 : c900             	cmp #0
d6b5 : d017             	bne fs_next_fat_entry
                        	
                        	; If got here then empty cluster found
                        	; fh_handle->FH_CurrClust is the empty cluster
                        	
                        	; Mark this cluster as used
d6b7 : a2ff             	ldx #0xff
d6b9 : a9ff             	lda #0xff
d6bb : 2082d4           	jsr fs_putword_sd_buf
                        
                        	; flush this FAT entry back so this cluster is safe f
d6be : 206dd6           	jsr fs_flush_curr_sect
                        	
d6c1 : 64b7             	stz fh_handle+FH_SectCounter	; Zero the sector count
d6c3 : a6b5             	ldx fh_handle+FH_CurrClust
d6c5 : a5b6             	lda fh_handle+FH_CurrClust+1
d6c7 : 202ad6           	jsr fs_get_start_sect_data		; Initialise the sector
d6ca : 7a               	ply
d6cb : fa               	plx
d6cc : 68               	pla
d6cd : 60               	rts
                        	; If got here then need to find another cluster
d6ce :                  fs_next_fat_entry
                        	_incZPWord fh_handle+FH_CurrClust	; Increment the clu
                        
                        	; Only 256 FAT entries in a sector of 512 bytes
d6d4 : a5b5             	lda fh_handle+FH_CurrClust		; Check low byte of clust
d6d6 : d0d2             	bne fs_check_curr_clust			; Else keep checking cluste
AS65 Assembler for R6502 [1.42].                                     Page  106
------------------------------ kernel\kernel.s -------------------------------

                        	; Every 256 FAT entries, need to get a new FAT sector
d6d8 :                  fs_next_fat_sect
d6d8 : 20ddd6           	jsr fs_inc_curr_sec				; Increment to the next FAT se
d6db : 80ca             	bra fs_check_empty_sector		; Go an load the new FAT s
                        	
                        
                        ;****************************************
                        ;* fs_inc_curr_sec
                        ;* Increment sector by 1
                        ;* Input : fh_handle has the sector
                        ;****************************************
d6dd :                  fs_inc_curr_sec
d6dd : 48               	pha
d6de : da               	phx
d6df : 5a               	phy
                        	
                        	; add 1 to LSB as sector address is little endian
d6e0 : a200             	ldx #0x00
d6e2 : a004             	ldy #0x04
d6e4 : 38               	sec
d6e5 :                  fs_inc_sec_byte
d6e5 : b5b8             	lda fh_handle+FH_CurrSec,x
d6e7 : 6900             	adc #0x00
d6e9 : 95b8             	sta fh_handle+FH_CurrSec,x
d6eb : e8               	inx
d6ec : 88               	dey
d6ed : d0f6             	bne fs_inc_sec_byte
                        
d6ef : 7a               	ply
d6f0 : fa               	plx
d6f1 : 68               	pla
d6f2 : 60               	rts
                        	
                        
                        ;****************************************
                        ;* fs_get_FAT_clust_sect
                        ;* Given FH_CurrClust, set FH_CurrSec so that
                        ;* the sector contains the FAT entry
                        ;* Input : fh_handle has the details
                        ;* Output : None
                        ;* Regs affected : None
                        ;****************************************
d6f3 :                  fs_get_FAT_clust_sect
d6f3 : 48               	pha
d6f4 : da               	phx
d6f5 : 5a               	phy
                        	
                        	; Sector offset in to FAT = high byte
                        	; because a sector can hold 256 FAT entries
d6f6 : a5b6             	lda fh_handle+FH_CurrClust+1
d6f8 : 85b8             	sta fh_handle+FH_CurrSec
d6fa : 64b9             	stz fh_handle+FH_CurrSec+1
d6fc : 64ba             	stz fh_handle+FH_CurrSec+2
d6fe : 64bb             	stz fh_handle+FH_CurrSec+3
                        	
                        	; Add the FAT offset
d700 : 18               	clc
d701 : a200             	ldx #0x00
d703 : a004             	ldy #0x04
d705 :                  fs_get_add_fat
d705 : b5b8             	lda fh_handle+FH_CurrSec,x
d707 : 752d             	adc fs_fatsect,x
AS65 Assembler for R6502 [1.42].                                     Page  107
------------------------------ kernel\kernel.s -------------------------------

d709 : 95b8             	sta fh_handle+FH_CurrSec,x
d70b : e8               	inx
d70c : 88               	dey
d70d : d0f6             	bne fs_get_add_fat
                        
                        	; Now load the sector containing this cluster entry
d70f : 205ad6           	jsr fs_load_curr_sect
                        
d712 : 7a               	ply
d713 : fa               	plx
d714 : 68               	pla
d715 : 60               	rts
                        	
                        ;****************************************
                        ;* fs_update_FAT_entry
                        ;* FH_LastClust updated with FH_CurrClust
                        ;* Input : fh_handle has the details
                        ;* Output : None
                        ;* Regs affected : None
                        ;****************************************
d716 :                  fs_update_FAT_entry
d716 : 48               	pha
d717 : da               	phx
d718 : 5a               	phy
                        	
d719 : a5b5             	lda fh_handle+FH_CurrClust+0	; Save current cluster l
d71b : 48               	pha
d71c : a5b6             	lda fh_handle+FH_CurrClust+1	; Save current cluster h
d71e : 48               	pha
                        	; Move back to the last cluster entry
                        	_cpyZPWord fh_handle+FH_LastClust,fh_handle+FH_CurrCl
                        
                        
d727 : 20f3d6           	jsr fs_get_FAT_clust_sect		; Get the FAT sector to up
                        	; Index in to the FAT sector
d72a : a4c8             	ldy fh_handle+FH_LastClust
                        	; Get current cluster hi,lo from stack
d72c : 68               	pla
d72d : fa               	plx
                        	; Update FAT entry Y with cluster X,A
d72e : 2082d4           	jsr fs_putword_sd_buf
                        
                        	; The appropriate FAT sector has been updated
                        	; Now flush that sector back	
d731 : 206dd6           	jsr fs_flush_curr_sect
                        	
                        	; And restore the current cluster
d734 : 86b5             	stx fh_handle+FH_CurrClust		; Make it the current clu
d736 : 85b6             	sta fh_handle+FH_CurrClust+1	; Make it the current cl
                        	
d738 : 7a               	ply
d739 : fa               	plx
d73a : 68               	pla
d73b : 60               	rts
                        	
                        
                        ;****************************************
                        ;* fs_put_byte
                        ;* Put out a byte, incrementing size
                        ;* and committing clusters as necessary
                        ;* including reflecting this in the FAT table
                        ;* Input : fh_handle has the details, A = Byte to writ
AS65 Assembler for R6502 [1.42].                                     Page  108
------------------------------ kernel\kernel.s -------------------------------

                        ;* Output : None
                        ;* Regs affected : None
                        ;****************************************
d73c :                  fs_put_byte
d73c : da               	phx
d73d : 5a               	phy
d73e : 48               	pha
                        
                        	; Before writing a byte, need to check if the current
                        	; sector is full.
                        	; Check low 9 bits of size and if zero size (i.e. 1st
d73f : a5b0             	lda fh_handle+FH_Size
d741 : d024             	bne fs_put_do_put
d743 : a5b1             	lda fh_handle+FH_Size+1
d745 : f020             	beq fs_put_do_put
d747 : 2901             	and #1
d749 : d01c             	bne fs_put_do_put
                        
                        	; We need to flush this sector to disk
d74b : 206dd6           	jsr fs_flush_curr_sect
                        	; Move to next sector in the cluster
d74e : 20ddd6           	jsr fs_inc_curr_sec
                        	; Bump the sector counter
d751 : e6b7             	inc fh_handle+FH_SectCounter
                        	; Check if counter at sectors per cluster limit
d753 : a5b7             	lda fh_handle+FH_SectCounter
d755 : c920             	cmp #0x20
d757 : d00e             	bne fs_put_do_put
                        	; We need to find a new cluster now
                        	; But first update the FAT chain
                        	; so that the last cluster points to this
d759 : 2016d7           	jsr fs_update_FAT_entry
                        	; Before finding a new cluster
                        	; make the current the last
                        	_cpyZPWord fh_handle+FH_CurrClust,fh_handle+FH_LastCl
                        
                        	; Go find a new empty clust
                        	; starts at sector 0
d764 : 2095d6           	jsr fs_find_empty_clust
                        	; Finally, can write a byte to the
                        	; SD buffer in memory
d767 :                  fs_put_do_put	
d767 : a6b0             	ldx fh_handle+FH_Size			; Load size low as index in t
d769 : a4b1             	ldy fh_handle+FH_Size+1			; Check which half
d76b : 68               	pla								; Get A off stack and put back
d76c : 48               	pha
d76d : 205bd4           	jsr fs_putbyte_sd_buf
d770 :                  fs_put_inc_size
d770 : 38               	sec
d771 : a200             	ldx #0x00
d773 : a004             	ldy #0x04
d775 :                  fs_put_inc_size_byte
d775 : b5b0             	lda fh_handle+FH_Size,x
d777 : 6900             	adc #0
d779 : 95b0             	sta fh_handle+FH_Size,x
d77b : e8               	inx
d77c : 88               	dey
d77d : d0f6             	bne fs_put_inc_size_byte
d77f :                  fs_put_fin
d77f : 68               	pla
d780 : 7a               	ply
d781 : fa               	plx
AS65 Assembler for R6502 [1.42].                                     Page  109
------------------------------ kernel\kernel.s -------------------------------

d782 : 60               	rts
                        
                        ;****************************************
                        ;* fs_dir_save_entry
                        ;* Save dir entry back to disk
                        ;* Input : fh_handle has all the details
                        ;* Output : None
                        ;* Regs affected : None
                        ;****************************************
d783 :                  fs_dir_save_entry
d783 : 48               	pha
d784 : da               	phx
d785 : 5a               	phy
                        
                        	; Retrieve the sector where the file entry goes
d786 : a203             	ldx #0x03
d788 :                  fs_dir_curr_sect
d788 : b5c0             	lda fh_handle+FH_DirSect,x
d78a : 95b8             	sta fh_handle+FH_CurrSec,x
d78c : ca               	dex
d78d : 10f9             	bpl fs_dir_curr_sect
                        	
d78f : 205ad6           	jsr fs_load_curr_sect
                        
                        	; Restore index in to the correct entry
d792 : a5c4             	lda fh_handle+FH_DirOffset
d794 : 851f             	sta sd_slo
d796 : a5c5             	lda fh_handle+FH_DirOffset+1
d798 : 8520             	sta sd_shi
                        	
                        	;Save the filename
d79a : a200             	ldx #FH_Name				; Point to where name will go
d79c : a000             	ldy #FAT_Name
d79e :                  fs_dir_save_name_ch
d79e : b5a3             	lda fh_handle,x				; Get a char
d7a0 : f011             	beq fs_dir_name_done		; If zero then name done
d7a2 : c92e             	cmp #'.'					; Is it '.'
d7a4 : d003             	bne fs_dir_name_skip		; If so then don't consider
d7a6 : e8               	inx							; Jump over '.'
d7a7 : 800a             	bra fs_dir_name_done		; and start processing the ext
d7a9 :                  fs_dir_name_skip
d7a9 : c008             	cpy #FAT_Ext				; Reached the end of the name?
d7ab : f006             	beq fs_dir_name_done
d7ad : 911f             	sta (sd_slo),y				; No, so store the byte in name
d7af : e8               	inx
d7b0 : c8               	iny
d7b1 : 80eb             	bra fs_dir_save_name_ch
d7b3 :                  fs_dir_name_done
                        	
d7b3 : a920             	lda #' '					; Pad name with spaces
d7b5 :                  fs_dir_pad_name
d7b5 : c008             	cpy #FAT_Ext				; Padded enough?
d7b7 : f005             	beq fs_dir_pad_name_done
d7b9 : 911f             	sta (sd_slo),y				; Fill with space
d7bb : c8               	iny
d7bc : 80f7             	bra fs_dir_pad_name
d7be :                  fs_dir_pad_name_done
                        	
d7be :                  fs_dir_save_ext_ch
d7be : c00b             	cpy #FAT_Attr				; End of extension?
d7c0 : f00a             	beq fs_dir_ext_done
d7c2 : b5a3             	lda fh_handle,x				; Get a char
AS65 Assembler for R6502 [1.42].                                     Page  110
------------------------------ kernel\kernel.s -------------------------------

d7c4 : f006             	beq fs_dir_ext_done			; If zero then name done
d7c6 : 911f             	sta (sd_slo),y
d7c8 : e8               	inx
d7c9 : c8               	iny
d7ca : 80f2             	bra fs_dir_save_ext_ch	
d7cc :                  fs_dir_ext_done
                        	
d7cc : a920             	lda #' '					; Pad out any remaining with space
d7ce :                  fs_dir_ext_pad
d7ce : c00b             	cpy #FAT_Attr				; Reached the end of the extension?
d7d0 : f005             	beq fs_dir_ext_pad_done
d7d2 : 911f             	sta (sd_slo),y
d7d4 : c8               	iny
d7d5 : 80f7             	bra fs_dir_ext_pad
                        	; At the Attribute byte, zero out everything until si
d7d7 :                  fs_dir_ext_pad_done
                        	
d7d7 : a900             	lda #0
d7d9 :                  fs_dir_save_rest_ch
d7d9 : 911f             	sta (sd_slo),y
d7db : c8               	iny
d7dc : c01a             	cpy #FAT_FirstClust
d7de : d0f9             	bne fs_dir_save_rest_ch
                        	; Now save first cluster
d7e0 : a5c6             	lda fh_handle+FH_FirstClust
d7e2 : 911f             	sta (sd_slo),y
d7e4 : c8               	iny
d7e5 : a5c7             	lda fh_handle+FH_FirstClust+1
d7e7 : 911f             	sta (sd_slo),y
d7e9 : c8               	iny
                        
                        	; Now save size
d7ea : a200             	ldx #0
d7ec :                  df_dir_save_size_ch
d7ec : b5b0             	lda fh_handle+FH_Size,x
d7ee : 911f             	sta (sd_slo),y
d7f0 : c8               	iny
d7f1 : e8               	inx
d7f2 : e004             	cpx #4
d7f4 : d0f6             	bne df_dir_save_size_ch
                        
                        	; Ok done copying data to directory entry
                        	; Now flush this back to disk
                        	
d7f6 : 206dd6           	jsr fs_flush_curr_sect
                        	
                        	; Phew we are done
d7f9 : 7a               	ply
d7fa : fa               	plx
d7fb : 68               	pla
d7fc : 60               	rts
                        	
                        	
                        ;****************************************
                        ;* fs_open_read
                        ;* Open a file for reading
                        ;* Input : fh_handle has the name
                        ;* Output : None
                        ;* Regs affected : None
                        ;****************************************
d7fd :                  fs_open_read
d7fd : 48               	pha
AS65 Assembler for R6502 [1.42].                                     Page  111
------------------------------ kernel\kernel.s -------------------------------

d7fe : da               	phx
d7ff : 5a               	phy
                        
d800 : 20a0d4           	jsr fs_dir_root_start		; Start at root
d803 :                  fs_open_find
d803 : 18               	clc							; Only look for active files
d804 : 20b9d4           	jsr fs_dir_find_entry		; Find a valid entry
d807 : b02d             	bcs	fs_open_not_found		; If C then no more entries
d809 : a200             	ldx #0						; Check name matches
d80b :                  fs_open_check_name
d80b : b5a3             	lda fh_handle,x
d80d : dd9007           	cmp fh_dir,x
d810 : d0f1             	bne fs_open_find
d812 : c900             	cmp #0						; If no more bytes in name to check
d814 : f003             	beq fs_open_found
d816 : e8               	inx
d817 : 80f2             	bra fs_open_check_name
d819 :                  fs_open_found
d819 : 2080d6           	jsr fs_copy_dir_to_fh		; Put entry in to fh_handle
                        
d81c : a920             	lda #0x20					; 32 sector per cluster countdown			
d81e : 85b7             	sta fh_handle+FH_SectCounter
                        
d820 : a6c6             	ldx fh_handle+FH_FirstClust	; Load up first cluster
d822 : a5c7             	lda fh_handle+FH_FirstClust+1
                        
d824 : 202ad6           	jsr fs_get_start_sect_data	; Calc the first sector
d827 : 205ad6           	jsr fs_load_curr_sect		; Load it in to sd_buf
                        
                        
d82a : a203             	ldx #0x03					; Initialise pointer to beginning
d82c :                  fs_open_init_pointer
d82c : 74bc             	stz fh_handle+FH_Pointer,x
d82e : ca               	dex
d82f : 10fb             	bpl fs_open_init_pointer
                        
                        	; Set file mode to read
d831 : a900             	lda #0x00
d833 : 85ca             	sta fh_handle+FH_FileMode
                        
d835 : 18               	clc
d836 :                  fs_open_not_found
d836 : 7a               	ply
d837 : fa               	plx
d838 : 68               	pla
d839 : 60               	rts
                        
                        
                        ;****************************************
                        ;* fs_open_write
                        ;* Open a file for writing
                        ;* Input : fh_handle has the name
                        ;*		 : existing file will overwritten
                        ;*		 : new file will be created
                        ;* Output : None
                        ;* Regs affected : None
                        ;****************************************
d83a :                  fs_open_write
d83a : 48               	pha
d83b : da               	phx
d83c : 5a               	phy
                        
AS65 Assembler for R6502 [1.42].                                     Page  112
------------------------------ kernel\kernel.s -------------------------------

                        	; try and delete any file with the same name first
d83d : a5a3             	lda fh_handle+FH_Name		; save first char as it gets d
d83f : 48               	pha
d840 : 2094d8           	jsr fs_delete				; now delete it
d843 : 68               	pla							; restore first char
d844 : 85a3             	sta fh_handle+FH_Name
d846 : 20a0d4           	jsr fs_dir_root_start		; Start at root
d849 : 38               	sec							; Find an empty file entry
d84a : 20b9d4           	jsr fs_dir_find_entry		; Find a valid entry
d84d : b020             	bcs	fs_open_write_fin		; Error, didn't find!
d84f : 38               	sec
d850 : 2080d6           	jsr fs_copy_dir_to_fh		; Copy entry to file handle
                        
d853 : 64b0             	stz fh_handle+FH_Size+0		; Size is zero initially
d855 : 64b1             	stz fh_handle+FH_Size+1
d857 : 64b2             	stz fh_handle+FH_Size+2
d859 : 64b3             	stz fh_handle+FH_Size+3
                        
d85b : 2095d6           	jsr fs_find_empty_clust		; Where will be the first cl
                        
                        	; Set current, last and first cluster
d85e : a5b5             	lda fh_handle+FH_CurrClust
d860 : 85c6             	sta fh_handle+FH_FirstClust
d862 : 85c8             	sta fh_handle+FH_LastClust
d864 : a5b6             	lda fh_handle+FH_CurrClust+1
d866 : 85c7             	sta fh_handle+FH_FirstClust+1
d868 : 85c9             	sta fh_handle+FH_LastClust+1
                        
                        	; Set file mode to write
d86a : a9ff             	lda #0xff
d86c : 85ca             	sta fh_handle+FH_FileMode
                        
d86e : 18               	clc
d86f :                  fs_open_write_fin
d86f : 7a               	ply
d870 : fa               	plx
d871 : 68               	pla
d872 : 60               	rts
                        
                        
                        ;****************************************
                        ;* fs_close
                        ;* Close a file, only important for new files
                        ;* Input : fh_handle details
                        ;* Output : None
                        ;* Regs affected : None
                        ;****************************************
d873 :                  fs_close
d873 : 48               	pha
                        
                        	; Only need to close down stuff in write mode
d874 : a5ca             	lda fh_handle+FH_FileMode
d876 : f01a             	beq fs_close_done
                        	
                        	; Flush the current sector
d878 : 206dd6           	jsr fs_flush_curr_sect
                        
                        	; Update the chain from the last cluster
d87b : 2016d7           	jsr fs_update_FAT_entry
                        
                        	; Make current sector = last
d87e : a5b5             	lda fh_handle+FH_CurrClust
AS65 Assembler for R6502 [1.42].                                     Page  113
------------------------------ kernel\kernel.s -------------------------------

d880 : 85c8             	sta fh_handle+FH_LastClust
d882 : a5b6             	lda fh_handle+FH_CurrClust+1
d884 : 85c9             	sta fh_handle+FH_LastClust+1
                        	; Need to update the FAT entry
                        	; to show this cluster is last
d886 : a9ff             	lda #0xff
d888 : 85b5             	sta fh_handle+FH_CurrClust
d88a : 85b6             	sta fh_handle+FH_CurrClust+1
                        	; Now update the FAT entry to mark the last cluster
                        
d88c : 2016d7           	jsr fs_update_FAT_entry
                        
d88f : 2083d7           	jsr fs_dir_save_entry
                        
d892 :                  fs_close_done
d892 : 68               	pla
d893 : 60               	rts
                        
                        ;****************************************
                        ;* fs_delete
                        ;* Delete a file
                        ;* Input : fh_handle has the name
                        ;* Output : None
                        ;* Regs affected : None
                        ;****************************************
d894 :                  fs_delete
d894 : 48               	pha
d895 : da               	phx
d896 : 5a               	phy
                        
d897 : 20fdd7           	jsr fs_open_read			; Try and open the file
d89a : b02e             	bcs fs_delete_fin			; If not found then fin
                        	
                        	; Mark first char with deleted indicator
d89c : a9e5             	lda #0xe5
d89e : 85a3             	sta fh_handle+FH_Name
                        
                        	; Save this back to directory table
d8a0 : 2083d7           	jsr fs_dir_save_entry
                        
                        	; Now mark all related clusters as free
d8a3 : a6c6             	ldx fh_handle+FH_FirstClust
d8a5 : 86b5             	stx fh_handle+FH_CurrClust
d8a7 : a4c7             	ldy fh_handle+FH_FirstClust+1
d8a9 : 84b6             	sty fh_handle+FH_CurrClust+1
d8ab :                  fs_delete_clust
                        	; X and Y always contain current cluster
                        	; Make last = current
d8ab : 86c8             	stx fh_handle+FH_LastClust
d8ad : 84c9             	sty fh_handle+FH_LastClust+1
                        
                        	; Given current cluster, find next
                        	; save in X,Y
d8af : 2097d5           	jsr fs_get_next_cluster
                        	; load X,Y with the next cluster
d8b2 : a6b5             	ldx fh_handle+FH_CurrClust
d8b4 : a4b6             	ldy fh_handle+FH_CurrClust+1
                        	
                        	; Zero out the cluster number
d8b6 : 64b5             	stz fh_handle+FH_CurrClust
d8b8 : 64b6             	stz fh_handle+FH_CurrClust+1
                        
AS65 Assembler for R6502 [1.42].                                     Page  114
------------------------------ kernel\kernel.s -------------------------------

                        	; Update FAT entry of Last Cluster with zero
d8ba : 2016d7           	jsr fs_update_FAT_entry
                        
                        	; Restore the next cluster found earlier
d8bd : 86b5             	stx fh_handle+FH_CurrClust
d8bf : 84b6             	sty fh_handle+FH_CurrClust+1
                        
                        	; If the next cluster is not 0xffff
                        	; then continue
d8c1 : e0ff             	cpx #0xff
d8c3 : d0e6             	bne fs_delete_clust
d8c5 : c0ff             	cpy #0xff
d8c7 : d0e2             	bne fs_delete_clust
d8c9 : 18               	clc
d8ca :                  fs_delete_fin
d8ca : 7a               	ply
d8cb : fa               	plx
d8cc : 68               	pla
d8cd : 60               	rts
                        
                        
                        	
d8ce :                  msg_initialising_fs
d8ce : 496e697469616c.. 	db "Initialising filesystem\r",0
d8e7 :                  fs_msg_directory_listing
d8e7 : 53442043617264.. 	db "SD Card Directory\r",0
                        
                        	include "io\io.s"
                        ;*****************************************************
                        ;*
                        ;*	DOLO-1 HOMEBREW COMPUTER
                        ;*	Hardware and software design by Dolo Miah
                        ;*	Copyright 2014-18
                        ;*  Free to use for any non-commercial purpose subject
                        ;*  full credit of original my authorship please!
                        ;*
                        ;*  IO.S
                        ;*  General IO module.  Allows different IO devices to
                        ;*  utilised transparently by the rest of the code.
                        ;*  Other code should use "io_" commands so that they
                        ;*  do not need to know what specific device is provid
                        ;*  input and output capabilities.  On startup, the ke
                        ;*  examines the BBC DIP switch to decide whether to
                        ;*  initialise the IO to serial through the ACIA or us
                        ;*  the BBC keyboard for input with the VDP for output
                        ;*  Loading and saving files from the SD card is simil
                        ;*  achieved by pointing to SD card get and put byte
                        ;*  routines.
                        ;*
                        ;*****************************************************
                        
                        	; ROM code
                        	code
                        
                        ;****************************************
                        ;* io_init_default
                        ;* Initialise the default device and make active
                        ;* Using dip switch to either select
                        ;* Keyboard and screen or serial port
                        ;* Output : None
                        ;* Regs affected : P, A
                        ;****************************************
AS65 Assembler for R6502 [1.42].                                     Page  115
------------------------------ kernel\kernel.s -------------------------------

d8fa :                  io_init_default
d8fa : 2043c1           	jsr kb_scan_options	; Check options
d8fd : 2901             	and #0x01			; Bit 0 = IO Mode (1=KB/VDP, 0=Serial)
d8ff : 4c02d9           	jmp io_active_device
                        
                        ;****************************************
                        ;* io_active_device
                        ;* Activate device
                        ;* Input : A = Device number
                        ;* Output : None
                        ;* Regs affected : P, A
                        ;****************************************
d902 :                  io_active_device
d902 : 0a               	asl	a				; x16 the Block number
d903 : 0a               	asl a
d904 : 0a               	asl a
d905 : 0a               	asl a
d906 : a8               	tay
d907 : a200             	ldx #0
                        	; Copy device settings to io block
d909 :                  io_copy_data
d909 : b997d9           	lda io_devices,y
d90c : 9d8007           	sta io_block,x
d90f : c8               	iny
d910 : e8               	inx
d911 : e010             	cpx #16
d913 : d0f4             	bne io_copy_data
                        	
d915 : a900             	lda #lo(ser_buf)	; Initialise buffer and size
d917 : 851b             	sta buf_lo
d919 : a902             	lda #hi(ser_buf)
d91b : 851c             	sta buf_hi
d91d : a9ff             	lda #255
d91f : 851d             	sta buf_sz
d921 : a90d             	lda #UTF_CR		; Line terminator is CR
d923 : 851e             	sta buf_ef
d925 : 60               	rts
                        
                        ;****************************************
                        ;* io_get_ch
                        ;* Get a char (wait forever or just check)
                        ;* Input : C = 1 for synchronous, 0 for async
                        ;* Output : A = Byte code, C = 0 means A is invalid
                        ;* Regs affected : P, A
                        ;****************************************
d926 :                  io_get_ch
d926 : 6c8007           	jmp (io_block+io_get_byte)
                        	
                        
                        ;****************************************
                        ;* io_get_ch
                        ;* Get a char (wait forever or just check)
                        ;* Input : C = 1 for synchronous, 0 for async
                        ;* Output : A = Byte code, C = 0 means A is invalid
                        ;* Regs affected : P, A
                        ;****************************************
d929 :                  io_put_ch
d929 : 6c8207           	jmp (io_block+io_put_byte)
                        	
                        ;****************************************
                        ;* io_open_read
                        ;* Open for reading
AS65 Assembler for R6502 [1.42].                                     Page  116
------------------------------ kernel\kernel.s -------------------------------

                        ;* Input : X,A = pointer to filename (zero terminated)
                        ;* Output : C=0 success
                        ;* Regs affected : All
                        ;****************************************
d92c :                  io_open_read
d92c : 6c8407           	jmp (io_block+io_open_r)
                        	
                        ;****************************************
                        ;* io_open_write
                        ;* Open for reading
                        ;* Input : X,A = pointer to filename (zero terminated)
                        ;* Output : C=0 success
                        ;* Regs affected : All
                        ;****************************************
d92f :                  io_open_write
d92f : 6c8607           	jmp (io_block+io_open_w)
                        
                        ;****************************************
                        ;* io_close
                        ;* Close a file
                        ;* Input : 
                        ;* Output : C=0 success
                        ;* Regs affected : All
                        ;****************************************
d932 :                  io_close
d932 : 6c8807           	jmp (io_block+io_close_f)
                        	
                        ;****************************************
                        ;* io_delete
                        ;* Delete a file
                        ;* Input : 
                        ;* Output : C=0 success
                        ;* Regs affected : All
                        ;****************************************
d935 :                  io_delete
d935 : 6c8a07           	jmp (io_block+io_del_f)
                        	
                        ;****************************************
                        ;* io_read_line
                        ;* Read a line, terminated by terminating char or max 
                        ;* Input : buf_(lo/hi/sz/ef) : Address, Max size, end 
                        ;* Output : Y = Line length C = Buffer limit reached
                        ;* Regs affected : None
                        ;****************************************
d938 :                  io_read_line
d938 : 48               	pha
                        
d939 : 08               	php					; Save echo state
                        	
d93a : a000             	ldy #0x00			; Starting at first byte
d93c :                  io_get_line_byte
d93c : 38               	sec					; Getting bytes synchronously
d93d : 2026d9           	jsr io_get_ch		; Get a byte
d940 : 28               	plp					; Get echo state
d941 : 08               	php					; Instantly save it back
d942 : 900c             	bcc io_skip_echo	; Carry not set = don't echo
d944 : c97f             	cmp #UTF_DEL		; Delete?
d946 : d005             	bne io_do_echo
d948 : c000             	cpy #0				; Already at beginning?
d94a : f004             	beq io_skip_echo	; Don't echo delete
d94c : 88               	dey					; Else decrement length
d94d :                  io_do_echo
AS65 Assembler for R6502 [1.42].                                     Page  117
------------------------------ kernel\kernel.s -------------------------------

d94d : 2029d9           	jsr io_put_ch		; Echo it
d950 :                  io_skip_echo
d950 : c920             	cmp #UTF_SPECIAL	; Special character?
d952 : 9007             	bcc io_skip_special	; Skip if so (don't add to buffer
d954 : c97f             	cmp #UTF_DEL		; Don't proces DEL either
d956 : f003             	beq io_skip_special
d958 : 911b             	sta (buf_lo),y		; Save it
d95a : c8               	iny					; Increase length
d95b :                  io_skip_special
d95b : c51e             	cmp buf_ef			; Is it the terminating char?
d95d : f008             	beq io_get_line_done	; If yes then done
d95f : c41d             	cpy buf_sz			; Reached the buffer max size?
d961 : d0d9             	bne io_get_line_byte	; No, get another byte
d963 : 28               	plp					; Remember to pull echo state off stack
d964 : 38               	sec					; Yes, set carry flag
d965 : 68               	pla
d966 : 60               	rts					; And done
d967 :                  io_get_line_done
d967 : a900             	lda #0
d969 : 911b             	sta (buf_lo),y		; Terminate with 0
d96b : 28               	plp					; Remember to pull echo state off stack
d96c : 18               	clc					; Clear carry flag
d96d : 68               	pla
d96e : 60               	rts					; Fin
                        
                        ;****************************************
                        ;* io_write_line
                        ;* Put a line of bytes out of a certain length
                        ;* Input : buf_(lo/hi/sz/ef) : Address, Y=Max size
                        ;* Output : None
                        ;* Regs affected : All
                        ;****************************************
d96f :                  io_write_line
d96f : 5a               	phy
d970 : 48               	pha
                        	
d971 : a000             	ldy #0				; Start at first byte
d973 :                  write_line_byte
d973 : c41d             	cpy buf_sz			; Check first if buffer sized reached
d975 : f008             	beq write_line_done	; to catch zero length outputs
d977 : b11b             	lda (buf_lo),y		; Read the byte
d979 : 2029d9           	jsr io_put_ch		; Transmit
d97c : c8               	iny					; Ready for next byte
d97d : d0f4             	bne write_line_byte	; Forced branch as Y will only be
d97f :                  write_line_done
                        
d97f : 68               	pla
d980 : 7a               	ply
d981 : 60               	rts	
                        
                        ;****************************************
                        ;* io_print_line
                        ;* Print a line (when data is not already in serial bu
                        ;* Input : X = Address Lo, A = Address Hi
                        ;* Output : Y=number chars output
                        ;* Regs affected : All
                        ;****************************************
d982 :                  io_print_line
d982 : 48               	pha
                        
d983 : 8618             	stx tmp_clo					; Store the string pointer
d985 : 8519             	sta tmp_chi					; lo and hi
AS65 Assembler for R6502 [1.42].                                     Page  118
------------------------------ kernel\kernel.s -------------------------------

d987 : a000             	ldy #0						; Start at the beginning!
d989 :                  io_print_line_byte
d989 : b118             	lda (tmp_clo),y				; Copy byte to
d98b : f006             	beq io_print_done			; If zero then done - print
d98d : 2029d9           	jsr io_put_ch				; Transmit
d990 : c8               	iny
d991 : d0f6             	bne io_print_line_byte		; Carry on until zero found o
d993 :                  io_print_done
d993 : 68               	pla
d994 : 60               	rts
                        
                        ;*** Null operation just clc and return ***
d995 :                  io_null_op
d995 : 18               	clc
d996 : 60               	rts
                        	
                        ;* IO devices defined here
d997 :                  io_devices
                        ;* Device zero is the serial port
                        ;* only offers get and put
d997 :                  io_device0					; Serial device, input = Ser, output = 
d997 : 00c0             	dw	get_byte			; io_get_ch
d999 : 10c0             	dw	put_byte			; io_put_ch
d99b : 95d9             	dw	io_null_op			; io_open_r
d99d : 95d9             	dw	io_null_op			; io_open_w
d99f : 95d9             	dw	io_null_op			; io_close_f
d9a1 : 95d9             	dw	io_null_op			; io_del_f
d9a3 : 95d9             	dw	io_null_op			; io_ext1
d9a5 : 95d9             	dw	io_null_op			; io_ext2
                        ;* Device one is keyboard / screen
                        ;* only offers get and put
d9a7 :                  io_device1					; Default device, input = screen editor
d9a7 : bacc             	dw	gr_get_key			; io_get_ch
d9a9 : c9cc             	dw	gr_put_byte			; io_put_ch
d9ab : 95d9             	dw	io_null_op			; io_open_r
d9ad : 95d9             	dw	io_null_op			; io_open_w
d9af : 95d9             	dw	io_null_op			; io_close_f
d9b1 : 95d9             	dw	io_null_op			; io_del_f
d9b3 : 95d9             	dw	io_null_op			; io_ext1
d9b5 : 95d9             	dw	io_null_op			; io_ext2
                        ;* Device two is the file system on SD card
                        ;* Offers all IO functions
d9b7 :                  io_device2					; SD device, input = SD, output = SD
d9b7 : 0bd6             	dw	fs_get_next_byte	; io_get_ch
d9b9 : 3cd7             	dw	fs_put_byte			; io_put_ch
d9bb : fdd7             	dw	fs_open_read		; io_open_r
d9bd : 3ad8             	dw	fs_open_write		; io_open_w
d9bf : 73d8             	dw	fs_close			; io_close_f
d9c1 : 94d8             	dw	fs_delete			; io_del_f
d9c3 : 95d9             	dw	io_null_op			; io_ext1
d9c5 : 95d9             	dw	io_null_op			; io_ext2
                        
                        	include "dflat\dflat.s"
                        ;*****************************************************
                        ;*
                        ;*	DOLO-1 HOMEBREW COMPUTER
                        ;*	Hardware and software design by Dolo Miah
                        ;*	Copyright 2014-18
                        ;*  Free to use for any non-commercial purpose subject
                        ;*  full credit of original my authorship please!
                        ;*
                        ;*  DFLAT.S
AS65 Assembler for R6502 [1.42].                                     Page  119
------------------------------ kernel\kernel.s -------------------------------

                        ;*  This is the main controller code file for dflat.
                        ;*  This file includes all the required dflat source f
                        ;*  needed:
                        ;*  - error.s is the error handling module
                        ;*  - var.s is the variable handling module
                        ;*  - tokenise.s is the tokenisation module
                        ;*  - progedit.s is the program editing module
                        ;*  - runtime.s is the runtime module
                        ;*  - stack.s is the stack handling module
                        ;*  The above modules include further source files as
                        ;*  needed.
                        ;*
                        ;*****************************************************
                        
                        	; ROM code
                        	code  
                        
                        	include "dflat\error.s"
                        ;*****************************************************
                        ;*
                        ;*	DOLO-1 HOMEBREW COMPUTER
                        ;*	Hardware and software design by Dolo Miah
                        ;*	Copyright 2014-18
                        ;*  Free to use for any non-commercial purpose subject
                        ;*  full credit of original my authorship please!
                        ;*
                        ;*  ERROR.S
                        ;*  Error handling module.
                        ;*  Whan an error is thrown using BRK, this module han
                        ;*  displaying the error plus any associated line numb
                        ;*  if it was running a program.  It then resets neces
                        ;*  settings and takes the system back to program edit
                        ;*  mode.  The message uses the general IO handler, th
                        ;*  output will be to either screen or serial dependin
                        ;*  the BBC keyboard DIP switch.
                        ;*
                        ;*****************************************************
                        
                        	; ROM code
                        	code  
                        	include "dflat\error.i"
                        ;*****************************************************
                        ;*
                        ;*	DOLO-1 HOMEBREW COMPUTER
                        ;*	Hardware and software design by Dolo Miah
                        ;*	Copyright 2014-18
                        ;*  Free to use for any non-commercial purpose subject
                        ;*  full credit of original my authorship please!
                        ;*
                        ;*  ERROR.I
                        ;*  Error definitions file.
                        ;*  The macro to throw an error is elswhere, but basic
                        ;*  It issues a 6502 BRK commmand with the next byte b
                        ;*  the error code.  The BRK handler then picks up the
                        ;*  code and shows the appropriate message plus any li
                        ;*  number if a program was running.
                        ;*
                        ;*****************************************************
                        
                        	; ROM code
                        	code  
                        
AS65 Assembler for R6502 [1.42].                                     Page  120
------------------------------ kernel\kernel.s -------------------------------

                        ; Error message numbers
0000 =                  DFERR_OK		=	0
0001 =                  DFERR_ERROR		=	1
0002 =                  DFERR_SYNTAX	=	2
0003 =                  DFERR_RUNTIME	=	3
0004 =                  DFERR_TYPEMISM	=	4
0005 =                  DFERR_DIM		=	5
0006 =                  DFERR_UNTIL		=	6
0007 =                  DFERR_NOPROC	=	7
0008 =                  DFERR_PROCPARM	=	8
0009 =                  DFERR_IMMEDIATE	=	9
000a =                  DFERR_UNCLOSEDIF=	10
000b =                  DFERR_NOIF		=	11
000c =                  DFERR_NEXTFOR	=	12
000d =                  DFERR_FNAME		=	13
000e =                  DFERR_STRLONG	=	14
000f =                  DFERR_BREAK		=	15
0010 =                  DFERR_NODATA	=	16
0011 =                  DFERR_WEND		=	17
0012 =                  DFERR_NOLINE	=	18
0013 =                  DFERR_RETURN	=	19
                        
                        
                        
                        	
                        	
                        	
                        	
                        ; Error message table, each msg null terminated
d9c7 :                  df_tk_errortab
d9c7 : 4f6b00           	db	"Ok", 0
d9ca : 47656e6572616c00 	db	"General", 0
d9d2 : 53796e74617800   	db	"Syntax", 0
d9d9 : 52756e74696d6500 	db	"Runtime", 0
d9e1 : 54797065206d69.. 	db	"Type mismatch", 0
d9ef : 52652d44696d00   	db	"Re-Dim", 0
d9f6 : 4e6f2072657065.. 	db	"No repeat", 0
da00 : 50726f63206e6f.. 	db	"Proc not found", 0
da0f : 50726f63207061.. 	db	"Proc parm mismatch", 0
da22 : 556e6578706563.. 	db	"Unexpected end", 0
da31 : 556e636c6f7365.. 	db	"Unclosed if", 0
da3d : 4e6f20696600     	db	"No if", 0
da43 : 4e6f20466f7200   	db	"No For", 0
da4a : 46696c656e616d.. 	db	"Filename", 0
da53 : 537472696e6720.. 	db	"String too long", 0
da63 : 427265616b00     	db	"Break", 0
da69 : 4f7574206f6620.. 	db	"Out of data", 0
da75 : 4e6f207768696c.. 	db	"No while", 0
da7e : 4e6f206c696e6500 	db	"No line", 0
da86 : 4e6f2072657475.. 	db	"No return value"
da95 : 00               	db	0
                        
da96 :                  df_tk_error_inline
da96 : 20696e206c696e.. 	db	" in line ", 0
daa0 :                  df_tk_error_atpos
daa0 : 20706f732000     	db	" pos ", 0
daa6 :                  df_tk_error_error
daa6 : 206572726f7200   	db	" error", 0
                        
                        ;****************************************
                        ;* df_trap_error
                        ;* Show an error message
AS65 Assembler for R6502 [1.42].                                     Page  121
------------------------------ kernel\kernel.s -------------------------------

                        ;* errno is error number
                        ;* currlin = Line number
                        ;* exeoff = offset
                        ;* at the end jump to program editor
                        ;****************************************
daad :                  df_trap_error
                        	; reset SP
daad : a660             	ldx df_sp
daaf : 9a               	txs
                        	; set IO back to normal
dab0 : 20fad8           	jsr io_init_default
                        	
dab3 : a9c7             	lda #lo(df_tk_errortab)
dab5 : 858c             	sta df_tmpptra
dab7 : a9d9             	lda #hi(df_tk_errortab)
dab9 : 858d             	sta df_tmpptra+1
dabb : a65e             	ldx errno
dabd :                  df_show_err_find
dabd : e000             	cpx #0
dabf : f013             	beq df_show_err_found
dac1 :                  df_show_err_skip
                        	_incZPWord df_tmpptra
                        
dac7 : b28c             	lda (df_tmpptra)
dac9 : d0f6             	bne df_show_err_skip
                        	_incZPWord df_tmpptra
                        
dad1 : ca               	dex
dad2 : 80e9             	bra df_show_err_find
dad4 :                  df_show_err_found
dad4 : a68c             	ldx df_tmpptra
dad6 : a58d             	lda df_tmpptra+1
dad8 : 2082d9           	jsr io_print_line
dadb : a2a6             	ldx #lo(df_tk_error_error)
dadd : a9da             	lda #hi(df_tk_error_error)
dadf : 2082d9           	jsr io_print_line
                        	; if line number <> 0 then print it
dae2 : a001             	ldy #DFTK_LINNUM
dae4 : b187             	lda (df_currlin),y
dae6 : aa               	tax
dae7 : c8               	iny
dae8 : b187             	lda (df_currlin),y
daea : c900             	cmp #0x00
daec : d006             	bne df_show_err_linnum
daee : e000             	cpx #0x00
daf0 : d002             	bne df_show_err_linnum
daf2 : 8011             	bra df_show_err_fin
daf4 :                  df_show_err_linnum
                        	_println df_tk_error_inline
                        
db01 : 18               	clc
db02 : 20c5cf           	jsr print_a_to_d
db05 :                  df_show_err_fin
db05 : a489             	ldy df_exeoff
db07 : f015             	beq df_show_err_done
                        	_println df_tk_error_atpos
                        
db16 : 98               	tya
db17 : aa               	tax
db18 : a900             	lda #0
db1a : 18               	clc
db1b : 20c5cf           	jsr print_a_to_d	
AS65 Assembler for R6502 [1.42].                                     Page  122
------------------------------ kernel\kernel.s -------------------------------

db1e :                  df_show_err_done
db1e : a90d             	lda #UTF_CR
db20 : 2029d9           	jsr io_put_ch
db23 : 18               	clc
                        	; back to editor
db24 : 4cabe5           	jmp df_pg_dflat
                        	
                        	include "dflat\var.s"
                        ;*****************************************************
                        ;*
                        ;*	DOLO-1 HOMEBREW COMPUTER
                        ;*	Hardware and software design by Dolo Miah
                        ;*	Copyright 2014-18
                        ;*  Free to use for any non-commercial purpose subject
                        ;*  full credit of original my authorship please!
                        ;*
                        ;*  VAR.S
                        ;*  This module handles all the variable management in
                        ;*  When a new variable is detected during tokenisatio
                        ;*  is added to the variable tables.  Any subsequent u
                        ;*  that variable is tokenised as an index in to the v
                        ;*  table.  There are two variable tables:
                        ;*  Variable name table (VNT) keeps track of variable 
                        ;*  Variable value table (VVT) maintains variable prop
                        ;*  including type, dimension (if array) and of course
                        ;*  actual values.  For an array, the value is a point
                        ;*  memory grabbed using the 'malloc' function (see st
                        ;*  This approach to variable managemet is directly fr
                        ;*  Atari 8 bit.  The disadvantage is that during a bi
                        ;*  session you may end up having a much larger variab
                        ;*  table than you need.  Why?  Well because say you e
                        ;*  %a as a new variable, but then later change it to 
                        ;*  In this case %a remains in the variable tables - d
                        ;*  only ever adds to the table!  However it is easily
                        ;*  solved - when you save and then reload from new a
                        ;*  program, the variable table is built up as the pro
                        ;*  is loaded.
                        ;*  The VNT grows down from the top of free memory, wi
                        ;*  the VVT growing down from just below the VNT.
                        ;*
                        ;*****************************************************
                        
                        
                        	; ROM code
                        	code  
                        
                        ;****************************************
                        ;* Find VVT slot given VVT index
                        ;* A = index
                        ;* Return : df_tmpptra
                        ;* CC = No error
                        ;****************************************
db27 :                  df_var_addr
                        	; save index and multiply by 8
db27 : 858c             	sta df_tmpptra
db29 : 648d             	stz df_tmpptra+1
                        
db2b : 068c             	asl df_tmpptra
db2d : 268d             	rol df_tmpptra+1
                        
db2f : 068c             	asl df_tmpptra
db31 : 268d             	rol df_tmpptra+1
AS65 Assembler for R6502 [1.42].                                     Page  123
------------------------------ kernel\kernel.s -------------------------------

                        
db33 : 068c             	asl df_tmpptra
db35 : 268d             	rol df_tmpptra+1
                        
                        	; add in vvt start offset
                        	_addZPWord df_tmpptra,df_vvtstrt
                        
db44 : 18               	clc
db45 : 60               	rts
                        	
                        ;****************************************
                        ;* Find a variable
                        ;* CC if found, A has index
                        ;****************************************
db46 :                  df_var_find
                        	; start at the beginning of the vnt table
                        	_cpyZPWord df_vntstrt,df_tmpptra
                        
                        	; start at index 0
db4e : 648e             	stz df_tmpptrb
db50 :                  df_var_match_vnt
                        	; If reached the var count then not found
db50 : a572             	lda df_varcnt
db52 : c58e             	cmp df_tmpptrb
db54 : f030             	beq df_var_find_no_vnt
                        	; match each char in buffer with vnt
db56 : a47d             	ldy df_linoff
db58 :                  df_var_match_vnt_sym
db58 : b90005           	lda df_linbuff,y
db5b : d28c             	cmp (df_tmpptra)
db5d : d013             	bne df_var_vnt_sym_nomatch
                        	; if single char match then increment
                        	; source and search
db5f : c8               	iny
                        	_incZPWord df_tmpptra
                        
                        	; if more chars in vnt entry then continue
db66 : b28c             	lda (df_tmpptra)
db68 : d0ee             	bne df_var_match_vnt_sym
                        	; if no more chars in vnt entry but
                        	; but chars in buffer then try next vnt
db6a : b90005           	lda df_linbuff,y
db6d : 20dddd           	jsr df_tk_isalphanum
db70 : 9020             	bcc df_var_find_true
db72 :                  df_var_vnt_sym_nomatch
                        	; find the zero terminator
db72 : b28c             	lda (df_tmpptra)
db74 : f008             	beq	df_var_vnt_entry_end
                        	_incZPWord df_tmpptra
                        
db7c : 80f4             	bra df_var_vnt_sym_nomatch
db7e :                  df_var_vnt_entry_end
                        	; increment index
db7e : e68e             	inc df_tmpptrb
                        	; check if got to the end of the VNT
db80 : a572             	lda df_varcnt
db82 : c58e             	cmp df_tmpptrb
db84 : d004             	bne df_var_match_next_vnt
                        	; if at end then no matches found
db86 :                  df_var_find_no_vnt
db86 : a900             	lda #0
db88 : 38               	sec
AS65 Assembler for R6502 [1.42].                                     Page  124
------------------------------ kernel\kernel.s -------------------------------

db89 : 60               	rts
db8a :                  df_var_match_next_vnt
                        	; skip over zero terminator
                        	_incZPWord df_tmpptra
                        
db90 : 80be             	bra df_var_match_vnt
db92 :                  df_var_find_true
                        	; Got a match
db92 : a58e             	lda df_tmpptrb
db94 : 847d             	sty df_linoff
db96 : 18               	clc
db97 : 60               	rts
                        
                        	
                        ;****************************************
                        ;* General block move
                        ;* tmpptra = start of old block
                        ;* tmpptrb = block length
                        ;* tmpptrc = start of new block
                        ;****************************************
db98 :                  df_var_block_move
                        	; if block len = 0 then move nothing
db98 : a58e             	lda df_tmpptrb
db9a : d006             	bne df_var_block_move_do
db9c : a58f             	lda df_tmpptrb+1
db9e : d002             	bne df_var_block_move_do
                        	; damn zero block length
dba0 : 18               	clc
dba1 : 60               	rts
dba2 :                  df_var_block_move_do
dba2 : a200             	ldx #0					; Bytes transferred counter hi
dba4 : a000             	ldy #0					; Bytes transferred counter lo
                        	; if tmpptrc < tmpptra then move from
                        	; old start to new start else
                        	; move from old end to new end
dba6 : 38               	sec
dba7 : a58c             	lda df_tmpptra
dba9 : e590             	sbc df_tmpptrc
dbab : a58d             	lda df_tmpptra+1
dbad : e591             	sbc df_tmpptrc+1
dbaf : 901d             	bcc df_var_end_to_end
                        	; ok going from start to start c++ = a++
dbb1 :                  df_var_start_to_start_byte
dbb1 : b28c             	lda (df_tmpptra)
dbb3 : 9290             	sta (df_tmpptrc)
                        	_incZPWord df_tmpptra
                        
                        	_incZPWord df_tmpptrc
                        
dbc1 : c8               	iny
dbc2 : d001             	bne df_start_to_start_nowrap
dbc4 : e8               	inx
dbc5 :                  df_start_to_start_nowrap
dbc5 : c48e             	cpy df_tmpptrb
dbc7 : d0e8             	bne df_var_start_to_start_byte
dbc9 : e48f             	cpx df_tmpptrb+1
dbcb : d0e4             	bne df_var_start_to_start_byte
                        	; done
dbcd : 60               	rts
dbce :                  df_var_end_to_end
                        	; going end to end
                        	; need to adjust ptrc to be end
AS65 Assembler for R6502 [1.42].                                     Page  125
------------------------------ kernel\kernel.s -------------------------------

                        	; c = c + (b-a)
                        	; first copy b
                        	_cpyZPWord df_tmpptrb,df_tmpptrd
                        
                        	; do d-a, result in d
                        	_subZPWord df_tmpptrd,df_tmpptra
                        
                        	; now c + d, result in c
                        	_addZPWord df_tmpptrc, df_tmpptrd
                        
                        	; ok do the copy from end c-- = d--
dbf0 :                  df_var_end_to_end_byte
dbf0 : b28e             	lda (df_tmpptrb)
dbf2 : 9290             	sta (df_tmpptrc)
                        	_decZPWord df_tmpptrc
                        
                        	_decZPWord df_tmpptrb
                        
dc12 : c8               	iny
dc13 : d001             	bne df_end_to_end_nowrap
dc15 : e8               	inx
dc16 :                  df_end_to_end_nowrap
dc16 : c48e             	cpy df_tmpptrb
dc18 : d0d6             	bne df_var_end_to_end_byte
dc1a : e48f             	cpx df_tmpptrb+1
dc1c : d0d2             	bne df_var_end_to_end_byte
                        	; done
dc1e : 60               	rts
                        	
                        ;****************************************
                        ;* Insert a variable name in to vnt
                        ;* X = number of bytes to make room
                        ;* Requires a block move of everything
                        ;* from vvt start to vnt end
                        ;* ptrb is vnt free entry
                        ;* ptrc is vvt free entry
                        ;****************************************
dc1f :                  df_var_insert_space
                        	; *** REMEMBER TO DO A SPACE CHECK EVENTUALLY! ***
                        	
                        
                        	; Start from current vvt start
                        	_cpyZPWord df_vvtstrt,df_tmpptra
                        
                        
                        	; Length = vvt end - vvt start
                        	_cpyZPWord df_vvtend,df_tmpptrb
                        
                        	_subZPWord df_tmpptrb,df_vvtstrt
                        
                        
                        	; *vvt move* vnt size + vt size
dc3c : 8a               	txa
dc3d : 18               	clc
dc3e : 6908             	adc #DFVVT_SZ
dc40 : 8592             	sta df_tmpptrd
dc42 : 6493             	stz df_tmpptrd+1
                        
                        	; New block start = vvt start - size
                        	_cpyZPWord df_vvtstrt,df_tmpptrc
                        
                        	_subZPWord df_tmpptrc,df_tmpptrd
AS65 Assembler for R6502 [1.42].                                     Page  126
------------------------------ kernel\kernel.s -------------------------------

                        
                        
                        	; vvt start = new block start
                        	_cpyZPWord df_tmpptrc,df_vvtstrt
                        
                        
                        	; Do a block move of vvt, save X first
dc61 : da               	phx
dc62 : 2098db           	jsr df_var_block_move
dc65 : fa               	plx
                        	
                        	;*******************
                        	
                        	; *vnt move* vnt move size is just var name length
dc66 : 8692             	stx df_tmpptrd
dc68 : 6493             	stz df_tmpptrd+1
                        
                        	; start from current vnt start
                        	_cpyZPWord df_vntstrt,df_tmpptra
                        
                        
                        	; Length = vnt end - vnt start
                        	_cpyZPWord df_vntend,df_tmpptrb
                        
                        	_subZPWord df_tmpptrb,df_vntstrt
                        
                        
                        	; New block start = vnt start - size
                        	_cpyZPWord df_vntstrt,df_tmpptrc
                        
                        	_subZPWord df_tmpptrc,df_tmpptrd
                        
                        
                        	; vnt start = same, vvt end = same
                        	_cpyZPWord df_tmpptrc,df_vntstrt
                        
                        	_cpyZPWord df_tmpptrc,df_vvtend
                        
                        	
                        	; Do a block move of vnt
dcac : 2098db           	jsr df_var_block_move
                        
                        	; ** SOME DEBUG PRINTING
                        
                        	; Copy done increment variable count
dcaf : e672             	inc df_varcnt
dcb1 : 18               	clc
dcb2 : 60               	rts
                        	
                        	
                        ;****************************************
                        ;* Analyse variable name
                        ;* Return type in A
                        ;* X = Length including pre-fixes
                        ;* Y = Offset to next char after var name
                        ;****************************************
dcb3 :                  df_var_analyse	
dcb3 : a47d             	ldy df_linoff
                        	; check from beginning of type table
dcb5 : a200             	ldx #0
dcb7 :                  df_var_analyse_type
dcb7 : b90005           	lda df_linbuff,y
AS65 Assembler for R6502 [1.42].                                     Page  127
------------------------------ kernel\kernel.s -------------------------------

dcba : ddf6dc           	cmp df_var_type,x
dcbd : f009             	beq df_var_type_found
dcbf : e8               	inx
dcc0 : e8               	inx
dcc1 : bdf6dc           	lda df_var_type,x
dcc4 : d0f1             	bne df_var_analyse_type
                        	; No type match, or perhaps is not a variable
                        	; So not a fatal error here
dcc6 :                  df_var_analyse_err
dcc6 : 38               	sec
dcc7 : 60               	rts
dcc8 :                  df_var_type_found
                        	; save the type found
dcc8 : bdf7dc           	lda df_var_type+1,x
dccb : 858c             	sta df_tmpptra
                        	; cound the actual number of alpha nums
dccd : a2ff             	ldx #0xff
dccf :                  df_var_type_countlen
                        	; count alpha nums
dccf : c8               	iny
dcd0 : e8               	inx
dcd1 : b90005           	lda df_linbuff,y
dcd4 : 20dddd           	jsr df_tk_isalphanum
dcd7 : b0f6             	bcs df_var_type_countlen
dcd9 : e000             	cpx #0
dcdb : d002             	bne df_var_analyse_chk_ary
                        	; if zero alphanums fatal error
                        	SWBRK DFERR_SYNTAX
                        
dcdf :                  df_var_analyse_chk_ary
                        	; Check for array type
dcdf : c95b             	cmp #'['
dce1 : d00a             	bne df_var_not_arry
                        	; array and proc type not compatible
dce3 : a58c             	lda df_tmpptra
dce5 : c940             	cmp #DFVVT_PROC
dce7 : f0dd             	beq df_var_analyse_err
dce9 : 0980             	ora #DFVVT_ARRY
dceb : 858c             	sta df_tmpptra
dced :                  df_var_not_arry
                        	; Ok got everything
                        	; calculate length from y
                        	; y is next char after var name
dced : 98               	tya
dcee : 38               	sec
dcef : e57d             	sbc df_linoff			; where we started
                        	; put len in X
dcf1 : aa               	tax
                        	; put type in A
dcf2 : a58c             	lda df_tmpptra
dcf4 : 18               	clc
dcf5 : 60               	rts
dcf6 :                  df_var_type
dcf6 : 5f40             	db '_', DFVVT_PROC
dcf8 : 2501             	db '%', DFVVT_INT
dcfa : 5e02             	db '^', DFVVT_BYT
dcfc : 2404             	db '$', DFVVT_STR
                        ;	db '#', DFVVT_FLT		; Should be # but not supported
dcfe : 00               	db 0
                        
                        ;****************************************
                        ;* Find or create a variable
AS65 Assembler for R6502 [1.42].                                     Page  128
------------------------------ kernel\kernel.s -------------------------------

                        ;* If found then type needs to match mask
                        ;* Not a fatal error because could be part
                        ;* of a trial of different parsing options
                        ;****************************************
dcff :                  df_var_findcreate
                        	; save mask
dcff : 48               	pha
                        	; save mask zero state
dd00 : c900             	cmp #0
dd02 : 08               	php
dd03 : 2046db           	jsr df_var_find
dd06 : b011             	bcs df_var_findcreate_create
                        	; If found then check type with mask
                        	; save var index in X
dd08 : aa               	tax
                        	; restore mask state
dd09 : 28               	plp
                        	; don't check mask if zero
dd0a : f009             	beq df_var_findcreate_found
dd0c : 2027db           	jsr df_var_addr
                        	; restore mask
dd0f : 68               	pla
dd10 : 328c             	and (df_tmpptra)
                        	; but if mask is non zero then and must be non zero t
dd12 : f016             	beq df_var_findcreate_err
dd14 : 48               	pha
dd15 :                  df_var_findcreate_found
                        	; discard mask
dd15 : 68               	pla	
dd16 : 8a               	txa					; Put index in A
dd17 : 18               	clc
dd18 : 60               	rts
dd19 :                  df_var_findcreate_create
                        	; find type (A) and length (X)
dd19 : 20b3dc           	jsr df_var_analyse
                        	; keep A temporarily
dd1c : 858c             	sta df_tmpptra
                        	; if not a variable then return with C=1
dd1e : b008             	bcs df_var_findcreate_errp
                        	; check if mask needs to be applied
dd20 : 28               	plp
dd21 : f009             	beq df_var_analyse_okp
                        	; else pop the mask and check
dd23 : 68               	pla
dd24 : 258c             	and df_tmpptra
dd26 : d005             	bne df_var_analyse_ok
dd28 :                  df_var_findcreate_errp
dd28 : 68               	pla
dd29 : 68               	pla
dd2a :                  df_var_findcreate_err
dd2a : 38               	sec
dd2b : 60               	rts
dd2c :                  df_var_analyse_okp
dd2c : 68               	pla
dd2d :                  df_var_analyse_ok
dd2d : a58c             	lda df_tmpptra
                        	; extra space for zero terminator
dd2f : e8               	inx
                        	; save data in reverse order to when needed
dd30 : 5a               	phy
dd31 : da               	phx
dd32 : 48               	pha
AS65 Assembler for R6502 [1.42].                                     Page  129
------------------------------ kernel\kernel.s -------------------------------

                        	; insert space of X bytes
dd33 : 201fdc           	jsr df_var_insert_space
dd36 : 9005             	bcc df_var_initialise_var
                        	; error inserting space
dd38 : 68               	pla
dd39 : fa               	plx
dd3a : 7a               	ply
dd3b : 38               	sec
dd3c : 60               	rts
                        	
dd3d :                  df_var_initialise_var
                        	; vvt entry = vvt end - 8
dd3d : 38               	sec
dd3e : a570             	lda df_vvtend
dd40 : e908             	sbc #8
dd42 : 858c             	sta df_tmpptra
dd44 : a571             	lda df_vvtend+1
dd46 : e900             	sbc #0
dd48 : 858d             	sta df_tmpptra+1
                        	
dd4a : 68               	pla						; Get type back
dd4b : 928c             	sta (df_tmpptra)		; put type in vvt slot
dd4d : a900             	lda #0					; zero the rest
dd4f : a007             	ldy #7
dd51 :                  df_var_zero_vnt
dd51 : 918c             	sta (df_tmpptra),y
dd53 : 88               	dey
dd54 : d0fb             	bne df_var_zero_vnt
                        
dd56 : fa               	plx						; Get back variable name length
dd57 : 868e             	stx df_tmpptrb
                        	; vnt entry = vnt end - var name length
dd59 : 38               	sec
dd5a : a56c             	lda df_vntend
dd5c : e58e             	sbc df_tmpptrb
dd5e : 858c             	sta df_tmpptra
dd60 : a56d             	lda df_vntend+1
dd62 : e900             	sbc #0
dd64 : 858d             	sta df_tmpptra+1
                        
dd66 : ca               	dex						; Copy one less from input buff
dd67 : a47d             	ldy df_linoff			; Start at var name beginning
                        	; copy variable name to vnt slot
dd69 :                  df_var_findcreate_copy
dd69 : b90005           	lda df_linbuff,y
dd6c : 928c             	sta (df_tmpptra)
dd6e : c8               	iny
                        	_incZPWord df_tmpptra
                        
dd75 : ca               	dex
dd76 : d0f1             	bne df_var_findcreate_copy
                        	; put in zero terminator
dd78 : a900             	lda #0
dd7a : 928c             	sta (df_tmpptra)
                        
dd7c : 7a               	ply						; Get back y
                        	; move offset to reflect comsumed chars
dd7d : 847d             	sty df_linoff
                        	; index of new variable 1 less than count
dd7f : a572             	lda df_varcnt
dd81 : 3a               	dec a
                        	
AS65 Assembler for R6502 [1.42].                                     Page  130
------------------------------ kernel\kernel.s -------------------------------

dd82 : 18               	clc
dd83 : 60               	rts
                        	
                        
                        	include "dflat\tokenise.s"
                        ;*****************************************************
                        ;*
                        ;*	DOLO-1 HOMEBREW COMPUTER
                        ;*	Hardware and software design by Dolo Miah
                        ;*	Copyright 2014-18
                        ;*  Free to use for any non-commercial purpose subject
                        ;*  full credit of original my authorship please!
                        ;*
                        ;*  TOKENISE.S
                        ;*  Controlling module for tokenisation.  Basically th
                        ;*  module is given a raw input buffer, which it will 
                        ;*  attempt to tokenise fully.  Any syntax errors are
                        ;*  thrown at the first point of detection.  If all go
                        ;*  well, the parsed input will be in a tokenised buff
                        ;*  which can be executed in immediate mode or save in
                        ;*  line number order to memory.
                        ;*  dflat syntax is very simple - every statement must
                        ;*  with a keyword.  The only exception is assignment 
                        ;*  procedure invocation - but even these scenarios ar
                        ;*  tokenised so during runtime we just execute tokens
                        ;*  The raw buffer is consumed one byte at a time and 
                        ;*  tokenised buffer is written one byte at a time.  T
                        ;*  syntax means there is no need to undo reads of the
                        ;*  or tokenised buffer.  The only refinement is that 
                        ;*  allowed to peek a character in the raw buffer with
                        ;*  consuming it.
                        ;*
                        ;*****************************************************
                        
                        	; ROM code
                        	code  
                        
                        ;****************************************
                        ;* df_tk_peek_buf
                        ;* Return next char in A but no change to pointer
                        ;****************************************
dd84 :                  df_tk_peek_buf
dd84 : a47d             	ldy df_linoff
dd86 : b90005           	lda df_linbuff,y
dd89 : 60               	rts
                        
                        ;****************************************
                        ;* df_tk_get_buf
                        ;* Return next char in A and inc pointer
                        ;* Don't advance if null char found
                        ;****************************************
dd8a :                  df_tk_get_buf
dd8a : a47d             	ldy df_linoff
dd8c : b90005           	lda df_linbuff,y
dd8f : f003             	beq df_tk_get_buf_null
dd91 : c8               	iny
dd92 : 847d             	sty df_linoff
dd94 :                  df_tk_get_buf_null
dd94 : 60               	rts
                        
                        ;****************************************
                        ;* df_tk_put_tok
AS65 Assembler for R6502 [1.42].                                     Page  131
------------------------------ kernel\kernel.s -------------------------------

                        ;* Put A in token buffer and inc pointer
                        ;****************************************
dd95 :                  df_tk_put_tok
dd95 : a47e             	ldy df_tokoff
dd97 : 998005           	sta df_tokbuff,y
dd9a : c8               	iny
dd9b : 847e             	sty df_tokoff
dd9d : 60               	rts
                        	
                        ;****************************************
                        ;* df_tk_isnum
                        ;* Check char in A for number 0-9
                        ;* Return: CC = False, CS = True
                        ;****************************************
dd9e :                  df_tk_isnum
dd9e : c930             	cmp #'0'
dda0 : 9006             	bcc df_tk_isnum_false
dda2 : c93a             	cmp #'9'+1
dda4 : b002             	bcs df_tk_isnum_false
dda6 : 38               	sec
dda7 : 60               	rts
dda8 :                  df_tk_isnum_false
dda8 : 18               	clc
dda9 : 60               	rts
                        	
                        ;****************************************
                        ;* df_tk_isbin
                        ;* Check char in A for binary digit
                        ;* Return: CC = False, CS = True
                        ;****************************************
ddaa :                  df_tk_isbin
ddaa : c930             	cmp #'0'
ddac : f006             	beq df_tk_isbin_true
ddae : c931             	cmp #'1'
ddb0 : f002             	beq df_tk_isbin_true
ddb2 : 18               	clc
ddb3 : 60               	rts
ddb4 :                  df_tk_isbin_true
ddb4 : 38               	sec
ddb5 : 60               	rts
                        
                        ;****************************************
                        ;* df_tk_ishex
                        ;* Check char in A for number 0-9, A-F, a-f
                        ;* Return: CC = False, CS = True
                        ;****************************************
ddb6 :                  df_tk_ishex
ddb6 : 48               	pha
ddb7 : 209edd           	jsr df_tk_isnum
ddba : b00b             	bcs df_tk_ishex_truep
ddbc : 0920             	ora #0x20
ddbe : c961             	cmp #'a'
ddc0 : 9007             	bcc df_tk_ishex_false
ddc2 : c967             	cmp #'f'+1
ddc4 : b003             	bcs df_tk_ishex_false
ddc6 :                  df_tk_ishex_true
ddc6 : 38               	sec
ddc7 :                  df_tk_ishex_truep
ddc7 : 68               	pla
ddc8 : 60               	rts
ddc9 :                  df_tk_ishex_false
ddc9 : 18               	clc
AS65 Assembler for R6502 [1.42].                                     Page  132
------------------------------ kernel\kernel.s -------------------------------

ddca : 68               	pla
ddcb : 60               	rts
                        	
                        ;****************************************
                        ;* df_tk_isalpha
                        ;* Check next char in A alpha a-z, A-Z
                        ;* Return: CC = False, CS = True
                        ;****************************************
ddcc :                  df_tk_isalpha
ddcc : 48               	pha
ddcd : 0920             	ora #0x20					; Convert to lower case for checking
ddcf : c961             	cmp #'a'
ddd1 : 9007             	bcc df_tk_isalpha_false
ddd3 : c97b             	cmp #'z'+1
ddd5 : b003             	bcs df_tk_isalpha_false
ddd7 : 68               	pla
ddd8 : 38               	sec
ddd9 : 60               	rts
ddda :                  df_tk_isalpha_false
ddda : 68               	pla
dddb : 18               	clc
dddc : 60               	rts
                        
                        ;****************************************
                        ;* df_tk_isalphanum
                        ;* Check next char A for a-z,A-Z,0-9
                        ;* Return: CC = False, CS = True
                        ;****************************************
dddd :                  df_tk_isalphanum
dddd : 20ccdd           	jsr df_tk_isalpha
dde0 : 9001             	bcc df_tk_try_num
dde2 : 60               	rts
dde3 :                  df_tk_try_num
dde3 : 209edd           	jsr df_tk_isnum
dde6 : 60               	rts
                        	
                        ;****************************************
                        ;* df_tk_isnvar
                        ;* Check next char A for ^ or %
                        ;* Return: CC = False, CS = True
                        ;****************************************
dde7 :                  df_tk_isnvar
dde7 : c95e             	cmp #'^'
dde9 : f006             	beq df_tk_isnvar_true
ddeb : c925             	cmp #'%'
dded : f002             	beq df_tk_isnvar_true
ddef : 18               	clc
ddf0 : 60               	rts
ddf1 :                  df_tk_isnvar_true
ddf1 : 38               	sec
ddf2 : 60               	rts
                        
                        ;****************************************
                        ;* df_tk_issvar
                        ;* Check next char A for $
                        ;* Return: CC = False, CS = True
                        ;****************************************
ddf3 :                  df_tk_issvar
ddf3 : c925             	cmp #'%'
ddf5 : f002             	beq df_tk_issvar_true
ddf7 : 18               	clc
ddf8 : 60               	rts
AS65 Assembler for R6502 [1.42].                                     Page  133
------------------------------ kernel\kernel.s -------------------------------

ddf9 :                  df_tk_issvar_true
ddf9 : 38               	sec
ddfa : 60               	rts
                        
                        ;****************************************
                        ;* df_tk_isproc
                        ;* Check next char A for _
                        ;* Return: CC = False, CS = True
                        ;****************************************
ddfb :                  df_tk_isproc
ddfb : c95f             	cmp #'_'
ddfd : f002             	beq df_tk_isproc_true
ddff : 18               	clc
de00 : 60               	rts
de01 :                  df_tk_isproc_true
de01 : 38               	sec
de02 : 60               	rts
                        
                        ;****************************************
                        ;* df_tk_skip_ws
                        ;* Skip ws in linbuff
                        ;* Return: linoff updated to next non-ws, A = char
                        ;****************************************
de03 :                  df_tk_skip_ws
de03 :                  df_tk_ws_loop1
de03 : 2084dd           	jsr df_tk_peek_buf
de06 : 2013de           	jsr df_tk_isws
de09 : 9007             	bcc df_tk_ws_done
de0b : e67d             	inc df_linoff
de0d : 2095dd           	jsr df_tk_put_tok
de10 : 80f1             	bra df_tk_ws_loop1
de12 :                  df_tk_ws_done
de12 : 60               	rts
                        
                        ;****************************************
                        ;* df_tk_isws
                        ;* Check char is ws (only space is counted)
                        ;* Return: CC = False, CS = True
                        ;****************************************
de13 :                  df_tk_isws
de13 : c920             	cmp #' '
de15 : d002             	bne df_tk_isws_false
de17 : 38               	sec
de18 : 60               	rts
de19 :                  df_tk_isws_false	
de19 : 18               	clc
de1a : 60               	rts
                        
                        ;****************************************
                        ;* Find a character expected ignoring ws
                        ;* Input A = expected char
                        ;* CC = found, CS = Error
                        ;****************************************
de1b :                  df_tk_expect
de1b : 48               	pha
                        	; skip ws
de1c : 2003de           	jsr df_tk_skip_ws
                        	; peek the buffer
de1f : 68               	pla
de20 : a47d             	ldy df_linoff
de22 : d90005           	cmp df_linbuff,y
                        	; if not expected char then error
AS65 Assembler for R6502 [1.42].                                     Page  134
------------------------------ kernel\kernel.s -------------------------------

de25 : d002             	bne df_tk_expecterr
de27 : 18               	clc
de28 : 60               	rts
de29 :                  df_tk_expecterr
de29 : 38               	sec
de2a : 60               	rts
                        
                        ;****************************************
                        ;* Find a character expected ignoring ws
                        ;* Input A = expected char
                        ;* Tokenises the character as well
                        ;* CC = found, CS = Error
                        ;****************************************
de2b :                  df_tk_expect_tok
de2b : 201bde           	jsr df_tk_expect
de2e : b007             	bcs df_tk_expecttokret
de30 : 208add           	jsr df_tk_get_buf
de33 : 2095dd           	jsr df_tk_put_tok
de36 : 18               	clc
de37 :                  df_tk_expecttokret
de37 : 60               	rts
                        
                        ;****************************************
                        ;* Find a character expected ignoring ws
                        ;* Input A = expected char
                        ;* Tokenises the character as well
                        ;* FATAL IF NOT FOUND
                        ;****************************************
de38 :                  df_tk_expect_tok_err
de38 : 202bde           	jsr df_tk_expect_tok
de3b : b002             	bcs df_tk_expect_tok_fatal
de3d : 18               	clc
de3e : 60               	rts
de3f :                  df_tk_expect_tok_fatal
                        	SWBRK DFERR_SYNTAX
                        
                        
                        ;****************************************
                        ;* Tokenise a constant number
                        ;****************************************
de41 :                  df_tk_num
                        	; X,A = address, linbuff must be on page boundary
de41 : 18               	clc
de42 : a900             	lda #lo(df_linbuff)
de44 : 657d             	adc df_linoff
de46 : aa               	tax
de47 : a905             	lda #hi(df_linbuff)
de49 : 6900             	adc #0
de4b : a000             	ldy #0				; any numeric format
de4d : 20f3cd           	jsr con_n_to_a
de50 : b033             	bcs df_tk_num_err
                        	; A = format
                        	; X = how many digits processed
                        	; Jump over that many chars
de52 : a8               	tay
de53 : 18               	clc
de54 : 8a               	txa
de55 : 657d             	adc df_linoff
de57 : 857d             	sta df_linoff
                        	; Now tokenise an integer
de59 : 98               	tya
de5a : c901             	cmp #NUM_DEC
AS65 Assembler for R6502 [1.42].                                     Page  135
------------------------------ kernel\kernel.s -------------------------------

de5c : d004             	bne df_tk_num_hexbin
de5e : a909             	lda #DFTK_INTDEC	; decimal always an int
de60 : 8014             	bra df_tk_num_put
de62 :                  df_tk_num_hexbin
de62 : 18               	clc
de63 : 6904             	adc #4				; Default to BYT
de65 : c907             	cmp #NUM_BIN+4
de67 : f009             	beq df_tk_num_bin
de69 : e004             	cpx #4				; 4 chars processed = byte
de6b : f009             	beq df_tk_num_put
de6d :                  df_tk_num_makeint
de6d : 18               	clc
de6e : 6904             	adc #4				; now make INT
de70 : 8004             	bra df_tk_num_put
de72 :                  df_tk_num_bin
de72 : e00a             	cpx #0x0a			; 10 chars processed = byte
de74 : d0f7             	bne df_tk_num_makeint
de76 :                  df_tk_num_put
de76 : 2095dd           	jsr df_tk_put_tok
de79 : a546             	lda num_a
de7b : 2095dd           	jsr df_tk_put_tok
de7e : a547             	lda num_a+1
de80 : 2095dd           	jsr df_tk_put_tok
de83 : 18               	clc
de84 : 60               	rts
de85 :                  df_tk_num_err
de85 : 38               	sec
de86 : 60               	rts
                        
                        ;****************************************
                        ;* Tokenise a constant char
                        ;****************************************
de87 :                  df_tk_char
                        	; skip the first quote
de87 : 208add           	jsr df_tk_get_buf
                        	; put in the token
de8a : a900             	lda #DFTK_CHR
de8c : 2095dd           	jsr df_tk_put_tok
                        	; get the char value and save
de8f : 208add           	jsr df_tk_get_buf
de92 : 2095dd           	jsr df_tk_put_tok
                        	; always put two bytes in, even for a BYTE type
de95 : a900             	lda #0
de97 : 2095dd           	jsr df_tk_put_tok
                        	; next byte must be single quote
de9a : 208add           	jsr df_tk_get_buf
de9d : c927             	cmp #0x27
de9f : d002             	bne df_tk_char_err
dea1 : 18               	clc
dea2 : 60               	rts
dea3 :                  df_tk_char_err
dea3 : 38               	sec
dea4 : 60               	rts
                        
                        ;****************************************
                        ;* Tokenise a constant string
                        ;****************************************
dea5 :                  df_tk_str
                        	; skip the first quote
dea5 : 208add           	jsr df_tk_get_buf
                        	; put in the token
dea8 : a910             	lda #DFTK_STRLIT
AS65 Assembler for R6502 [1.42].                                     Page  136
------------------------------ kernel\kernel.s -------------------------------

deaa : 2095dd           	jsr df_tk_put_tok
dead :                  df_tk_str_ch
                        	; copy string chars in to token buffer
                        	; until another quote or end of line
dead : 208add           	jsr df_tk_get_buf
deb0 : c900             	cmp #0
deb2 : f010             	beq df_tk_str_err
deb4 : c922             	cmp #0x22
deb6 : f005             	beq df_tk_str_don
deb8 : 2095dd           	jsr df_tk_put_tok
debb : 80f0             	bra df_tk_str_ch
debd :                  df_tk_str_don
                        	; zero terminated strings
debd : a900             	lda #0
debf : 2095dd           	jsr df_tk_put_tok
dec2 : 18               	clc
dec3 : 60               	rts
dec4 :                  df_tk_str_err
                        	SWBRK DFERR_SYNTAX
                        
                        	
                        ;****************************************
                        ;* Tokenise a constant (num, string, char)
                        ;****************************************
dec6 :                  df_tk_const
dec6 : 2003de           	jsr df_tk_skip_ws
                        	; Check what constant it is
dec9 : 2084dd           	jsr df_tk_peek_buf
decc : 209edd           	jsr df_tk_isnum
decf : 9003             	bcc df_tk_const_try_str
ded1 : 4c41de           	jmp df_tk_num
ded4 :                  df_tk_const_try_str
                        	; check for double quote
ded4 : c922             	cmp #0x22
ded6 : d002             	bne df_tk_const_try_char
ded8 : 80cb             	jmp df_tk_str
deda :                  df_tk_const_try_char
                        	; check for single apostrophe
deda : c927             	cmp #0x27
dedc : d002             	bne df_tk_const_err
dede : 80a7             	jmp df_tk_char
dee0 :                  df_tk_const_err
                        	SWBRK DFERR_SYNTAX
                        
                        	
                        ;****************************************
                        ;* Tokenise a variable - A = mask
                        ;* Return : A = variable index
                        ;****************************************
dee2 :                  df_tk_var
                        	; Find or create variable, index in A
dee2 : 20ffdc           	jsr df_var_findcreate
dee5 : 9001             	bcc df_tk_var_cont
dee7 : 60               	rts
dee8 :                  df_tk_var_cont
                        	; Save variable index for later
dee8 : 48               	pha
                        	; Put VAR escape in token buffer
dee9 : a911             	lda #DFTK_VAR					
deeb : 2095dd           	jsr df_tk_put_tok
                        	; Get variable index and put in token buffer
deee : 68               	pla
AS65 Assembler for R6502 [1.42].                                     Page  137
------------------------------ kernel\kernel.s -------------------------------

deef : 48               	pha
def0 : 2095dd           	jsr df_tk_put_tok
                        	; count of any array indices
def3 :                  df_tk_var_ck
                        	; check if array procesing needed
def3 : 2084dd           	jsr df_tk_peek_buf
def6 : c95b             	cmp #'['
def8 : d009             	bne df_tk_var_noarry
                        	; get the bracket and put in token buffer
defa : 208add           	jsr df_tk_get_buf
defd : 2095dd           	jsr df_tk_put_tok
                        	; process numeric expression in bracket
df00 : 2094df           	jsr df_tk_narry
df03 :                  df_tk_var_noarry
                        	; restore var index
df03 : 68               	pla
df04 : 18               	clc
df05 : 60               	rts
                        
                        ;****************************************
                        ;* Tokenise a parameter in proc definition
                        ;* Return : A = variable index
                        ;****************************************
df06 :                  df_tk_parm
                        	; if preceeding with non-local qualifier DFTK_VARPARM
df06 : 2084dd           	jsr df_tk_peek_buf
df09 : c926             	cmp #DFTK_VARPARM
df0b : d006             	bne df_tk_parm_skip_var
                        	; get the qualifier and put in token buffer
df0d : 208add           	jsr df_tk_get_buf
df10 : 2095dd           	jsr df_tk_put_tok	
df13 :                  df_tk_parm_skip_var
                        	; don't have a certain type of var
df13 : a900             	lda #0
df15 : 80cb             	jmp df_tk_var
                        	
                        	
                        ;****************************************
                        ;* Tokenise a variable to localise
                        ;* Return : A = variable index
                        ;****************************************
df17 :                  df_tk_localvar
                        	; Find or create variable, index in A
df17 : 20ffdc           	jsr df_var_findcreate
df1a : 9001             	bcc df_tk_localvar_cont
df1c : 60               	rts
df1d :                  df_tk_localvar_cont
                        	; Save variable index for later
df1d : 48               	pha
                        	; Put VAR escape in token buffer
df1e : a911             	lda #DFTK_VAR					
df20 : 2095dd           	jsr df_tk_put_tok
                        	; Get variable index and put in token buffer
df23 : 68               	pla
df24 : 2095dd           	jsr df_tk_put_tok
df27 : 18               	clc
df28 : 60               	rts
                        
                        ;****************************************
                        ;* Tokenise call or def of proc
                        ;* Mode : A = 0 means def, else call
                        ;****************************************
AS65 Assembler for R6502 [1.42].                                     Page  138
------------------------------ kernel\kernel.s -------------------------------

df29 :                  df_tk_proc
df29 : 8596             	sta df_procmode
df2b : 2003de           	jsr df_tk_skip_ws
df2e : 20fbdd           	jsr df_tk_isproc
df31 : 905f             	bcc df_tk_proc_err
                        	; Find or create variable, index in A
df33 : a940             	lda #DFVVT_PROC
df35 : 20ffdc           	jsr df_var_findcreate
df38 : b058             	bcs df_tk_proc_err
                        	; Save variable index for later
df3a : 48               	pha
                        	; Put PROC escape in token buffer
df3b : a912             	lda #DFTK_PROC					
df3d : 2095dd           	jsr df_tk_put_tok
                        	; Get variable index and put in token buffer
df40 : 68               	pla
df41 : 48               	pha
df42 : 2095dd           	jsr df_tk_put_tok
                        
                        	; initially assume no args
df45 : 6497             	stz df_procargs
                        	
                        	; Must have an open bracket
df47 : a928             	lda #'('
df49 : 2038de           	jsr df_tk_expect_tok_err
                        	; if immediately followed by close bracket then no pa
df4c : 2084dd           	jsr df_tk_peek_buf
df4f : c929             	cmp #')'
df51 : f028             	beq df_tk_proc_noparm
                        	; else tokenise parm variables
df53 :                  df_tk_proc_parms
df53 : 2003de           	jsr df_tk_skip_ws
                        	; call appropriate routine for mode
df56 : a596             	lda df_procmode
df58 : d005             	bne df_tk_proc_call
                        	; tokenise parameter variable in def mode
df5a : 2006df           	jsr df_tk_parm
df5d : 8003             	bra df_tk_proc_skip_call
df5f :                  df_tk_proc_call
                        	; tokenise expression in call mode
df5f : 2026e0           	jsr df_tk_expression
df62 :                  df_tk_proc_skip_call
df62 : b02d             	bcs df_tk_proc_errp
                        	; increment number of args
df64 : e697             	inc df_procargs
                        	; what is next non ws char
df66 : 2003de           	jsr df_tk_skip_ws
df69 : c92c             	cmp #','
df6b : f006             	beq df_tk_proc_comma
df6d : c929             	cmp #')' 
df6f : d020             	bne df_tk_proc_errp
df71 : 8008             	bra df_tk_proc_noparm
                        	; comma found, more parms to process
df73 :                  df_tk_proc_comma
df73 : 208add           	jsr df_tk_get_buf
df76 : 2095dd           	jsr df_tk_put_tok
df79 : 80d8             	bra df_tk_proc_parms
df7b :                  df_tk_proc_noparm
                        	; consume the close bracket
df7b : 208add           	jsr df_tk_get_buf
df7e : 2095dd           	jsr df_tk_put_tok
                        	
AS65 Assembler for R6502 [1.42].                                     Page  139
------------------------------ kernel\kernel.s -------------------------------

                        	; restore var index
df81 : 68               	pla
                        	; update arg count if def mode
df82 : a696             	ldx df_procmode
df84 : d009             	bne df_tk_proc_skip_args
                        	; get address of proc
df86 : 2027db           	jsr df_var_addr
                        	; put arg count in dim2
df89 : a004             	ldy #DFVVT_DIM2
df8b : a597             	lda df_procargs
df8d : 918c             	sta (df_tmpptra),y
df8f :                  df_tk_proc_skip_args	
df8f : 18               	clc
df90 : 60               	rts
df91 :                  df_tk_proc_errp
df91 : 68               	pla
df92 :                  df_tk_proc_err
                        	SWBRK DFERR_SYNTAX
                        
                        
                        ;****************************************
                        ;* Parse array index
                        ;****************************************
df94 :                  df_tk_narry
                        	; if array open bracket encountered
                        	; then tokenise a numeric expression
df94 : 2026e0           	jsr df_tk_expression
                        	; If a comma is next, then another expression
df97 : a92c             	lda #','
df99 : 202bde           	jsr df_tk_expect_tok
df9c : b003             	bcs df_tk_narry_end
                        	; copy the comman in to buffer
df9e : 2026e0           	jsr df_tk_expression
dfa1 :                  df_tk_narry_end
                        	; after the second dimension, must be close sq brak
dfa1 : a95d             	lda #']'
dfa3 : 2038de           	jsr df_tk_expect_tok_err
dfa6 : 60               	rts
                        
                        ;****************************************
                        ;* Parse bracket
                        ;****************************************
dfa7 :                  df_tk_nbrkt
                        	; if  open bracket encountered
                        	; then tokenise a numeric expression
dfa7 : 2026e0           	jsr df_tk_expression
                        	; skip any ws, copying in to tokbuff
dfaa : 38               	sec
dfab : 2003de           	jsr df_tk_skip_ws
                        	; get char, which must be ')'
dfae : 208add           	jsr df_tk_get_buf
dfb1 : c929             	cmp #')'
dfb3 : d005             	bne df_tk_nbrkt_err
dfb5 : 2095dd           	jsr df_tk_put_tok
dfb8 : 18               	clc
dfb9 : 60               	rts
dfba :                  df_tk_nbrkt_err
                        	SWBRK DFERR_SYNTAX
                        
                        	
                        ;****************************************
                        ;* Parse call to numeric proc
AS65 Assembler for R6502 [1.42].                                     Page  140
------------------------------ kernel\kernel.s -------------------------------

                        ;****************************************
dfbc :                  df_tk_nterm_proc
                        	; call mode
dfbc : a901             	lda #1
dfbe : 2029df           	jsr df_tk_proc
dfc1 : 60               	rts
                        
                        ;****************************************
                        ;* Parse numeric term
                        ;****************************************
dfc2 :                  df_tk_nterm
                        	; skip any ws first, copying in to tokbuff
dfc2 : 2003de           	jsr df_tk_skip_ws
dfc5 : 2084dd           	jsr df_tk_peek_buf
dfc8 : c900             	cmp #0
dfca : d002             	bne df_tk_nterm_cont
dfcc : 38               	sec
dfcd : 60               	rts
dfce :                  df_tk_nterm_cont
                        	; if open bracket then process it
dfce : c928             	cmp #'('
dfd0 : d00a             	bne df_tk_nterm_tryfn
                        	; get the bracket and put in token buffer
dfd2 : 208add           	jsr df_tk_get_buf
dfd5 : 2095dd           	jsr df_tk_put_tok
                        	; go process the open bracket
dfd8 : 20a7df           	jsr df_tk_nbrkt
dfdb : 60               	rts
dfdc :                  df_tk_nterm_tryfn
dfdc : 48               	pha
                        	; try decoding a built-in function
dfdd : a902             	lda #DFTK_FN
dfdf : 20fce0           	jsr df_tk_matchtok
dfe2 : b00c             	bcs df_tk_nterm_try_proc
                        	; pull old A in to Y but don't use
dfe4 : 7a               	ply
                        	; put the token with MSB set
dfe5 : 0980             	ora #0x80
dfe7 : 2095dd           	jsr df_tk_put_tok
dfea : 20d7e0           	jsr df_tk_exec_parser 
dfed : b01b             	bcs df_tk_nterm_err
dfef : 60               	rts
dff0 :                  df_tk_nterm_try_proc
dff0 : 68               	pla
                        	; if it's not a func then try proc
dff1 : 20fbdd           	jsr df_tk_isproc
dff4 : 9006             	bcc df_tk_nterm_try_var
dff6 : 20bcdf           	jsr df_tk_nterm_proc
dff9 : b00f             	bcs df_tk_nterm_err
dffb : 60               	rts
dffc :                  df_tk_nterm_try_var
                        	; Non-zero mask means var must be this type
dffc : a900             	lda #0
dffe : 20e2de           	jsr df_tk_var
e001 : b001             	bcs df_tk_nterm_try_const
e003 : 60               	rts
e004 :                  df_tk_nterm_try_const
                        	; Try decoding a constant
e004 : 20c6de           	jsr df_tk_const
e007 : b001             	bcs df_tk_nterm_err
e009 : 60               	rts
e00a :                  df_tk_nterm_err
AS65 Assembler for R6502 [1.42].                                     Page  141
------------------------------ kernel\kernel.s -------------------------------

                        	SWBRK DFERR_SYNTAX
                        
                        
                        ;****************************************
                        ;* Parse numeric operator
                        ;****************************************
e00c :                  df_tk_nop
e00c : 2003de           	jsr df_tk_skip_ws
e00f : 2084dd           	jsr df_tk_peek_buf
e012 : c900             	cmp #0
e014 : f00e             	beq df_tk_nop_false
                        	; must be an operator token for numeric
e016 : a90c             	lda #DFTK_OP | DFTK_STROP
e018 : 20fce0           	jsr df_tk_matchtok
e01b : b007             	bcs df_tk_nop_false
                        	; got a token
e01d : 0980             	ora #DFTK_TOKEN
e01f : 2095dd           	jsr df_tk_put_tok
e022 : 18               	clc
e023 : 60               	rts
e024 :                  df_tk_nop_false
e024 : 38               	sec
e025 : 60               	rts
                        
                        ;****************************************
                        ;* Parse numeric expression
                        ;****************************************
e026 :                  df_tk_expression
                        	; Tokenise a numeric term
e026 : 20c2df           	jsr df_tk_nterm
                        	; Try and tokenise a numeric operator
e029 : 200ce0           	jsr df_tk_nop
                        	; If an operator was tokenised
                        	; then loop back for another term
e02c : 90f8             	bcc df_tk_expression
                        	; If no operator was found then
                        	; expression is done
e02e : 18               	clc
e02f : 60               	rts
                        
                        ;****************************************
                        ;* Check end of statement
                        ;****************************************
e030 :                  df_tk_isEOS
e030 : 2003de           	jsr df_tk_skip_ws
e033 : 2084dd           	jsr df_tk_peek_buf
e036 : c93a             	cmp #':'
e038 : f002             	beq df_tk_eos
e03a : 18               	clc
e03b : 60               	rts
e03c :                  df_tk_eos
                        	; eat the separator
e03c : 208add           	jsr df_tk_get_buf
                        	; put in to token buffer
e03f : 2095dd           	jsr df_tk_put_tok
                        	; this is the position of the next statement
e042 : a57e             	lda df_tokoff
                        	; put it in the last statement offset slot
e044 : a480             	ldy df_tokstidx
e046 : 998005           	sta df_tokbuff,y
e049 : 38               	sec
e04a : 60               	rts
AS65 Assembler for R6502 [1.42].                                     Page  142
------------------------------ kernel\kernel.s -------------------------------

                        	
                        	
                        ;****************************************
                        ;* Parse user defined proc
                        ;****************************************
e04b :                  df_tk_parse_user_proc
                        	; put proc token in as a call
e04b : a981             	lda #0x81
e04d : 2095dd           	jsr df_tk_put_tok
e050 : a901             	lda #1
e052 : 2029df           	jsr df_tk_proc
e055 : 60               	rts
                        
                        
                        ;****************************************
                        ;* Parse a command
                        ;* Do not fatal error if this fails
                        ;****************************************
e056 :                  df_tk_parse_command
                        	; only looking for keywords
e056 : a901             	lda #DFTK_KW
e058 : 20fce0           	jsr df_tk_matchtok
e05b : b010             	bcs df_tk_parse_command_err
                        	; if match then store token in the line buffer
                        	; Set MSB
e05d : 0980             	ora #0x80
e05f : 2095dd           	jsr df_tk_put_tok
                        	; call the parser to do tokenise based on the stateme
e062 : a584             	lda df_symoff
e064 : 20d7e0           	jsr df_tk_exec_parser
e067 : b004             	bcs df_tk_parse_command_err
                        	; [1] ignore white space but keep it
e069 : 2003de           	jsr df_tk_skip_ws
                        	; No error in parsing this command
e06c : 18               	clc
e06d :                  df_tk_parse_command_err
e06d : 60               	rts
                        
                        ;****************************************
                        ;* lexer
                        ;****************************************
e06e :                  df_lexer_line
                        	; start at the beginning of the line buffer
e06e : 647d             	stz df_linoff
                        	; start at the beginning of the tokenised buffer
e070 : 647e             	stz df_tokoff
                        	; set current line to the token buffer
e072 : a980             	lda #lo(df_tokbuff)
e074 : 8587             	sta df_currlin
e076 : a905             	lda #hi(df_tokbuff)
e078 : 8588             	sta df_currlin+1
                        	; Set the line length to 0
e07a : a900             	lda #0
e07c : 2095dd           	jsr df_tk_put_tok
                        	
                        	; any leading white space, ignore and discard
e07f : 2003de           	jsr df_tk_skip_ws
                        
                        	; if peek next character is a number then assume line
                        	; else assume a statement
e082 : 209edd           	jsr df_tk_isnum
e085 : 9005             	bcc df_lexer_skip_lnum
AS65 Assembler for R6502 [1.42].                                     Page  143
------------------------------ kernel\kernel.s -------------------------------

                        	; if line number then capture the line number and adv
e087 : 20dce0           	jsr df_tk_linenum
e08a : 8008             	bra df_tk_body
e08c :                  df_lexer_skip_lnum
                        	; if no line number then zero out the line number in 
                        	; line zero will indicate an immediate mode command
e08c : a900             	lda #0
e08e : 2095dd           	jsr df_tk_put_tok				; Line num low byte
e091 : 2095dd           	jsr df_tk_put_tok				; Line num high byte
e094 :                  df_tk_body
                        	; Offset for next statement
e094 : a57e             	lda df_tokoff
e096 : 8580             	sta df_tokstidx
e098 : a900             	lda #0
e09a : 2095dd           	jsr df_tk_put_tok				; Offset to next statement
                        	; [1] capture white space from line buffer in to toke
e09d : 2003de           	jsr df_tk_skip_ws
                        	; If next non ws is zero then this is an empty line
                        	; so return with length zero but line number filled i
                        	; token buffer
e0a0 : c900             	cmp #0
e0a2 : f02f             	beq df_tk_line_empty
                        	; if next char is _ then parse a user defined proc ca
e0a4 : 20fbdd           	jsr df_tk_isproc
e0a7 : 9005             	bcc df_tk_try_command
e0a9 : 204be0           	jsr df_tk_parse_user_proc
e0ac : 800e             	bra df_tk_done
e0ae :                  df_tk_try_command
                        	; try  a keyword
e0ae : 2056e0           	jsr df_tk_parse_command
e0b1 : b002             	bcs	df_tk_try_assign
e0b3 : 8007             	bra df_tk_done
e0b5 :                  df_tk_try_assign
                        	; nothing but to try an assignment operation
e0b5 : 20dae3           	jsr df_tk_assign
e0b8 : b01b             	bcs	df_tk_parseerror
e0ba : 8000             	bra df_tk_done
e0bc :                  df_tk_done
                        	; put statement index stuff here in case of multi-sta
                        	; check for : and if present tokenise plus update las
                        	; then go back to try and process another statement
e0bc : 2030e0           	jsr df_tk_isEOS
e0bf : b0d3             	bcs df_tk_body
                        	; if not at end of line, then must be error
e0c1 : 2084dd           	jsr df_tk_peek_buf
e0c4 : c900             	cmp #0
e0c6 : d00d             	bne df_tk_parseerror
                        	; Get line length length
e0c8 : a47e             	ldy df_tokoff
                        	; ensure there is always a zero after the last tokeni
e0ca : a900             	lda #0
e0cc : 998005           	sta df_tokbuff,y
                        	; save the line length
e0cf : 98               	tya
e0d0 : 8d8005           	sta df_tokbuff
e0d3 :                  df_tk_line_empty
e0d3 : 18               	clc
e0d4 : 60               	rts
e0d5 :                  df_tk_parseerror
                        	SWBRK DFERR_SYNTAX
                        
                        
AS65 Assembler for R6502 [1.42].                                     Page  144
------------------------------ kernel\kernel.s -------------------------------

                        ;****************************************
                        ;* df_tk_parsestatement
                        ;* Execute parse routine for this statement
                        ;* Input: df_tokoff is the token found
                        ;* Return: CC = Parsed ok, CS = Error
                        ;****************************************
e0d7 :                  df_tk_exec_parser
e0d7 : 0a               	asl a
e0d8 : aa               	tax
e0d9 : 7cb4e2           	jmp (df_tk_tokenjmp,x)
                        	
                        
                        ;****************************************
                        ;* df_tk_linenum
                        ;* Tokenise line number
                        ;****************************************
e0dc :                  df_tk_linenum
                        	; Convert line number to 16 bit number
                        	; Save the line number
                        	; Increment the buffer pointer
e0dc : 18               	clc
e0dd : a900             	lda #lo(df_linbuff)
e0df : 657d             	adc df_linoff
e0e1 : aa               	tax
e0e2 : a905             	lda #hi(df_linbuff)
e0e4 : 6900             	adc #0
e0e6 : a001             	ldy #1			; Decimal format only
e0e8 : 20f3cd           	jsr con_n_to_a
e0eb : 18               	clc
e0ec : 8a               	txa
e0ed : 657d             	adc df_linoff
e0ef : 857d             	sta df_linoff
                        	; Now save line number
e0f1 : a546             	lda num_a
e0f3 : 2095dd           	jsr df_tk_put_tok
e0f6 : a547             	lda num_a+1
e0f8 : 2095dd           	jsr df_tk_put_tok
e0fb : 60               	rts
                        
                        ;****************************************
                        ;* df_tk_matchtok
                        ;* Try and find a token match against the table df_tok
                        ;* Input:
                        ;*			Current df_linbuff and df_linoff
                        ;* Return: 	CC = No Error, CS = Error
                        ;*			df_linoff points to next char if CC else unchange
                        ;****************************************
e0fc :                  df_tk_matchtok
                        	; save the mask to check types against
e0fc : 48               	pha
                        	; Start at token symbols beginning
e0fd : a950             	lda #lo(df_tokensyms)
e0ff : 8582             	sta df_symtab
e101 : a9e1             	lda #hi(df_tokensyms)
e103 : 8583             	sta df_symtab+1
e105 : 6484             	stz df_symoff
e107 :                  df_tk_checknexttok
                        	; check this token type first
e107 : 68               	pla
e108 : 48               	pha
e109 : a684             	ldx df_symoff
e10b : 3d66e3           	and df_tk_tokentype,x
AS65 Assembler for R6502 [1.42].                                     Page  145
------------------------------ kernel\kernel.s -------------------------------

e10e : f019             	beq df_tk_symnomatch
                        	; From the line buffer current pointer
                        	; Check for a token match
e110 : a47d             	ldy df_linoff
e112 :                  df_tk_checktokch
                        	; Get symtable char
                        	; and mask off MSB
e112 : b282             	lda (df_symtab)
                        	; Save the value and mask off MSB
e114 : 48               	pha
e115 : 297f             	and #0x7f
                        	; Compare with current line buffer char
e117 : d90005           	cmp df_linbuff,y
                        	; If chars not match then this symbol fails
e11a : d00c             	bne df_tk_symnomatchp
                        	; If match and symbol has MSB then
                        	; all of the symbol matched
e11c : 68               	pla 
e11d : 3029             	bmi df_tk_symfound
                        	; else more chars to match
                        	; so increment line buffer pointers
                        	_incZPWord df_symtab
                        
e125 : c8               	iny
e126 : 80ea             	bra df_tk_checktokch
e128 :                  df_tk_symnomatchp
e128 : 68               	pla
e129 :                  df_tk_symnomatch
                        	; Increment symbol counter to next symbol
e129 : e684             	inc df_symoff
e12b :                  df_tk_symnextentry
e12b : b282             	lda (df_symtab)
                        	; End of symbol is MSB
e12d : 3008             	bmi  df_tk_foundsymend
                        	_incZPWord df_symtab
                        
e135 : 80f4             	bra df_tk_symnextentry
e137 :                  df_tk_foundsymend
                        	; Increment char to point to new symbol
                        	; for matching with line buffer
                        	_incZPWord df_symtab
                        
                        	; If next char is not zero then
                        	; try and match with line buffer
e13d : b282             	lda (df_symtab)
e13f : d0c6             	bne df_tk_checknexttok
                        	; else symbol table exhausted
                        	; so no match found
                        	; Zero symbol counter
e141 : 6484             	stz df_symoff
                        	; forget about mask
e143 : 68               	pla	
e144 : a900             	lda #0
                        	; Set C to indicate error (no match)
e146 : 38               	sec
e147 : 60               	rts
e148 :                  df_tk_symfound
                        	; forget about mask
e148 : 68               	pla
                        	; Save line buffer pointer (points to next char)
                        	; Clear C to indicate success (match)
e149 : c8               	iny
AS65 Assembler for R6502 [1.42].                                     Page  146
------------------------------ kernel\kernel.s -------------------------------

e14a : 847d             	sty df_linoff
e14c : a584             	lda df_symoff
e14e : 18               	clc
e14f : 60               	rts
                        
                        	include "dflat\tksymtab.s"
                        ;*****************************************************
                        ;*
                        ;*	DOLO-1 HOMEBREW COMPUTER
                        ;*	Hardware and software design by Dolo Miah
                        ;*	Copyright 2014-18
                        ;*  Free to use for any non-commercial purpose subject
                        ;*  full credit of original my authorship please!
                        ;*
                        ;*  TKSYMTAB.S
                        ;*  Runtime token jump table.
                        ;*  dflat uses four key tables to tokenise and run pro
                        ;*  - df_tokensyms    - table of token symbols
                        ;*  - df_tk_tokentype - table of token types
                        ;*  - df_tk_tokenjmp  - table of tokenising routines
                        ;*  - df_rt_tokenjmp  - table of runtime routines
                        ;*  The key is the token symbols.  When a line is ente
                        ;*  in to the raw (untokenised) buffer, df_tokensyms i
                        ;*  used to identify tokens.  The position of the foun
                        ;*  token is used to then look up type and jump vector
                        ;*  in the other tables.
                        ;*
                        ;*****************************************************
                        
                        	; ROM code
                        	code  
                        
                        ; Statement Token table
                        ; keywords
e150 :                  df_tokensyms
e150 : 80               	db	0x80						; Implicit numeric assign
e151 : 80               	db	0x80						; Implicit call procedure
e152 : bb               	db	";"+0x80					; Comment
e153 : 7072696e746cee   	db	"printl",'n'+0x80			; println <exprlist>
e15a : 7072696ef4       	db	"prin",'t'+0x80				; print <exprlist>
e15f : 6465e6           	db	"de",'f'+0x80				; def
e162 : 656e646465e6     	db	"endde",'f'+0x80			; enddef
e168 : 7265747572ee     	db	"retur",'n'+0x80			; return
e16e : 6c6f6361ec       	db	"loca",'l'+0x80				; local <varlist>
e173 : 6469ed           	db	"di",'m'+0x80				; dim <varlist>
e176 : 7265706561f4     	db	"repea",'t'+0x80			; repeat
e17c : 756e7469ec       	db	"unti", 'l'+0x80			; until <condition>
e181 : 666ff2           	db	"fo",'r'+0x80				; for %a=<start>,<end>,<increment
e184 : 6e6578f4         	db	"nex",'t'+0x80				; next
e188 : 7768696ce5       	db	"whil",'e'+0x80				; while <condition>
e18d : 77656ee4         	db	"wen",'d'+0x80				; wend
e191 : 69e6             	db	"i",'f'+0x80				; if <condition>
e193 : 656c73e5         	db	"els",'e'+0x80				; else
e197 : 656e6469e6       	db	"endi",'f'+0x80				; endif
e19c : 656c69e6         	db	"eli",'f'+0x80				; elif <condition>
e1a0 : 646174e1         	db	"dat",'a'+0x80				; data
e1a4 : 7275ee           	db	"ru",'n'+0x80				; run
e1a7 : 6c6973f4         	db	"lis",'t'+0x80				; list [start][,end]
e1ab : 696e7075f4       	db	"inpu",'t'+0x80				; input <var>
e1b0 : 6d6f64e5         	db	"mod",'e'+0x80				; mode <n>
e1b4 : 706c6ff4         	db	"plo",'t'+0x80				; plot <x>,<y>,<char|string>
e1b8 : 637572736ff2     	db	"curso",'r'+0x80			; cursor <n>
AS65 Assembler for R6502 [1.42].                                     Page  147
------------------------------ kernel\kernel.s -------------------------------

e1be : 636cf3           	db	"cl",'s'+0x80				; cls
e1c1 : 76706f6be5       	db	"vpok",'e'+0x80				; vpoke <addr>,<val>
e1c6 : 7365747664f0     	db	"setvd",'p'+0x80			; setvdp <reg>,<val>
e1cc : 636f6c6f75f2     	db	"colou",'r'+0x80			; colour <reg>,<val>
e1d2 : 73707269746570.. 	db	"spritepa",'t'+0x80			; spritepat <patnum>,<array>
e1db : 73707269746570.. 	db	"spritepo",'s'+0x80			; spritepos <sprnum>,<x>,<y>
e1e4 : 73707269746563.. 	db	"spriteco",'l'+0x80			; spritecol <sprnum>,<col>
e1ed : 7370726974656e.. 	db	"spritenm",'e'+0x80			; spritenme <sprnum>,<patnum
e1f6 : 7370726974e5     	db	"sprit",'e'+0x80			; sprite n,x,y,p,c
e1fc : 706f6be5         	db	"pok",'e'+0x80				; poke a,v
e200 : 646f6be5         	db	"dok",'e'+0x80				; doke a,v
e204 : 736f756ee4       	db	"soun",'d'+0x80				; sound
e209 : 6d757369e3       	db	"musi",'c'+0x80				; music
e20e : 706c61f9         	db	"pla",'y'+0x80				; play
e212 : 736176e5         	db	"sav",'e'+0x80				; save
e216 : 6c6f61e4         	db	"loa",'d'+0x80				; load
e21a : 6469f2           	db	"di",'r'+0x80				; dir
e21d : 6465ec           	db 	"de",'l'+0x80				; del
e220 : 726561e4         	db	"rea",'d'+0x80				; read
e224 : 6e65f7           	db	"ne",'w'+0x80				; new
e227 : 72656e75ed       	db	"renu",'m'+0x80				; renum <start>,<offset>,<incre
e22c : 776169f4         	db	"wai",'t'+0x80				; wait <delay>
e230 : 72657365f4       	db	"rese",'t'+0x80				; reset <var>
e235 : 68697265f3       	db	"hire",'s'+0x80				; hires <col>
e23a : 706f696ef4       	db	"poin",'t'+0x80				; point x,y,mode
e23f : 6c696ee5         	db	"lin",'e'+0x80				; line x0,x1,y0,y1,mode
                        ; Functions
e243 : 767065656ba8     	db	"vpeek",'('+0x80			; vpeek(x)
e249 : 7065656ba8       	db	"peek",'('+0x80				; peek(x)
e24e : 6465656ba8       	db	"deek",'('+0x80				; peek(x)
e253 : 737469636ba8     	db	"stick",'('+0x80			; stick(x)
e259 : 6b6579a8         	db	"key",'('+0x80				; key(x)
e25d : 636872a8         	db	"chr",'('+0x80				; chr(x)
e261 : 6c656674a8       	db	"left",'('+0x80				; left(x$,y)
e266 : 7269676874a8     	db	"right",'('+0x80			; right(x$,y)
e26c : 6d6964a8         	db	"mid",'('+0x80				; mid(x$,y)
e270 : 6c656ea8         	db	"len",'('+0x80				; len(x$)
e274 : 6d656da8         	db	"mem",'('+0x80				; mem(x)
e278 : 7363726ea8       	db	"scrn",'('+0x80				; scrn(x,y)
e27d : 726e64a8         	db	"rnd",'('+0x80				; rnd(x)
e281 : 656c6170736564a8 	db	"elapsed",'('+0x80			; elapsed(<var>)
                        ; Numeric operators, in priority
e289 : aa               	db	'*'+0x80					; Multiply
e28a : af               	db 	'/'+0x80					; Divide
e28b : dc               	db 	'\\'+0x80					; Modulus
e28c : 3cbc             	db	'<','<'+0x80				; Shift left
e28e : 3ebe             	db	'>','>'+0x80				; Shift right
e290 : ab               	db 	'+'+0x80					; Add
e291 : ad               	db	'-'+0x80					; Subtract
                        ; Conditional operators, in priority
e292 : 616ee4           	db "an",'d'+0x80				; AND
e295 : 6ff2             	db "o",'r'+0x80					; OR
e297 : 3cbd             	db "<",'='+0x80					; Less than or equal
e299 : 3ebd             	db ">",'='+0x80					; Greater than or equal
e29b : 3cbe             	db "<",'>'+0x80					; Not equal
e29d : bc               	db '<'+0x80						; Less than
e29e : be               	db '>'+0x80						; Greater than
e29f : 3dbd             	db "=",'='+0x80					; Equality (always last)
                        ; String conditional operators, in priority
e2a1 : 24ab             	db "$",'+'+0x80					; String cat
e2a3 : 243cbd           	db "$<",'='+0x80				; Less than or equal
e2a6 : 243ebd           	db "$>",'='+0x80				; Greater than or equal
AS65 Assembler for R6502 [1.42].                                     Page  148
------------------------------ kernel\kernel.s -------------------------------

e2a9 : 243cbe           	db "$<",'>'+0x80				; Not equal
e2ac : 24bc             	db "$",'<'+0x80					; Less than
e2ae : 24be             	db "$",'>'+0x80					; Greater than
e2b0 : 243dbd           	db "$=",'='+0x80				; Equality (always last)
                        
e2b3 : 00               	db  0
                        
                        
                        	
                        	
                        	include "dflat\tkjmptab.s"
                        ;*****************************************************
                        ;*
                        ;*	DOLO-1 HOMEBREW COMPUTER
                        ;*	Hardware and software design by Dolo Miah
                        ;*	Copyright 2014-18
                        ;*  Free to use for any non-commercial purpose subject
                        ;*  full credit of original my authorship please!
                        ;*
                        ;*  TKJUMPTAB.S
                        ;*  Runtime token jump table.
                        ;*  dflat uses four key tables to tokenise and run pro
                        ;*  - df_tokensyms    - table of token symbols
                        ;*  - df_tk_tokentype - table of token types
                        ;*  - df_tk_tokenjmp  - table of tokenising routines
                        ;*  - df_rt_tokenjmp  - table of runtime routines
                        ;*  The key is the token symbols.  When a line is ente
                        ;*  in to the raw (untokenised) buffer, df_tokensyms i
                        ;*  used to identify tokens.  The position of the foun
                        ;*  token is used to then look up type and jump vector
                        ;*  in the other tables.
                        ;*
                        ;*****************************************************
                        
                        	; ROM code
                        	code  
                        
                        ; Tokeniser jump table
                        ; In token order of df_tokensyms
e2b4 :                  df_tk_tokenjmp
e2b4 : dae3             	dw	df_tk_assign
e2b6 : 6fe4             	dw	df_tk_callproc
e2b8 : e2e3             	dw	df_tk_comment
e2ba : 08e4             	dw	df_tk_println
e2bc : 08e4             	dw	df_tk_print
e2be : 47e4             	dw	df_tk_def
e2c0 : 97e4             	dw	df_tk_enddef
e2c2 : 99e4             	dw	df_tk_return
e2c4 : 36e4             	dw	df_tk_local
e2c6 : 25e4             	dw	df_tk_dim
e2c8 : 97e4             	dw	df_tk_repeat
e2ca : 99e4             	dw	df_tk_until
e2cc : 4de4             	dw	df_tk_for
e2ce : 97e4             	dw	df_tk_next
e2d0 : 99e4             	dw	df_tk_while
e2d2 : 97e4             	dw	df_tk_wend
e2d4 : 99e4             	dw	df_tk_if
e2d6 : 97e4             	dw	df_tk_else
e2d8 : 97e4             	dw	df_tk_endif
e2da : 99e4             	dw	df_tk_elseif
e2dc : 08e4             	dw	df_tk_data
e2de : 97e4             	dw	df_tk_run
AS65 Assembler for R6502 [1.42].                                     Page  149
------------------------------ kernel\kernel.s -------------------------------

e2e0 : f3e3             	dw	df_tk_list
e2e2 : 1ce4             	dw	df_tk_input
e2e4 : 99e4             	dw	df_tk_mode
e2e6 : a9e4             	dw	df_tk_plot
e2e8 : 99e4             	dw	df_tk_cursor
e2ea : 97e4             	dw	df_tk_cls
e2ec : 9de4             	dw	df_tk_vpoke
e2ee : 9de4             	dw	df_tk_setvdp
e2f0 : a9e4             	dw	df_tk_colour
e2f2 : 9de4             	dw	df_tk_spritepat
e2f4 : a9e4             	dw	df_tk_spritepos
e2f6 : 9de4             	dw	df_tk_spritecol
e2f8 : 9de4             	dw	df_tk_spritenme
e2fa : c1e4             	dw	df_tk_sprite
e2fc : 9de4             	dw	df_tk_poke
e2fe : 9de4             	dw	df_tk_doke
e300 : a9e4             	dw	df_tk_sound
e302 : b5e4             	dw	df_tk_music
e304 : b5e4             	dw	df_tk_play
e306 : 9de4             	dw	df_tk_save
e308 : 9de4             	dw	df_tk_load
e30a : 97e4             	dw	df_tk_dir
e30c : 99e4             	dw	df_tk_del
e30e : 25e4             	dw	df_tk_read
e310 : 97e4             	dw	df_tk_new
e312 : a9e4             	dw	df_tk_renum
e314 : 99e4             	dw	df_tk_wait
e316 : 71e4             	dw	df_tk_reset
e318 : 99e4             	dw	df_tk_hires
e31a : a9e4             	dw	df_tk_point
e31c : c1e4             	dw	df_tk_line
                        
e31e : 7ae4             	dw	df_tk_vpeek
e320 : 7ae4             	dw	df_tk_peek
e322 : 7ae4             	dw	df_tk_deek
e324 : 7ae4             	dw	df_tk_stick
e326 : 7ae4             	dw	df_tk_key
e328 : 7ae4             	dw	df_tk_chr
e32a : 8de4             	dw	df_tk_left
e32c : 8de4             	dw	df_tk_right
e32e : 92e4             	dw	df_tk_mid
e330 : 7ae4             	dw	df_tk_len
e332 : 7ae4             	dw	df_tk_mem
e334 : 8de4             	dw	df_tk_scrn
e336 : 7ae4             	dw	df_tk_rnd
e338 : 83e4             	dw	df_tk_elapsed
                        	
e33a : 97e4             	dw	df_tk_mult
e33c : 97e4             	dw	df_tk_div
e33e : 97e4             	dw	df_tk_mod
e340 : 97e4             	dw	df_tk_asl
e342 : 97e4             	dw	df_tk_lsr
e344 : 97e4             	dw	df_tk_add
e346 : 97e4             	dw	df_tk_sub
                        	
e348 : 97e4             	dw	df_tk_and
e34a : 97e4             	dw	df_tk_or
e34c : 97e4             	dw	df_tk_lte
e34e : 97e4             	dw	df_tk_gte
e350 : 97e4             	dw	df_tk_ne
e352 : 97e4             	dw	df_tk_lt
e354 : 97e4             	dw	df_tk_gt
AS65 Assembler for R6502 [1.42].                                     Page  150
------------------------------ kernel\kernel.s -------------------------------

e356 : 97e4             	dw	df_tk_eq
                        
e358 : 97e4             	dw	df_tk_sadd
e35a : 97e4             	dw	df_tk_slte
e35c : 97e4             	dw	df_tk_sgte
e35e : 97e4             	dw	df_tk_sne
e360 : 97e4             	dw	df_tk_slt
e362 : 97e4             	dw	df_tk_sgt
e364 : 97e4             	dw	df_tk_seq
                        
                        	
                        	
                        	
                        	
                        	
                        	include "dflat\tktyptab.s"
                        ;*****************************************************
                        ;*
                        ;*	DOLO-1 HOMEBREW COMPUTER
                        ;*	Hardware and software design by Dolo Miah
                        ;*	Copyright 2014-18
                        ;*  Free to use for any non-commercial purpose subject
                        ;*  full credit of original my authorship please!
                        ;*
                        ;*  RTJUMPTAB.S
                        ;*  Runtime token jump table.
                        ;*  dflat uses four key tables to tokenise and run pro
                        ;*  - df_tokensyms    - table of token symbols
                        ;*  - df_tk_tokentype - table of token types
                        ;*  - df_tk_tokenjmp  - table of tokenising routines
                        ;*  - df_rt_tokenjmp  - table of runtime routines
                        ;*  The key is the token symbols.  When a line is ente
                        ;*  in to the raw (untokenised) buffer, df_tokensyms i
                        ;*  used to identify tokens.  The position of the foun
                        ;*  token is used to then look up type and jump vector
                        ;*  in the other tables.
                        ;*
                        ;*****************************************************
                        
                        	; ROM code
                        	code  
                        
                        ; Tokeniser type table (is it a keyword, function, ope
                        ; In token order of df_tokensyms
e366 :                  df_tk_tokentype
e366 : 01               	db	DFTK_KW
e367 : 01               	db	DFTK_KW
e368 : 01               	db	DFTK_KW
e369 : 01               	db	DFTK_KW
e36a : 01               	db	DFTK_KW
e36b : 01               	db	DFTK_KW
e36c : 01               	db	DFTK_KW
e36d : 01               	db	DFTK_KW
e36e : 01               	db	DFTK_KW
e36f : 01               	db	DFTK_KW
e370 : 01               	db	DFTK_KW
e371 : 01               	db	DFTK_KW
e372 : 01               	db	DFTK_KW
e373 : 01               	db	DFTK_KW
e374 : 01               	db	DFTK_KW
e375 : 01               	db	DFTK_KW
e376 : 01               	db	DFTK_KW
AS65 Assembler for R6502 [1.42].                                     Page  151
------------------------------ kernel\kernel.s -------------------------------

e377 : 01               	db	DFTK_KW
e378 : 01               	db	DFTK_KW
e379 : 01               	db	DFTK_KW
e37a : 01               	db	DFTK_KW
e37b : 01               	db	DFTK_KW
e37c : 01               	db	DFTK_KW
e37d : 01               	db	DFTK_KW
e37e : 01               	db	DFTK_KW
e37f : 01               	db	DFTK_KW
e380 : 01               	db	DFTK_KW
e381 : 01               	db	DFTK_KW
e382 : 01               	db	DFTK_KW
e383 : 01               	db	DFTK_KW
e384 : 01               	db	DFTK_KW
e385 : 01               	db	DFTK_KW
e386 : 01               	db	DFTK_KW
e387 : 01               	db	DFTK_KW
e388 : 01               	db	DFTK_KW
e389 : 01               	db	DFTK_KW
e38a : 01               	db	DFTK_KW
e38b : 01               	db	DFTK_KW
e38c : 01               	db	DFTK_KW
e38d : 01               	db	DFTK_KW
e38e : 01               	db	DFTK_KW
e38f : 01               	db	DFTK_KW
e390 : 01               	db	DFTK_KW
e391 : 01               	db	DFTK_KW
e392 : 01               	db	DFTK_KW
e393 : 01               	db	DFTK_KW
e394 : 01               	db	DFTK_KW
e395 : 01               	db	DFTK_KW
e396 : 01               	db	DFTK_KW
e397 : 01               	db	DFTK_KW
e398 : 01               	db	DFTK_KW
e399 : 01               	db	DFTK_KW
e39a : 01               	db	DFTK_KW
                        
e39b : 32               	db 	DFTK_FN | DFTK_INT | DFTK_BYT
e39c : 32               	db 	DFTK_FN | DFTK_INT | DFTK_BYT
e39d : 32               	db 	DFTK_FN | DFTK_INT | DFTK_BYT
e39e : 32               	db 	DFTK_FN | DFTK_INT | DFTK_BYT
e39f : 32               	db 	DFTK_FN | DFTK_INT | DFTK_BYT
e3a0 : 42               	db 	DFTK_FN | DFTK_STR
e3a1 : 42               	db 	DFTK_FN | DFTK_STR
e3a2 : 42               	db 	DFTK_FN | DFTK_STR
e3a3 : 42               	db 	DFTK_FN | DFTK_STR
e3a4 : 32               	db 	DFTK_FN | DFTK_INT | DFTK_BYT
e3a5 : 32               	db 	DFTK_FN | DFTK_INT | DFTK_BYT
e3a6 : 32               	db 	DFTK_FN | DFTK_INT | DFTK_BYT
e3a7 : 32               	db 	DFTK_FN | DFTK_INT | DFTK_BYT
e3a8 : 32               	db 	DFTK_FN | DFTK_INT | DFTK_BYT
                        	;* Operators add the order of precedence (0=high, 7=l
e3a9 : 38               	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 0
e3aa : 38               	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 0
e3ab : 38               	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 0
e3ac : 39               	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 1
e3ad : 39               	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 1
e3ae : 3a               	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 2
e3af : 3a               	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 2
                        
e3b0 : 3d               	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 5
e3b1 : 3e               	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 6
AS65 Assembler for R6502 [1.42].                                     Page  152
------------------------------ kernel\kernel.s -------------------------------

e3b2 : 3b               	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 3
e3b3 : 3b               	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 3
e3b4 : 3b               	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 3
e3b5 : 3b               	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 3
e3b6 : 3b               	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 3
e3b7 : 3f               	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 7
                        
e3b8 : 44               	db 	DFTK_STROP | DFTK_STR
e3b9 : 4b               	db 	DFTK_OP | DFTK_STR + 3
e3ba : 4b               	db 	DFTK_OP | DFTK_STR + 3
e3bb : 4b               	db 	DFTK_OP | DFTK_STR + 3
e3bc : 4b               	db 	DFTK_OP | DFTK_STR + 3
e3bd : 4b               	db 	DFTK_OP | DFTK_STR + 3
e3be : 4f               	db 	DFTK_OP | DFTK_STR + 7
                        
                        	
                        	
                        	
                        	
                        
                        	include "dflat\toksubs.s"
                        ;*****************************************************
                        ;*
                        ;*	DOLO-1 HOMEBREW COMPUTER
                        ;*	Hardware and software design by Dolo Miah
                        ;*	Copyright 2014-18
                        ;*  Free to use for any non-commercial purpose subject
                        ;*  full credit of original my authorship please!
                        ;*
                        ;*  TOKSUBS.S
                        ;*  Module that implements the tokenisation of keyword
                        ;*  When a line is being parsed, the index of the keyw
                        ;*  found in the symbol table is used to call a routin
                        ;*  here.  The job of a routine here is then to furthe
                        ;*  parse the raw input e.g. a command that takes two 
                        ;*  parameters, need to do what it needs to identify t
                        ;*  Despite the number of keywords in dflat, this isn'
                        ;*  anywhere near the size of rtsubs.s (the runtime
                        ;*  equivalent of this) because there is so much in co
                        ;*  synactically.
                        ;*  The tokenised output is put in to its own buffer a
                        ;*  if the whole input was tokenised successfully then
                        ;*  dflat will either try and execute (if in immediate
                        ;*  mode), or save it to program memory in line number
                        ;*  order.
                        ;*
                        ;*****************************************************
                        
                        	; ROM code
                        	code  
                        
                        ;****************************************
                        ;* Parse assignment preamble
                        ;****************************************
e3bf :                  df_tk_preassign
                        	; Put assignment token
                        	; assume its a numeric int for now
e3bf : a980             	lda #0x80
e3c1 : 2095dd           	jsr df_tk_put_tok
                        	
                        	; first find or create a variable
e3c4 : a900             	lda #0	
AS65 Assembler for R6502 [1.42].                                     Page  153
------------------------------ kernel\kernel.s -------------------------------

e3c6 : 20e2de           	jsr df_tk_var
                        	; next char sound be =
e3c9 : a93d             	lda #'='
e3cb : 2038de           	jsr df_tk_expect_tok_err
                        	; skip more ws
e3ce : 2003de           	jsr df_tk_skip_ws
                        	; should not be at end of line
e3d1 : 2084dd           	jsr df_tk_peek_buf
e3d4 : f002             	beq df_tk_parse_ass_err
e3d6 : 18               	clc
e3d7 : 60               	rts
e3d8 :                  df_tk_parse_ass_err
                        	SWBRK DFERR_SYNTAX
                        
                        
                        ;****************************************
                        ;* Parse numeric assignment
                        ;****************************************
e3da :                  df_tk_assign
e3da : 20bfe3           	jsr df_tk_preassign
                        	; tokenise an expression (int or byte)
e3dd : 2026e0           	jsr df_tk_expression
e3e0 : 18               	clc
e3e1 : 60               	rts
                        
                        
e3e2 :                  df_tk_comment
                        	; copy all subsequent chars to token
e3e2 : 2084dd           	jsr df_tk_peek_buf
e3e5 : c900             	cmp #0
e3e7 : f008             	beq df_tk_comment_done
e3e9 : 208add           	jsr df_tk_get_buf
e3ec : 2095dd           	jsr df_tk_put_tok
e3ef : 80f1             	bra df_tk_comment
e3f1 :                  df_tk_comment_done
e3f1 : 18               	clc
e3f2 : 60               	rts
                        
e3f3 :                  df_tk_list
                        	; tokenise an expression
e3f3 : 2026e0           	jsr df_tk_expression
e3f6 : 2084dd           	jsr df_tk_peek_buf
                        	; if not at the end then keep going
e3f9 : c92c             	cmp #','
e3fb : d009             	bne df_tk_list_done
e3fd : 208add           	jsr df_tk_get_buf
e400 : 2095dd           	jsr df_tk_put_tok
e403 : 2026e0           	jsr df_tk_expression	
e406 :                  df_tk_list_done
e406 : 18               	clc
e407 : 60               	rts
                        	
e408 :                  df_tk_data
e408 :                  df_tk_println
e408 :                  df_tk_print
                        	; tokenise an expression
e408 : 2026e0           	jsr df_tk_expression
e40b : 2084dd           	jsr df_tk_peek_buf
                        	; if not at the end then keep going
e40e : c92c             	cmp #','
e410 : d008             	bne df_tk_print_done
e412 : 208add           	jsr df_tk_get_buf
AS65 Assembler for R6502 [1.42].                                     Page  154
------------------------------ kernel\kernel.s -------------------------------

e415 : 2095dd           	jsr df_tk_put_tok
e418 : 80ee             	bra df_tk_print
e41a :                  df_tk_print_done
e41a : 18               	clc
e41b : 60               	rts
                        
e41c :                  df_tk_input
e41c : 2003de           	jsr df_tk_skip_ws
                        	; tokenise a variable
e41f : a900             	lda #0
e421 : 20e2de           	jsr df_tk_var
                        	; either cc or cs depending on error condition
e424 : 60               	rts
                        	
e425 :                  df_tk_read
e425 :                  df_tk_dim
e425 : 2003de           	jsr df_tk_skip_ws
                        	; tokenise a variable
e428 : a900             	lda #0
e42a : 20e2de           	jsr df_tk_var
                        	; if not at the end then keep going
e42d : a92c             	lda #','
e42f : 202bde           	jsr df_tk_expect_tok
e432 : 90f1             	bcc df_tk_dim
e434 : 18               	clc
e435 : 60               	rts
                        
e436 :                  df_tk_local
e436 : 2003de           	jsr df_tk_skip_ws
                        	; tokenise a variable
e439 : a900             	lda #0
e43b : 2017df           	jsr df_tk_localvar
                        	; if not at the end then keep going
e43e : a92c             	lda #','
e440 : 202bde           	jsr df_tk_expect_tok
e443 : 90f1             	bcc df_tk_local
e445 : 18               	clc
e446 : 60               	rts
                        
                        ; A = 0 : Def
                        ; A = 1 : Call
e447 :                  df_tk_def
e447 : a900             	lda #0
e449 : 2029df           	jsr df_tk_proc
e44c : 60               	rts
                        
                        
                        ; syntax : for %a=1,10,1
e44d :                  df_tk_for
e44d : 2003de           	jsr df_tk_skip_ws
                        
                        	; tokenise the for variable
e450 : a901             	lda #DFVVT_INT
e452 : 20e2de           	jsr df_tk_var
                        
                        	; always expect '='
e455 : a93d             	lda #'='
e457 : 2038de           	jsr df_tk_expect_tok_err
                        
                        	; starting value
e45a : 2026e0           	jsr df_tk_expression
                        	
AS65 Assembler for R6502 [1.42].                                     Page  155
------------------------------ kernel\kernel.s -------------------------------

                        	; always expect ',' separator
e45d : a92c             	lda #','
e45f : 2038de           	jsr df_tk_expect_tok_err
                        
                        	; ending value
e462 : 2026e0           	jsr df_tk_expression
                        	
                        	; always expect ',' separator
e465 : a92c             	lda #','
e467 : 2038de           	jsr df_tk_expect_tok_err
                        	
                        	; step value
e46a : 2026e0           	jsr df_tk_expression
e46d :                  df_tk_for_done
e46d : 18               	clc
e46e : 60               	rts
                        	
                        ; call to proc should not occur by itself
e46f :                  df_tk_callproc
e46f : 38               	sec
e470 : 60               	rts
                        
                        ; timer reset expects an int variable only
e471 :                  df_tk_reset
e471 : 2003de           	jsr df_tk_skip_ws
                        
                        	; tokenise a variable
e474 : a901             	lda #DFVVT_INT
e476 : 20e2de           	jsr df_tk_var
e479 : 60               	rts
                        
                        ; These functions expect 1 numeric parmeter
e47a :                  df_tk_len
e47a :                  df_tk_chr
e47a :                  df_tk_key
e47a :                  df_tk_stick
e47a :                  df_tk_deek
e47a :                  df_tk_vpeek
e47a :                  df_tk_peek
e47a :                  df_tk_mem
e47a :                  df_tk_rnd
e47a : 2026e0           	jsr df_tk_expression
e47d :                  df_tk_closebrkt
e47d : a929             	lda #')'
e47f : 2038de           	jsr df_tk_expect_tok_err
e482 : 60               	rts
                        
                        ; This function expects a variable only
e483 :                  df_tk_elapsed
e483 : 2003de           	jsr df_tk_skip_ws
                        
                        	; tokenise a variable
e486 : a901             	lda #DFVVT_INT
e488 : 20e2de           	jsr df_tk_var
                        	; must have close braket
e48b : 80f0             	jmp df_tk_closebrkt
                        
                        ; These functions expect 2 parameters
e48d :                  df_tk_left
e48d :                  df_tk_right
e48d :                  df_tk_scrn
e48d : 209de4           	jsr df_tk_2parms
AS65 Assembler for R6502 [1.42].                                     Page  156
------------------------------ kernel\kernel.s -------------------------------

e490 : 80eb             	jmp df_tk_closebrkt
                        
                        ; These functions expect 3 parameters
e492 :                  df_tk_mid
e492 : 20a9e4           	jsr df_tk_3parms
e495 : 80e6             	jmp df_tk_closebrkt
                        
                        ;all these commands require no parameters
e497 :                  df_tk_else
e497 :                  df_tk_endif
e497 :                  df_tk_enddef
e497 :                  df_tk_repeat
e497 :                  df_tk_next
e497 :                  df_tk_wend
e497 :                  df_tk_run
e497 :                  df_tk_add
e497 :                  df_tk_sadd
e497 :                  df_tk_dir
e497 :                  df_tk_cls
e497 :                  df_tk_new
e497 :                  df_tk_mult
e497 :                  df_tk_div
e497 :                  df_tk_mod
e497 :                  df_tk_asl
e497 :                  df_tk_lsr
e497 :                  df_tk_sub
e497 :                  df_tk_and
e497 :                  df_tk_or
e497 :                  df_tk_lte
e497 :                  df_tk_lt
e497 :                  df_tk_gte
e497 :                  df_tk_gt
e497 :                  df_tk_ne
e497 :                  df_tk_eq
e497 :                  df_tk_slte
e497 :                  df_tk_sgte
e497 :                  df_tk_sne
e497 :                  df_tk_slt
e497 :                  df_tk_sgt
e497 :                  df_tk_seq
e497 : 18               	clc
e498 : 60               	rts
                        
                        ; These commands expect 1 parameter	
e499 :                  df_tk_while
e499 :                  df_tk_until
e499 :                  df_tk_if
e499 :                  df_tk_elseif
e499 :                  df_tk_wait
e499 :                  df_tk_cursor
e499 :                  df_tk_mode
e499 :                  df_tk_del
e499 :                  df_tk_hires
e499 :                  df_tk_return
                        	; first parm
e499 : 2026e0           	jsr df_tk_expression
e49c : 60               	rts
                        
                        ; These commands expect 2 numeric parameters
e49d :                  df_tk_setvdp
e49d :                  df_tk_spritepat
e49d :                  df_tk_spritecol
AS65 Assembler for R6502 [1.42].                                     Page  157
------------------------------ kernel\kernel.s -------------------------------

e49d :                  df_tk_spritenme
e49d :                  df_tk_vpoke
e49d :                  df_tk_poke
e49d :                  df_tk_doke
e49d :                  df_tk_save
e49d :                  df_tk_load
e49d :                  df_tk_2parms
                        	; first parm
e49d : 2026e0           	jsr df_tk_expression
e4a0 : a92c             	lda #','
e4a2 : 2038de           	jsr df_tk_expect_tok_err
                        	; tokenise second parm
e4a5 : 2026e0           	jsr df_tk_expression
e4a8 : 60               	rts
                        
                        ; these commands expect 3 numeric parameters
e4a9 :                  df_tk_plot
e4a9 :                  df_tk_sound
e4a9 :                  df_tk_colour
e4a9 :                  df_tk_spritepos
e4a9 :                  df_tk_renum
e4a9 :                  df_tk_point
e4a9 :                  df_tk_3parms
e4a9 : 209de4           	jsr df_tk_2parms
e4ac : a92c             	lda #','
e4ae : 2038de           	jsr df_tk_expect_tok_err
                        	; tokenise third parm
e4b1 : 2026e0           	jsr df_tk_expression
e4b4 : 60               	rts
                        
                        ; these commands expect 4 numeric parameters
e4b5 :                  df_tk_play
e4b5 :                  df_tk_music
e4b5 :                  df_tk_4parms
e4b5 : 209de4           	jsr df_tk_2parms
e4b8 : a92c             	lda #','
e4ba : 2038de           	jsr df_tk_expect_tok_err
e4bd : 209de4           	jsr df_tk_2parms
e4c0 : 60               	rts
                        
                        ; these commands expect 5 numeric parameters
e4c1 :                  df_tk_sprite
e4c1 :                  df_tk_line
e4c1 :                  df_tk_5parms
e4c1 : 20b5e4           	jsr df_tk_4parms
e4c4 : a92c             	lda #','
e4c6 : 2038de           	jsr df_tk_expect_tok_err
e4c9 : 2026e0           	jsr df_tk_expression
e4cc : 60               	rts
                        
                        
                        
                        	include "dflat\progedit.s"
                        ;*****************************************************
                        ;*
                        ;*	DOLO-1 HOMEBREW COMPUTER
                        ;*	Hardware and software design by Dolo Miah
                        ;*	Copyright 2014-18
                        ;*  Free to use for any non-commercial purpose subject
                        ;*  full credit of original my authorship please!
                        ;*
                        ;*  PROGEDIT.S
AS65 Assembler for R6502 [1.42].                                     Page  158
------------------------------ kernel\kernel.s -------------------------------

                        ;*  dflat module to enable editing of a dflat program.
                        ;*  dflat bascially starts here - waiting for user inp
                        ;*  when a line is entered, if it is not preceeded by 
                        ;*  line number it is tokenised and attempted to be ru
                        ;*  immediatly.  If it is preceeded by a line number, 
                        ;*  number is used to save the tokenised line in the r
                        ;*  position in memory.
                        ;*  So this is just like a good old editing session us
                        ;*  nearly any common flavour of 80s basic. However df
                        ;*  tokenises everything except whitespace and string
                        ;*  constants - even when saving.  Unlike my trust Ori
                        ;*  where I could type in any garbage and it would be
                        ;*  saved with the line number, dflat needs to be able
                        ;*  tokenise the line.  So it's actually a bit more li
                        ;*  Atari 8 bit BASIC.
                        ;*
                        ;*****************************************************
                        
                        
                        ;****************************************
                        ;* df_pg_find_line
                        ;* Find a line number in X(L), A(H)
                        ;* Return X(L), A(H) of line, Y = Length
                        ;* C=1 Exact match not found, C=0 Exact Found
                        ;* If not exact match then next highest line address
                        ;* Will be in X and A
                        ;****************************************
e4cd :                  df_pg_find_line
e4cd : 8646             	stx num_a
e4cf : 8547             	sta num_a+1
e4d1 : a566             	lda df_prgstrt
e4d3 : 8552             	sta num_tmp
e4d5 : a567             	lda df_prgstrt+1
e4d7 : 8553             	sta num_tmp+1
e4d9 :                  df_pg_check_next_line
e4d9 : a552             	lda num_tmp
e4db : c568             	cmp df_prgend
e4dd : d00f             	bne df_pg_check_line
e4df : a553             	lda num_tmp+1
e4e1 : c569             	cmp df_prgend+1
e4e3 : d009             	bne df_pg_check_line
e4e5 :                  df_pr_line_gt_target	
                        	; End of program or line > target
                        	; Load Y with the length
e4e5 : b252             	lda (num_tmp)
e4e7 : a8               	tay
e4e8 : a652             	ldx num_tmp
e4ea : a553             	lda num_tmp+1
e4ec : 38               	sec
e4ed : 60               	rts
e4ee :                  df_pg_check_line
e4ee : a001             	ldy #DFTK_LINNUM
e4f0 : a546             	lda num_a
e4f2 : d152             	cmp (num_tmp),y
e4f4 : d010             	bne df_pr_line_nomatch
e4f6 : c8               	iny
e4f7 : a547             	lda num_a+1
e4f9 : d152             	cmp (num_tmp),y
e4fb : d009             	bne df_pr_line_nomatch
                        	; Got an exact match
e4fd : b252             	lda (num_tmp)
e4ff : a8               	tay
AS65 Assembler for R6502 [1.42].                                     Page  159
------------------------------ kernel\kernel.s -------------------------------

e500 : a652             	ldx num_tmp
e502 : a553             	lda num_tmp+1
e504 : 18               	clc
e505 : 60               	rts
e506 :                  df_pr_line_nomatch
                        	; Check if this line > target
e506 : 38               	sec
e507 : a001             	ldy #DFTK_LINNUM
e509 : a546             	lda num_a
e50b : f152             	sbc (num_tmp),y
e50d : c8               	iny
e50e : a547             	lda num_a+1
e510 : f152             	sbc (num_tmp),y
e512 : 90d1             	bcc df_pr_line_gt_target
e514 :                  df_pr_line_next
                        	; Else we go to next line
e514 : 18               	clc
e515 : a552             	lda num_tmp
e517 : 7252             	adc (num_tmp)
e519 : 8552             	sta num_tmp
e51b : a553             	lda num_tmp+1
e51d : 6900             	adc #0
e51f : 8553             	sta num_tmp+1
e521 : 80b6             	bra df_pg_check_next_line
                        	
                        ;****************************************
                        ;* df_pg_insert_block
                        ;* Insert a block at adr (X, A) of size Y
                        ;* df_prgend updated
                        ;* C=1 Error, C=0 Ok
                        ;****************************************
e523 :                  df_pg_insert_block
                        	; Inserting requires a block copy from
                        	; end of program space to the insert address
                        	
                        	; Save address as this is the lowest address
e523 : 8646             	stx num_a
e525 : 8547             	sta num_a+1
                        	; End of program space is the first byte to move
e527 : a568             	lda df_prgend
e529 : 854e             	sta num_x
e52b : a569             	lda df_prgend+1
e52d : 854f             	sta num_x+1	
e52f :                  df_pg_insert_byte
                        	; Move a byte from the current top
e52f : b24e             	lda (num_x)
                        	; To the new top (+Y)
e531 : 914e             	sta (num_x),y
                        	; Compare current address with lowest
e533 : a54e             	lda num_x
e535 : c546             	cmp num_a
e537 : d014             	bne df_pg_insert_next_byte
e539 : a54f             	lda num_x+1
e53b : c547             	cmp num_a+1
e53d : d00e             	bne df_pg_insert_next_byte
                        	; Finished, update program end pointer
e53f : 18               	clc
e540 : 98               	tya
e541 : 6568             	adc df_prgend
e543 : 8568             	sta df_prgend
e545 : a569             	lda df_prgend+1
e547 : 6900             	adc #0
AS65 Assembler for R6502 [1.42].                                     Page  160
------------------------------ kernel\kernel.s -------------------------------

e549 : 8569             	sta df_prgend+1
e54b : 18               	clc
e54c : 60               	rts
e54d :                  df_pg_insert_next_byte
                        	; Decrement current address
e54d : 38               	sec
e54e : a54e             	lda num_x
e550 : e901             	sbc #1
e552 : 854e             	sta num_x
e554 : a54f             	lda num_x+1
e556 : e900             	sbc #0
e558 : 854f             	sta num_x+1
e55a : 80d3             	bra df_pg_insert_byte
                        
                        ;****************************************
                        ;* df_pg_delete_block
                        ;* Delete a block at adr (X, A) of size Y
                        ;* df_prgend updated
                        ;* C=1 Error, C=0 Ok
                        ;****************************************
e55c :                  df_pg_delete_block
                        	; Deleting requires a block copy from
                        	; deletion address to end of program
                        	
                        	; Save address as this is the start address
e55c : 8646             	stx num_a
e55e : 8547             	sta num_a+1
e560 :                  df_pg_delete_byte
                        	; Move a byte from current+Y
e560 : b146             	lda (num_a),y
                        	; Down to current
e562 : 9246             	sta (num_a)
                        	; Compare current address with lowest
e564 : a546             	lda num_a
e566 : c568             	cmp df_prgend
e568 : d017             	bne df_pg_delete_next_byte
e56a : a547             	lda num_a+1
e56c : c569             	cmp df_prgend+1
e56e : d011             	bne df_pg_delete_next_byte
                        	; Finished, update program end pointer
e570 : 8446             	sty num_a
e572 : 38               	sec
e573 : a568             	lda df_prgend
e575 : e546             	sbc num_a
e577 : 8568             	sta df_prgend
e579 : a569             	lda df_prgend+1
e57b : e900             	sbc #0
e57d : 8569             	sta df_prgend+1
e57f : 18               	clc
e580 : 60               	rts
e581 :                  df_pg_delete_next_byte
                        	; Decrement current address
e581 : 18               	clc
e582 : a546             	lda num_a
e584 : 6901             	adc #1
e586 : 8546             	sta num_a
e588 : a547             	lda num_a+1
e58a : 6900             	adc #0
e58c : 8547             	sta num_a+1
e58e : 80d0             	bra df_pg_delete_byte
                        
                        
AS65 Assembler for R6502 [1.42].                                     Page  161
------------------------------ kernel\kernel.s -------------------------------

                        ;****************************************
                        ;* Get a line of input
                        ;* Input: C=1 for echo, 0 for no echo
                        ;* Output: C=0 means linbuff is valid
                        ;****************************************
e590 :                  df_pg_inputline
                        	; C is set on input for echo or not
                        	; Read a line of input
e590 : 2038d9           	jsr io_read_line
                        	; If nothing entered then sec
e593 : c000             	cpy #0
e595 : d002             	bne df_pg_inputline_ok
e597 : 38               	sec
e598 : 60               	rts
e599 :                  df_pg_inputline_ok
                        	; Copy input bytes to line buffer
                        	; for lexical analysis
e599 :                  df_pg_copyinputtolinbuff
e599 : b11b             	lda (buf_lo),y
e59b : 990005           	sta df_linbuff,y
e59e : 88               	dey
e59f : 10f8             	bpl df_pg_copyinputtolinbuff
e5a1 : 18               	clc
e5a2 : 60               	rts
                        
                        ;****************************************
                        ;* Tokenise line buffer
                        ;* Set line to 0x0000 if immediate line
                        ;****************************************
e5a3 :                  df_pg_tokeniseline
e5a3 : 206ee0           	jsr df_lexer_line
e5a6 : 9001             	bcc df_pg_tokeniseline_ok
e5a8 : 60               	rts
e5a9 :                  df_pg_tokeniseline_ok
e5a9 : 18               	clc
e5aa : 60               	rts
                        
                        ;****************************************
                        ;* df_pg_dflat
                        ;* Start a dflat editing session
                        ;****************************************
e5ab :                  df_pg_dflat
                        	; stack pointer
e5ab : ba               	tsx
e5ac : 8660             	stx df_sp
                        	; error handler address
e5ae : a9ad             	lda #lo(df_trap_error)
e5b0 : 8561             	sta df_pc
e5b2 : a9da             	lda #hi(df_trap_error)
e5b4 : 8562             	sta df_pc+1
                        	
                        	; make sure normal I/O is resumed
e5b6 : 20fad8           	jsr io_init_default
e5b9 :                  df_pg_prompt
e5b9 : a23f             	ldx #lo(df_pg_prompt_msg)
e5bb : a9e6             	lda #hi(df_pg_prompt_msg)
e5bd : 2082d9           	jsr io_print_line
e5c0 : 645f             	stz df_immed
e5c2 :                  df_pg_getcommand
                        	; current line is the token buffer when editing
e5c2 : a980             	lda #lo(df_tokbuff)
e5c4 : 8587             	sta df_currlin
AS65 Assembler for R6502 [1.42].                                     Page  162
------------------------------ kernel\kernel.s -------------------------------

e5c6 : a905             	lda #hi(df_tokbuff)
e5c8 : 8588             	sta df_currlin+1
e5ca : 38               	sec
e5cb : 2090e5           	jsr df_pg_inputline
e5ce : b017             	bcs df_pg_done
e5d0 : 20e9e5           	jsr df_pg_tokenise
e5d3 : a55f             	lda df_immed
e5d5 : f0eb             	beq df_pg_getcommand
                        	; run from tokbuff
e5d7 : a280             	ldx #lo(df_tokbuff)
e5d9 : a905             	lda #hi(df_tokbuff)
                        	; always skip length and line number
e5db : a003             	ldy #3
e5dd : 8489             	sty df_exeoff
                        	; init currlin
e5df : 20ebe9           	jsr df_rt_init_stat_ptr
                        	; start execution
e5e2 : 20fce9           	jsr df_rt_exec_stat
                        	; Go and get another line of input
e5e5 : 80d2             	bra df_pg_prompt
                        	; if blank line then return to cmd
e5e7 :                  df_pg_done
e5e7 : 18               	clc
e5e8 : 60               	rts
                        
                        	; tokenise the line
e5e9 :                  df_pg_tokenise
e5e9 : 645e             	stz errno
e5eb : 20a3e5           	jsr df_pg_tokeniseline
e5ee : 2046e6           	jsr df_initrun
                        	; check if line number == 0
e5f1 : a001             	ldy #DFTK_LINNUM
e5f3 : b98005           	lda df_tokbuff,y
e5f6 : d00c             	bne df_pg_line_number
e5f8 : a002             	ldy #DFTK_LINNUM+1
e5fa : b98005           	lda df_tokbuff,y
e5fd : d005             	bne df_pg_line_number
                        	
                        	; line number == 0 so in immediate mode from tokbuff
                        	; don't zero out the line length as some routines use
                        	; run the line in immediate mode
e5ff : a901             	lda #1
e601 : 855f             	sta df_immed
e603 : 60               	rts
                        
                        	; put the numbered line in to the right bit of memory
e604 :                  df_pg_line_number
                        	; Check if this line exists
e604 : a001             	ldy #DFTK_LINNUM
e606 : b98005           	lda df_tokbuff,y
e609 : aa               	tax
e60a : c8               	iny
e60b : b98005           	lda df_tokbuff,y
e60e : 20cde4           	jsr df_pg_find_line
                        	; Save line address for later
e611 : da               	phx
e612 : 48               	pha
                        	; If line exists then it needs deleting
e613 : b003             	bcs df_pg_skip_del_line
                        
                        	; delete line from program
e615 : 205ce5           	jsr df_pg_delete_block
AS65 Assembler for R6502 [1.42].                                     Page  163
------------------------------ kernel\kernel.s -------------------------------

e618 :                  df_pg_skip_del_line
                        	; If line length is zero
                        	; then nothing else to do (i.e. line was deleted)
e618 : a000             	ldy #DFTK_LINLEN
e61a : b98005           	lda df_tokbuff,y
e61d : a8               	tay
                        	; save the tokenised line length
e61e : 5a               	phy
e61f : d004             	bne df_pg_insertline
                        	; Length was zero, so get temp stuff off stack
e621 : 7a               	ply
e622 : 68               	pla
e623 : fa               	plx
e624 : 60               	rts
                        
                        	; insert a program line unless it is immediate
e625 :                  df_pg_insertline
                        	; Restore previously saved length
e625 : 7a               	ply
                        	; Restore previously saved address to reinsert to
e626 : 68               	pla
e627 : fa               	plx
                        	; And save it all back to stack again
e628 : da               	phx
e629 : 48               	pha
e62a : 5a               	phy
                        	; We now have insert address and length
e62b : 2023e5           	jsr df_pg_insert_block
                        	; Restore length and sub 1 to get index in to this li
e62e : 7a               	ply
e62f : 88               	dey
                        	; Restore address to a pointer
e630 : 68               	pla
e631 : 8547             	sta num_a+1
e633 : fa               	plx
e634 : 8646             	stx num_a
                        	; num_a is destination, tokbuff is source, Y is size-
e636 :                  df_pg_insertlinbyte
e636 : b98005           	lda df_tokbuff,y
e639 : 9146             	sta (num_a),y
e63b : 88               	dey
e63c : 10f8             	bpl df_pg_insertlinbyte
e63e : 60               	rts
                        	
e63f :                  df_pg_prompt_msg
e63f : 52656164790d00   	db "Ready",UTF_CR,0
                        
                        	include "dflat\runtime.s"
                        ;*****************************************************
                        ;*
                        ;*	DOLO-1 HOMEBREW COMPUTER
                        ;*	Hardware and software design by Dolo Miah
                        ;*	Copyright 2014-18
                        ;*  Free to use for any non-commercial purpose subject
                        ;*  full credit of original my authorship please!
                        ;*
                        ;*  RUNTIME.S
                        ;*  This module is the runtime coordinator.  When the 
                        ;*  wants to run a program, execution of statements fr
                        ;*  required procedure starts and proceeds from there
                        ;*  according to normal program flow.
                        ;*  This module also contains critical routines for th
AS65 Assembler for R6502 [1.42].                                     Page  164
------------------------------ kernel\kernel.s -------------------------------

                        ;*  evaluation of expressions (numeric and string).
                        ;*  Whilst the code to implement a specific command is
                        ;*  rtsubs.s, this is the key module that controls eve
                        ;*
                        ;*****************************************************
                        
                        	; ROM code
                        	code  
                        
                        ;****************************************
                        ;* df_initrun
                        ;* Initialise program space for runtime
                        ;****************************************
e646 :                  df_initrun
                        	; String and array heap initialisation
                        	; Grows up from end of prog space PLUS 1
                        	; Initially empty (dim will allocate)
e646 : a568             	lda df_prgend
e648 : 8573             	sta df_starstrt
e64a : a569             	lda df_prgend+1
e64c : 8574             	sta df_starstrt+1
                        	_incZPWord df_starstrt
                        
                        	_cpyZPWord df_starstrt,df_starend
                        
                        	
                        	; Reset runtime stack (grows up)
e65c : 6477             	stz df_rtstop
                        
                        	; Reset parameter stack (grows up)
e65e : 6478             	stz df_parmtop
                        	
                        	; Reset data pointer high byte
e660 : 64a0             	stz df_currdat+1
                        	
                        	; clear proc addresses
e662 : 2068e6           	jsr df_rt_init_vvt
                        
                        	; if nest counter zeroed
e665 : 649e             	stz df_ifnest
                        
                        ;	clc
e667 : 60               	rts
                        
                        ;****************************************
                        ;* Initialise vvt
                        ;****************************************
e668 :                  df_rt_init_vvt
                        	; starting at beginning of vvt
                        	_cpyZPWord df_vvtstrt,df_tmpptra
                        
e670 : a672             	ldx df_varcnt
e672 : f027             	beq df_rt_init_done
e674 :                  df_rt_init_vvt_slot
                        	; zero out first 3 bytes
e674 : a900             	lda #0
e676 : a001             	ldy #1
e678 : 918c             	sta (df_tmpptra),y
e67a : c8               	iny
e67b : 918c             	sta (df_tmpptra),y
e67d : c8               	iny
e67e : 918c             	sta (df_tmpptra),y
AS65 Assembler for R6502 [1.42].                                     Page  165
------------------------------ kernel\kernel.s -------------------------------

e680 : c8               	iny
                        	; before doing dim2 check if proc
                        	; as we don't want to erase the parm count
e681 : b28c             	lda (df_tmpptra)
e683 : 2940             	and #DFVVT_PROC
e685 : d004             	bne df_rt_init_vvt_skip
                        	; if not proc then zero dim2
e687 : a900             	lda #0
e689 : 918c             	sta (df_tmpptra),y	
e68b :                  df_rt_init_vvt_skip
                        	; increment pointer to next slot
                        	_adcZPWord df_tmpptra,8
                        
e698 : ca               	dex
e699 : d0d9             	bne df_rt_init_vvt_slot
e69b :                  df_rt_init_done
                        ;	clc
e69b : 60               	rts
                        
                        ;****************************************
                        ;* Evaluate a numeric expression
                        ;****************************************
e69c :                  df_rt_neval
                        	; push terminator on cpu stack
                        	; so we know where we are
e69c : a900             	lda #0
e69e : 48               	pha
                        
                        	; find escape token or keyword token
                        	; if escape token push on to operand stack
                        	; if keyword token push on to operator stack
e69f :                  df_rt_neval_optk
e69f : a589             	lda df_exeoff
                        	; check end of line
e6a1 : c57f             	cmp df_eolidx
e6a3 : f06d             	beq df_rt_neval_process
e6a5 : c580             	cmp df_tokstidx
e6a7 : f069             	beq df_rt_neval_process
e6a9 : a8               	tay
e6aa : b187             	lda (df_currlin),y
e6ac : 3020             	bmi df_rt_neval_tk
e6ae : c920             	cmp #DFTK_ESCVAL
e6b0 : 9017             	bcc df_rt_neval_esc
                        	; check for evaluation terminators
                        	; specifically ',' and ']'
e6b2 : c92c             	cmp #','
e6b4 : f05c             	beq df_rt_neval_process
e6b6 : c95d             	cmp #']'
e6b8 : f058             	beq df_rt_neval_process
                        	; check for brackets
                        	; if close bracket then process
e6ba : c929             	cmp #')'
e6bc : f054             	beq df_rt_neval_process
                        	; if bracket then evaluate expression recursively
e6be : c928             	cmp #'('
e6c0 : d04c             	bne df_rt_neval_nextbyte
                        	; move past open bracket
e6c2 : e689             	inc df_exeoff
                        	; call evaluation function recursively
e6c4 : 209ce6           	jsr df_rt_neval
e6c7 : 8045             	bra df_rt_neval_nextbyte
e6c9 :                  df_rt_neval_esc
AS65 Assembler for R6502 [1.42].                                     Page  166
------------------------------ kernel\kernel.s -------------------------------

e6c9 : 201be7           	jsr df_rt_eval_esc
e6cc : 8040             	bra df_rt_neval_nextbyte
                        	; if a token then push on operator stack
e6ce :                  df_rt_neval_tk
e6ce : 8489             	sty df_exeoff
e6d0 : 297f             	and #0x7f
                        	; check if op (look up type using X as index)
                        	; X contains the current operator index
e6d2 : aa               	tax
e6d3 : bd66e3           	lda df_tk_tokentype,x
                        	; A contains token type
e6d6 : 858e             	sta df_tmpptrb
e6d8 : 8908             	bit #DFTK_OP
e6da : d006             	bne df_rt_neval_tk_op
                        	; check if fn
e6dc : 8902             	bit #DFTK_FN
e6de : d02a             	bne df_rt_neval_tk_fn
                        
                        	; If got here then something wrong
                        	SWBRK DFERR_TYPEMISM
                        
                        	
e6e2 :                  df_rt_neval_tk_op
                        	; if this op < current top of op stack
                        	; then do the op as it is higher priority so should
                        	; not be pushed
                        	; what is top of the op stack?
                        	; save current op token value
                        	; C=0 means process the op now, else don't
                        	; save current operator index
e6e2 : 868c             	stx df_tmpptra
                        	; mask off to keep priority
e6e4 : 2907             	and #DFTK_OPMSK
e6e6 : 858e             	sta df_tmpptrb
                        	; peek top of op stack - pull and push A
e6e8 : 68               	pla
e6e9 : 48               	pha
                        	; if 0 then nothing so push op
e6ea : f019             	beq df_rt_neval_pushOp
                        	; use it to index in to type table
e6ec : aa               	tax
e6ed : bd66e3           	lda df_tk_tokentype,x
                        	; mask off to keep priority
e6f0 : 2907             	and #DFTK_OPMSK
                        	; compare with the saved token type which includes pr
e6f2 : c58e             	cmp df_tmpptrb
                        	; if top of stack >= current then C=1
                        	; else C=0
                        	; what is the state of C?
                        	; if 1 then just pushOp
e6f4 : f002             	beq df_rt_neval_donow
e6f6 : b00d             	bcs df_rt_neval_pushOp
e6f8 :                  df_rt_neval_donow
                        	; was C=0 so process now before pushing the new op
                        	; get operator off cpu stack
e6f8 : 68               	pla
                        	; save the current op on cpu stack
e6f9 : a68c             	ldx df_tmpptra
e6fb : da               	phx
                        	; now run the token that came off the stack
e6fc : 2057ea           	jsr df_rt_run_token
                        	; get current op off cpu stack in to X
AS65 Assembler for R6502 [1.42].                                     Page  167
------------------------------ kernel\kernel.s -------------------------------

e6ff : fa               	plx
                        	; get the token type in to Y
e700 : bd66e3           	lda df_tk_tokentype,x
                        	; now go back around again to check whether to push t
e703 : 80dd             	bra df_rt_neval_tk_op
e705 :                  df_rt_neval_pushOp
                        	; push the operator
e705 : a58c             	lda df_tmpptra
e707 : 48               	pha
e708 : 8004             	bra df_rt_neval_nextbyte
                        
e70a :                  df_rt_neval_tk_fn
e70a : 8a               	txa
                        	; run a fn token - returns a value on stack
e70b : 2057ea           	jsr df_rt_run_token
                        	; move to next byte
e70e :                  df_rt_neval_nextbyte
e70e : e689             	inc df_exeoff
e710 : 808d             	bra df_rt_neval_optk
                        	; keep going until non-ws char found or end of line /
                        
e712 :                  df_rt_neval_process	
                        	; pop operator off stack and execute
                        	; keep popping until reached the terminator
e712 : 68               	pla
e713 : f005             	beq df_rt_neval_done
                        	; run the token code
e715 : 2057ea           	jsr df_rt_run_token
                        	; top two bytes on stack is the result
e718 : 80f8             	bra df_rt_neval_process
e71a :                  df_rt_neval_done
                        ;	clc
e71a : 60               	rts
                        
                        	
                        ; jump to escape evaluation routine
e71b :                  df_rt_eval_esc
e71b : 0a               	asl a
e71c : aa               	tax
e71d : 7c20e7           	jmp (df_rt_eval_esc_tab,x)
                        	
e720 :                  df_rt_eval_esc_tab
e720 : dde7             	dw df_rt_eval_chr
e722 : e9e7             	dw df_rt_eval_reserved
e724 : e9e7             	dw df_rt_eval_reserved
e726 : e9e7             	dw df_rt_eval_reserved
e728 : e9e7             	dw df_rt_eval_reserved	
e72a : e9e7             	dw df_rt_eval_reserved	; no such thing as bytdec
e72c : dde7             	dw df_rt_eval_bythex
e72e : dde7             	dw df_rt_eval_bytbin
e730 : e9e7             	dw df_rt_eval_reserved	
e732 : dde7             	dw df_rt_eval_intdec
e734 : dde7             	dw df_rt_eval_inthex
e736 : dde7             	dw df_rt_eval_intbin
e738 : e9e7             	dw df_rt_eval_reserved
e73a : e9e7             	dw df_rt_eval_reserved
e73c : e9e7             	dw df_rt_eval_reserved
e73e : e9e7             	dw df_rt_eval_reserved	
e740 : ebe7             	dw df_rt_eval_strlit
e742 : 31e8             	dw df_rt_eval_var
e744 : 1ae9             	dw df_rt_eval_proc
                        
AS65 Assembler for R6502 [1.42].                                     Page  168
------------------------------ kernel\kernel.s -------------------------------

                        
                        ;****************************************
                        ;* Evaluate a numeric expression and get
                        ;* the result back off the stack in A,X
                        ;****************************************
e746 :                  df_rt_getnval
                        	; evaluate the expression
e746 : 209ce6           	jsr df_rt_neval
                        	; expecting an int/byte back
e749 : 4c4dfa           	jmp df_st_popInt
                        
                        
                        ;****************************************
                        ;* Evaluate a string expression
                        ;* X, A = Destination buffer / space
                        ;****************************************
e74c :                  df_rt_seval
                        	; keep X,A on the stack - will be modified
e74c : 48               	pha
e74d : da               	phx
                        	; push original destination
e74e : 2024fa           	jsr df_st_pushStr
                        	; Push the destination to the 6502 stack
                        	; hi byte first then lo
                        	; push string idx so we know our starting position
                        	; in the string buffer
                        	; this limits all evaluations to 255 bytes
                        ;	lda df_stridx
                        ;	jsr df_st_pushOp
                        
                        	; find escape token or keyword token
                        	; if escape token push on to operand stack
                        	; if keyword operator token push on to operator stack
                        	; if keyword function token run it
                        
e751 :                  df_rt_seval_optk
e751 : a489             	ldy df_exeoff
                        	; check end of line
e753 : c47f             	cpy df_eolidx
e755 : f069             	beq df_rt_seval_done
e757 : c480             	cpy df_tokstidx
e759 : f065             	beq df_rt_seval_done
e75b : b187             	lda (df_currlin),y
e75d : 301c             	bmi df_rt_seval_tk
e75f : c920             	cmp #DFTK_ESCVAL
e761 : 900a             	bcc df_rt_seval_esc
                        	; check for evaluation terminators
                        	; specifically ',' and ')'
e763 : c92c             	cmp #','
e765 : f059             	beq df_rt_seval_done
e767 : c929             	cmp #')'
e769 : f055             	beq df_rt_seval_done
e76b : 804f             	bra df_rt_seval_nextbyte
e76d :                  df_rt_seval_esc
                        	; the only escape char is STRLIT, VAR or PROC
e76d : c910             	cmp #DFTK_STRLIT
e76f : f044             	beq	df_rt_seval_esc_strlit
e771 : c911             	cmp #DFTK_VAR
e773 : f024             	beq	df_rt_seval_esc_var
e775 : c912             	cmp #DFTK_PROC
e777 : f041             	beq	df_rt_seval_esc_proc
                        
AS65 Assembler for R6502 [1.42].                                     Page  169
------------------------------ kernel\kernel.s -------------------------------

                        	; error if got here
                        	SWBRK DFERR_SYNTAX
                        
                        
                        	; if a token then push on operator stack
e77b :                  df_rt_seval_tk
e77b : 8489             	sty df_exeoff
e77d : 297f             	and #0x7f
                        	; check if op
e77f : aa               	tax
e780 : bd66e3           	lda df_tk_tokentype,x
e783 : 2904             	and #DFTK_STROP
e785 : d009             	bne df_rt_seval_tk_op
                        	; check if fn
e787 : bd66e3           	lda df_tk_tokentype,x
e78a : 2902             	and #DFTK_FN
e78c : d005             	bne df_rt_seval_tk_fn	
                        	
                        	; token type mismatch if got here
                        	SWBRK DFERR_TYPEMISM
                        
                        
e790 :                  df_rt_seval_tk_op
                        	; the only op is $+
                        	; so just ignore!
e790 : 8a               	txa
e791 : 8029             	bra df_rt_seval_nextbyte
                        
e793 :                  df_rt_seval_tk_fn
e793 : 8a               	txa
e794 : 2057ea           	jsr df_rt_run_token
e797 : 8004             	bra df_rt_seval_copy
                        
e799 :                  df_rt_seval_esc_var
                        	; go process the variable as a normal RVAL
e799 : 18               	clc
e79a : 2031e8           	jsr df_rt_eval_var
                        	; copy source off rt stack to destination
e79d :                  df_rt_seval_copy
                        	; pull destination pointer
e79d : 68               	pla
e79e : 858c             	sta df_tmpptra
e7a0 : 68               	pla
e7a1 : 858d             	sta df_tmpptra+1
                        	; pop source string pointer off stack
e7a3 : 2051fa           	jsr df_st_popStr
e7a6 : 868e             	stx df_tmpptrb
e7a8 : 858f             	sta df_tmpptrb+1
                        	; go and copy the string
e7aa : 20c4e7           	jsr df_rt_copyStr
                        	; now save the destination
e7ad : a58d             	lda df_tmpptra+1
e7af : 48               	pha
e7b0 : a58c             	lda df_tmpptra
e7b2 : 48               	pha
                        	
e7b3 : 8007             	bra df_rt_seval_nextbyte
                        	
e7b5 :                  df_rt_seval_esc_strlit
                        	; evaluate string literal
e7b5 : 20ebe7           	jsr df_rt_eval_strlit
e7b8 : 80e3             	bra df_rt_seval_copy
AS65 Assembler for R6502 [1.42].                                     Page  170
------------------------------ kernel\kernel.s -------------------------------

                        	
e7ba :                  df_rt_seval_esc_proc
                        	; not yet suported *******
                        	SWBRK DFERR_RUNTIME
                        
                        	
e7bc :                  df_rt_seval_nextbyte
e7bc : e689             	inc df_exeoff
e7be : 8091             	bra df_rt_seval_optk
                        	; keep going until non-ws char found or end of line /
e7c0 :                  df_rt_seval_done
                        	; 
e7c0 : 68               	pla
e7c1 : 68               	pla
                        	
e7c2 : 18               	clc
e7c3 : 60               	rts
                        
                        
                        ; Copy string from ptrb to ptra
e7c4 :                  df_rt_copyStr
e7c4 : a000             	ldy #0
e7c6 :                  df_rt_copyStr_ch
e7c6 : b18e             	lda (df_tmpptrb),y
e7c8 : 918c             	sta (df_tmpptra),y
e7ca : f003             	beq df_rt_copyStr_done
e7cc : c8               	iny
e7cd : 80f7             	bra df_rt_copyStr_ch
e7cf :                  df_rt_copyStr_done
e7cf : 98               	tya
e7d0 : 18               	clc
e7d1 : 658c             	adc df_tmpptra
e7d3 : 858c             	sta df_tmpptra
e7d5 : a58d             	lda df_tmpptra+1
e7d7 : 6900             	adc #0
e7d9 : 858d             	sta df_tmpptra+1
e7db : 18               	clc
e7dc : 60               	rts
                        	
                        ;****************************************
                        ;* Evaluate and push numeric value
                        ;****************************************
e7dd :                  df_rt_eval_intdec
e7dd :                  df_rt_eval_bytdec
e7dd :                  df_rt_eval_inthex
e7dd :                  df_rt_eval_bythex
e7dd :                  df_rt_eval_intbin
e7dd :                  df_rt_eval_bytbin
e7dd :                  df_rt_eval_chr
                        	; numeric constant
e7dd : c8               	iny
e7de : b187             	lda (df_currlin),y
e7e0 : aa               	tax
e7e1 : c8               	iny
e7e2 : b187             	lda (df_currlin),y
                        	; save offset before calling any routine
e7e4 : 8489             	sty df_exeoff
                        	; push number on to stack
e7e6 : 4c20fa           	jmp df_st_pushInt
                        
e7e9 :                  df_rt_eval_reserved
                        	; should not get here
AS65 Assembler for R6502 [1.42].                                     Page  171
------------------------------ kernel\kernel.s -------------------------------

                        	SWBRK DFERR_RUNTIME
                        
                        
                        ;****************************************
                        ;* Evaluate and push string constant
                        ;****************************************
e7eb :                  df_rt_eval_strlit
e7eb : 8489             	sty df_exeoff
                        	; calculate the effective address
                        	; y + currlin
e7ed : 98               	tya
                        	; set carry to add one extra
e7ee : 38               	sec
e7ef : 6587             	adc df_currlin
e7f1 : 858c             	sta df_tmpptra
e7f3 : aa               	tax
e7f4 : a588             	lda df_currlin+1
e7f6 : 6900             	adc #0
e7f8 : 858d             	sta df_tmpptra+1
                        	
                        	; push string on to stack
e7fa : 2024fa           	jsr df_st_pushStr
                        	; now proceed until end of string found
e7fd : a489             	ldy df_exeoff
e7ff :                  df_rt_eval_strlit_ch
e7ff : b187             	lda (df_currlin),y
e801 : f003             	beq df_rt_eval_strlit_done
e803 : c8               	iny
e804 : 80f9             	bra df_rt_eval_strlit_ch
e806 :                  df_rt_eval_strlit_done
e806 : 8489             	sty df_exeoff
e808 : 60               	rts
                        
                        ;****************************************
                        ;* Return array parameter
                        ;* A has parm
                        ;****************************************
e809 :                  df_rt_arry_parm
                        	; move past open bracket or comma
e809 : e689             	inc df_exeoff
                        	; evaluate expression inside bracket
e80b : 2046e7           	jsr df_rt_getnval
e80e : 8a               	txa
                        ;	clc
e80f : 60               	rts
                        	
                        ;****************************************
                        ;* Return double array parameter
                        ;* X = dim1, Y = dim2
                        ;****************************************
e810 :                  df_rt_arry_parm2
                        	; go get array parm 1
e810 : 2009e8           	jsr df_rt_arry_parm
e813 : 48               	pha
e814 : a200             	ldx #0
e816 : a489             	ldy df_exeoff
e818 :                  df_rt_arry_parm2_term
e818 : b187             	lda (df_currlin),y
e81a : c95d             	cmp #']'
e81c : f00f             	beq df_rt_arry_parm2_skiparry2
e81e : c92c             	cmp #','
e820 : f005             	beq df_rt_arry_parm2_arry2
AS65 Assembler for R6502 [1.42].                                     Page  172
------------------------------ kernel\kernel.s -------------------------------

e822 : 8489             	sty df_exeoff
e824 : c8               	iny
e825 : 80f1             	bra df_rt_arry_parm2_term
e827 :                  df_rt_arry_parm2_arry2
                        	; get second dimension and put in Y
e827 : 2009e8           	jsr df_rt_arry_parm
e82a : a8               	tay
e82b : fa               	plx
                        ;	clc
e82c : 60               	rts
e82d :                  df_rt_arry_parm2_skiparry2
e82d : a000             	ldy #0
e82f : fa               	plx
                        ;	clc
e830 : 60               	rts
                        
                        	
                        ;****************************************
                        ;* Evaluate and push variable
                        ;* The actual value is pushed if numeric
                        ;* The pointer is pushed if string
                        ;* Carry Set = LVAR else normal RVAR
                        ;* LVAR : Y = line index, A=vvt type, tmpptra = vvt sl
                        ;****************************************
e831 :                  df_rt_eval_var
                        	; save carry bit
e831 : 08               	php
                        	; if lvar mode then already passed escape token
e832 : b00a             	bcs df_rt_eval_lvskip
                        	; move past var escape token
e834 : c8               	iny
e835 : 8489             	sty df_exeoff
                        	; get var index and convert to vvt address
e837 : b187             	lda (df_currlin),y
e839 : 2027db           	jsr df_var_addr
                        	; push vvt type first as this is the last thing we ne
e83c : b28c             	lda (df_tmpptra)
e83e :                  df_rt_eval_lvskip
e83e : 48               	pha
                        	; Test A
e83f : aa               	tax
                        	; simple variable
e840 : 1012             	bpl df_rt_eval_var_notarry
                        	; even if an array if no dimensions then return base 
                        	; if at end of statement or line then simple copy
e842 : c47f             	cpy df_eolidx
e844 : f02b             	beq df_rt_eval_var_simple
e846 : c480             	cpy df_tokstidx
e848 : f027             	beq df_rt_eval_var_simple
                        	; if next ch is not [ then simple copy
e84a : c8               	iny
e84b : b187             	lda (df_currlin),y
e84d : 88               	dey
e84e : c95b             	cmp #'['
e850 : d01f             	bne df_rt_eval_var_simple
                        	; go do array handling
e852 : 802d             	bra df_rt_eval_var_do_arry
e854 :                  df_rt_eval_var_notarry
                        	; pull the type but not needed here
e854 : 68               	pla
                        	; check if lvar wanted rather than rvar
e855 : 28               	plp
AS65 Assembler for R6502 [1.42].                                     Page  173
------------------------------ kernel\kernel.s -------------------------------

e856 : b00c             	bcs df_rt_eval_lvar
                        	; just push the vvt lo,hi value
e858 : a001             	ldy #DFVVT_LO
e85a : b18c             	lda (df_tmpptra),y
e85c : aa               	tax
e85d : a002             	ldy #DFVVT_HI
e85f : b18c             	lda (df_tmpptra),y
e861 : 4c20fa           	jmp df_st_pushInt
                        
e864 :                  df_rt_eval_lvar
                        	; it's not an array, push the address of DFVVT_LO
                        	; add DFVVT_LO offset to slot address in X,A
e864 : 18               	clc
e865 : a901             	lda #DFVVT_LO
e867 : 658c             	adc df_tmpptra
e869 : aa               	tax
e86a : a58d             	lda df_tmpptra+1
e86c : 6900             	adc #0
                        
                        	; push pointer to lo,hi
e86e : 4c28fa           	jmp df_st_pushPtr
                        	
e871 :                  df_rt_eval_var_simple
                        ;	clc
                        	; simply get lo,hi and push ptr on stack
e871 : a001             	ldy #DFVVT_LO
e873 : b18c             	lda (df_tmpptra),y
e875 : aa               	tax
e876 : a002             	ldy #DFVVT_HI
e878 : b18c             	lda (df_tmpptra),y
                        	; hi val saved in Y
e87a : a8               	tay
                        	; get the type and discard P
e87b : 68               	pla
e87c : 68               	pla
                        	; move Y to A
e87d : 98               	tya
e87e : 4c28fa           	jmp df_st_pushPtr
                        	
e881 :                  df_rt_eval_var_do_arry
                        	; move past var index
e881 : e689             	inc df_exeoff
                        	; zero out x,y as they have dimension info
e883 : a200             	ldx #0
e885 : a000             	ldy #0
                        	
                        	; ** Array handling routine **
                        	; A on stack = type
                        	; save vvt address
e887 : a58d             	lda df_tmpptra+1
e889 : 48               	pha
e88a : a58c             	lda df_tmpptra
e88c : 48               	pha
                        	
                        	; get array parms in X,Y
e88d : 2010e8           	jsr df_rt_arry_parm2
                        	; restore vvt address
e890 : 68               	pla
e891 : 858c             	sta df_tmpptra
e893 : 68               	pla
e894 : 858d             	sta df_tmpptra+1
                        	; save dimension indices for later
AS65 Assembler for R6502 [1.42].                                     Page  174
------------------------------ kernel\kernel.s -------------------------------

                        	; save x last as needed first
e896 : 5a               	phy
e897 : da               	phx
                        	; if y is zero then need to decide some stuff
e898 : c000             	cpy #0
e89a : d00e             	bne df_rt_eval_var_dim2adj
                        	; if dim2 > 0 then swap x,y
e89c : a004             	ldy #DFVVT_DIM2
e89e : b18c             	lda (df_tmpptra),y
e8a0 : a000             	ldy #0
e8a2 : c900             	cmp #0
e8a4 : f004             	beq df_rt_eval_var_dim2adj
                        	; pop from stack in swapped order
e8a6 : 7a               	ply
e8a7 : fa               	plx
                        	; save back on stack
e8a8 : 5a               	phy
e8a9 : da               	phx
                        	
e8aa :                  df_rt_eval_var_dim2adj
                        	; don't let y=0
e8aa : c000             	cpy #0
e8ac : d001             	bne df_rt_eval_var_dim2adjy
e8ae : c8               	iny
e8af :                  df_rt_eval_var_dim2adjy
                        	; don't let x=0
e8af : e000             	cpx #0
e8b1 : d001             	bne df_rt_eval_var_dim2adjx
e8b3 : e8               	inx
e8b4 :                  df_rt_eval_var_dim2adjx
                        	;calculate offset
                        	;(y-1)*dim1 + (x-1)
e8b4 : ca               	dex
e8b5 : 88               	dey
                        	; (y-1)
e8b6 : 8446             	sty num_a
e8b8 : 6447             	stz num_a+1
                        	; if y is 0 then no need to multiply
e8ba : f00b             	beq df_rt_eval_var_nomult
                        	; (dim1)
e8bc : a003             	ldy #DFVVT_DIM1
e8be : b18c             	lda (df_tmpptra),y
e8c0 : 854a             	sta num_b
e8c2 : 644b             	stz num_b+1
                        	; (y-1)*dim1 num_a has result
e8c4 : 20fecf           	jsr int_fast_mult
e8c7 :                  df_rt_eval_var_nomult
                        	; move x to a
e8c7 : 8a               	txa
                        	; add x to num_a
e8c8 : 18               	clc
e8c9 : 6546             	adc num_a
e8cb : 8546             	sta num_a
e8cd : a547             	lda num_a+1
e8cf : 6900             	adc #0
e8d1 : 8547             	sta num_a+1
                        	; now have element offset in num_a
                        	; dimensions in x and y
e8d3 : fa               	plx
e8d4 : 7a               	ply
                        	; get type of variable originally found
e8d5 : 68               	pla
AS65 Assembler for R6502 [1.42].                                     Page  175
------------------------------ kernel\kernel.s -------------------------------

e8d6 : 48               	pha
e8d7 : 2901             	and #DFVVT_INT
e8d9 : f004             	beq df_rt_eval_var_push
                        	; if it is int then multiply offset by 2
e8db : 0646             	asl num_a
e8dd : 2647             	rol num_a+1
e8df :                  df_rt_eval_var_push
                        	; add pointer in lo,hi to num_a
e8df : 18               	clc
e8e0 : a001             	ldy #DFVVT_LO
e8e2 : b18c             	lda (df_tmpptra),y
e8e4 : 6546             	adc num_a
e8e6 : 8546             	sta num_a
e8e8 : a002             	ldy #DFVVT_HI
e8ea : b18c             	lda (df_tmpptra),y
e8ec : d002             	bne df_rt_array_exists
                        	; if vvt address hi is zero then array not dimensione
                        	SWBRK DFERR_DIM
                        
e8f0 :                  df_rt_array_exists
e8f0 : 6547             	adc num_a+1
e8f2 : 8547             	sta num_a+1	
                        	; get the type
e8f4 : 68               	pla
                        	; if not int or byte then push string
e8f5 : 2903             	and #DFVVT_INT|DFVVT_BYT
e8f7 : f019             	beq df_rt_eval_var_str
                        	; get LVAR preference
e8f9 : 28               	plp
e8fa : b017             	bcs df_rt_eval_ptr
                        	; need to load lo and hi for int
                        	; but only lo for byt
e8fc : 2901             	and #DFVVT_INT
e8fe : f00a             	beq df_rt_eval_byt
                        	; push the contents pointed to by num_a
e900 : b246             	lda (num_a)
e902 : aa               	tax
e903 : a001             	ldy #1
e905 : b146             	lda (num_a),y
e907 : 4c20fa           	jmp df_st_pushInt
e90a :                  df_rt_eval_byt
e90a : b246             	lda (num_a)
e90c : aa               	tax
e90d : a900             	lda #0
e90f : 4c20fa           	jmp df_st_pushInt
e912 :                  df_rt_eval_var_str
e912 : 28               	plp
e913 :                  df_rt_eval_ptr
                        ;	clc
                        	; put num_a not contents
e913 : a646             	ldx num_a
e915 : a547             	lda num_a+1
e917 : 4c28fa           	jmp df_st_pushPtr
                        	
e91a :                  df_rt_eval_proc
e91a : a578             	lda df_parmtop				; Save current position of paramete
e91c : 48               	pha
e91d : 20ccf8           	jsr df_rt_proc				; Go and call the user function
e920 : 68               	pla							; Get back the original parameter stack pos
e921 : c578             	cmp df_parmtop				; if it is the same, then no return
e923 : f002             	beq df_rt_eval_proc_err
e925 : 18               	clc
AS65 Assembler for R6502 [1.42].                                     Page  176
------------------------------ kernel\kernel.s -------------------------------

e926 : 60               	rts
e927 :                  df_rt_eval_proc_err
                        	; if no return value then report an errror
                        	SWBRK DFERR_RETURN
                        
                        
                        
                        
                        ;****************************************
                        ;* get two ints off the runtime stack
                        ;* first parm in ptrb, second in ptra
                        ;****************************************
e929 :                  df_rt_get2Ints
                        	; the first int popped is actually the second parm
e929 : 204dfa           	jsr df_st_popInt
e92c : 868e             	stx df_tmpptrb
e92e : 858f             	sta df_tmpptrb+1
                        
e930 : 204dfa           	jsr df_st_popInt
e933 : 868c             	stx df_tmpptra
e935 : 858d             	sta df_tmpptra+1
e937 : 60               	rts
                        
                        ;****************************************
                        ;* get two strings off the runtime stack
                        ;* first parm in ptrb, second in ptra
                        ;****************************************
e938 :                  df_rt_get2Strs
                        	; the first int popped is actually the second parm
e938 : 2051fa           	jsr df_st_popStr
e93b : 868e             	stx df_tmpptrb
e93d : 858f             	sta df_tmpptrb+1
                        
e93f : 2051fa           	jsr df_st_popStr
e942 : 868c             	stx df_tmpptra
e944 : 858d             	sta df_tmpptra+1
e946 : 60               	rts
                        
                        ;****************************************
                        ; common code for 2 ints runtime parsing
                        ;****************************************
e947 :                  df_rt_parm_2ints
                        	; evaluate 1st parm
e947 : 209ce6           	jsr df_rt_neval
                        	; jump over comma
e94a : e689             	inc df_exeoff
                        	; evaluate the 2nd parm
e94c : 209ce6           	jsr df_rt_neval
                        
                        	; pop 2nd parm
e94f : 204dfa           	jsr df_st_popInt
e952 : 868e             	stx df_tmpptrb
e954 : 858f             	sta df_tmpptrb+1
                        	; pop 1st parm
e956 : 204dfa           	jsr df_st_popInt
e959 : 868c             	stx df_tmpptra
e95b : 858d             	sta df_tmpptra+1
e95d : 60               	rts
                        
                        ;****************************************
                        ; common code for 3 ints runtime parsing
                        ;****************************************
AS65 Assembler for R6502 [1.42].                                     Page  177
------------------------------ kernel\kernel.s -------------------------------

e95e :                  df_rt_parm_3ints
                        	; evaluate 1st parm
e95e : 209ce6           	jsr df_rt_neval
e961 : e689             	inc df_exeoff
                        	; evaluate the 2nd parm
e963 : 209ce6           	jsr df_rt_neval
e966 : e689             	inc df_exeoff
                        	; evaluate the 3rd parm
e968 : 209ce6           	jsr df_rt_neval
                        
                        	; pop 3rd parm
e96b : 204dfa           	jsr df_st_popInt
e96e : 8690             	stx df_tmpptrc
e970 : 8591             	sta df_tmpptrc+1
                        	; pop 2nd parm
e972 : 204dfa           	jsr df_st_popInt
e975 : 868e             	stx df_tmpptrb
e977 : 858f             	sta df_tmpptrb+1
                        	; pop 1st parm
e979 : 204dfa           	jsr df_st_popInt
e97c : 868c             	stx df_tmpptra
e97e : 858d             	sta df_tmpptra+1
e980 : 60               	rts
                        
                        ;****************************************
                        ; common code for 4 ints runtime parsing
                        ;****************************************
e981 :                  df_rt_parm_4ints
                        	; evaluate 1st parm
e981 : 209ce6           	jsr df_rt_neval
e984 : e689             	inc df_exeoff
                        	; evaluate the 2nd parm
e986 : 209ce6           	jsr df_rt_neval
e989 : e689             	inc df_exeoff
                        	; evaluate the 3rd parm
e98b : 209ce6           	jsr df_rt_neval
e98e : e689             	inc df_exeoff
                        	; evaluate the 4th parm
e990 : 209ce6           	jsr df_rt_neval
                        
                        	; pop 4th parm
e993 : 204dfa           	jsr df_st_popInt
e996 : 8692             	stx df_tmpptrd
e998 : 8593             	sta df_tmpptrd+1
                        	; pop 3rd parm
e99a : 204dfa           	jsr df_st_popInt
e99d : 8690             	stx df_tmpptrc
e99f : 8591             	sta df_tmpptrc+1
                        	; pop 2nd parm
e9a1 : 204dfa           	jsr df_st_popInt
e9a4 : 868e             	stx df_tmpptrb
e9a6 : 858f             	sta df_tmpptrb+1
                        	; pop 1st parm
e9a8 : 204dfa           	jsr df_st_popInt
e9ab : 868c             	stx df_tmpptra
e9ad : 858d             	sta df_tmpptra+1
e9af : 60               	rts
                        
                        ;****************************************
                        ; common code for 5 ints runtime parsing
                        ;****************************************
e9b0 :                  df_rt_parm_5ints
AS65 Assembler for R6502 [1.42].                                     Page  178
------------------------------ kernel\kernel.s -------------------------------

                        	; evaluate 1st parm
e9b0 : 209ce6           	jsr df_rt_neval
e9b3 : e689             	inc df_exeoff
                        	; evaluate the 2nd parm
e9b5 : 209ce6           	jsr df_rt_neval
e9b8 : e689             	inc df_exeoff
                        	; evaluate the 3rd parm
e9ba : 209ce6           	jsr df_rt_neval
e9bd : e689             	inc df_exeoff
                        	; evaluate the 4th parm
e9bf : 209ce6           	jsr df_rt_neval
e9c2 : e689             	inc df_exeoff
                        	; evaluate the 5th parm
e9c4 : 209ce6           	jsr df_rt_neval
                        
                        	; pop 5th parm
e9c7 : 204dfa           	jsr df_st_popInt
e9ca : 8694             	stx df_tmpptre
e9cc : 8595             	sta df_tmpptre+1
                        	; pop 4th parm
e9ce : 204dfa           	jsr df_st_popInt
e9d1 : 8692             	stx df_tmpptrd
e9d3 : 8593             	sta df_tmpptrd+1
                        	; pop 3rd parm
e9d5 : 204dfa           	jsr df_st_popInt
e9d8 : 8690             	stx df_tmpptrc
e9da : 8591             	sta df_tmpptrc+1
                        	; pop 2nd parm
e9dc : 204dfa           	jsr df_st_popInt
e9df : 868e             	stx df_tmpptrb
e9e1 : 858f             	sta df_tmpptrb+1
                        	; pop 1st parm
e9e3 : 204dfa           	jsr df_st_popInt
e9e6 : 868c             	stx df_tmpptra
e9e8 : 858d             	sta df_tmpptra+1
                        
e9ea : 60               	rts
                        
                        ;****************************************
                        ;* initialise statement to be executed
                        ;* X,A = line pointer, Y=statement offset
                        ;****************************************
e9eb :                  df_rt_init_stat_ptr
                        	; save current line
e9eb : 8687             	stx df_currlin
e9ed : 8588             	sta df_currlin+1
e9ef : 8481             	sty df_curstidx
e9f1 : 8489             	sty df_exeoff
e9f3 : b287             	lda (df_currlin)
e9f5 : 857f             	sta df_eolidx
e9f7 : b187             	lda (df_currlin),y
e9f9 : 8580             	sta df_tokstidx
e9fb : 60               	rts
                        	
                        ;****************************************
                        ;* Execute from a statement pointed to
                        ;* by currlin and exeoff
                        ;****************************************
e9fc :                  df_rt_exec_stat
e9fc : a687             	ldx df_currlin
e9fe : a588             	lda df_currlin+1
ea00 : a489             	ldy df_exeoff
AS65 Assembler for R6502 [1.42].                                     Page  179
------------------------------ kernel\kernel.s -------------------------------

ea02 :                  df_rt_exec_init_ptr
ea02 : 20ebe9           	jsr df_rt_init_stat_ptr
                        	; assume normal flow of control if next line hi = 0
                        	; this means no line can execute below page 1, no los
ea05 : 648b             	stz df_nextlin+1
                        
                        	; find first token in statement
ea07 :                  df_rt_exec_find_tok
ea07 : c8               	iny
ea08 : b187             	lda (df_currlin),y
ea0a : 10fb             	bpl df_rt_exec_find_tok
ea0c :                  df_rt_exec_found_tok
                        	; skip past token to next byte in readiness
ea0c : c8               	iny
ea0d : 8489             	sty df_exeoff
                        	; *** CHECK FOR ENDDEF TOKEN IF SO DONE ***
                        ;	cmp #DFRT_ENDDEF
                        ;	bne df_rt_exec_notend
                        ;	cmp #DFRT_RETURN
                        ;	bne df_rt_exec_notend
                        ;	jmp df_rt_enddef
                        ;	rts
ea0f :                  df_rt_exec_notend
                        	; save the token
ea0f : 48               	pha
                        	; Run that statement
ea10 : 2057ea           	jsr df_rt_run_token
                        	; what token was run, if it was enddef or return then
ea13 : 68               	pla
ea14 : c986             	cmp #DFRT_ENDDEF
ea16 : f033             	beq df_rt_exec_end
ea18 : c987             	cmp #DFRT_RETURN
ea1a : f02f             	beq df_rt_exec_end
                        	
                        	; check for break, asynch get
ea1c : 18               	clc
ea1d : 2026d9           	jsr io_get_ch
ea20 : c903             	cmp #UTF_ETX					; CTRL-C?
ea22 : d002             	bne df_rt_exec_cont
                        	SWBRK DFERR_BREAK
                        
ea26 :                  df_rt_exec_cont
                        	; check if normal flow of control
ea26 : a58b             	lda df_nextlin+1
ea28 : d025             	bne df_rt_exec_jump
                        	; try and execute another statement
ea2a : a480             	ldy df_tokstidx
ea2c : 8489             	sty df_exeoff
ea2e : d0cc             	bne df_rt_exec_stat
                        
                        	; reached end of line, move to next
ea30 : 18               	clc
ea31 : b287             	lda (df_currlin)
ea33 : 6587             	adc df_currlin
ea35 : 8587             	sta df_currlin
ea37 : a588             	lda df_currlin+1
ea39 : 6900             	adc #0
ea3b : 8588             	sta df_currlin+1
                        	
                        	; start from first statement in new line
ea3d : a003             	ldy #3
ea3f : 8489             	sty df_exeoff
AS65 Assembler for R6502 [1.42].                                     Page  180
------------------------------ kernel\kernel.s -------------------------------

                        
                        	; check if this line has any content (length >0)
ea41 : b287             	lda (df_currlin)
ea43 : 857f             	sta df_eolidx
                        	; no more lines (len = 0), program done
ea45 : d0b5             	bne df_rt_exec_stat
                        	; else done
                        	; normally wouldn't get here except immediate mode
                        	; if line number <> 0 then error
ea47 : a55f             	lda df_immed
ea49 : f002             	beq df_rt_unexpected_end
ea4b :                  df_rt_exec_end
ea4b : 18               	clc
ea4c : 60               	rts
ea4d :                  df_rt_unexpected_end
                        	SWBRK DFERR_IMMEDIATE
                        
                        
                        	; if hi byte of nextline is not zero then
                        	; current line = next line
ea4f :                  df_rt_exec_jump
                        	; initialise statement pointer from nextlin,tokstidx
ea4f : a68a             	ldx df_nextlin
ea51 : a58b             	lda df_nextlin+1
ea53 : a480             	ldy df_tokstidx
ea55 : 80ab             	bra df_rt_exec_init_ptr
                        
                        	
                        ;****************************************
                        ;* Run statement in A
                        ;****************************************
ea57 :                  df_rt_run_token
                        	; mask off MSB
                        ;	and #0x7f
                        	; multiply by 2
ea57 : 0a               	asl a
ea58 : aa               	tax
                        	; execution code finishes with rts
ea59 : 7c1aeb           	jmp (df_rt_tokenjmp,x)
                        
                        
                        ;****************************************
                        ;* X,A : Line Address, Y = Index
                        ;* C=0 Found next statement
                        ;* C=1 No statement found
                        ;****************************************
ea5c :                  df_rt_nextstat
                        	; save pointer
ea5c : 869b             	stx df_lineptr
ea5e : 859c             	sta df_lineptr+1
                        	; if end of program then err
ea60 : b29b             	lda (df_lineptr)
ea62 : f01c             	beq df_rt_nextstat_err
                        	; if next statement idx 0
ea64 : b19b             	lda (df_lineptr),y
                        	; then go to next line
ea66 : f007             	beq df_rt_nextstat_ln
                        	; else make this Y
ea68 : a8               	tay
                        	; X = line low
ea69 : a69b             	ldx df_lineptr
                        	; A = line high
AS65 Assembler for R6502 [1.42].                                     Page  181
------------------------------ kernel\kernel.s -------------------------------

ea6b : a59c             	lda df_lineptr+1
ea6d : 18               	clc
ea6e : 60               	rts
ea6f :                  df_rt_nextstat_ln
                        	; for next line, add line length to ptr
ea6f : 18               	clc
ea70 : b29b             	lda (df_lineptr)
ea72 : 659b             	adc df_lineptr
ea74 : 859b             	sta df_lineptr
ea76 : a59c             	lda df_lineptr+1
ea78 : 6900             	adc #0
ea7a : 859c             	sta df_lineptr+1
                        	; if end of program set C
ea7c : b29b             	lda (df_lineptr)
ea7e : d004             	bne df_rt_nextstat_dn
ea80 :                  df_rt_nextstat_err
ea80 : a000             	ldy #0
ea82 : 38               	sec
ea83 : 60               	rts
ea84 :                  df_rt_nextstat_dn
ea84 : a69b             	ldx df_lineptr
ea86 : a59c             	lda df_lineptr+1
                        	; always skip line number and length for start of 1st
ea88 : a003             	ldy #3
ea8a : 18               	clc
ea8b : 60               	rts
                        
                        ;****************************************
                        ;* Push current line and statement to runtime stack
                        ;****************************************
ea8c :                  df_rt_push_stat
ea8c : a581             	lda df_curstidx
ea8e : 20d7f9           	jsr df_st_pushByte
ea91 : a588             	lda df_currlin+1
ea93 : a687             	ldx df_currlin
ea95 : 4cf0f9           	jmp df_st_pushWord
                        ;	clc
                        ;	rts
                        
                        ;****************************************
                        ;* Pop line and statement from runtime stack
                        ;* And transfer control to next statement
                        ;****************************************
ea98 :                  df_rt_pop_stat
ea98 : 20fef9           	jsr df_st_popWord
ea9b : 868a             	stx	df_nextlin
ea9d : 858b             	sta df_nextlin+1
ea9f : 20e0f9           	jsr df_st_popByte
eaa2 : a8               	tay
eaa3 : a68a             	ldx df_nextlin
eaa5 : a58b             	lda df_nextlin+1
eaa7 : 205cea           	jsr df_rt_nextstat
eaaa : 868a             	stx df_nextlin
eaac : 858b             	sta df_nextlin+1
eaae : 8480             	sty df_tokstidx
                        ;	clc
eab0 : 60               	rts
                        
                        ;****************************************
                        ;* Find proc definition with var index A
                        ;* Only call if proc not found before
                        ;****************************************
AS65 Assembler for R6502 [1.42].                                     Page  182
------------------------------ kernel\kernel.s -------------------------------

eab1 :                  df_rt_findproc
                        	; save the search index
eab1 : 851a             	sta tmp_a
                        	; start at program beginning
                        	_cpyZPWord df_prgstrt,df_lineptr
                        
eabb : a003             	ldy #3
eabd : 849d             	sty df_lineidx
eabf : b29b             	lda (df_lineptr)
eac1 : f02c             	beq df_rt_findproc_err
eac3 :                  df_rt_findproc_cmd
eac3 : c8               	iny
eac4 : b19b             	lda (df_lineptr),y
eac6 : 10fb             	bpl df_rt_findproc_cmd
eac8 : c985             	cmp #DFRT_DEF
eaca : d010             	bne df_rt_findproc_nextstat
                        	; skip def token
eacc : c8               	iny
                        	; skip proc escape token
eacd : c8               	iny
                        	; now check the proc var number
eace : b19b             	lda (df_lineptr),y
ead0 : c51a             	cmp tmp_a
ead2 : d008             	bne df_rt_findproc_nextstat
                        	; found it, return AXY with line details
ead4 : a69b             	ldx df_lineptr
ead6 : a59c             	lda df_lineptr+1
ead8 : a49d             	ldy df_lineidx
eada : 18               	clc
eadb : 60               	rts
eadc :                  df_rt_findproc_nextstat
                        	; restore AXY line details and find next statement
eadc : a69b             	ldx df_lineptr
eade : a59c             	lda df_lineptr+1
eae0 : a49d             	ldy df_lineidx
eae2 : 205cea           	jsr df_rt_nextstat
eae5 : b008             	bcs df_rt_findproc_err
eae7 : 869b             	stx df_lineptr
eae9 : 859c             	sta df_lineptr+1
eaeb : 849d             	sty df_lineidx
eaed : 80d4             	bra df_rt_findproc_cmd
                        	; error
eaef :                  df_rt_findproc_err
                        	SWBRK DFERR_NOPROC
                        
                        	
                        ;****************************************
                        ;* Find an escape value
                        ;* Does not check for end of line or statement
                        ;****************************************
eaf1 :                  df_rt_findescval
eaf1 : a489             	ldy df_exeoff
eaf3 : 88               	dey
eaf4 :                  df_rt_findescval_loop
eaf4 : c8               	iny
eaf5 : b187             	lda (df_currlin),y
eaf7 : c920             	cmp #DFTK_ESCVAL
eaf9 : b0f9             	bcs df_rt_findescval_loop
eafb : 8489             	sty df_exeoff
eafd : 60               	rts
                        
                        ;****************************************
AS65 Assembler for R6502 [1.42].                                     Page  183
------------------------------ kernel\kernel.s -------------------------------

                        ;* Get an lvar
                        ;* Assumes next token will be escape DFTK_VAR
                        ;* tmpptra contains vvt slot address
                        ;* X,A is the lvar pointer
                        ;****************************************
eafe :                  df_rt_getlvar
eafe : 20f1ea           	jsr df_rt_findescval
                        	; move past the escape value
eb01 : c8               	iny
                        	; pointing to variable index
eb02 : b187             	lda (df_currlin),y
eb04 : 8489             	sty df_exeoff
                        	; get the vvt address
eb06 : 2027db           	jsr df_var_addr
                        	; get the type
eb09 : b28c             	lda (df_tmpptra)
                        	; set carry flag to return pointer (lvar)
eb0b : 38               	sec
eb0c : 2031e8           	jsr df_rt_eval_var
eb0f : 4c55fa           	jmp df_st_popPtr
                        ;	rts
                        
                        ;****************************************
                        ;* Pop stat from rt stack and continue
                        ;* Y MUST BE ON THE CPU STACK AS IT GETS PLYed HERE
                        ;****************************************
eb12 :                  df_rt_pop_stat_go
eb12 : 2098ea           	jsr df_rt_pop_stat
                        	; restore stack pointer so we don't lose this entry
eb15 : 7a               	ply
eb16 : 8477             	sty df_rtstop
eb18 : 18               	clc
eb19 : 60               	rts
                        
                        	include "dflat\rtjmptab.s"
                        ;*****************************************************
                        ;*
                        ;*	DOLO-1 HOMEBREW COMPUTER
                        ;*	Hardware and software design by Dolo Miah
                        ;*	Copyright 2014-18
                        ;*  Free to use for any non-commercial purpose subject
                        ;*  full credit of original my authorship please!
                        ;*
                        ;*  RTJUMPTAB.S
                        ;*  Runtime token jump table.
                        ;*  dflat uses four key tables to tokenise and run pro
                        ;*  - df_tokensyms    - table of token symbols
                        ;*  - df_tk_tokentype - table of token types
                        ;*  - df_tk_tokenjmp  - table of tokenising routines
                        ;*  - df_rt_tokenjmp  - table of runtime token and esc
                        ;*  The key is the token symbols.  When a line is ente
                        ;*  in to the raw (untokenised) buffer, df_tokensyms i
                        ;*  used to identify tokens.  The position of the foun
                        ;*  token is used to then look up type and jump vector
                        ;*  in the other tables.
                        ;*
                        ;*****************************************************
                        
                        	; ROM code
                        	code  
                        
                        ; Tokeniser jump table
AS65 Assembler for R6502 [1.42].                                     Page  184
------------------------------ kernel\kernel.s -------------------------------

                        ; In token order of df_tokensyms
eb1a :                  df_rt_tokenjmp
eb1a : 56f2             	dw	df_rt_assign
eb1c : ccf8             	dw	df_rt_proc
eb1e : 5bf2             	dw	df_rt_comment
eb20 : 0bf2             	dw	df_rt_println
eb22 : cdf1             	dw	df_rt_print
eb24 : 26f9             	dw	df_rt_def			; 0x85
eb26 : 8ef9             	dw	df_rt_enddef		; 0x86
eb28 : 93f9             	dw	df_rt_return		; 0x87
eb2a : 80f0             	dw	df_rt_local
eb2c : abf0             	dw	df_rt_dim
eb2e : 56ef             	dw	df_rt_repeat		; 0x8a
eb30 : 5fef             	dw	df_rt_until
eb32 : c4ee             	dw	df_rt_for			; 0x8c
eb34 : 04ef             	dw	df_rt_next			; 0x8d
eb36 : a4ed             	dw	df_rt_while			; 0x8e
eb38 : 09ee             	dw	df_rt_wend			; 0x8f
eb3a : 84ee             	dw	df_rt_if			; 0x90
eb3c : 73ee             	dw	df_rt_else			; 0x91
eb3e : 6dee             	dw	df_rt_endif			; 0x92
eb40 : 73ee             	dw	df_rt_elseif		; 0x93
eb42 : 5bf2             	dw	df_rt_data			; 0x94
eb44 : 5df2             	dw	df_rt_run
eb46 : d2f2             	dw	df_rt_list
eb48 : 44f0             	dw	df_rt_input
eb4a : 7af1             	dw	df_rt_mode
eb4c : 31f1             	dw	df_rt_plot
eb4e : 73f1             	dw	df_rt_cursor
eb50 : 25f1             	dw	df_rt_cls
eb52 : b9f4             	dw	df_rt_vpoke
eb54 : c7f4             	dw	df_rt_setvdp
eb56 : d3f4             	dw	df_rt_colour
eb58 : 25f5             	dw	df_rt_spritepat
eb5a : 51f5             	dw	df_rt_spritepos
eb5c : 90f5             	dw	df_rt_spritecol
eb5e : 94f5             	dw	df_rt_spritenme
eb60 : fef4             	dw	df_rt_sprite
eb62 : b0f4             	dw	df_rt_poke
eb64 : a2f4             	dw	df_rt_doke
eb66 : c2f5             	dw	df_rt_sound
eb68 : d7f5             	dw	df_rt_music
eb6a : f8f5             	dw	df_rt_play
eb6c : 5ff6             	dw	df_rt_save
eb6e : 7bf6             	dw	df_rt_load
eb70 : 97f6             	dw	df_rt_dir
eb72 : 8ef6             	dw	df_rt_del
eb74 : 38f0             	dw	df_rt_read
eb76 : a1ed             	dw	df_rt_new
eb78 : 6df2             	dw	df_rt_renum
eb7a : b3f1             	dw	df_rt_wait
eb7c : c4f6             	dw	df_rt_reset
eb7e : 83f1             	dw	df_rt_hires
eb80 : 8bf1             	dw	df_rt_point
eb82 : 99f1             	dw	df_rt_line
                        	
eb84 : f6f6             	dw	df_rt_vpeek
eb86 : dbf6             	dw	df_rt_peek
eb88 : d8f6             	dw	df_rt_deek
eb8a : 20f7             	dw	df_rt_stick
eb8c : 83f7             	dw	df_rt_key
eb8e : 03f8             	dw	df_rt_chr
AS65 Assembler for R6502 [1.42].                                     Page  185
------------------------------ kernel\kernel.s -------------------------------

eb90 : 19f8             	dw	df_rt_left
eb92 : 2df8             	dw	df_rt_right
eb94 : 4df8             	dw	df_rt_mid
eb96 : 70f8             	dw	df_rt_len
eb98 : 35f7             	dw	df_rt_mem
eb9a : 98f7             	dw	df_rt_scrn
eb9c : 04f7             	dw	df_rt_rnd
eb9e : abf7             	dw	df_rt_elapsed
                        	
eba0 : 1eec             	dw	df_rt_mult
eba2 : 3eec             	dw	df_rt_div
eba4 : 5eec             	dw	df_rt_mod
eba6 : 7fec             	dw	df_rt_asl
eba8 : 91ec             	dw	df_rt_lsr
ebaa : faeb             	dw	df_rt_add
ebac : 0cec             	dw	df_rt_sub
                        	
ebae : 21ed             	dw	df_rt_and
ebb0 : 30ed             	dw	df_rt_or
ebb2 : d9ec             	dw	df_rt_lte
ebb4 : fdec             	dw	df_rt_gte
ebb6 : c6ec             	dw	df_rt_ne
ebb8 : ebec             	dw	df_rt_lt
ebba : 0fed             	dw	df_rt_gt
ebbc : b3ec             	dw	df_rt_eq
                        
ebbe : 7eef             	dw	df_rt_sadd
ebc0 : 5fed             	dw	df_rt_slte
ebc2 : 70ed             	dw	df_rt_sgte
ebc4 : 7ded             	dw	df_rt_sne
ebc6 : 86ed             	dw	df_rt_slt
ebc8 : 8fed             	dw	df_rt_sgt
ebca : 98ed             	dw	df_rt_seq
                        
                        ; escape sequence handlers
                        ; to do the reverse of tokenising during the listing
                        ; command which is also used to save to disk.
ebcc :                  df_rt_escjmp
ebcc : 95f3             	dw df_rt_lst_chr
ebce : 94f3             	dw df_rt_lst_reserved
ebd0 : 94f3             	dw df_rt_lst_reserved
ebd2 : 94f3             	dw df_rt_lst_reserved
ebd4 : 94f3             	dw df_rt_lst_reserved	
ebd6 : 94f3             	dw df_rt_lst_reserved	; no such thing as bytdec
ebd8 : b3f3             	dw df_rt_lst_bythex
ebda : d7f3             	dw df_rt_lst_bytbin
ebdc : 94f3             	dw df_rt_lst_reserved	
ebde : 03f4             	dw df_rt_lst_intdec
ebe0 : c6f3             	dw df_rt_lst_inthex
ebe2 : dff3             	dw df_rt_lst_intbin
ebe4 : 94f3             	dw df_rt_lst_reserved
ebe6 : 94f3             	dw df_rt_lst_reserved
ebe8 : 94f3             	dw df_rt_lst_reserved
ebea : 94f3             	dw df_rt_lst_reserved	
ebec : 43f4             	dw df_rt_lst_strlit
ebee : 0ff4             	dw df_rt_lst_var
ebf0 : 0ff4             	dw df_rt_lst_proc
                        
                        	include "dflat\rtsubs.s"
                        ;*****************************************************
                        ;*
                        ;*	DOLO-1 HOMEBREW COMPUTER
AS65 Assembler for R6502 [1.42].                                     Page  186
------------------------------ kernel\kernel.s -------------------------------

                        ;*	Hardware and software design by Dolo Miah
                        ;*	Copyright 2014-18
                        ;*  Free to use for any non-commercial purpose subject
                        ;*  full credit of original my authorship please!
                        ;*
                        ;*  RTSUBS.S
                        ;*  Module that implements the runtime execution of df
                        ;*  keywords and functions.
                        ;*  So this is where most of the action is for runtime
                        ;*  a line is being executed, the dflat runtime contro
                        ;*  jumps through the runtime table to routines here.
                        ;*  Every dflat statement begins with a token (ignorin
                        ;*  whitespace), even the implicit assignment and proc
                        ;*  invocation.
                        ;*
                        ;*****************************************************
                        
                        	; ROM code
                        	code  
                        
                        	include "dflat\numop.s"
                        ;*****************************************************
                        ;*
                        ;*	DOLO-1 HOMEBREW COMPUTER
                        ;*	Hardware and software design by Dolo Miah
                        ;*	Copyright 2014-18
                        ;*  Free to use for any non-commercial purpose subject
                        ;*  full credit of original my authorship please!
                        ;*
                        ;*  NUMOP.S
                        ;*	Dflat number AND string operators.
                        ;*  Uses the operator stack to get parameters, leaving
                        ;*  result on the operator stack.
                        ;*
                        ;*****************************************************
                        
                        	; ROM code
                        	code  
                        
                        ; common pushint code
ebf2 :                  df_rt_putintres
ebf2 : a68c             	ldx df_tmpptra
ebf4 : a58d             	lda df_tmpptra+1
ebf6 : 18               	clc
ebf7 : 4c20fa           	jmp df_st_pushInt
                        
                        ; add two numbers
ebfa :                  df_rt_add
ebfa : 2029e9           	jsr df_rt_get2Ints
                        	_addZPWord df_tmpptra,df_tmpptrb
                        
ec0a : 80e6             	jmp df_rt_putintres
                        	
                        ; subtract
ec0c :                  df_rt_sub
ec0c : 2029e9           	jsr df_rt_get2Ints
                        	_subZPWord df_tmpptra,df_tmpptrb
                        
ec1c : 80d4             	jmp df_rt_putintres
                        
                        ; multiply
ec1e :                  df_rt_mult
AS65 Assembler for R6502 [1.42].                                     Page  187
------------------------------ kernel\kernel.s -------------------------------

ec1e : 2029e9           	jsr df_rt_get2Ints
                        	_cpyZPWord df_tmpptra,num_a
                        
                        	_cpyZPWord df_tmpptrb,num_b
                        
ec31 : 2025d0           	jsr int_mult
                        	_cpyZPWord num_a,df_tmpptra
                        
ec3c : 80b4             	jmp df_rt_putintres
                        
                        ; divide
ec3e :                  df_rt_div
ec3e : 2029e9           	jsr df_rt_get2Ints
                        	_cpyZPWord df_tmpptra,num_a
                        
                        	_cpyZPWord df_tmpptrb,num_b
                        
ec51 : 204ed0           	jsr int_div
                        	_cpyZPWord num_a,df_tmpptra
                        
ec5c : 8094             	jmp df_rt_putintres
                        
                        ; mod
ec5e :                  df_rt_mod
ec5e : 2029e9           	jsr df_rt_get2Ints
                        	_cpyZPWord df_tmpptra,num_a
                        
                        	_cpyZPWord df_tmpptrb,num_b
                        
ec71 : 204ed0           	jsr int_div
                        	_cpyZPWord num_x,df_tmpptra
                        
ec7c : 4cf2eb           	jmp df_rt_putintres
                        
                        ; shift left
ec7f :                  df_rt_asl
ec7f : 2029e9           	jsr df_rt_get2Ints
                        	; use low byte only for # of shifts
ec82 : a68e             	ldx df_tmpptrb
ec84 : e8               	inx
ec85 :                  df_rt_aslbit
ec85 : ca               	dex
ec86 : f006             	beq df_rt_asldone
ec88 : 068c             	asl df_tmpptra
ec8a : 268d             	rol df_tmpptra+1
ec8c : 80f7             	bra df_rt_aslbit
ec8e :                  df_rt_asldone
ec8e : 4cf2eb           	jmp df_rt_putintres
                        
                        ; shift right
ec91 :                  df_rt_lsr
ec91 : 2029e9           	jsr df_rt_get2Ints
                        	; use low byte only for # of shifts
ec94 : a68e             	ldx df_tmpptrb
ec96 : e8               	inx
ec97 :                  df_rt_lsrbit
ec97 : ca               	dex
ec98 : f006             	beq df_rt_lsrdone
ec9a : 468d             	lsr df_tmpptra+1
ec9c : 668c             	ror df_tmpptra
ec9e : 80f7             	bra df_rt_lsrbit
eca0 :                  df_rt_lsrdone
AS65 Assembler for R6502 [1.42].                                     Page  188
------------------------------ kernel\kernel.s -------------------------------

eca0 : 4cf2eb           	jmp df_rt_putintres
                        
                        ; common routine push true
eca3 :                  df_rt_true
eca3 : a2ff             	ldx #0xff
eca5 : a9ff             	lda #0xff
eca7 : 18               	clc
eca8 : 4c20fa           	jmp df_st_pushInt
                        
                        ; common routine push false
ecab :                  df_rt_false
ecab : a200             	ldx #0x00
ecad : a900             	lda #0x00
ecaf : 18               	clc
ecb0 : 4c20fa           	jmp df_st_pushInt
                        
                        ; a == b
ecb3 :                  df_rt_eq
ecb3 : 2029e9           	jsr df_rt_get2Ints
ecb6 :                  df_rt_eq_chk			; used by other internal routines
ecb6 : a58c             	lda df_tmpptra
ecb8 : c58e             	cmp df_tmpptrb
ecba : d008             	bne df_rt_eq_false
ecbc : a58d             	lda df_tmpptra+1
ecbe : c58f             	cmp df_tmpptrb+1
ecc0 : d002             	bne df_rt_eq_false
ecc2 : 80df             	jmp df_rt_true
ecc4 :                  df_rt_eq_false
ecc4 : 80e5             	jmp df_rt_false
                        
                        ; a <> b
ecc6 :                  df_rt_ne
ecc6 : 2029e9           	jsr df_rt_get2Ints
ecc9 : a58c             	lda df_tmpptra
eccb : c58e             	cmp df_tmpptrb
eccd : f002             	beq df_rt_ne_tryhi
eccf :                  df_rt_ne_true
eccf : 80d2             	jmp df_rt_true
ecd1 :                  df_rt_ne_tryhi
ecd1 : a58c             	lda df_tmpptra
ecd3 : c58e             	cmp df_tmpptrb
ecd5 : d0f8             	bne df_rt_ne_true
ecd7 : 80d2             	jmp df_rt_false
                        
                        ; a <= b
ecd9 :                  df_rt_lte
                        	; a <=b == (a-b) <= 0
ecd9 : 2029e9           	jsr df_rt_get2Ints
ecdc :                  df_rt_lte_calc
ecdc : 38               	sec
ecdd : a58c             	lda df_tmpptra
ecdf : e58e             	sbc df_tmpptrb
ece1 : a58d             	lda df_tmpptra+1
ece3 : e58f             	sbc df_tmpptrb+1
ece5 : 9002             	bcc df_rt_lte_true
ece7 : 80cd             	jmp df_rt_eq_chk
ece9 :                  df_rt_lte_true
ece9 : 80b8             	jmp df_rt_true
                        
                        ; a < b == (a-b) < 0
eceb :                  df_rt_lt
eceb : 2029e9           	jsr df_rt_get2Ints
AS65 Assembler for R6502 [1.42].                                     Page  189
------------------------------ kernel\kernel.s -------------------------------

ecee : 38               	sec
ecef : a58c             	lda df_tmpptra
ecf1 : e58e             	sbc df_tmpptrb
ecf3 : a58d             	lda df_tmpptra+1
ecf5 : e58f             	sbc df_tmpptrb+1
ecf7 : 9002             	bcc df_rt_lt_true
ecf9 : 80b0             	jmp df_rt_false
ecfb :                  df_rt_lt_true
ecfb : 80a6             	jmp df_rt_true
                        
                        ; a >= b == (b-a) <= 0
ecfd :                  df_rt_gte
ecfd : 2029e9           	jsr df_rt_get2Ints
ed00 : 38               	sec
ed01 : a58e             	lda df_tmpptrb
ed03 : e58c             	sbc df_tmpptra
ed05 : a58f             	lda df_tmpptrb+1
ed07 : e58d             	sbc df_tmpptra+1
ed09 : 9002             	bcc df_rt_gte_true
ed0b : 80a9             	jmp df_rt_eq_chk
ed0d :                  df_rt_gte_true
ed0d : 8094             	jmp df_rt_true
                        
                        ; a > b == (b-a) < 0
ed0f :                  df_rt_gt
ed0f : 2029e9           	jsr df_rt_get2Ints
ed12 : 38               	sec
ed13 : a58e             	lda df_tmpptrb
ed15 : e58c             	sbc df_tmpptra
ed17 : a58f             	lda df_tmpptrb+1
ed19 : e58d             	sbc df_tmpptra+1
ed1b : 9002             	bcc df_rt_gt_true
ed1d : 808c             	jmp df_rt_false
ed1f :                  df_rt_gt_true
ed1f : 8082             	jmp df_rt_true
                        
                        ; logical and
ed21 :                  df_rt_and
ed21 : 2029e9           	jsr df_rt_get2Ints
ed24 : a58c             	lda df_tmpptra
ed26 : 258e             	and df_tmpptrb
ed28 : aa               	tax
ed29 : a58d             	lda df_tmpptra+1
ed2b : 258f             	and df_tmpptrb+1
ed2d : 4c20fa           	jmp df_st_pushInt
                        	
                        ; logical or
ed30 :                  df_rt_or
ed30 : 2029e9           	jsr df_rt_get2Ints
ed33 : a58c             	lda df_tmpptra
ed35 : 058e             	ora df_tmpptrb
ed37 : aa               	tax
ed38 : a58d             	lda df_tmpptra+1
ed3a : 058f             	ora df_tmpptrb+1
ed3c : 4c20fa           	jmp df_st_pushInt
                        
                        ;********** STRING OPS **********
                        
                        ; common string comparator
ed3f :                  df_rt_str_comp
ed3f : 2038e9           	jsr df_rt_get2Strs
ed42 : a000             	ldy #0
AS65 Assembler for R6502 [1.42].                                     Page  190
------------------------------ kernel\kernel.s -------------------------------

ed44 :                  df_rt_str_comp_byte
ed44 : b18c             	lda (df_tmpptra),y
ed46 : d18e             	cmp (df_tmpptrb),y
                        	; if c=0 then <
ed48 : 9009             	bcc df_rt_str_comp_lt
                        	; if c=1 and nz then >
ed4a : d00b             	bne df_rt_str_comp_gt
                        	; if string end then ==
ed4c : b18c             	lda (df_tmpptra),y
ed4e : f00b             	beq df_rt_str_comp_eq
ed50 : c8               	iny
ed51 : 80f1             	bra df_rt_str_comp_byte
ed53 :                  df_rt_str_comp_lt
ed53 : a9ff             	lda #0xff
ed55 : 18               	clc
ed56 : 60               	rts
ed57 :                  df_rt_str_comp_gt
ed57 : a901             	lda #0x01
ed59 : 18               	clc
ed5a : 60               	rts
ed5b :                  df_rt_str_comp_eq
ed5b : a900             	lda #0x00
ed5d : 18               	clc
ed5e : 60               	rts
                        
                        ; string less than or equal
ed5f :                  df_rt_slte
ed5f : 203fed           	jsr df_rt_str_comp
ed62 : c9ff             	cmp #0xff
ed64 : f007             	beq df_rt_str_comp_true
ed66 : c900             	cmp #0x00
ed68 : f003             	beq df_rt_str_comp_true
ed6a :                  df_rt_str_comp_false
ed6a : 4cabec           	jmp df_rt_false
ed6d :                  df_rt_str_comp_true
ed6d : 4ca3ec           	jmp df_rt_true	
                        
                        ; string greater then or equal	
ed70 :                  df_rt_sgte
ed70 : 203fed           	jsr df_rt_str_comp
ed73 : c9ff             	cmp #0xff
ed75 : f0f6             	beq df_rt_str_comp_true
ed77 : c900             	cmp #0x00
ed79 : f0f2             	beq df_rt_str_comp_true
ed7b : 80ed             	bra df_rt_str_comp_false
                        
                        ; string not equal
ed7d :                  df_rt_sne
ed7d : 203fed           	jsr df_rt_str_comp
ed80 : c900             	cmp #0x00
ed82 : d0e9             	bne df_rt_str_comp_true
ed84 : 80e4             	bra df_rt_str_comp_false
                        
                        ; string less than
ed86 :                  df_rt_slt
ed86 : 203fed           	jsr df_rt_str_comp
ed89 : c9ff             	cmp #0xff
ed8b : f0e0             	beq df_rt_str_comp_true
ed8d : 80db             	bra df_rt_str_comp_false
                        
                        ; string greater than
ed8f :                  df_rt_sgt
AS65 Assembler for R6502 [1.42].                                     Page  191
------------------------------ kernel\kernel.s -------------------------------

ed8f : 203fed           	jsr df_rt_str_comp
ed92 : c901             	cmp #0x01
ed94 : f0d7             	beq df_rt_str_comp_true
ed96 : 80d2             	bra df_rt_str_comp_false
                        
                        ; string equal
ed98 :                  df_rt_seq
ed98 : 203fed           	jsr df_rt_str_comp
ed9b : c900             	cmp #0x00
ed9d : f0ce             	beq df_rt_str_comp_true
ed9f : 80c9             	bra df_rt_str_comp_false
                        
                        
eda1 :                  df_rt_new
eda1 : 4c75fa           	jmp df_clear
                        	
eda4 :                  df_rt_while
                        	; push statement address
eda4 : 208cea           	jsr df_rt_push_stat
                        	; DFRT_WHILE token
eda7 : a98e             	lda #DFRT_WHILE
eda9 : 20d7f9           	jsr df_st_pushByte
                        
                        	; get value in A,X
edac : 2046e7           	jsr df_rt_getnval
                        
                        	; if value<>0 then continue
edaf : e000             	cpx #0
edb1 : f001             	beq df_rt_while_done
edb3 : 60               	rts
edb4 :                  df_rt_while_done
                        	; pop while data off stack as not needed
edb4 : 20e0f9           	jsr df_st_popByte
edb7 : 20e0f9           	jsr df_st_popByte
edba : 20fef9           	jsr df_st_popWord
                        	; while evaluated false so find wend
                        	; but check for any nested while/wends
                        	; nest = 1 to start
edbd : a59e             	lda df_ifnest
edbf : 48               	pha
edc0 : a901             	lda #1
edc2 : 859e             	sta df_ifnest
                        	; find the matching else/elseif/endif
                        	; start from current statement
                        	_cpyZPWord df_currlin,df_nextlin
                        
edcc :                  df_rt_findwend
edcc : a68a             	ldx df_nextlin
edce : a58b             	lda df_nextlin+1
edd0 : a481             	ldy df_curstidx
edd2 : 205cea           	jsr df_rt_nextstat
                        	; got to end of program, then a problem
edd5 : b030             	bcs df_rt_wend_end
edd7 : 868a             	stx df_nextlin
edd9 : 858b             	sta df_nextlin+1
eddb : 8481             	sty df_curstidx
                        	; find the command token
eddd :                  df_rt_while_cmd
eddd : c8               	iny
edde : b18a             	lda (df_nextlin),y
ede0 : 10fb             	bpl df_rt_while_cmd
                        	; check for wend
AS65 Assembler for R6502 [1.42].                                     Page  192
------------------------------ kernel\kernel.s -------------------------------

ede2 : c98f             	cmp #DFRT_WEND
ede4 : d019             	bne df_rt_check_while
                        	; decrement nest
ede6 : c69e             	dec df_ifnest
                        	; if not zero then go find more commands
ede8 : d0e2             	bne df_rt_findwend
                        	; else found it, restore if nest
                        	; and skip the wend statement
edea : 68               	pla
edeb : 859e             	sta df_ifnest
eded : a68a             	ldx df_nextlin
edef : a58b             	lda df_nextlin+1
edf1 : a481             	ldy df_curstidx
edf3 : 205cea           	jsr df_rt_nextstat
                        	; got to end of program, then a problem
edf6 : b00f             	bcs df_rt_wend_end
                        	; need to update tokstidx to transfer control
edf8 : 868a             	stx df_nextlin
edfa : 858b             	sta df_nextlin+1
edfc : 8480             	sty df_tokstidx	
edfe : 60               	rts
edff :                  df_rt_check_while
                        	; check for while
edff : c98e             	cmp #DFRT_WHILE
ee01 : d0c9             	bne df_rt_findwend
                        	; if while found then increment nest
ee03 : e69e             	inc df_ifnest
ee05 : 80c5             	bra df_rt_findwend
ee07 :                  df_rt_wend_end
                        	SWBRK DFERR_IMMEDIATE
                        
                        
ee09 :                  df_rt_wend
ee09 : 20e0f9           	jsr df_st_popByte
ee0c : c98e             	cmp #DFRT_WHILE
ee0e : d00d             	bne df_rt_wend_err
                        	; pop the stat and continue
ee10 : 20fef9           	jsr df_st_popWord
ee13 : 868a             	stx	df_nextlin
ee15 : 858b             	sta df_nextlin+1
ee17 : 20e0f9           	jsr df_st_popByte
ee1a : 8580             	sta df_tokstidx
ee1c : 60               	rts
ee1d :                  df_rt_wend_err
                        	SWBRK DFERR_WEND
                        
                        
                        ;move to next statement during if/else matching
                        ;end of program is an error
ee1f :                  df_rt_if_stat
ee1f : a68a             	ldx df_nextlin
ee21 : a58b             	lda df_nextlin+1
ee23 : a481             	ldy df_curstidx
ee25 : 205cea           	jsr df_rt_nextstat
                        	; got to end of program, then a problem
ee28 : b009             	bcs df_rt_if_stat_err
ee2a : 868a             	stx df_nextlin
ee2c : 858b             	sta df_nextlin+1
ee2e : 8481             	sty df_curstidx
ee30 : 8480             	sty df_tokstidx
ee32 : 60               	rts
                        ; program ended with no match
AS65 Assembler for R6502 [1.42].                                     Page  193
------------------------------ kernel\kernel.s -------------------------------

ee33 :                  df_rt_if_stat_err
                        	SWBRK DFERR_UNCLOSEDIF
                        
                        	
                        ; find matching else/elseif/endif
                        ; C = 0 match else/elseif/endif
                        ; C = 1 match endif only
                        ; endif is always matched
                        ; ** MAKE SURE NEXTLIN IS POPULATED! **
ee35 :                  df_rt_if_match
                        	; save the current if nest level
ee35 : a59e             	lda df_ifnest
ee37 : 48               	pha
                        	; local if nest level is zero to start with
ee38 : 649e             	stz df_ifnest	
                        	; save match pref
ee3a : 08               	php
                        	; find the matching else/elseif/endif
                        	; start from df_nextlin, df_curstidx
ee3b :                  df_rt_findelseendif
ee3b : 201fee           	jsr df_rt_if_stat
                        	; find command
ee3e :                  df_rt_ifcmd
ee3e : c8               	iny
ee3f : b18a             	lda (df_nextlin),y
ee41 : 10fb             	bpl df_rt_ifcmd
                        	; check for endif
ee43 : c992             	cmp #DFRT_ENDIF
ee45 : f014             	beq df_rt_ifelse
                        
ee47 : 28               	plp
ee48 : 08               	php
                        	
ee49 : b008             	bcs df_rt_ifskipelseif
ee4b : c991             	cmp #DFRT_ELSE
ee4d : f00c             	beq df_rt_ifelse
ee4f : c993             	cmp #DFRT_ELSEIF
ee51 : f008             	beq df_rt_ifelse
ee53 :                  df_rt_ifskipelseif
                        	; another if token found - increment lcoal if nest le
ee53 : c990             	cmp #DFRT_IF
ee55 : d002             	bne df_rt_skipnestif
ee57 : e69e             	inc df_ifnest
ee59 :                  df_rt_skipnestif
                        	; no tokens of interest found, so next statement
ee59 : 80e0             	bra df_rt_findelseendif
                        	
                        	; found else/elseif/endif
                        	; but check if this is nested
ee5b :                  df_rt_ifelse
                        	; nest counter zero then found matching else/elseif/e
ee5b : a69e             	ldx df_ifnest
ee5d : f008             	beq df_rt_if_found
                        	; endif token found so decrement local nest
ee5f : c992             	cmp #DFRT_ENDIF
ee61 : d002             	bne df_rt_skipnestendif
ee63 : c69e             	dec df_ifnest
ee65 :                  df_rt_skipnestendif	
                        	; continue to search for else/endif
ee65 : 80d4             	bra df_rt_findelseendif
                        	; ok got a match
ee67 :                  df_rt_if_found
AS65 Assembler for R6502 [1.42].                                     Page  194
------------------------------ kernel\kernel.s -------------------------------

                        	; remove pref
ee67 : 28               	plp
                        	; restore global if nest
ee68 : fa               	plx
ee69 : 869e             	stx df_ifnest
                        
                        	;A contains the token found, Y is index in to df_next
ee6b : 18               	clc
ee6c : 60               	rts
                        
ee6d :                  df_rt_endif
                        	; decrement if next level
ee6d : c69e             	dec df_ifnest
ee6f : 3011             	bmi df_rt_noif_err
ee71 : 18               	clc
ee72 : 60               	rts
                        	
                        	; else and ifelse encountered in a normal sequence
                        	; only happens when the clause has been executed
                        	; so we only now need to find the endif
ee73 :                  df_rt_elseif
ee73 :                  df_rt_else
                        	; not in if mode then error
ee73 : a59e             	lda df_ifnest
ee75 : f00b             	beq df_rt_noif_err
                        	; find endif only
                        	; starting from current line and curstidx
                        	_cpyZPWord df_currlin,df_nextlin
                        
ee7f : 38               	sec
ee80 : 80b3             	jmp df_rt_if_match
                        
                        ; endif/else/elseif encountered outside of an if	
ee82 :                  df_rt_noif_err
                        	SWBRK DFERR_NOIF
                        
                        	
                        	; when if is encountered, the job of this routine is
                        	; to determine which clause to execute, then transfer
                        	; program control to that point.  in normal program
                        	; sequence else/elseif statements will signify the en
                        	; of an if construct.
ee84 :                  df_rt_if
                        	; increment global if nest counter
ee84 : e69e             	inc df_ifnest
ee86 :                  df_rt_ifeval
                        	; get value
ee86 : 2046e7           	jsr df_rt_getnval
                        	; if value<>0 if is successful then continue normal s
ee89 : c900             	cmp #0
ee8b : d035             	bne df_rt_if_done
ee8d : e000             	cpx #0
ee8f : d031             	bne df_rt_if_done
                        	; got here then if clause evaluated to false
                        	; match with else/elseif/endif
                        	; df_nextlin is used to find the clause to execute
                        	_cpyZPWord df_currlin,df_nextlin
                        
ee99 : 18               	clc						
ee9a : 2035ee           	jsr df_rt_if_match
                        	; A contains the token found, Y is index of this toke
                        
AS65 Assembler for R6502 [1.42].                                     Page  195
------------------------------ kernel\kernel.s -------------------------------

ee9d : c991             	cmp #DFRT_ELSE
                        	; else: df_nextlin and df_tokstidx points to the stat
ee9f : f01e             	beq df_rt_do_else
                        
eea1 : c992             	cmp #DFRT_ENDIF
                        	; else: df_nextlin and df_tokstidx points to the stat
eea3 : f01d             	beq df_rt_if_done
                        
                        	; elif detected - increment past the token and evalua
                        	; make this the current line and token index
                        	_cpyZPWord df_nextlin,df_currlin
                        
                        	; move past the token and save position
eead : c8               	iny
eeae : 5a               	phy
                        	; initialise statement pointer
eeaf : a481             	ldy df_curstidx
eeb1 : a687             	ldx df_currlin
eeb3 : a588             	lda df_currlin+1
eeb5 : 20ebe9           	jsr df_rt_init_stat_ptr
                        	; restore Y (one byte past the token) and save in exe
eeb8 : 7a               	ply
eeb9 : 8489             	sty df_exeoff
                        	; don't force a jump as we've initalised all vars her
eebb : 648b             	stz df_nextlin+1
                        	; now everyting is set up to evaluate the elif condit
eebd : 80c7             	bra df_rt_ifeval
                        	
eebf :                  df_rt_do_else
                        	; we need to point to the next statement not this one
eebf : 201fee           	jsr df_rt_if_stat
eec2 :                  df_rt_if_done
eec2 : 18               	clc
eec3 : 60               	rts
                        	
eec4 :                  df_rt_for
                        	; push statement address to rt stack
eec4 : 208cea           	jsr df_rt_push_stat
                        	; get lvar
eec7 : 20feea           	jsr df_rt_getlvar
                        	; Save lvar pointer
eeca : 48               	pha
eecb : da               	phx
eecc : e689             	inc df_exeoff
                        
                        	; find starting value
eece : 20f1ea           	jsr df_rt_findescval
                        	; evaluate the starting value
                        	; can't use df_rt_getnval as need to use A,X first
eed1 : 209ce6           	jsr df_rt_neval
                        	; get ready to update the counter
eed4 : fa               	plx
eed5 : 868c             	stx df_tmpptra
eed7 : 68               	pla
eed8 : 858d             	sta df_tmpptra+1
eeda : 48               	pha
eedb : da               	phx
                        	; get the starting value from op stack
eedc : 204dfa           	jsr df_st_popInt
                        	; save it to counter slot
eedf : a001             	ldy #1
eee1 : 918c             	sta (df_tmpptra),y
AS65 Assembler for R6502 [1.42].                                     Page  196
------------------------------ kernel\kernel.s -------------------------------

eee3 : 8a               	txa
eee4 : 88               	dey
eee5 : 928c             	sta (df_tmpptra)
                        
                        	; find end value
eee7 : 20f1ea           	jsr df_rt_findescval
                        	; evaluate the end value
eeea : 2046e7           	jsr df_rt_getnval
                        	; and put on rt stack
eeed : 20f0f9           	jsr df_st_pushWord
                        
                        	; find step value
eef0 : 20f1ea           	jsr df_rt_findescval
                        	; evaluate the end value
eef3 : 2046e7           	jsr df_rt_getnval
                        	; and push on rt stack
eef6 : 20f0f9           	jsr df_st_pushWord
                        	; save the counter slot address
eef9 : fa               	plx
eefa : 68               	pla
eefb : 20f0f9           	jsr df_st_pushWord
                        	; all done - counter set to start
                        	; stack contains counter slot, step val, end val, nex
                        	; now push for token
eefe : a98c             	lda #DFRT_FOR
ef00 : 20d7f9           	jsr df_st_pushByte
ef03 : 60               	rts
                        
ef04 :                  df_rt_next
                        	; remember stack position
ef04 : a477             	ldy df_rtstop
ef06 : 5a               	phy
ef07 : 20e0f9           	jsr df_st_popByte
ef0a : c98c             	cmp #DFRT_FOR
ef0c : d046             	bne df_rt_next_err
                        	; get the slot address
ef0e : 20fef9           	jsr df_st_popWord
                        	; save address to ptrd, contents to ptra
ef11 : 8692             	stx df_tmpptrd
ef13 : 8593             	sta df_tmpptrd+1
ef15 : b292             	lda (df_tmpptrd)
ef17 : 858c             	sta df_tmpptra
ef19 : a001             	ldy #1
ef1b : b192             	lda (df_tmpptrd),y
ef1d : 858d             	sta df_tmpptra+1
                        	
                        	; get step value, save in ptrb
ef1f : 20fef9           	jsr df_st_popWord
ef22 : 868e             	stx df_tmpptrb
ef24 : 858f             	sta df_tmpptrb+1
                        
                        	; add step to counter and save back to counter
                        	_addZPWord df_tmpptra,df_tmpptrb
                        
ef33 : a58c             	lda df_tmpptra
ef35 : 9292             	sta (df_tmpptrd)
ef37 : a001             	ldy #1
ef39 : a58d             	lda df_tmpptra+1
ef3b : 9192             	sta (df_tmpptrd),y
                        	
                        	; get end value, save in ptrb
ef3d : 20fef9           	jsr df_st_popWord
AS65 Assembler for R6502 [1.42].                                     Page  197
------------------------------ kernel\kernel.s -------------------------------

ef40 : 868e             	stx df_tmpptrb
ef42 : 858f             	sta df_tmpptrb+1
                        	
                        	; call lte operation but no need to get ints
                        	; as already in ptra and ptrb
ef44 : 20dcec           	jsr df_rt_lte_calc
                        	; check if true or false
ef47 : 204dfa           	jsr df_st_popInt
ef4a : e000             	cpx #0
                        	; if false then next is done
ef4c : f003             	beq df_next_done
                        	; else we continue
ef4e : 4c12eb           	jmp df_rt_pop_stat_go
                        	; if done, then continue with next statement
ef51 :                  df_next_done
ef51 : 4c73ef           	jmp df_rt_untilnext_done
                        	
ef54 :                  df_rt_next_err
                        	SWBRK DFERR_NEXTFOR
                        
                        
                        	
ef56 :                  df_rt_repeat
                        	; push statement address
ef56 : 208cea           	jsr df_rt_push_stat
                        	; DFRT_REPEAT token
ef59 : a98a             	lda #DFRT_REPEAT
ef5b : 20d7f9           	jsr df_st_pushByte
ef5e : 60               	rts
                        	
ef5f :                  df_rt_until
                        	; remember stack position
ef5f : a477             	ldy df_rtstop
ef61 : 5a               	phy
ef62 : 20e0f9           	jsr df_st_popByte
ef65 : c98a             	cmp #DFRT_REPEAT
ef67 : d013             	bne df_rt_until_err
                        	; evaluate expression in to A,X
ef69 : 2046e7           	jsr df_rt_getnval
                        	; if value<>0 then continue
ef6c : e000             	cpx #0
ef6e : d003             	bne df_rt_untilnext_done
                        
                        	; pop the stat and continue
ef70 : 4c12eb           	jmp df_rt_pop_stat_go
                        
ef73 :                  df_rt_untilnext_done
ef73 : 7a               	ply
                        	; pop 2 items off stack (line address, index)
ef74 : 20fef9           	jsr df_st_popWord
ef77 : 20e0f9           	jsr df_st_popByte
                        	; and continue
ef7a : 18               	clc
ef7b : 60               	rts
                        
ef7c :                  df_rt_until_err
                        	SWBRK DFERR_UNTIL
                        
                        	
ef7e :                  df_rt_sadd
ef7e : 18               	clc
ef7f : 60               	rts
AS65 Assembler for R6502 [1.42].                                     Page  198
------------------------------ kernel\kernel.s -------------------------------

                        	
ef80 :                  df_rt_print_num
ef80 : 204dfa           	jsr df_st_popInt
ef83 : 18               	clc
ef84 : 20c5cf           	jsr print_a_to_d
ef87 : 60               	rts
                        	
ef88 :                  df_rt_print_str
ef88 : 2051fa           	jsr df_st_popStr
ef8b : 868c             	stx df_tmpptra
ef8d : 858d             	sta df_tmpptra+1
ef8f : a000             	ldy #0
ef91 :                  df_rt_print_str_ch
ef91 : b18c             	lda (df_tmpptra),y
ef93 : f006             	beq df_rt_print_str_done
ef95 : 2029d9           	jsr io_put_ch
ef98 : c8               	iny
ef99 : 80f6             	bra df_rt_print_str_ch
ef9b :                  df_rt_print_str_done
ef9b : 18               	clc
ef9c : 60               	rts
                        
                        ; * Find the position of the next data item to read
ef9d :                  df_rt_nextdatum
                        	; load data line offset
ef9d : a4a1             	ldy df_datoff 
                        	; if data pointer unitialised (because high byte == 0
ef9f : a5a0             	lda df_currdat+1
efa1 : d02f             	bne df_rt_skipinitdataptr
                        	; then start at program beginning
                        	_cpyZPWord df_prgstrt,df_currdat
                        
efab :                  df_rt_datlinstart
                        	; if end of program then error
efab : b29f             	lda (df_currdat)
efad : f034             	beq df_rt_datumerr
                        	; index in to first line byte
efaf : a003             	ldy #3
efb1 : 84a1             	sty df_datoff
                        	; find first 'data' statement
efb3 :                  df_rt_datastatement
efb3 : c8               	iny
efb4 : 98               	tya
                        	; end of line reached?
efb5 : d29f             	cmp (df_currdat)
                        	; if not find data token
efb7 : d00f             	bne df_rt_getdatatk
efb9 :                  df_rt_datnextlin
                        	; if so then go to next line
efb9 : 18               	clc
efba : a59f             	lda df_currdat
efbc : 729f             	adc (df_currdat)
efbe : 859f             	sta df_currdat
efc0 : a5a0             	lda df_currdat+1
efc2 : 6900             	adc #0
efc4 : 85a0             	sta df_currdat+1
efc6 : 80e3             	bra df_rt_datlinstart
efc8 :                  df_rt_getdatatk
efc8 : b19f             	lda (df_currdat),y
efca : 10e7             	bpl df_rt_datastatement
                        	; found data statement?
efcc : c994             	cmp #DFRT_DATA
AS65 Assembler for R6502 [1.42].                                     Page  199
------------------------------ kernel\kernel.s -------------------------------

                        	; if not then go to next line	
efce : d0e9             	bne df_rt_datnextlin
efd0 : 84a1             	sty df_datoff	
efd2 :                  df_rt_skipinitdataptr
efd2 : 98               	tya
                        	; end of line reached?
efd3 : d29f             	cmp (df_currdat)
                        	; if so go to next line
efd5 : f0e2             	beq df_rt_datnextlin
                        	; else see if escape value
efd7 : b19f             	lda (df_currdat),y
efd9 : c920             	cmp #DFTK_ESCVAL
efdb : c8               	iny
efdc : b0f4             	bcs df_rt_skipinitdataptr
                        	; ok found an escape value
                        	; save position and return
efde : 88               	dey
efdf : 84a1             	sty df_datoff
efe1 : 18               	clc
efe2 : 60               	rts
efe3 :                  df_rt_datumerr
                        	SWBRK DFERR_NODATA
                        
                        
                        ; read a datum
efe5 :                  df_rt_readdatum
                        	; update data pointer to next data item
efe5 : 209def           	jsr df_rt_nextdatum
                        
                        	; now get lvar X,A from current statement
efe8 : 20feea           	jsr df_rt_getlvar
                        	; save lvar in tmpb, vvt ptr in tmpa
efeb : 868e             	stx df_tmpptrb
efed : 858f             	sta df_tmpptrb+1
                        		
                        	; first save save current prgoram line and offset
efef : a587             	lda df_currlin
eff1 : 48               	pha
eff2 : a588             	lda df_currlin+1
eff4 : 48               	pha
eff5 : a589             	lda df_exeoff
eff7 : 48               	pha
eff8 : a57f             	lda df_eolidx
effa : 48               	pha
effb : a580             	lda df_tokstidx
effd : 48               	pha
effe : a581             	lda df_curstidx
f000 : 48               	pha
                        
                        	; use data pointer as current position for evalution 
                        	_cpyZPWord df_currdat,df_currlin
                        
f009 : a5a1             	lda df_datoff
f00b : 8589             	sta df_exeoff
f00d : b29f             	lda (df_currdat)
f00f : 857f             	sta df_eolidx
f011 : 6480             	stz df_tokstidx
f013 : a903             	lda #3
f015 : 8581             	sta df_curstidx
                        	
                        	; get type from vvt ptr in tmpa
f017 : b28c             	lda (df_tmpptra)
AS65 Assembler for R6502 [1.42].                                     Page  200
------------------------------ kernel\kernel.s -------------------------------

f019 : a8               	tay
                        	; get lvar point from tmpb
f01a : a68e             	ldx df_tmpptrb
f01c : a58f             	lda df_tmpptrb+1
                        	
                        	; X,A and Y set up, now evaluate and perform assignme
f01e : 204af2           	jsr df_rt_doassign
                        
                        	; update data offset as data has been consumed
f021 : a589             	lda df_exeoff
f023 : 85a1             	sta df_datoff
                        	; restore line settings
f025 : 68               	pla
f026 : 8581             	sta df_curstidx
f028 : 68               	pla
f029 : 8580             	sta df_tokstidx
f02b : 68               	pla
f02c : 857f             	sta df_eolidx
f02e : 68               	pla
f02f : 8589             	sta df_exeoff
f031 : 68               	pla
f032 : 8588             	sta df_currlin+1
f034 : 68               	pla
f035 : 8587             	sta df_currlin
f037 : 60               	rts
                        
                        
f038 :                  df_rt_read
f038 : 20e5ef           	jsr df_rt_readdatum
f03b : e689             	inc df_exeoff
                        	; get line length
f03d : b287             	lda (df_currlin)
                        	; check if line done
f03f : c589             	cmp df_exeoff
f041 : d0f5             	bne df_rt_read
f043 : 60               	rts
                        
f044 :                  df_rt_input
                        	; df_tmpptra has the vvt address, X,A is the lvar ptr
f044 : 20feea           	jsr df_rt_getlvar
                        	; Save lvar pointer
f047 : 868e             	stx df_tmpptrb
f049 : 858f             	sta df_tmpptrb+1
                        	; go read a line of input
                        	; buf_lo ptr has the input, Y is size
f04b : 38               	sec
f04c : 2038d9           	jsr io_read_line
                        	; check the type
f04f : b28c             	lda (df_tmpptra)
f051 : 2904             	and #DFVVT_STR
f053 : d008             	bne df_rt_input_str
f055 : b28c             	lda (df_tmpptra)
f057 : 2903             	and #DFVVT_INT|DFVVT_BYT
f059 : d00b             	bne df_rt_input_num
                        	; if not int or byte then error
f05b : 8021             	bra df_rt_input_err
f05d :                  df_rt_input_str
f05d : b11b             	lda (buf_lo),y
f05f : 918e             	sta (df_tmpptrb),y
f061 : 88               	dey
f062 : 10f9             	bpl df_rt_input_str
f064 : 18               	clc
AS65 Assembler for R6502 [1.42].                                     Page  201
------------------------------ kernel\kernel.s -------------------------------

f065 : 60               	rts
                        
f066 :                  df_rt_input_num
                        	; X,A = address, linbuff must be on page boundary
f066 : a51c             	lda buf_lo+1
f068 : a61b             	ldx buf_lo
f06a : a000             	ldy #0				; any numeric format
f06c : 20f3cd           	jsr con_n_to_a
f06f : b00d             	bcs df_rt_input_err
f071 : a000             	ldy #0
f073 : a546             	lda num_a
f075 : 918e             	sta (df_tmpptrb),y
f077 : c8               	iny
f078 : a547             	lda num_a+1
f07a : 918e             	sta (df_tmpptrb),y
f07c : 18               	clc
f07d : 60               	rts
f07e :                  df_rt_input_err
                        	SWBRK DFERR_TYPEMISM
                        
                        	
f080 :                  df_rt_local
                        	; get current local count off rt stack
f080 : 20e0f9           	jsr df_st_popByte
                        	; save on pc stack for incrmenting
f083 : 48               	pha
f084 : a489             	ldy df_exeoff
f086 : 88               	dey
f087 :                  df_rt_local_findesc
f087 : c8               	iny
                        	; check end of line
f088 : c47f             	cpy df_eolidx
f08a : f019             	beq df_rt_local_done
f08c : c480             	cpy df_tokstidx
f08e : f015             	beq df_rt_local_done
                        	; find a var
f090 : b187             	lda (df_currlin),y
f092 : c911             	cmp #DFTK_VAR
f094 : d0f1             	bne df_rt_local_findesc
                        	; jump over escape value
f096 : c8               	iny
                        	; get var index
f097 : b187             	lda (df_currlin),y
f099 : 8489             	sty df_exeoff
                        	; localise this variable
f09b : 20bff9           	jsr df_rt_proc_local
                        	; increment local counter
f09e : 68               	pla
f09f : 1a               	inc a
f0a0 : 48               	pha
f0a1 : a489             	ldy df_exeoff
f0a3 : 80e2             	bra df_rt_local_findesc
f0a5 :                  df_rt_local_done
                        	; get the local counter
                        	; put on to rt stack
f0a5 : 68               	pla
f0a6 : 20d7f9           	jsr df_st_pushByte
f0a9 : 18               	clc
f0aa : 60               	rts
                        	
f0ab :                  df_rt_dim
f0ab : a489             	ldy df_exeoff
AS65 Assembler for R6502 [1.42].                                     Page  202
------------------------------ kernel\kernel.s -------------------------------

f0ad : 88               	dey
f0ae :                  df_rt_dim_findesc
                        	; check end of line
f0ae : c8               	iny
f0af : c47f             	cpy df_eolidx
f0b1 : f06e             	beq df_rt_dim_done
f0b3 : c480             	cpy df_tokstidx
f0b5 : f06a             	beq df_rt_dim_done
                        	; find a var
f0b7 : b187             	lda (df_currlin),y
f0b9 : c911             	cmp #DFTK_VAR
f0bb : d0f1             	bne df_rt_dim_findesc
                        	; jump over escape value
f0bd : c8               	iny
                        	; get var index
f0be : b187             	lda (df_currlin),y
                        	; move to open bracket
f0c0 : c8               	iny
f0c1 : 8489             	sty df_exeoff
                        	; Calcuate VVT slot address in to tmpa
f0c3 : 2027db           	jsr df_var_addr
                        	; check if already dim'd
f0c6 : a003             	ldy #DFVVT_DIM1
f0c8 : b18c             	lda (df_tmpptra),y
f0ca : d057             	bne df_rt_dim_err
                        	; Save slot address found earlier
f0cc : a58c             	lda df_tmpptra
f0ce : 48               	pha
f0cf : a58d             	lda df_tmpptra+1
f0d1 : 48               	pha
f0d2 : 2010e8           	jsr df_rt_arry_parm2
                        	; Restore slot address
f0d5 : 68               	pla
f0d6 : 858d             	sta df_tmpptra+1
f0d8 : 68               	pla
f0d9 : 858c             	sta df_tmpptra
                        ;	bcs df_rt_dim_err
                        	; save x,y to dim1,2
f0db : 5a               	phy
f0dc : da               	phx
f0dd : a003             	ldy #DFVVT_DIM1
f0df : 68               	pla
f0e0 : 918c             	sta (df_tmpptra),y
f0e2 : c8               	iny
f0e3 : 68               	pla
f0e4 : 918c             	sta (df_tmpptra),y	
f0e6 :                  df_rt_dim_alloc
                        	; ok we have up to 2 dimensions
                        	; mult dim 1 and 2 if dim 2 <> 0
f0e6 : a003             	ldy #DFVVT_DIM1
f0e8 : b18c             	lda (df_tmpptra),y
f0ea : 8546             	sta num_a
f0ec : 6447             	stz num_a+1
f0ee : c8               	iny
f0ef : b18c             	lda (df_tmpptra),y
f0f1 : d002             	bne df_rt_dim2_nz
f0f3 : a901             	lda #1
f0f5 :                  df_rt_dim2_nz
f0f5 : 854a             	sta num_b
f0f7 : 644b             	stz num_b+1
f0f9 : 20fecf           	jsr int_fast_mult
                        	; check the type if int then mult2
AS65 Assembler for R6502 [1.42].                                     Page  203
------------------------------ kernel\kernel.s -------------------------------

f0fc : b28c             	lda (df_tmpptra)
f0fe : 2901             	and #DFVVT_INT
f100 : f004             	beq df_rt_dim2_mul2
f102 : 0646             	asl num_a
f104 : 2647             	rol num_a+1
f106 :                  df_rt_dim2_mul2	
                        	; finally, we have a size of array
f106 : a646             	ldx num_a
f108 : a547             	lda num_a+1
                        
                        	; get a block of that size from heap
f10a : 2059fa           	jsr df_st_malloc
                        	; save pointer to block in var
f10d : a002             	ldy #DFVVT_HI
f10f : 918c             	sta (df_tmpptra),y
f111 : 8a               	txa
f112 : 88               	dey
f113 : 918c             	sta (df_tmpptra),y
                        	; finally, update the type to indicate array
f115 : b28c             	lda (df_tmpptra)
f117 : 0980             	ora #DFVVT_ARRY
f119 : 928c             	sta (df_tmpptra)
                        	; don't increment byte again - go check for more vars
f11b : 808e             	bra df_rt_dim	
f11d :                  df_rt_dim_next_byte
f11d : e689             	inc df_exeoff
f11f : 808a             	bra df_rt_dim
f121 :                  df_rt_dim_done
f121 : 18               	clc
f122 : 60               	rts
f123 :                  df_rt_dim_err
                        	SWBRK DFERR_DIM
                        
                        
f125 :                  df_rt_cls
                        	; set cursror position to top left first
f125 : a200             	ldx #0
f127 : a000             	ldy #0
f129 : 20fdcb           	jsr gr_set_cur_pos
f12c : 2045ca           	jsr gr_cls
f12f : 18               	clc
f130 : 60               	rts
                        	
f131 :                  df_rt_plot
                        	; evaluate the expression
f131 : 2046e7           	jsr df_rt_getnval
                        	; save lo byte
f134 : da               	phx
                        	; jump over comma
f135 : e689             	inc df_exeoff
                        	; evaluate the expression
f137 : 2046e7           	jsr df_rt_getnval
                        	; save lo byte
f13a : da               	phx
                        	; jump over comma
f13b : e689             	inc df_exeoff
                        	; evaluate the expression
f13d : 209ce6           	jsr df_rt_neval
                        	; check the type on the stack
f140 : 2045fa           	jsr df_st_peekType
                        	; if >=0x80 then a pointer / string
f143 : c080             	cpy #0x80
AS65 Assembler for R6502 [1.42].                                     Page  204
------------------------------ kernel\kernel.s -------------------------------

f145 : b00e             	bcs df_rt_plotstr
                        	; else it is int
f147 : 204dfa           	jsr df_st_popInt
                        	; put low byte of pop result in a
f14a : 8a               	txa
                        	; get y and x in that order
f14b : 7a               	ply
f14c : fa               	plx
                        	; set cursror position
f14d : 20fdcb           	jsr gr_set_cur_pos
                        	; plot the char in a
f150 : 206aca           	jsr gr_plot
f153 : 18               	clc
f154 : 60               	rts
f155 :                  df_rt_plotstr
                        	; pop string pointer
f155 : 2055fa           	jsr df_st_popPtr
                        	; save pointer to tmpa
f158 : 868c             	stx df_tmpptra
f15a : 858d             	sta df_tmpptra+1
                        	; get y and x in that order
f15c : 7a               	ply
f15d : fa               	plx
                        	; set cursror position
f15e :                  df_rt_plotstrch
f15e : 20fdcb           	jsr gr_set_cur_pos
f161 : b28c             	lda (df_tmpptra)
f163 : f00c             	beq df_rt_plotstrdone
                        	_incZPWord df_tmpptra
                        
f16b : 206aca           	jsr gr_plot
f16e : e8               	inx
f16f : 80ed             	bra df_rt_plotstrch
f171 :                  df_rt_plotstrdone
f171 : 18               	clc
f172 : 60               	rts
                        	
f173 :                  df_rt_cursor
                        	; evaluate the expression
f173 : 2046e7           	jsr df_rt_getnval
                        	; write low byte of vdp_curoff
                        	; by writing a zero then cursor on else not
f176 : 8607             	stx vdp_curoff
f178 : 18               	clc
f179 : 60               	rts
                        		
                        
f17a :                  df_rt_mode
                        	; evaluate the expression
f17a : 2046e7           	jsr df_rt_getnval
                        	; only interested in low byte
f17d : 8a               	txa
f17e : 203dca           	jsr gr_init_screen
f181 : 18               	clc
f182 : 60               	rts
                        
f183 :                  df_rt_hires
                        	; evaluate the expression X = colour fg/bg
f183 : 2046e7           	jsr df_rt_getnval
f186 : 2008ca           	jsr gr_init_screen_hires
f189 : 18               	clc
f18a : 60               	rts
AS65 Assembler for R6502 [1.42].                                     Page  205
------------------------------ kernel\kernel.s -------------------------------

                        	
f18b :                  df_rt_point
f18b : 205ee9           	jsr df_rt_parm_3ints
f18e : a68c             	ldx df_tmpptra
f190 : a48e             	ldy df_tmpptrb
f192 : a590             	lda df_tmpptrc
f194 : 207aca           	jsr gr_point
f197 : 18               	clc
f198 : 60               	rts
                        
f199 :                  df_rt_line
f199 : 20b0e9           	jsr df_rt_parm_5ints
f19c : a58c             	lda df_tmpptra				; load x0
f19e : 8546             	sta num_a
f1a0 : a58e             	lda	df_tmpptrb				; load y0
f1a2 : 8547             	sta num_a+1
f1a4 : a590             	lda df_tmpptrc				; load x1
f1a6 : 8548             	sta num_a+2
f1a8 : a592             	lda df_tmpptrd				; load y1
f1aa : 8549             	sta num_a+3
f1ac : a594             	lda df_tmpptre				; load mode
f1ae : 20c1ca           	jsr gr_line
f1b1 : 18               	clc
f1b2 : 60               	rts
                        	
f1b3 :                  df_rt_wait
                        	; evaluate the expression
f1b3 : 2046e7           	jsr df_rt_getnval
                        	; put high byte in to Y (X,Y)=16 bits
f1b6 : a8               	tay
f1b7 :                  df_rt_wait_counter
                        	; get vdp low byte timer val in A
f1b7 : a504             	lda vdp_cnt	
f1b9 :                  df_rt_wait_tick
                        	; check if a tick has occurred (i.e. val <> A)
f1b9 : c504             	cmp vdp_cnt
f1bb : f0fc             	beq df_rt_wait_tick
                        	; countdown tick
f1bd : ca               	dex
f1be : e0ff             	cpx #0xff
f1c0 : d001             	bne df_rt_wait_skiphi
f1c2 : 88               	dey
f1c3 :                  df_rt_wait_skiphi
f1c3 : e000             	cpx #0
f1c5 : d0f0             	bne df_rt_wait_counter
f1c7 : c000             	cpy #0
f1c9 : d0ec             	bne df_rt_wait_counter
f1cb : 18               	clc
f1cc : 60               	rts
                        	
f1cd :                  df_rt_print
f1cd : c689             	dec df_exeoff
f1cf :                  df_rt_print_ws
f1cf : e689             	inc df_exeoff
                        	; evaluate an expression
f1d1 : a489             	ldy df_exeoff
f1d3 : c47f             	cpy df_eolidx
f1d5 : f032             	beq df_rt_print_done
f1d7 : c480             	cpy df_tokstidx
f1d9 : f02e             	beq df_rt_print_done
f1db : b187             	lda (df_currlin),y
f1dd : c920             	cmp #' '
AS65 Assembler for R6502 [1.42].                                     Page  206
------------------------------ kernel\kernel.s -------------------------------

f1df : f0ee             	beq df_rt_print_ws
f1e1 : c92c             	cmp #','
f1e3 : f0ea             	beq df_rt_print_ws
                        	; save index
f1e5 : 8489             	sty df_exeoff
                        	
                        	; if starts with string literal then process seval
f1e7 : c910             	cmp #DFTK_STRLIT
f1e9 : f015             	beq df_rt_print_string
f1eb :                  df_rt_print_numeric
f1eb : 209ce6           	jsr df_rt_neval
                        	; check what is on the argument stack
f1ee : a478             	ldy df_parmtop
f1f0 : 88               	dey
f1f1 : b90007           	lda df_opstck,y
f1f4 : 3005             	bmi df_rt_print_gotstr
f1f6 : 2080ef           	jsr df_rt_print_num
f1f9 : 80d2             	bra df_rt_print
f1fb :                  df_rt_print_gotstr
f1fb : 2088ef           	jsr df_rt_print_str
f1fe : 80cd             	bra df_rt_print
f200 :                  df_rt_print_string
                        	; point to string accumulator
f200 : a67b             	ldx df_sevalptr
f202 : a57c             	lda df_sevalptr+1
f204 : 204ce7           	jsr df_rt_seval
f207 : 80f2             	bra df_rt_print_gotstr
f209 :                  df_rt_print_done
f209 : 18               	clc
f20a : 60               	rts
                        	
f20b :                  df_rt_println
f20b : 20cdf1           	jsr df_rt_print
f20e : a90d             	lda #UTF_CR
f210 : 2029d9           	jsr io_put_ch
f213 : 60               	rts
                        
                        
                        ; assign to a number variable
                        ; X,A must have lvar
f214 :                  df_rt_nassign
f214 : 48               	pha
f215 : da               	phx
                        	; now go evaluate expression in to A,X
f216 : 2046e7           	jsr df_rt_getnval
                        	; restore variable address to write to
f219 : 7a               	ply
f21a : 848c             	sty df_tmpptra
f21c : 7a               	ply
f21d : 848d             	sty df_tmpptra+1
                        	; save X,A int in contents section
f21f : a001             	ldy #1
f221 : 918c             	sta (df_tmpptra),y
f223 : 8a               	txa
f224 : a000             	ldy #0
f226 : 918c             	sta (df_tmpptra),y
                        
f228 : 18               	clc
f229 : 60               	rts
                        
                        ; assign to a string variable
                        ; X,A must have lvar
AS65 Assembler for R6502 [1.42].                                     Page  207
------------------------------ kernel\kernel.s -------------------------------

f22a :                  df_rt_sassign
                        	; now go evaluate expression
                        	; with the destination being X,A
f22a : 204ce7           	jsr df_rt_seval
                        
                        	; get string pointer from top of runtime stack
f22d : 2051fa           	jsr df_st_popStr
                        	
f230 : 18               	clc
f231 : 60               	rts
                        
                        ; generate lvar from a var token ready for assignment
f232 :                  df_rt_generate_lvar
                        	; move past escape val
f232 : e689             	inc df_exeoff
f234 : a489             	ldy df_exeoff
                        	; pointing to variable index
f236 : b187             	lda (df_currlin),y
                        	; get the vvt address
f238 : 2027db           	jsr df_var_addr
                        
                        	; get the type and save
f23b : b28c             	lda (df_tmpptra)
f23d : 48               	pha
                        
                        	; set carry flag to return pointer (lvar)
f23e : 38               	sec
f23f : 2031e8           	jsr df_rt_eval_var
f242 : 2055fa           	jsr df_st_popPtr
                        	; pull the type previously saved into Y
f245 : 7a               	ply
                        	; move past the lvar variable index
f246 : e689             	inc df_exeoff
f248 : 18               	clc
f249 : 60               	rts
                        
                        ; assign
                        ; X,A,Y contain lvar pointer and type
f24a :                  df_rt_doassign
                        	; save A and put type Y in to A
f24a : 48               	pha
f24b : 98               	tya
f24c : 2904             	and #DFVVT_STR
                        	; if a string then string expression
f24e : f003             	beq df_rt_assign_num
                        	; remember to restore A
                        	; jump to string expression evaluator
f250 : 68               	pla
f251 : 80d7             	jmp df_rt_sassign
f253 :                  df_rt_assign_num
                        	; else jump to numeric expression evaluator
                        	; remember to restore A
f253 : 68               	pla
f254 : 80be             	jmp df_rt_nassign
                        
                        ; general assignment execution
f256 :                  df_rt_assign
f256 : 2032f2           	jsr df_rt_generate_lvar
                        	; go and do the assignment
f259 : 80ef             	jmp df_rt_doassign
                        	
                        ; comment or data token is ignored by runtime
AS65 Assembler for R6502 [1.42].                                     Page  208
------------------------------ kernel\kernel.s -------------------------------

f25b :                  df_rt_comment
f25b :                  df_rt_data
f25b : 18               	clc
f25c : 60               	rts
                        
                        	
                        ; run token	
f25d :                  df_rt_run
f25d : 38               	sec
f25e : 60               	rts
                        
                        ; end of line / statement indicator
                        ; CS = End, CC = not end
f25f :                  df_rt_eos
f25f : a489             	ldy df_exeoff
f261 : c47f             	cpy df_eolidx
f263 : f006             	beq df_rt_eos_true
f265 : c480             	cpy df_tokstidx
f267 : f002             	beq df_rt_eos_true
f269 : 18               	clc
f26a : 60               	rts
f26b :                  df_rt_eos_true
f26b : 38               	sec
f26c : 60               	rts
                        
                        ; renum start,offset,increment
                        ; if increment == 0 then just add offset to the affect
                        ; if increment <> 0 then renumber from first affected 
                        ; renumbers from the first matching line to end of pro
f26d :                  df_rt_renum
f26d : e689             	inc df_exeoff
f26f : 205ee9           	jsr df_rt_parm_3ints
                        	; starting line number
f272 : a68c             	ldx df_tmpptra
f274 : a58d             	lda df_tmpptra+1
f276 : 20cde4           	jsr df_pg_find_line
f279 : 9002             	bcc df_rt_renum_ok
                        	SWBRK DFERR_NOLINE
                        
f27d :                  df_rt_renum_ok
                        	; save starting position in program
f27d : 8692             	stx df_tmpptrd
f27f : 8593             	sta df_tmpptrd+1
f281 :                  df_rt_renum_do
                        	; if not end of program
f281 : b292             	lda (df_tmpptrd)
                        	; then renumber this line
f283 : d001             	bne df_rt_renum_update
                        	; else done
f285 : 60               	rts
f286 :                  df_rt_renum_update
                        	; add offset to start line number
                        	; add increment to start line number
                        	; if increment <> 0 then update this line number with
                        	; if increment == 0 then add offset to this  line num
                        	
                        	; add offset to start line number
                        	_addZPWord df_tmpptra,df_tmpptrb
                        
                        	; if increment == 0 then update this line with start 
f293 : a590             	lda df_tmpptrc
f295 : 0591             	ora df_tmpptrc+1
AS65 Assembler for R6502 [1.42].                                     Page  209
------------------------------ kernel\kernel.s -------------------------------

f297 : f01a             	beq df_rt_renum_mode2
                        	; mode 1 means increment <> 0
                        	; so set this line number to current value of start l
f299 : a001             	ldy #DFTK_LINNUM
f29b : a58c             	lda df_tmpptra
f29d : 9192             	sta (df_tmpptrd),y
f29f : c8               	iny
f2a0 : a58d             	lda df_tmpptra+1
f2a2 : 9192             	sta (df_tmpptrd),y
                        	; add increment to start line
                        	_addZPWord df_tmpptra,df_tmpptrc
                        
f2b1 : 8010             	bra df_rt_renum_next
f2b3 :                  df_rt_renum_mode2
                        	; mode 2 means increment == 0
                        	; so just add offset to this line number
f2b3 : a001             	ldy #DFTK_LINNUM
f2b5 : 18               	clc
f2b6 : b192             	lda (df_tmpptrd),y
f2b8 : 658e             	adc df_tmpptrb
f2ba : 9192             	sta (df_tmpptrd),y
f2bc : c8               	iny
f2bd : b192             	lda (df_tmpptrd),y
f2bf : 658f             	adc df_tmpptrb+1
f2c1 : 9192             	sta (df_tmpptrd),y	
f2c3 :                  df_rt_renum_next
f2c3 : 18               	clc
f2c4 : a592             	lda df_tmpptrd
f2c6 : 7292             	adc (df_tmpptrd)
f2c8 : 8592             	sta df_tmpptrd
f2ca : a593             	lda df_tmpptrd+1
f2cc : 6900             	adc #0
f2ce : 8593             	sta df_tmpptrd+1
f2d0 : 80af             	bra df_rt_renum_do
                        
                        	
                        ; list token
f2d2 :                  df_rt_list
f2d2 : 6494             	stz df_tmpptre		; Zero means in normal list mode not 
                        	; if end of statement then no line specifiers
f2d4 : 205ff2           	jsr df_rt_eos
                        	; so list whole program
f2d7 : b01b             	bcs df_rt_listprg
                        
                        	; else get 1st parameter
f2d9 : 2046e7           	jsr df_rt_getnval
                        	; find the starting line number in X,A
f2dc : 20cde4           	jsr df_pg_find_line
f2df : 868c             	stx df_tmpptra
f2e1 : 858d             	sta df_tmpptra+1
                        	
                        	; if end of statement then only start line was provid
f2e3 : 205ff2           	jsr df_rt_eos
                        	; so list until end of program
f2e6 : b014             	bcs df_rt_listprgend
                        	; else get 2nd parameter
f2e8 : e689             	inc df_exeoff
f2ea : 2046e7           	jsr df_rt_getnval
                        	; find the starting line number in X,A
f2ed : 20cde4           	jsr df_pg_find_line
f2f0 : 48               	pha
f2f1 : da               	phx
AS65 Assembler for R6502 [1.42].                                     Page  210
------------------------------ kernel\kernel.s -------------------------------

f2f2 : 800e             	bra df_rt_list_line
                        
                        ; Common listing routine used by LIST and SAVE
                        ; tmpe = 0 means in LIST mode else SAVE mode
                        ; can stop the listing in LIST mode with CTRL-C
f2f4 :                  df_rt_listprg
                        	; program start and end as for pointer value
                        	_cpyZPWord df_prgstrt, df_tmpptra
                        
f2fc :                  df_rt_listprgend
f2fc : a569             	lda df_prgend+1
f2fe : 48               	pha
f2ff : a568             	lda df_prgend
f301 : 48               	pha
f302 :                  df_rt_list_line
                        	; if line length = 0 then end of program
f302 : b28c             	lda (df_tmpptra)
f304 : f015             	beq df_rt_list_line_fin
                        	; if in list mode and CTRL-C then also stop
f306 : a594             	lda df_tmpptre
f308 : d015             	bne df_rt_list_line_cont
                        	; check for break, asynch get
f30a : 18               	clc
f30b :                  df_rt_list_synckey
f30b : 2026d9           	jsr io_get_ch
f30e : c920             	cmp #' '						; Space = PAUSE
f310 : f006             	beq df_rt_list_pause
f312 : c903             	cmp #UTF_ETX					; CTRL-C?
f314 : f005             	beq df_rt_list_line_fin
f316 : 8007             	bra df_rt_list_line_cont		; any other key continues
f318 :                  df_rt_list_pause
f318 : 38               	sec								; Check key sync
f319 : 80f0             	bra df_rt_list_synckey
f31b :                  df_rt_list_line_fin
f31b : 68               	pla
f31c : 68               	pla
f31d : 18               	clc
f31e : 60               	rts
f31f :                  df_rt_list_line_cont
f31f : a000             	ldy #0
f321 : 8489             	sty df_exeoff
f323 : 2093f4           	jsr df_rt_list_linnum
f326 : a003             	ldy #3
f328 : b18c             	lda (df_tmpptra),y
f32a : 8580             	sta df_tokstidx
f32c : c8               	iny
f32d : 8489             	sty df_exeoff
f32f :                  df_rt_list_decode
f32f : a489             	ldy df_exeoff
f331 : b18c             	lda (df_tmpptra),y
f333 : 300e             	bmi df_rt_list_token
f335 : c920             	cmp #DFTK_ESCVAL
f337 : 9005             	bcc df_rt_list_escval
                        	; normal char just print it
f339 : 2029d9           	jsr io_put_ch
f33c : 800a             	bra df_rt_list_nexttok
f33e :                  df_rt_list_escval
                        	; A and Y need to be valid on entry
f33e : 2080f3           	jsr df_rt_list_decode_esc
f341 : 8005             	bra df_rt_list_nexttok
f343 :                  df_rt_list_token
f343 : 205cf4           	jsr df_rt_list_decode_token
AS65 Assembler for R6502 [1.42].                                     Page  211
------------------------------ kernel\kernel.s -------------------------------

f346 : 8000             	bra df_rt_list_nexttok
f348 :                  df_rt_list_nexttok	
                        	; advance the line offset
f348 : e689             	inc df_exeoff
f34a : a589             	lda df_exeoff
                        	; check if at end of line
f34c : d28c             	cmp (df_tmpptra)
f34e : f00e             	beq df_rt_list_next_line
                        	; check if at end of statement
f350 : c580             	cmp df_tokstidx
f352 : d0db             	bne df_rt_list_decode
f354 : a8               	tay
                        	; save the next statement offset
f355 : b18c             	lda (df_tmpptra),y
f357 : 8580             	sta df_tokstidx
f359 : c8               	iny
f35a : 8489             	sty df_exeoff
f35c : 80d1             	bra df_rt_list_decode
f35e :                  df_rt_list_next_line
                        	; new line
f35e : a90d             	lda #UTF_CR
f360 : 2029d9           	jsr io_put_ch
                        	; increment pointer to next line
f363 : 18               	clc
f364 : a58c             	lda df_tmpptra
f366 : 728c             	adc (df_tmpptra)
f368 : 858c             	sta df_tmpptra
f36a : a58d             	lda df_tmpptra+1
f36c : 6900             	adc #0
f36e : 858d             	sta df_tmpptra+1
                        	; if pointer > end then listing is done
f370 : 38               	sec
f371 : 68               	pla
f372 : aa               	tax
f373 : e58c             	sbc df_tmpptra
f375 : 68               	pla
f376 : 48               	pha
f377 : da               	phx
f378 : e58d             	sbc df_tmpptra+1
f37a : b086             	bcs df_rt_list_line
                        	
                        	; if got here then reached tmpb
f37c : 68               	pla
f37d : 68               	pla
f37e : 18               	clc
f37f : 60               	rts
                        
                        ; decode escape sequences
f380 :                  df_rt_list_decode_esc
                        	; jump over esc byte
f380 : c8               	iny
f381 : 8489             	sty df_exeoff
                        	; get the next two bytes in case needed
f383 : 48               	pha
f384 : b18c             	lda (df_tmpptra),y
f386 : 858e             	sta df_tmpptrb
f388 : c8               	iny
f389 : b18c             	lda (df_tmpptra),y
f38b : 858f             	sta df_tmpptrb+1
f38d : 88               	dey
f38e : 68               	pla
                        	; x2 to get jmp offset
AS65 Assembler for R6502 [1.42].                                     Page  212
------------------------------ kernel\kernel.s -------------------------------

f38f : 0a               	asl a
f390 : aa               	tax
                        	; now jump to decoder
f391 : 7ccceb           	jmp (df_rt_escjmp,x)
                        
                        ; reserved
f394 :                  df_rt_lst_reserved
f394 : 60               	rts
                        
                        ; decode a byte char
f395 :                  df_rt_lst_chr
f395 : a927             	lda #0x27			; Single quote
f397 : 2029d9           	jsr io_put_ch
f39a : a58e             	lda df_tmpptrb
f39c : 2029d9           	jsr io_put_ch
f39f : a927             	lda #0x27			; Single quote
f3a1 : 2029d9           	jsr io_put_ch
f3a4 : c8               	iny
f3a5 : 8489             	sty df_exeoff
f3a7 : 60               	rts
                        
                        ; Output 0x for hex chars
f3a8 :                  df_rt_lst_hex_pre
f3a8 : a930             	lda #'0'
f3aa : 2029d9           	jsr io_put_ch
f3ad : a978             	lda #'x'
f3af : 2029d9           	jsr io_put_ch
f3b2 : 60               	rts
                        
                        ; Decode a byte hex	
f3b3 :                  df_rt_lst_bythex
f3b3 : 20a8f3           	jsr df_rt_lst_hex_pre
f3b6 :                  df_rt_lst_lo_hex
f3b6 : a58e             	lda df_tmpptrb
f3b8 : 20a8cd           	jsr str_a_to_x
f3bb : 2029d9           	jsr io_put_ch
f3be : 8a               	txa
f3bf : 2029d9           	jsr io_put_ch
f3c2 : c8               	iny
f3c3 : 8489             	sty df_exeoff
f3c5 : 60               	rts
                        
                        ; Decode an int hex
f3c6 :                  df_rt_lst_inthex
f3c6 : 20a8f3           	jsr df_rt_lst_hex_pre
f3c9 : a58f             	lda df_tmpptrb+1
f3cb : 20a8cd           	jsr str_a_to_x
f3ce : 2029d9           	jsr io_put_ch
f3d1 : 8a               	txa
f3d2 : 2029d9           	jsr io_put_ch
f3d5 : 80df             	jmp df_rt_lst_lo_hex
                        
                        ; Decode a byte binary
f3d7 :                  df_rt_lst_bytbin
f3d7 : a208             	ldx #8
f3d9 : a58e             	lda df_tmpptrb
f3db : 858f             	sta df_tmpptrb+1
f3dd : 8005             	bra df_rt_lst_bin
                        
                        ; Decode a int binary
                        
f3df :                  df_rt_lst_intbin
AS65 Assembler for R6502 [1.42].                                     Page  213
------------------------------ kernel\kernel.s -------------------------------

f3df : a210             	ldx #16
f3e1 : c8               	iny
f3e2 : 8489             	sty df_exeoff
                        
                        ; Main 01 decoding of binary
f3e4 :                  df_rt_lst_bin
f3e4 : a930             	lda #'0'
f3e6 : 2029d9           	jsr io_put_ch
f3e9 : a962             	lda #'b'
f3eb : 2029d9           	jsr io_put_ch
f3ee :                  df_rt_lst_bit
f3ee : a930             	lda #'0'
f3f0 : 068e             	asl df_tmpptrb
f3f2 : 268f             	rol df_tmpptrb+1
f3f4 : 9002             	bcc df_rt_lst_bit_skip0
f3f6 : a931             	lda #'1'
f3f8 :                  df_rt_lst_bit_skip0
f3f8 : 2029d9           	jsr io_put_ch
f3fb : ca               	dex
f3fc : d0f0             	bne df_rt_lst_bit
f3fe : c8               	iny
f3ff : 8489             	sty df_exeoff
f401 : 18               	clc
f402 : 60               	rts
                        	
                        ; Decode a decimal integer
f403 :                  df_rt_lst_intdec	
f403 : a68e             	ldx df_tmpptrb
f405 : a58f             	lda df_tmpptrb+1
f407 : c8               	iny
f408 : 8489             	sty df_exeoff
f40a : 18               	clc
f40b : 20c5cf           	jsr print_a_to_d
f40e : 60               	rts
                        
                        ; decode a variable or procedure
f40f :                  df_rt_lst_var
f40f :                  df_rt_lst_proc
                        	; get var index
f40f : b18c             	lda (df_tmpptra),y
f411 : aa               	tax
                        	_cpyZPWord df_vntstrt,df_tmpptrb
                        
f41a :                  df_rt_list_findvvt
f41a : e000             	cpx #0
f41c : f015             	beq df_rt_list_gotvvt
f41e :                  df_rt_list_vvtend
f41e : b28e             	lda (df_tmpptrb)
f420 : f008             	beq df_rt_list_gotvvtend
                        	_incZPWord df_tmpptrb
                        
f428 : 80f4             	bra df_rt_list_vvtend
f42a :                  df_rt_list_gotvvtend
                        	_incZPWord df_tmpptrb
                        
f430 : ca               	dex
f431 : 80e7             	bra df_rt_list_findvvt
f433 :                  df_rt_list_gotvvt
f433 : b28e             	lda (df_tmpptrb)
f435 : f00b             	beq df_rt_list_donvvt
f437 : 2029d9           	jsr io_put_ch
                        	_incZPWord df_tmpptrb
AS65 Assembler for R6502 [1.42].                                     Page  214
------------------------------ kernel\kernel.s -------------------------------

                        
f440 : 80f1             	bra df_rt_list_gotvvt
f442 :                  df_rt_list_donvvt
f442 : 60               	rts
                        
f443 :                  df_rt_lst_strlit
f443 : a922             	lda #0x22
f445 : 2029d9           	jsr io_put_ch
f448 : a489             	ldy df_exeoff
f44a :                  df_rt_lst_strlitch
f44a : b18c             	lda (df_tmpptra),y
f44c : f006             	beq df_rt_lst_strlitdon
f44e : 2029d9           	jsr io_put_ch
f451 : c8               	iny
f452 : 80f6             	bra df_rt_lst_strlitch
f454 :                  df_rt_lst_strlitdon
f454 : a922             	lda #0x22
f456 : 2029d9           	jsr io_put_ch
f459 : 8489             	sty df_exeoff
f45b : 60               	rts
                        	
                        ; decode a token value with MSB set
f45c :                  df_rt_list_decode_token
f45c : 297f             	and #0x7f
                        	; token 0 and 1 don't get decoded they are implicit
f45e : c902             	cmp #2
f460 : b001             	bcs df_rt_list_do_decode_tkn
f462 : 60               	rts
f463 :                  df_rt_list_do_decode_tkn
f463 : aa               	tax
f464 : a950             	lda #lo(df_tokensyms)
f466 : 858e             	sta df_tmpptrb
f468 : a9e1             	lda #hi(df_tokensyms)
f46a : 858f             	sta df_tmpptrb+1
f46c :                  df_rt_list_find_sym
f46c : e000             	cpx #0
f46e : f00f             	beq df_rt_list_got_sym
f470 :                  df_rt_list_next_ch
f470 : b28e             	lda (df_tmpptrb)
f472 : 48               	pha
                        	_incZPWord df_tmpptrb
                        
f479 : 68               	pla
f47a : 10f4             	bpl df_rt_list_next_ch
f47c :                  df_rt_list_got_last_sym
                        	; ok got to the last ch
                        	; advance to next sym
f47c : ca               	dex
f47d : 80ed             	bra df_rt_list_find_sym
f47f :                  df_rt_list_got_sym
f47f : a58f             	lda df_tmpptrb+1
f481 : b28e             	lda (df_tmpptrb)
f483 : 08               	php
f484 : 297f             	and #0x7f
f486 : 2029d9           	jsr io_put_ch
                        	_incZPWord df_tmpptrb
                        
f48f : 28               	plp
f490 : 10ed             	bpl df_rt_list_got_sym
f492 : 60               	rts 
                        	
f493 :                  df_rt_list_linnum
AS65 Assembler for R6502 [1.42].                                     Page  215
------------------------------ kernel\kernel.s -------------------------------

f493 : a001             	ldy #1
f495 : b18c             	lda (df_tmpptra),y
f497 : aa               	tax
f498 : a002             	ldy #2
f49a : b18c             	lda (df_tmpptra),y
f49c : 18               	clc
f49d : 20c5cf           	jsr print_a_to_d
f4a0 : 18               	clc
f4a1 : 60               	rts
                        
f4a2 :                  df_rt_doke
f4a2 : 2047e9           	jsr df_rt_parm_2ints
f4a5 : a58e             	lda df_tmpptrb
f4a7 : 928c             	sta (df_tmpptra)
                        	; get high byte to doke
f4a9 : a58e             	lda df_tmpptrb
f4ab : a001             	ldy #1
                        	; poke hi byte
f4ad : 918c             	sta (df_tmpptra),y
f4af : 60               	rts
                        	
f4b0 :                  df_rt_poke
f4b0 : 2047e9           	jsr df_rt_parm_2ints
f4b3 : a58e             	lda df_tmpptrb
f4b5 : 928c             	sta (df_tmpptra)
f4b7 : 18               	clc
f4b8 : 60               	rts
                        
f4b9 :                  df_rt_vpoke
f4b9 : 2047e9           	jsr df_rt_parm_2ints
f4bc : a68c             	ldx df_tmpptra
f4be : a48d             	ldy df_tmpptra+1
f4c0 : a58e             	lda df_tmpptrb
f4c2 : 201cc8           	jsr vdp_poke
f4c5 : 18               	clc
f4c6 : 60               	rts
                        
f4c7 :                  df_rt_setvdp
f4c7 : 2047e9           	jsr df_rt_parm_2ints
f4ca : a58c             	lda df_tmpptra
f4cc : a68e             	ldx df_tmpptrb
f4ce : 20d6c7           	jsr vdp_wr_reg
f4d1 : 18               	clc
f4d2 : 60               	rts
                        
f4d3 :                  df_rt_colour
f4d3 : 205ee9           	jsr df_rt_parm_3ints
                        	; colour is a combination of b and c parms
f4d6 : a58e             	lda df_tmpptrb
f4d8 : 0a               	asl a
f4d9 : 0a               	asl a
f4da : 0a               	asl a
f4db : 0a               	asl a
f4dc : 0590             	ora df_tmpptrc
f4de : 48               	pha
f4df : a58c             	lda df_tmpptra
f4e1 : c920             	cmp #32					; 32 = border colour
f4e3 : f011             	beq df_rt_colour_border
                        	; else write to the colour table
                        	; first calculate the colour table address
f4e5 : 18               	clc
f4e6 : 65cd             	adc vdp_base+vdp_addr_col
AS65 Assembler for R6502 [1.42].                                     Page  216
------------------------------ kernel\kernel.s -------------------------------

f4e8 : aa               	tax
f4e9 : a5ce             	lda vdp_base+vdp_addr_col+1
f4eb : 6900             	adc #0
f4ed : 20e1c7           	jsr vdp_wr_addr
f4f0 : 68               	pla
f4f1 : 200fc8           	jsr vdp_wr_vram
f4f4 : 18               	clc
f4f5 : 60               	rts
f4f6 :                  df_rt_colour_border
f4f6 : a907             	lda #7
f4f8 : fa               	plx
f4f9 : 20d6c7           	jsr vdp_wr_reg
f4fc : 18               	clc
f4fd : 60               	rts
                        
f4fe :                  df_rt_sprite
f4fe : 20b0e9           	jsr df_rt_parm_5ints
                        	; calculate the sprite number in vram
f501 : a58c             	lda df_tmpptra
f503 : 0a               	asl a
f504 : 0a               	asl a
f505 : 18               	clc
f506 : 65d1             	adc vdp_base+vdp_addr_spa
f508 : aa               	tax
f509 : a5d2             	lda vdp_base+vdp_addr_spa+1
f50b : 6900             	adc #0
f50d : 20e1c7           	jsr vdp_wr_addr
                        	; now write the vertical position (tmpc, not b)
f510 : a590             	lda df_tmpptrc
f512 : 200fc8           	jsr vdp_wr_vram
                        	; now write the horizontal position (tmpb)
f515 : a58e             	lda df_tmpptrb
f517 : 200fc8           	jsr vdp_wr_vram
                        	; now write the pattern name (tmpd)
f51a : a592             	lda df_tmpptrd
f51c : 200fc8           	jsr vdp_wr_vram
                        	; now write the colour / ec byte (tmpe)
f51f : a594             	lda df_tmpptre
f521 : 200fc8           	jsr vdp_wr_vram
f524 : 60               	rts
                        
                        
                        ; copy pattern array to sprite pattern vram
                        ; pattern array is a mim 4 element int
f525 :                  df_rt_spritepat
f525 : 2047e9           	jsr df_rt_parm_2ints
                        	; save sprite number
f528 : 868c             	stx df_tmpptra
f52a : 648d             	stz df_tmpptra+1
                        	; multiply by 8 to get pattern offset
f52c : 068c             	asl df_tmpptra
f52e : 268d             	rol df_tmpptra+1
f530 : 068c             	asl df_tmpptra
f532 : 268d             	rol df_tmpptra+1
f534 : 068c             	asl df_tmpptra
f536 : 268d             	rol df_tmpptra+1
                        	; add offset to sprite pattern base
                        	; and put in X,A
f538 : a58c             	lda df_tmpptra
f53a : 65d3             	adc vdp_base+vdp_addr_spp
f53c : aa               	tax
f53d : a58d             	lda df_tmpptra+1
AS65 Assembler for R6502 [1.42].                                     Page  217
------------------------------ kernel\kernel.s -------------------------------

f53f : 65d4             	adc vdp_base+vdp_addr_spp+1
                        	; set vdp address
f541 : 20e1c7           	jsr vdp_wr_addr
                        	; start from beginning of array
f544 : a000             	ldy #0
f546 :                  df_rt_spritepat_line
                        	; get the sprite patten from array
f546 : b18e             	lda (df_tmpptrb),y
                        	; and write to vdp
f548 : 200fc8           	jsr vdp_wr_vram
f54b : c8               	iny
                        	; do this for 8 bytes (4 elements)
f54c : c008             	cpy #8
f54e : d0f6             	bne df_rt_spritepat_line
f550 : 60               	rts
                        
f551 :                  df_rt_spritepos
f551 : 205ee9           	jsr df_rt_parm_3ints
                        	; calculate the sprite number in vram
f554 : a58c             	lda df_tmpptra
f556 : 0a               	asl a
f557 : 0a               	asl a
f558 : 65d1             	adc vdp_base+vdp_addr_spa
f55a : aa               	tax
f55b : a5d2             	lda vdp_base+vdp_addr_spa+1
f55d : 6900             	adc #0
f55f : 20e1c7           	jsr vdp_wr_addr
                        	; now write the vertical position (tmpc, not b)
f562 : a590             	lda df_tmpptrc
f564 : 200fc8           	jsr vdp_wr_vram
                        	; now write the horizontal position (tmpb)
f567 : a58e             	lda df_tmpptrb
f569 : 200fc8           	jsr vdp_wr_vram
f56c : 60               	rts
                        
                        ; common routine for col and nme variations
                        ; A contains offset in to sprite table to update
f56d :                  df_rt_spriteattr
                        	; save A which contains the offset
f56d : 48               	pha
f56e : 2047e9           	jsr df_rt_parm_2ints
                        	; calculate the sprite number in vram
f571 : a58c             	lda df_tmpptra
f573 : 0a               	asl a
f574 : 0a               	asl a
f575 : 65d1             	adc vdp_base+vdp_addr_spa
f577 : 858c             	sta df_tmpptra
f579 : a5d2             	lda vdp_base+vdp_addr_spa+1
f57b : 6900             	adc #0
f57d : 858d             	sta df_tmpptra+1
                        	; add offset and put in X,A to set VRAM address
f57f : 68               	pla							; get offset from stack
f580 : 658c             	adc df_tmpptra
f582 : aa               	tax
f583 : a58d             	lda df_tmpptra+1
f585 : 6900             	adc #0
f587 : 20e1c7           	jsr vdp_wr_addr
                        	; now write the value to the attribute
f58a : a58e             	lda df_tmpptrb
f58c : 200fc8           	jsr vdp_wr_vram
f58f : 60               	rts
                        
AS65 Assembler for R6502 [1.42].                                     Page  218
------------------------------ kernel\kernel.s -------------------------------

f590 :                  df_rt_spritecol
                        	; offset is 3 for colour byte
f590 : a903             	lda #3
f592 : 80d9             	jmp df_rt_spriteattr
                        
f594 :                  df_rt_spritenme
                        	; offset is 2 for name byte
f594 : a902             	lda #2
f596 : 80d5             	jmp df_rt_spriteattr
                        
f598 :                  df_rt_snd_common
                        	; 3 inputs
                        	; tmpa = channel (1,2,3), tmpb = period, tmpc = vol
f598 : a58c             	lda df_tmpptra
                        	; tone channel addressing is 0 to 2
f59a : 3a               	dec a
f59b : 2903             	and #3
                        	; ok doing a tone channel, get reg index for period
f59d : 0a               	asl a
f59e : aa               	tax
                        	; get low byte of period
f59f : a48e             	ldy df_tmpptrb
f5a1 : 207ec2           	jsr snd_set
                        	; increment reg number to high byte
f5a4 : e8               	inx
                        	; get high byte of period
f5a5 : a58f             	lda df_tmpptrb+1
f5a7 : 290f             	and #0x0f
f5a9 : a8               	tay
                        	; set period
f5aa : 207ec2           	jsr snd_set
                        	; get volume register index (8 = channel 1)
f5ad : 18               	clc
f5ae : a58c             	lda df_tmpptra
f5b0 : 2903             	and #3
f5b2 : 6907             	adc #7
f5b4 : aa               	tax
                        	; get volume
f5b5 : a590             	lda df_tmpptrc
f5b7 : 290f             	and #0x0f
f5b9 : d002             	bne df_rt_sound_env_skip
                        	; envelope mode
f5bb : 0910             	ora #0x10
f5bd :                  df_rt_sound_env_skip
f5bd : a8               	tay
f5be : 207ec2           	jsr snd_set
f5c1 : 60               	rts
                        
                        ; sound chan,period,volume	
f5c2 :                  df_rt_sound
f5c2 : 205ee9           	jsr df_rt_parm_3ints
f5c5 :                  df_rt_dosound
                        	; check which channel (0 = noise)
f5c5 : a58c             	lda df_tmpptra
f5c7 : f002             	beq df_rt_sound_noise
f5c9 : 80cd             	jmp df_rt_snd_common
f5cb :                  df_rt_sound_noise
                        	; ok update the noise channel, volume is irrelevant
f5cb : a206             	ldx #6
f5cd : a58e             	lda df_tmpptrb
f5cf : 291f             	and #0x1f
f5d1 : a8               	tay
AS65 Assembler for R6502 [1.42].                                     Page  219
------------------------------ kernel\kernel.s -------------------------------

f5d2 : 207ec2           	jsr snd_set
f5d5 : 18               	clc
f5d6 : 60               	rts
                        
                        ; music chan,octave,note,volume
f5d7 :                  df_rt_music
f5d7 : 2081e9           	jsr df_rt_parm_4ints
                        	; parm 2 = octave, need to x 12word = 24
f5da : 18               	clc
f5db : a58e             	lda df_tmpptrb
f5dd : 658e             	adc df_tmpptrb
f5df : 658e             	adc df_tmpptrb
f5e1 : 0a               	asl a
f5e2 : 0a               	asl a
                        	; we have x12, now add note to get index
f5e3 : 6590             	adc df_tmpptrc
f5e5 : 0a               	asl a
f5e6 : aa               	tax
                        	; get low byte of period
f5e7 : bdfac2           	lda snd_music_tab,x
f5ea : 858e             	sta df_tmpptrb
f5ec : e8               	inx
                        	; get high byte of period
f5ed : bdfac2           	lda snd_music_tab,x
f5f0 : 858f             	sta df_tmpptrb+1
                        	; put vol in tmpc
f5f2 : a592             	lda df_tmpptrd
f5f4 : 8590             	sta df_tmpptrc
                        	; tmpa,b,c contain chan,per,vol
f5f6 : 80cd             	jmp df_rt_dosound
                        	
                        	
                        ; play tonemask,noisemask,envelope,period
f5f8 :                  df_rt_play
f5f8 : 2081e9           	jsr df_rt_parm_4ints
                        	; parm 1 = tone enable
f5fb : a58c             	lda df_tmpptra
f5fd : 2907             	and #7
f5ff : 858c             	sta df_tmpptra
                        	; parm 2 = noise enable
f601 : a58e             	lda df_tmpptrb
f603 : 2907             	and #7
f605 : 0a               	asl a
f606 : 0a               	asl a
f607 : 0a               	asl a
f608 : 058c             	ora df_tmpptra
                        	; we now have bits set for channels to enable
                        	; but need to invert for the 8910
                        	; keep top 2 bits 0 as these are port a and b inputs
f60a : 493f             	eor #0x3f
f60c : a8               	tay
                        	; reg 7 is control register
f60d : a207             	ldx #7
f60f : 207ec2           	jsr snd_set
                        	; parm 3 = envelope mode
f612 : a590             	lda df_tmpptrc
f614 : 290f             	and #0xf
f616 : a8               	tay
                        	; 13 is envelope shape register
f617 : a20d             	ldx #13
f619 : 207ec2           	jsr snd_set
                        	; parm 4 = envelope period
AS65 Assembler for R6502 [1.42].                                     Page  220
------------------------------ kernel\kernel.s -------------------------------

                        	; 11 is envelope period register
f61c : a20b             	ldx #11
                        	; get low
f61e : a492             	ldy df_tmpptrd
f620 : 207ec2           	jsr snd_set
                        	; get high
f623 : e8               	inx
f624 : a493             	ldy df_tmpptrd+1
f626 : 207ec2           	jsr snd_set
f629 : 18               	clc
f62a : 60               	rts
                        
                        
                        ;* common filename procesing routine
                        ;* 
f62b :                  df_rt_init_filename
                        	; evaluate string
f62b : 209ce6           	jsr df_rt_neval
f62e : 2051fa           	jsr df_st_popStr
                        
                        	; save string address
f631 : 868e             	stx df_tmpptrb
f633 : 858f             	sta df_tmpptrb+1
                        	
                        	; copy string to fhandle
f635 : a000             	ldy #0
f637 :                  df_rt_copy_fn
f637 : b18e             	lda (df_tmpptrb),y
f639 : 8940             	bit #0x40					; If 0x40 bit not set
f63b : f002             	beq df_rt_fname_case		; then not an alpha char
f63d : 29df             	and #0xdf					; Else mask out 0x20 bit to make upper 
f63f :                  df_rt_fname_case	
f63f : 99a300           	sta fh_handle,y
f642 : c8               	iny
f643 : c900             	cmp #0
f645 : d0f0             	bne df_rt_copy_fn
f647 : 60               	rts
                        	
                        ;* common file parsing routine
f648 :                  df_rt_parse_file
f648 : e689             	inc df_exeoff
                        	; evaluate device
f64a : 2046e7           	jsr df_rt_getnval
                        	; save low byte on stack
f64d : 8a               	txa
                        	; only lowest bit valid
f64e : 2901             	and #1
                        	; mul2 gives 0 or 2 (0=ser,2=sd)
f650 : 0a               	asl a
f651 : 48               	pha
                        	; jump over comma
f652 : e689             	inc df_exeoff
                        
                        	; now process filename
f654 : 202bf6           	jsr df_rt_init_filename
                        
                        	; get device id
f657 : 68               	pla
f658 : 2002d9           	jsr io_active_device
f65b : 18               	clc
f65c : 60               	rts
f65d :                  df_rt_file_errc
AS65 Assembler for R6502 [1.42].                                     Page  221
------------------------------ kernel\kernel.s -------------------------------

                        	SWBRK DFERR_FNAME
                        
                        ; save 'x',"file" where 0=serial, 1=SDcard	
f65f :                  df_rt_save
f65f : 2048f6           	jsr df_rt_parse_file
f662 : 202fd9           	jsr io_open_write
f665 : b0f6             	bcs df_rt_file_errc
                        	; ok now have redirected output to device
                        	; go and list the program in save mode
f667 : a901             	lda #1
f669 : 8594             	sta df_tmpptre
f66b : 20f4f2           	jsr df_rt_listprg
                        	; final CR to end the save
f66e : a90d             	lda #UTF_CR
f670 : 2029d9           	jsr io_put_ch
f673 :                  df_rt_file_cleanup
                        	; close the file
f673 : 2032d9           	jsr io_close
                        	; restore to default device io
f676 : 20fad8           	jsr io_init_default
f679 : 18               	clc
f67a : 60               	rts
                        
                        ; load 'x',"file" where 0=serial, 1=SDCard
f67b :                  df_rt_load
f67b : 2048f6           	jsr df_rt_parse_file
f67e : 202cd9           	jsr io_open_read
f681 : b0da             	bcs df_rt_file_errc
                        	; no echo - very important
                        	; else might try and write to a device
                        	; only open for reading (i.e. SD CARD)
f683 :                  df_rt_loadline
f683 : 18               	clc
f684 : 2090e5           	jsr df_pg_inputline
                        	; if C then empty line (just CR) so done
f687 : b0ea             	bcs df_rt_file_cleanup
f689 : 20e9e5           	jsr df_pg_tokenise
f68c : 80f5             	bra df_rt_loadline
                        
f68e :                  df_rt_del
f68e : 202bf6           	jsr df_rt_init_filename		; Parse filename
f691 : 2094d8           	jsr fs_delete				; Delete file
f694 : b0c7             	bcs df_rt_file_errc
f696 : 60               	rts
                        
f697 :                  df_rt_dir
f697 : 20a0d4           	jsr fs_dir_root_start		; Start at root
f69a :                  df_rt_dir_show_entry
f69a : 18               	clc							; Only looking for valid files
f69b : 20b9d4           	jsr fs_dir_find_entry		; Find a valid entry
f69e : b022             	bcs df_rt_dir_done			; If C then no more entries so d
f6a0 : a290             	ldx #lo(fh_dir)				; Set up pointer to name
f6a2 : a907             	lda #hi(fh_dir)
f6a4 : 2082d9           	jsr io_print_line			; Print name
f6a7 : a920             	lda #' '					; print spaces
f6a9 :                  df_rt_dir_pad
f6a9 : 2029d9           	jsr io_put_ch
f6ac : c8               	iny							; pad to 13 chars
f6ad : c00d             	cpy #13
f6af : d0f8             	bne df_rt_dir_pad
                        
f6b1 : ae9d07           	ldx fh_dir+FH_Size			; Low byte of size
AS65 Assembler for R6502 [1.42].                                     Page  222
------------------------------ kernel\kernel.s -------------------------------

f6b4 : ad9e07           	lda fh_dir+FH_Size+1		; High byte of size
f6b7 : 18               	clc							; Don't show leading zeros
f6b8 : 20c5cf           	jsr print_a_to_d			; Print a string
f6bb : a90d             	lda #UTF_CR
f6bd : 2029d9           	jsr io_put_ch
f6c0 : 80d8             	bra df_rt_dir_show_entry	; Find another entry
f6c2 :                  df_rt_dir_done
f6c2 : 18               	clc
f6c3 : 60               	rts
                        
                        ; reset %var
f6c4 :                  df_rt_reset
                        	; now get lvar X,A from current statement
f6c4 : 20feea           	jsr df_rt_getlvar
                        	; save lvar in tmpb, vvt ptr in tmpa
f6c7 : 868e             	stx df_tmpptrb
f6c9 : 858f             	sta df_tmpptrb+1
                        	; load the vdp count as the reset value of timer
                        	; turn off interrupts while reading vdp lo,hi
f6cb : a001             	ldy #1	; This is in readiness to read high byte of va
f6cd : 78               	sei
f6ce : a504             	lda vdp_cnt
f6d0 : 928e             	sta (df_tmpptrb)
f6d2 : a505             	lda vdp_cnt+1
                        	; restore interrupts asap
f6d4 : 58               	cli
f6d5 : 918e             	sta (df_tmpptrb),y
f6d7 : 60               	rts
                        
                        ;***** FUNCTIONS *****
                        
f6d8 :                  df_rt_deek
f6d8 : 38               	sec
f6d9 : 8001             	bra df_rt_readbyte
f6db :                  df_rt_peek
f6db : 18               	clc
f6dc :                  df_rt_readbyte
f6dc : 08               	php
f6dd : e689             	inc df_exeoff
f6df : 2046e7           	jsr df_rt_getnval
f6e2 : 868c             	stx df_tmpptra
f6e4 : 858d             	sta df_tmpptra+1
f6e6 : b28c             	lda (df_tmpptra)
f6e8 : aa               	tax
f6e9 : a900             	lda #0
f6eb : 28               	plp
f6ec : 9005             	bcc df_rt_readbyte_skip
f6ee : 18               	clc
f6ef : a001             	ldy #1
f6f1 : b18c             	lda (df_tmpptra),y
f6f3 :                  df_rt_readbyte_skip
f6f3 : 4c20fa           	jmp df_st_pushInt
                        
f6f6 :                  df_rt_vpeek
f6f6 : e689             	inc df_exeoff
f6f8 : 2046e7           	jsr df_rt_getnval
f6fb : 2028c8           	jsr vdp_peek
f6fe : aa               	tax
f6ff : a900             	lda #0
f701 : 4c20fa           	jmp df_st_pushInt
                        
f704 :                  df_rt_rnd
AS65 Assembler for R6502 [1.42].                                     Page  223
------------------------------ kernel\kernel.s -------------------------------

f704 : e689             	inc df_exeoff
f706 : 2046e7           	jsr df_rt_getnval
                        	; if input is 0 then generate next random number
f709 : e000             	cpx #0
f70b : f002             	beq df_rt_rnd_next
                        	; else set the seed to that number
f70d : 86a2             	stx df_rnd
f70f :                  df_rt_rnd_next
f70f : a5a2             	lda df_rnd
f711 : f003             	beq df_rt_rnd_eor
f713 : 0a               	asl a
f714 : 9002             	bcc df_rt_rnd_noeor
f716 :                  df_rt_rnd_eor
f716 : 491d             	eor #0x1d
f718 :                  df_rt_rnd_noeor
f718 : 85a2             	sta df_rnd
f71a : aa               	tax
f71b : a900             	lda #0
f71d : 4c20fa           	jmp df_st_pushInt
                        	
f720 :                  df_rt_stick
f720 : e689             	inc df_exeoff
f722 : 2046e7           	jsr df_rt_getnval
                        	; only low byte is used
f725 : 868c             	stx df_tmpptra
f727 : 20d6c2           	jsr snd_get_joy0
f72a : 98               	tya
                        	; invert the bits so that 1=switch on
f72b : 49ff             	eor #0xff
f72d : 258c             	and df_tmpptra
f72f : aa               	tax
f730 : a900             	lda #0
f732 : 4c20fa           	jmp df_st_pushInt
                        
                        ;* Return memory footprint as follows:
                        ;* 0	Return free memory (start of vvt - end of prg)
                        ;* 1	Return program size (end of prg - start of prg)
                        ;* 2	Return size of vars (end of vnt - start of vvt)
f735 :                  df_rt_mem
f735 : e689             	inc df_exeoff
f737 : 2046e7           	jsr df_rt_getnval
                        	; only low byte is used
f73a : e001             	cpx #1
f73c : f016             	beq df_rt_mem_prg
f73e : e002             	cpx #2
f740 : f024             	beq df_rt_mem_var
                        	; default is free memory
f742 :                  df_rt_mem_free
                        	_cpyZPWord df_vvtstrt,df_tmpptra
                        
                        	_cpyZPWord df_prgend,df_tmpptrb
                        
f752 : 8022             	bra df_rt_mem_calc
f754 :                  df_rt_mem_prg
                        	_cpyZPWord df_prgend,df_tmpptra
                        
                        	_cpyZPWord df_prgstrt,df_tmpptrb
                        
f764 : 8010             	bra df_rt_mem_calc
f766 :                  df_rt_mem_var
                        	_cpyZPWord df_vntend,df_tmpptra
                        
AS65 Assembler for R6502 [1.42].                                     Page  224
------------------------------ kernel\kernel.s -------------------------------

                        	_cpyZPWord df_vvtstrt,df_tmpptrb
                        
f776 :                  df_rt_mem_calc
                        	; tmpa-tmpb result in X,A
f776 : 38               	sec
f777 : a58c             	lda df_tmpptra
f779 : e58e             	sbc df_tmpptrb
f77b : aa               	tax
f77c : a58d             	lda df_tmpptra+1
f77e : e58f             	sbc df_tmpptrb+1
f780 : 4c20fa           	jmp df_st_pushInt
                        
                        ; %k=key(%sync) %sync>=1 means sync
f783 :                  df_rt_key
f783 : e689             	inc df_exeoff
f785 : 2046e7           	jsr df_rt_getnval
                        	; only low byte is used, check for sync or async
                        	; c=1 if x==0 else x>0 makes c=0
f788 : e001             	cpx #1
f78a : 2026d9           	jsr io_get_ch
f78d : 9003             	bcc df_rt_key_valid
                        	; zero out A
f78f : a900             	lda #0
f791 : 18               	clc
f792 :                  df_rt_key_valid
f792 : aa               	tax
f793 : a900             	lda #0
f795 : 4c20fa           	jmp df_st_pushInt
                        
                        	
                        ; s = scrn(x,y)
f798 :                  df_rt_scrn
f798 : e689             	inc df_exeoff
f79a : 2047e9           	jsr df_rt_parm_2ints
f79d : a68c             	ldx df_tmpptra
f79f : a48e             	ldy df_tmpptrb
f7a1 : 20fdcb           	jsr gr_set_cur_pos
f7a4 : a609             	ldx vdp_curval
f7a6 : a900             	lda #0
f7a8 : 4c20fa           	jmp df_st_pushInt
                        
                        ; %e=elapsed(%var)
f7ab :                  df_rt_elapsed
                        	; now get lvar X,A from current statement
f7ab : 20feea           	jsr df_rt_getlvar
f7ae : e689             	inc df_exeoff
                        	; save lvar in tmpb, vvt ptr in tmpa
f7b0 : 868e             	stx df_tmpptrb
f7b2 : 858f             	sta df_tmpptrb+1
                        	; subtract vdp counter from value
                        	; turn off interrupts while reading vdp lo,hi
f7b4 : a001             	ldy #1	; This is in readiness to read high byte of va
f7b6 : 38               	sec
f7b7 : 78               	sei
f7b8 : a504             	lda vdp_cnt
f7ba : f28e             	sbc (df_tmpptrb)
f7bc : aa               	tax
f7bd : a505             	lda vdp_cnt+1
                        	; restore interrupts asap
f7bf : 58               	cli
f7c0 : f18e             	sbc (df_tmpptrb),y
f7c2 : 4c20fa           	jmp df_st_pushInt
AS65 Assembler for R6502 [1.42].                                     Page  225
------------------------------ kernel\kernel.s -------------------------------

                        	
                        ; string length calculator
                        ; X,A = source
                        ; A = length not including zero
f7c5 :                  df_rt_strlen_common
f7c5 : 868c             	stx df_tmpptra
f7c7 : 858d             	sta df_tmpptra+1
f7c9 : a0ff             	ldy #0xff
f7cb :                  df_rt_strlen_count
f7cb : c8               	iny
f7cc : b18c             	lda (df_tmpptra),y
f7ce : d0fb             	bne df_rt_strlen_count
f7d0 : 98               	tya
f7d1 : 60               	rts
                        	
                        	
                        ; common routine to extract a string
                        ; tmpa = source string
                        ; tmpb = dest string
                        ; tmpc = start pos
                        ; tmpd = endpos	
f7d2 :                  df_rt_str_extract
                        	; source string
f7d2 : 2051fa           	jsr df_st_popStr
f7d5 : 868c             	stx df_tmpptra
f7d7 : 858d             	sta df_tmpptra+1
                        	; destination is string accumulator
f7d9 : a57b             	lda df_sevalptr
f7db : 858e             	sta df_tmpptrb
f7dd : a57c             	lda df_sevalptr+1
f7df : 858f             	sta df_tmpptrb+1
                        	; start pos
f7e1 : a490             	ldy df_tmpptrc
f7e3 :                  df_rt_str_cpy_ch
f7e3 : c492             	cpy df_tmpptrd
f7e5 : f011             	beq df_str_src_end
f7e7 : b18c             	lda (df_tmpptra),y
f7e9 : f00d             	beq df_str_src_end
f7eb : 928e             	sta (df_tmpptrb)
                        	_incZPWord df_tmpptrb
                        
f7f3 : c8               	iny
f7f4 : d0ed             	bne df_rt_str_cpy_ch
                        	SWBRK DFERR_STRLONG
                        
f7f8 :                  df_str_src_end
f7f8 : a900             	lda #0
f7fa : 928e             	sta (df_tmpptrb)
f7fc : a67b             	ldx df_sevalptr
f7fe : a57c             	lda df_sevalptr+1
f800 : 4c24fa           	jmp df_st_pushStr
                        
                        ; $c = chr(x)
f803 :                  df_rt_chr
f803 : e689             	inc df_exeoff
                        	; get char in X
f805 : 2046e7           	jsr df_rt_getnval
f808 : a000             	ldy #0
                        	; transfer lo byte to A
f80a : 8a               	txa
f80b : 917b             	sta (df_sevalptr),y
f80d : c8               	iny
AS65 Assembler for R6502 [1.42].                                     Page  226
------------------------------ kernel\kernel.s -------------------------------

                        	; zero terminator
f80e : a900             	lda #0
f810 : 917b             	sta (df_sevalptr),y
                        	; point to seval scratch area
f812 : a67b             	ldx df_sevalptr
f814 : a57c             	lda df_sevalptr+1
f816 : 4c24fa           	jmp df_st_pushStr
                        
                        ; $l = left($s, x)
f819 :                  df_rt_left
f819 : e689             	inc df_exeoff
                        	; first get the string to act on
                        	; point to string accumulator
f81b : a67b             	ldx df_sevalptr
f81d : a57c             	lda df_sevalptr+1
f81f : 204ce7           	jsr df_rt_seval
                        	; now get the num of chars
f822 : e689             	inc df_exeoff
f824 : 2046e7           	jsr df_rt_getnval
                        	; number of chars to extract
f827 : 8692             	stx df_tmpptrd
                        	; start position
f829 : 6490             	stz df_tmpptrc
f82b : 80a5             	jmp df_rt_str_extract
                        
                        ; $r = right($s, x)
f82d :                  df_rt_right
f82d : e689             	inc df_exeoff
                        	; first get the string to act on
                        	; point to string accumulator
f82f : a67b             	ldx df_sevalptr
f831 : a57c             	lda df_sevalptr+1
f833 : 204ce7           	jsr df_rt_seval
                        	; now get the num of chars from the right
f836 : e689             	inc df_exeoff
f838 : 2046e7           	jsr df_rt_getnval
                        	; number of chars to extract from the right
f83b : 8690             	stx df_tmpptrc
                        	; end pos = len
f83d : a67b             	ldx df_sevalptr
f83f : a57c             	lda df_sevalptr+1
f841 : 20c5f7           	jsr df_rt_strlen_common
f844 : 8592             	sta df_tmpptrd
                        	; subtract num chars to extract to get start pos
f846 : 38               	sec
f847 : e590             	sbc df_tmpptrc
f849 : 8590             	sta df_tmpptrc
f84b : 8085             	jmp df_rt_str_extract
                        
                        ; $m = mid($s, x, y)
f84d :                  df_rt_mid
f84d : e689             	inc df_exeoff
                        	; first get the string to act on
                        	; point to string accumulator
f84f : a67b             	ldx df_sevalptr
f851 : a57c             	lda df_sevalptr+1
f853 : 204ce7           	jsr df_rt_seval
                        	; now get start of string segment
f856 : e689             	inc df_exeoff
f858 : 209ce6           	jsr df_rt_neval
                        	; number of chars to extract
f85b : e689             	inc df_exeoff
AS65 Assembler for R6502 [1.42].                                     Page  227
------------------------------ kernel\kernel.s -------------------------------

f85d : 2046e7           	jsr df_rt_getnval
f860 : 8692             	stx df_tmpptrd
                        	; start position
f862 : 204dfa           	jsr df_st_popInt
f865 : 8690             	stx df_tmpptrc
                        	; update end pos by adding start pos
f867 : 8a               	txa
f868 : 18               	clc
f869 : 6592             	adc df_tmpptrd
f86b : 8592             	sta df_tmpptrd
f86d : 4cd2f7           	jmp df_rt_str_extract
                        
                        ; %l = len($s)
f870 :                  df_rt_len
f870 : e689             	inc df_exeoff
f872 : a67b             	ldx df_sevalptr
f874 : a57c             	lda df_sevalptr+1
f876 : 204ce7           	jsr df_rt_seval
f879 : 2051fa           	jsr df_st_popStr
f87c : 20c5f7           	jsr df_rt_strlen_common
f87f : aa               	tax
f880 : a900             	lda #0
f882 : 4c20fa           	jmp df_st_pushInt
                        	
                        
                        	include "dflat\proc.s"
                        ;*****************************************************
                        ;*
                        ;*	DOLO-1 HOMEBREW COMPUTER
                        ;*	Hardware and software design by Dolo Miah
                        ;*	Copyright 2014-18
                        ;*  Free to use for any non-commercial purpose subject
                        ;*  full credit of original my authorship please!
                        ;*
                        ;*  PROC.S
                        ;*  dflat module to handle procedures:
                        ;*  - executing a procedure
                        ;*  - find a proc, pass local and non-local parameters
                        ;*  - return from a proc, unload locals
                        ;*  - save the definition of a proc in the VNT and VVT
                        ;*
                        ;*****************************************************
                        
                        	; ROM code
                        	code  
                        
                        ; executing a procedure in A
f885 :                  df_rt_exec_proc
                        	; get pointer to the procedure
f885 : 2027db           	jsr df_var_addr
                        	; need to save all important vars
f888 : a587             	lda df_currlin
f88a : 48               	pha
f88b : a588             	lda df_currlin+1
f88d : 48               	pha
f88e : a589             	lda df_exeoff
f890 : 48               	pha
f891 : a580             	lda df_tokstidx
f893 : 48               	pha
f894 : a581             	lda df_curstidx
f896 : 48               	pha
f897 : a57f             	lda df_eolidx
AS65 Assembler for R6502 [1.42].                                     Page  228
------------------------------ kernel\kernel.s -------------------------------

f899 : 48               	pha
f89a : a59e             	lda df_ifnest
f89c : 48               	pha
                        
                        	; now initialise the data
f89d : a001             	ldy #DFVVT_LO
f89f : b18c             	lda (df_tmpptra),y
f8a1 : 8587             	sta df_currlin
f8a3 : c8               	iny
f8a4 : b18c             	lda (df_tmpptra),y
f8a6 : 8588             	sta df_currlin+1
f8a8 : c8               	iny
f8a9 : b18c             	lda (df_tmpptra),y
f8ab : 8589             	sta df_exeoff
f8ad : 8581             	sta df_curstidx
f8af : b287             	lda (df_currlin)
f8b1 : 8580             	sta df_tokstidx
                        	; now execute statements
f8b3 : 20fce9           	jsr df_rt_exec_stat
                        ;	bcs df_rt_exec_proc_err
                        	; now restore the position
f8b6 : 68               	pla
f8b7 : 859e             	sta df_ifnest
f8b9 : 68               	pla
f8ba : 857f             	sta df_eolidx
f8bc : 68               	pla
f8bd : 8581             	sta df_curstidx
f8bf : 68               	pla
f8c0 : 8580             	sta df_tokstidx
f8c2 : 68               	pla
f8c3 : 8589             	sta df_exeoff
f8c5 : 68               	pla
f8c6 : 8588             	sta df_currlin+1
f8c8 : 68               	pla
f8c9 : 8587             	sta df_currlin
                        	; should be all restored, so return
f8cb : 60               	rts
                        
                        ; call procedure
f8cc :                  df_rt_proc
                        	; move past escape token
f8cc : e689             	inc df_exeoff
f8ce : a489             	ldy df_exeoff
f8d0 : b187             	lda (df_currlin),y
                        	; save index for later
f8d2 : 48               	pha
                        	; get the address of procedure
f8d3 : 2027db           	jsr df_var_addr
                        	_cpyZPWord df_tmpptra,df_procptr
                        
                        	; is index 0 (dim1)
                        	; then find the procedure
f8de : a003             	ldy #DFVVT_DIM1
f8e0 : b199             	lda (df_procptr),y
f8e2 : d016             	bne df_rt_proc_addr
                        	; find proc, AXY is returned
f8e4 : 68               	pla
f8e5 : 48               	pha
f8e6 : 20b1ea           	jsr df_rt_findproc
                        	; save y (line index)
f8e9 : 841a             	sty tmp_a
                        	; now go and update the proc vvt address
AS65 Assembler for R6502 [1.42].                                     Page  229
------------------------------ kernel\kernel.s -------------------------------

f8eb : a002             	ldy #DFVVT_HI
f8ed : 9199             	sta (df_procptr),y
f8ef : a001             	ldy #DFVVT_LO
f8f1 : 8a               	txa
f8f2 : 9199             	sta (df_procptr),y
f8f4 : a003             	ldy #DFVVT_DIM1
                        	; get back line index in to A
f8f6 : a51a             	lda tmp_a
f8f8 : 9199             	sta (df_procptr),y
f8fa :                  df_rt_proc_addr
                        	; move past proc idx and first open bracket
f8fa : e689             	inc df_exeoff
f8fc : e689             	inc df_exeoff
                        	
                        	; get parm count
f8fe : a004             	ldy #DFVVT_DIM2
f900 : b199             	lda (df_procptr),y
f902 : f014             	beq df_rt_proc_parm_none
                        	; push the right number of parms on
f904 : 48               	pha
                        
f905 :                  df_rt_proc_push_parm
f905 : 209ce6           	jsr df_rt_neval
                        ;	bcs df_rt_proc_parmother
f908 : a489             	ldy df_exeoff
f90a : b187             	lda (df_currlin),y
f90c : c929             	cmp #')'
f90e : f007             	beq df_rt_proc_parm_done
                        	; move past comma
f910 : e689             	inc df_exeoff
                        	; get parm count off stack
f912 : 68               	pla
                        	; decrement
f913 : 3a               	dec a
                        	; and put back on stack
f914 : 48               	pha
                        	; go back and do all required parms
f915 : d0ee             	bne df_rt_proc_push_parm
                        	; remove parm counter from stack
f917 :                  df_rt_proc_parm_done
f917 : 68               	pla
f918 :                  df_rt_proc_parm_none
                        	; should be at close bracket
f918 : a489             	ldy df_exeoff
f91a : b187             	lda (df_currlin),y
f91c : c929             	cmp #')'
f91e : d004             	bne df_rt_proc_parmerr
                        	; should be no more parms
                        	; ok, finally we have all parms on rt stack
                        	; now execute the procedure
                        	; get back the proc index
f920 : 68               	pla
f921 : 4c85f8           	jmp df_rt_exec_proc
                        	
f924 :                  df_rt_proc_parmerr
                        	SWBRK DFERR_PROCPARM
                        
                        
                        
f926 :                  df_rt_def
                        	; line offset pointing at DFTK_PROC
                        	; skip over PROC id byte and open bracket
AS65 Assembler for R6502 [1.42].                                     Page  230
------------------------------ kernel\kernel.s -------------------------------

f926 : e689             	inc df_exeoff
f928 : e689             	inc df_exeoff
                        	; parms on stack in reverse order to parm list
                        	; so get each parm and type and save to scratch
f92a : a201             	ldx #1									; actual # of parms is X-1
f92c : a489             	ldy df_exeoff
f92e :                  df_rt_def_find_var
f92e : c8               	iny
f92f : b187             	lda (df_currlin),y
                        	; check if end of parm list
f931 : c929             	cmp #')'
f933 : f018             	beq df_rt_def_parm_done
                        	; else check if found a variable escape token (<32)
f935 : c911             	cmp #DFTK_VAR
f937 : f009             	beq df_rt_def_got_var
                        	; else check if non-local specifier
f939 : c926             	cmp #DFTK_VARPARM						; This is a regular ASCII char
f93b : f002             	beq df_rt_def_got_varparm
f93d : 80ef             	bra df_rt_def_find_var
f93f :                  df_rt_def_got_varparm
                        	; set high bit
f93f : 0980             	ora #0x80
                        	; advance over non-local specifier
f941 : c8               	iny
f942 :                  df_rt_def_got_var
                        	; when we get here either A contains DFTK_VAR token (
                        	; keep only the MSB
f942 : 2980             	and #0x80
                        	; skip over DFTK_VAR to var index
f944 : c8               	iny
                        	; get var index and OR with A which will have MSB res
f945 : 1187             	ora (df_currlin),y
                        	; save the index in scratch
f947 : 9db807           	sta scratch,x
                        	; increment count
f94a : e8               	inx
f94b : 80e1             	bra df_rt_def_find_var
f94d :                  df_rt_def_parm_done
                        	; save index that we got to
f94d : 8489             	sty df_exeoff
                        	; all var indices on the operator stack
                        	; now load up variables with parameters
f94f : 8697             	stx df_procargs
                        	; initially assume no locals
f951 : 6498             	stz df_procloc
f953 :                  df_rt_def_load_var
f953 : c697             	dec df_procargs
f955 : f02e             	beq df_rt_def_load_var_done
                        	; get var index
f957 : a697             	ldx df_procargs
f959 : bdb807           	lda scratch,x
                        	
                        	; save this temporarily
f95c : 48               	pha
                        	; mask off MSB in case it is set
f95d : 297f             	and #0x7f
                        	; get vvt slot address
f95f : 2027db           	jsr df_var_addr
                        	; get the var index off the stack
f962 : 68               	pla
                        	; if MSB is set then this is not a local variable
f963 : 3007             	bmi df_rt_def_initialise_parm
AS65 Assembler for R6502 [1.42].                                     Page  231
------------------------------ kernel\kernel.s -------------------------------

                        	; else call the local handling code
                        	; push the var index on to the runtime stack
f965 : 297f             	and #0x7f
f967 : 20d2f9           	jsr df_rt_proc_parm_local
                        	; increment number of locals
f96a : e698             	inc df_procloc
f96c :                  df_rt_def_initialise_parm
                        	; load type
f96c : b28c             	lda (df_tmpptra)
                        	; if array or string type then pop pointer from opera
f96e : 2984             	and #DFVVT_STR|DFVVT_ARRY
f970 : f005             	beq df_rt_def_load_var_int
f972 : 2055fa           	jsr df_st_popPtr
f975 : 8003             	bra df_rt_def_load_var_int_skip
f977 :                  df_rt_def_load_var_int
                        	; must be int pop it from operator stack
f977 : 204dfa           	jsr df_st_popInt
f97a :                  df_rt_def_load_var_int_skip
                        	; update the variable
f97a : a002             	ldy #DFVVT_HI
f97c : 918c             	sta (df_tmpptra),y
f97e : a001             	ldy #DFVVT_LO
f980 : 8a               	txa
f981 : 918c             	sta (df_tmpptra),y	
f983 : 80ce             	bra df_rt_def_load_var
f985 :                  df_rt_def_load_var_done
                        	; save the number of lcoal parameters found so they c
                        	; be unloaded when the proc ends
f985 : a598             	lda df_procloc
f987 : 20d7f9           	jsr df_st_pushByte
                        	; continue with next statement
f98a : 18               	clc
f98b : 60               	rts
                        	; def error - parameter problem
f98c :                  df_rt_def_err
                        	SWBRK DFERR_PROCPARM
                        
                        
                        	
                        ; end def for a proc
f98e :                  df_rt_enddef
                        	; unload any locals
f98e : 209af9           	jsr df_rt_proc_unlocal
                        	; nothing to do - main loop will terminate
f991 : 18               	clc
f992 : 60               	rts
                        	
                        ; return a value
f993 :                  df_rt_return
                        	; evaluate the return and put on the parameter stack
f993 : 209ce6           	jsr df_rt_neval
                        	; process this like an end of procedure
f996 : 208ef9           	jsr df_rt_enddef
f999 : 60               	rts
                        	
                        	
                        ; unload any local variables from runtime stack
f99a :                  df_rt_proc_unlocal
f99a : 20e0f9           	jsr df_st_popByte
f99d : aa               	tax
f99e : f01e             	beq df_rt_proc_unload_done
f9a0 :                  df_rt_proc_unloadvar
AS65 Assembler for R6502 [1.42].                                     Page  232
------------------------------ kernel\kernel.s -------------------------------

f9a0 : 8a               	txa
f9a1 : da               	phx
                        	; var value is popped first then index
                        	; get a word and put in tmpb
f9a2 : 20fef9           	jsr df_st_popWord
f9a5 : 868e             	stx df_tmpptrb
f9a7 : 858f             	sta df_tmpptrb+1
                        	; get the var number
f9a9 : 20e0f9           	jsr df_st_popByte
                        	; store address in tmpa
f9ac : 2027db           	jsr df_var_addr
                        	; store lo byte first
f9af : a001             	ldy #DFVVT_LO
f9b1 : a58e             	lda df_tmpptrb
f9b3 : 918c             	sta (df_tmpptra),y
                        	; then hi
f9b5 : c8               	iny
f9b6 : a58f             	lda df_tmpptrb+1
f9b8 : 918c             	sta (df_tmpptra),y
                        	; restore counter
f9ba : fa               	plx
f9bb : ca               	dex
f9bc : d0e2             	bne df_rt_proc_unloadvar
f9be :                  df_rt_proc_unload_done
f9be : 60               	rts
                        	
                        ; push a local variable to the runtime stack
                        ; A = var index
                        ; var index is pushed first, then value
f9bf :                  df_rt_proc_local
                        	; save the var index on rt stack
f9bf : 20d7f9           	jsr df_st_pushByte
                        	; populate tmpa with var address
f9c2 : 2027db           	jsr df_var_addr
f9c5 :                  df_rt_proc_local_load	
                        	; load x,a with var value lo,hi
f9c5 : a001             	ldy #DFVVT_LO
f9c7 : b18c             	lda (df_tmpptra),y
f9c9 : aa               	tax
f9ca : c8               	iny
f9cb : b18c             	lda (df_tmpptra),y
                        	; push word on to rt stack
f9cd : 20f0f9           	jsr df_st_pushWord
f9d0 : 18               	clc
f9d1 : 60               	rts
                        	
f9d2 :                  df_rt_proc_parm_local				; Jsr to here in a def statem
                        	; save the var index on rt stack
f9d2 : 20d7f9           	jsr df_st_pushByte
f9d5 : 80ee             	jmp df_rt_proc_local_load
                        		
                        	
                        
                        	include "dflat\stack.s"
                        ;*****************************************************
                        ;*
                        ;*	DOLO-1 HOMEBREW COMPUTER
                        ;*	Hardware and software design by Dolo Miah
                        ;*	Copyright 2014-18
                        ;*  Free to use for any non-commercial purpose subject
                        ;*  full credit of original my authorship please!
                        ;*
AS65 Assembler for R6502 [1.42].                                     Page  233
------------------------------ kernel\kernel.s -------------------------------

                        ;*  STACK.S
                        ;*  This module implements the dflat software stacks. 
                        ;*  needs a few stacks:
                        ;*  - 6502 stack for expression parsing and reentrancy
                        ;*  - dflat runtime stack for things like for/next loo
                        ;*  - dflat parameter stack for passing parameters etc
                        ;*  The two software stacks are implemented in the sam
                        ;*  with the runtime stack growing up from 0 and the
                        ;*  operator stack growing down from 255.  Hopefully t
                        ;*  don't meet as there are no checks for this at the 
                        ;*  purely because I want speed over friendliness, alt
                        ;*  I may come to regret this.
                        ;*  I have also added the only runtime memory allocati
                        ;*  needed by dflat here.  Humourously I have called i
                        ;*  which is taken from the C language, but it only to
                        ;*  grab some memory after the of dflat program code f
                        ;*  arrays - which of course cannot have storage alloc
                        ;*  tokenisation time (e.g. because I dimension an arr
                        ;*  a size from a variable).
                        ;*
                        ;*****************************************************
                        
                        	; ROM code
                        	code  
                        
                        
                        ;****************************************
                        ;* Push a byte on to runtime stack
                        ;* A = byte
                        ;****************************************
f9d7 :                  df_st_pushByte
f9d7 : a477             	ldy df_rtstop
f9d9 : 990006           	sta df_rtstck,y
f9dc : c8               	iny
f9dd : 8477             	sty df_rtstop
f9df : 60               	rts
                        
                        ;****************************************
                        ;* Pop a byte off runtime stack
                        ;* A = byte
                        ;****************************************
f9e0 :                  df_st_popByte
f9e0 : a477             	ldy df_rtstop
f9e2 : 88               	dey
f9e3 : b90006           	lda df_rtstck,y
f9e6 : 8477             	sty df_rtstop
f9e8 : 60               	rts
                        
                        ;****************************************
                        ;* Peek a byte off runtime stack
                        ;* A = byte
                        ;****************************************
f9e9 :                  df_st_peekByte
f9e9 : a477             	ldy df_rtstop
f9eb : 88               	dey
f9ec : b90006           	lda df_rtstck,y
f9ef : 60               	rts
                        	
                        ;****************************************
                        ;* Push a word on to runtime stack
                        ;* X,A = word lo,hi
                        ;****************************************
AS65 Assembler for R6502 [1.42].                                     Page  234
------------------------------ kernel\kernel.s -------------------------------

f9f0 :                  df_st_pushWord
f9f0 : a477             	ldy df_rtstop
f9f2 : 990006           	sta df_rtstck,y
f9f5 : c8               	iny
f9f6 : 8a               	txa
f9f7 : 990006           	sta df_rtstck,y
f9fa : c8               	iny
f9fb : 8477             	sty df_rtstop
f9fd : 60               	rts
                        
                        ;****************************************
                        ;* Pop a word off runtime stack
                        ;* X,A = word lo,hi
                        ;****************************************
f9fe :                  df_st_popWord
f9fe : a477             	ldy df_rtstop
fa00 : 88               	dey
fa01 : b90006           	lda df_rtstck,y
fa04 : aa               	tax
fa05 : 88               	dey
fa06 : b90006           	lda df_rtstck,y
fa09 : 8477             	sty df_rtstop
fa0b : 60               	rts
                        
                        ;****************************************
                        ;* Push a parameter on to parm stack
                        ;* X,A - int
                        ;* Y - type
                        ;****************************************
fa0c :                  df_st_pushParmX
fa0c : 5a               	phy
fa0d : a478             	ldy df_parmtop
                        	; push high byte first
fa0f : 990007           	sta df_opstck,y
fa12 : c8               	iny
                        	; push low byte next (xfer from X)
fa13 : 8a               	txa
fa14 : 990007           	sta df_opstck,y
fa17 : c8               	iny
                        	; push type
fa18 : 68               	pla
fa19 : 990007           	sta df_opstck,y
fa1c : c8               	iny
                        	; save new top of stack
fa1d : 8478             	sty df_parmtop
fa1f : 60               	rts
                        
                        ;****************************************
                        ;* Push an int on to parm stack
                        ;* X,A - int
                        ;****************************************
fa20 :                  df_st_pushInt
fa20 : a001             	ldy #DFST_INT
fa22 : 80e8             	jmp df_st_pushParmX
                        
                        ;****************************************
                        ;* Push a string pointer on to parm stack
                        ;* X,A - int
                        ;****************************************
fa24 :                  df_st_pushStr
fa24 : a080             	ldy #DFST_STR
fa26 : 80e4             	jmp df_st_pushParmX
AS65 Assembler for R6502 [1.42].                                     Page  235
------------------------------ kernel\kernel.s -------------------------------

                        
                        ;****************************************
                        ;* Push a general pointer on to parm stack
                        ;* X,A - int
                        ;****************************************
fa28 :                  df_st_pushPtr
fa28 : a0ff             	ldy #0xff
fa2a : 80e0             	jmp df_st_pushParmX
                        	
                        ;****************************************
                        ;* Pop parameter from the stack
                        ;* X,A - int
                        ;* Y - type expected
                        ;****************************************
fa2c :                  df_st_popParmX
fa2c : 5a               	phy
fa2d : a478             	ldy df_parmtop
                        	; pull low byte first
fa2f : 68               	pla
fa30 : 88               	dey
fa31 : 390007           	and df_opstck,y
fa34 : f00d             	beq df_st_typemismatcherr
                        	; pull low byte first
fa36 : 88               	dey
fa37 : b90007           	lda df_opstck,y
fa3a : aa               	tax
                        	; pull high byte next
fa3b : 88               	dey
fa3c : b90007           	lda df_opstck,y
                        	; save new top of stack
fa3f : 8478             	sty df_parmtop
fa41 : 18               	clc
fa42 : 60               	rts
fa43 :                  df_st_typemismatcherr
                        	SWBRK DFERR_TYPEMISM
                        
                        
                        ;****************************************
                        ;* Return type on top of stack
                        ;* Y - type
                        ;****************************************
fa45 :                  df_st_peekType
fa45 : a478             	ldy df_parmtop
fa47 : 88               	dey
fa48 : b90007           	lda df_opstck,y
fa4b : a8               	tay
fa4c : 60               	rts
                        
                        ;****************************************
                        ;* Pop an int off parm stack
                        ;* X,A - int
                        ;****************************************
fa4d :                  df_st_popInt
fa4d : a001             	ldy #DFST_INT
fa4f : 80db             	jmp df_st_popParmX
                        
                        ;****************************************
                        ;* Pop a string pointer off parm stack
                        ;* X,A - int
                        ;****************************************
fa51 :                  df_st_popStr
fa51 : a080             	ldy #DFST_STR
AS65 Assembler for R6502 [1.42].                                     Page  236
------------------------------ kernel\kernel.s -------------------------------

fa53 : 80d7             	jmp df_st_popParmX
                        	
                        ;****************************************
                        ;* Pop a general pointer off parm stack
                        ;* X,A - int
                        ;****************************************
fa55 :                  df_st_popPtr
fa55 : a0ff             	ldy #0xff
fa57 : 80d3             	jmp df_st_popParmX
                        	
                        	
                        ;****************************************
                        ;* Allocate space on the heap
                        ;* X, A = Number of bytes to allocate
                        ;* X, A return address of allocated space
                        ;****************************************
fa59 :                  df_st_malloc
                        	; save A in Y
fa59 : a8               	tay
                        	; save old starend
fa5a : a576             	lda df_starend+1
fa5c : 48               	pha
fa5d : a575             	lda df_starend
fa5f : 48               	pha
                        	; restore A from Y
fa60 : 98               	tya
                        	; add X,A to starend
fa61 : 48               	pha
fa62 : 8a               	txa
fa63 : 18               	clc
fa64 : 6575             	adc df_starend
fa66 : 8575             	sta df_starend
fa68 : 68               	pla
fa69 : 6576             	adc df_starend+1
fa6b : 8576             	sta df_starend+1
                        	; return old starend as start of space
fa6d : 68               	pla
fa6e : aa               	tax
fa6f : 68               	pla
fa70 : 60               	rts
                        	
                        
                        ;****************************************
                        ;* df_init
                        ;* Initialise dflat language settings
                        ;****************************************
fa71 :                  df_init
                        	; Init program space
fa71 : 2075fa           	jsr df_clear
                        	
fa74 : 60               	rts
                        	
                        	
                        ;****************************************
                        ;* df_clear
                        ;* Initialise program space
                        ;****************************************
fa75 :                  df_clear
                        	; Start of program space
fa75 : a9b8             	lda #lo(DF_PROGSTART)
fa77 : 8566             	sta df_prgstrt
fa79 : 8568             	sta df_prgend
AS65 Assembler for R6502 [1.42].                                     Page  237
------------------------------ kernel\kernel.s -------------------------------

fa7b : a908             	lda #hi(DF_PROGSTART)
fa7d : 8567             	sta df_prgstrt+1
fa7f : 8569             	sta df_prgend+1
                        	; Terminal value in prog space
fa81 : a900             	lda #0
fa83 : 9266             	sta (df_prgstrt)
                        
                        	; Variable name table
                        	; Grows down from hi mem
fa85 : a900             	lda #lo(DF_MEMTOP)
fa87 : 856a             	sta df_vntstrt
fa89 : 856c             	sta df_vntend
fa8b : a9b0             	lda #hi(DF_MEMTOP)
fa8d : 856b             	sta df_vntstrt+1
fa8f : 856d             	sta df_vntend+1
                        
                        	; Variable value table
                        	; Grows down from vnt
fa91 : a56a             	lda df_vntstrt
fa93 : 856e             	sta df_vvtstrt
fa95 : 8570             	sta df_vvtend
fa97 : a56b             	lda df_vntstrt+1
fa99 : 856f             	sta df_vvtstrt+1
fa9b : 8571             	sta df_vvtend+1
                        	
                        	; No variables - zero the count
fa9d : 6472             	stz df_varcnt
                        	
                        	; String accumulator
fa9f : a900             	lda #lo(df_raw)
faa1 : 857b             	sta df_sevalptr
faa3 : a905             	lda #hi(df_raw)
faa5 : 857c             	sta df_sevalptr+1
                        
faa7 : 60               	rts
                        	
                        
                        
                        ;* Reset vector points here - 6502 starts here
faa8 :                  init	
                        	; First clear ram
faa8 : 4cdffa           	jmp init_ram		; jmp not jsr to ram initialiser
faab :                  init_2					; init_ram will jump back to here
faab : a2ff             	ldx #0xff		; Initialise stack pointer
faad : 9a               	txs
faae : d8               	cld
faaf : 78               	sei
                        	
fab0 : 20b6fa           	jsr kernel_init
                        
fab3 : 4c72d0           	jmp main
                        
fab6 :                  kernel_init
fab6 : 201dc0           	jsr init_acia		; initialise the acia
fab9 : 2060c0           	jsr init_cia0		; initialise the input cia
fabc : 2089c0           	jsr init_cia1		; initialise the output cia
fabf : 20a6c0           	jsr init_keyboard	; initialise keyboard timer setting
fac2 : 20dcc2           	jsr init_snd		; initialise the sound chip
fac5 : 2043c1           	jsr kb_scan_options	; Check options
fac8 : 2902             	and #0x02			; Bit 1 = Graphics Mode
faca : 203dca           	jsr gr_init_screen
facd : 20fad8           	jsr io_init_default	; Set default input/output
AS65 Assembler for R6502 [1.42].                                     Page  238
------------------------------ kernel\kernel.s -------------------------------

fad0 : 20ecd0           	jsr init_sdcard		; initialise the sd card interface
fad3 : 20a5d3           	jsr init_fs			; initialise the filesystem
fad6 : 6400             	stz vdp_st
fad8 : 6404             	stz vdp_cnt
                        
fada : 2071fa           	jsr df_init			; Initialise interpreter
                        	
fadd : 58               	cli					; irq interrupts enable
fade : 60               	rts
                        
fadf :                  init_ram
fadf : a900             	lda #0x00			; Start at 0x0000
fae1 : 8500             	sta 0x00
fae3 : 8501             	sta 0x01
fae5 : a002             	ldy #0x02			; But Y initially at 2 to not overwrite p
fae7 : a2b0             	ldx #0xb0			; Page counter - 0xB000 is max write addr
fae9 :                  init_ram_1
fae9 : 9100             	sta (0x00),y		; Zero a byte
faeb : c8               	iny
faec : d0fb             	bne init_ram_1		; Do a whole page
faee : e601             	inc 0x01			; Increase page pointer
faf0 : ca               	dex					; Reduce page count
faf1 : d0f6             	bne init_ram_1		; Carry on if not finished
                        	
faf3 : 80b6             	jmp init_2			; Carry on initialisation
                        	
                        	
                        ; 6502 jumps here on IRQ or BRK
faf5 :                  irq
                        	_pushAXY
                        
                        
                        	; Check if IRQ or BRK
                        	; load P from stack in to A
faf8 : ba               	tsx
faf9 : bd0401           	lda 0x104,x
                        	; BRK?
fafc : 2910             	and #0x10
fafe : d026             	bne irq_brk
                        	; if here then normal IRQ
fb00 : ad01b4           	lda VDP_STATUS			; Read status register
fb03 : 8500             	sta vdp_st
fb05 : ad0db0           	lda IO_0 + IFR			; Check status register CIA0
fb08 : 8501             	sta cia0_ifr
fb0a : ad0db2           	lda IO_1 + IFR			; Check status register CIA1
fb0d : 8502             	sta cia1_ifr
fb0f : ad01b6           	lda SER_STATUS
fb12 : 8503             	sta acia_st
fb14 : a97f             	lda #0x7f				; Clear IFRs
fb16 : 8d0db0           	sta IO_0 + IFR
fb19 : 8d0db2           	sta IO_1 + IFR
                        
fb1c : 20a2c7           	jsr int_vdp_handler		; Execute VDP handler also updat
fb1f : 20b5c0           	jsr int_kb_handler		; Execute keyboard handler
fb22 :                  irq_done	
                        	_pullAXY
                        
fb25 : 40               	rti
                        
                        ;* Handle BRK
fb26 :                  irq_brk
                        	; Handle BRK
AS65 Assembler for R6502 [1.42].                                     Page  239
------------------------------ kernel\kernel.s -------------------------------

                        	; Get PCL,H minus 2 gives the BRK instruction address
fb26 : 38               	sec
fb27 : bd0501           	lda 0x0105,x
fb2a : e902             	sbc #2
fb2c : 8563             	sta df_brkpc
fb2e : bd0601           	lda 0x0106,x
fb31 : e900             	sbc #0
fb33 : 8564             	sta df_brkpc+1
                        	; Get the byte pointed to by old PC
                        	; which is 1 on from the BRK
fb35 : a001             	ldy #1
fb37 : b163             	lda (df_brkpc),y
fb39 : 8565             	sta df_brkval
fb3b : 855e             	sta errno
                        	; now update the return address
fb3d : a561             	lda df_pc
fb3f : 9d0501           	sta 0x105,x
fb42 : a562             	lda df_pc+1
fb44 : 9d0601           	sta 0x106,x
                        	
                        	_pullAXY
                        
                        	; when RTI occurs:
                        	;  will return to error handler
                        	;  df_brkval will contain signature
fb4a : 40               	rti
                        
                        ; 6502 Non-maskable interrupt come here
fb4b :                  nmi
fb4b : 40               	rti
                        	
                        ; Update 24 bit timer and debounce counters
fb4c :                  update_timers
fb4c : e604             	inc vdp_cnt
fb4e : d006             	bne inc_kb_timers
fb50 : e605             	inc vdp_cnt_hi
fb52 : d002             	bne inc_kb_timers
fb54 : e606             	inc vdp_cnt_hi2
fb56 :                  inc_kb_timers
fb56 : a60f             	ldx kb_deb			; Is debounce 0?
fb58 : f002             	beq skip_kb_deb
fb5a : c60f             	dec kb_deb
fb5c :                  skip_kb_deb
fb5c : a610             	ldx kb_rep			; Is repeat timer 0?
fb5e : f002             	beq skip_kb_rep
fb60 : c610             	dec kb_rep
fb62 :                  skip_kb_rep
fb62 : 60               	rts
                        
                        
No errors in pass 2.
Wrote binary from address $c000 through $ffff.
Total size 16384 bytes.
