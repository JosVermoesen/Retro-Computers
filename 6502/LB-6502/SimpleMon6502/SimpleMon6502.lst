ca65 V2.13.3 - (C) Copyright 1998-2012 Ullrich von Bassewitz
Main file   : SimpleMon6502.s
Current file: SimpleMon6502.s

000000r 1               ; SimpleMon6502 - Simple Monitor for the 6502
000000r 1               ; COMMAND LINE DRIVEN
000000r 1               ; 	I = TEST INPUT STRING
000000r 1               ; 	D = DUMP HEX MEMORY BLOCK
000000r 1               ;	L = Set/Clr LED
000000r 1               ; SOME OF THE CODE WAS WRITTEN BY AI - COPILOT
000000r 1               ; BUILD PROCESS USES CC65 TOOLCHAIN UNDER WINDOWS
000000r 1               ;	https://cc65.github.io/doc/
000000r 1               ; ca65 WAS USED TO ASSEMBLE THE PROGRAM
000000r 1               ;	ca65 SimpleMon6502.s -o SimpleMon6502.o -l
000000r 1               ; ld65 WAS USED TO LINK THE PROGRAM
000000r 1               ;	ld65 -C LB65022.cfg SimpleMon6502.o -o SimpleMon6502.bin
000000r 1               ; srec_cat WAS USED TO CREATE A .HEX FILE
000000r 1               ;	srec_cat.exe SimpleMon6502.bin -binary -o SimpleMon6502.hex -Intel
000000r 1               
000000r 1               .debuginfo +
000000r 1               
000000r 1               .setcpu "6502"
000000r 1               .macpack longbranch
000000r 1               
000000r 1               STACK_TOP		:= $FC
000000r 1               
000000r 1               ; HARDWARE LOCATIONS
000000r 1               ACIA		:= $A000
000000r 1               ACIACtrl	:= ACIA+0
000000r 1               ACIAStat	:= ACIA+0
000000r 1               ACIAData	:= ACIA+1
000000r 1               LED			:= $C000	; WRITE TO ROM SPACE TO ACCESS LED
000000r 1               
000000r 1               ; PAGE ZERO LOCATIONS USED
000000r 1               PRSTRL := $10	; POINTER TO PRINT STRING
000000r 1               PRSTRH := $11
000000r 1               INSTRL := $12	; POINTER TO INPUT STRING
000000r 1               INSTRH := $13
000000r 1               SCR16L := $14	; 16-BIT SCRATCH LOCATION OFTEN USED TO PASS ADDRESSES
000000r 1               SCR16H := $15
000000r 1               
000000r 1               ; RAM LOCATIONS
000000r 1               RAMSTART	:= $0
000000r 1               INSTRBUFFER	:= $400	; RESERVE 64 BYTES FOR INPUT STRING $400-$43F
000000r 1               VAL16L		:= $440	; 16-BIT VALUE
000000r 1               VAL16H		:= $441
000000r 1               VAL8		:= $442	; 8-BIT VALUE
000000r 1               
000000r 1               ; VARIOUS DEFINES
000000r 1               CR := $0D ; COMMAND TERMINATION
000000r 1               LF := $0A
000000r 1               
000000r 1               .segment "CODE"
000000r 1               .org $C000
00C000  1               
00C000  1               ; MACRO TO PASS A 16-BIT ADDRESS TO A FUNCTION AND CALL THE FUNCTION
00C000  1               ;	A REGISTER IS THE UPPER 8-BITS OF THE ADDRESS
00C000  1               ;	Y REGISTER IS THE LOWER 8-BITS OF THE ADDRESS
00C000  1               ;	FNC_NAME IS THE FUNCTION THAT IS CALLED
00C000  1               .macro CALLPASS16 FNC_NAME, ADDR16
00C000  1               	PHA					; SAVE A ON STACK
00C000  1               	TYA					; SAVE Y ON STACK
00C000  1               	PHA
00C000  1               	LDA	#ADDR16/256		; A IS THE UPPER 8-BITS OF THE ADDRESS
00C000  1               	LDY	#ADDR16&255		; Y IS THE LOWER 8-BITS OF THE ADDRESS
00C000  1               	JSR FNC_NAME
00C000  1               	PLA					; RESTORE Y
00C000  1               	TAY
00C000  1               	PLA					; RESTORE A
00C000  1               .endmacro
00C000  1               
00C000  1               .macro SETUPSCRADDR VAL32
00C000  1               	PHA
00C000  1               	LDA	#VAL32&255
00C000  1               	STA SCR16L
00C000  1               	LDA	#VAL32/256
00C000  1               	STA SCR16H
00C000  1               	PLA
00C000  1               .endmacro
00C000  1               
00C000  1               .macro PUSHY
00C000  1               	TYA
00C000  1               	PHA
00C000  1               .endmacro
00C000  1               
00C000  1               .macro PULLY
00C000  1               	PLA
00C000  1               	TAY
00C000  1               .endmacro
00C000  1               
00C000  1               Reset:
00C000  1  D8           	CLD
00C001  1  78           	SEI
00C002  1  A2 FF        	LDX     #$FF
00C004  1  9A           	TXS
00C005  1               BEGIN_RAM_TEST:
00C005  1               ; TEST FIRST LOCATION
00C005  1  A9 55        	LDA	#$55
00C007  1  85 00        	STA	$0
00C009  1  A5 00        	LDA $0
00C00B  1  C9 55        	CMP #$55
00C00D  1  D0 58        	BNE	RAMFAIL
00C00F  1  A9 AA        	LDA	#$AA
00C011  1  85 00        	STA	$0
00C013  1  A5 00        	LDA $0
00C015  1  C9 AA        	CMP #$AA
00C017  1  D0 4E        	BNE	RAMFAIL
00C019  1               ; TEST 2ND LOCATION
00C019  1  A9 55        	LDA	#$55
00C01B  1  85 01        	STA	$1
00C01D  1  A5 01        	LDA $1
00C01F  1  C9 55        	CMP #$55
00C021  1  D0 44        	BNE	RAMFAIL
00C023  1  A9 AA        	LDA	#$AA
00C025  1  85 01        	STA	$1
00C027  1  A5 01        	LDA $1
00C029  1  C9 AA        	CMP #$AA
00C02B  1  D0 3A        	BNE	RAMFAIL
00C02D  1               ; TEST PAGE ZERO RAM
00C02D  1               ;
00C02D  1  A2 02        	LDX	#2
00C02F  1               FILLRAMTST:
00C02F  1  8A           	TXA
00C030  1  95 00        	STA RAMSTART,X
00C032  1  E8           	INX
00C033  1  E0 00        	CPX	#0
00C035  1  D0 F8        	BNE FILLRAMTST
00C037  1               CHKFILL:
00C037  1  A2 02        	LDX	#2
00C039  1               CHKNXT:
00C039  1  8A           	TXA
00C03A  1  D5 00        	CMP	RAMSTART,X
00C03C  1  D0 29        	BNE	RAMFAIL
00C03E  1  E8           	INX
00C03F  1  E0 00        	CPX	#0
00C041  1  D0 F6        	BNE	CHKNXT
00C043  1               ; FILL PAGE ZERO
00C043  1               FILLPAGEZERO:
00C043  1  A9 00        	LDA #$00
00C045  1  A2 00        	LDX	#00
00C047  1               LOOPFILLPAGEZERO:
00C047  1  95 00        	STA	$0,X
00C049  1  E8           	INX
00C04A  1  E0 00        	CPX	#0
00C04C  1  D0 F9        	BNE LOOPFILLPAGEZERO
00C04E  1               ; FILL THE REST OF THE RAM
00C04E  1               FILLRAM:
00C04E  1  A9 00        	LDA	#$00
00C050  1  85 00        	STA	$0
00C052  1  A2 01        	LDX	#1			; PAGE NUMBER, START AT PAGE 1
00C054  1  A9 00        	LDA #$00		; FILL VALUE
00C056  1               FILLPAGESLOOP:
00C056  1  86 01        	STX	$1
00C058  1               FILLCURRENTPAGE:
00C058  1  91 00        	STA	($0),Y
00C05A  1  C8           	INY
00C05B  1  C0 00        	CPY	#$00
00C05D  1  D0 F9        	BNE	FILLCURRENTPAGE
00C05F  1               ; INCREMENT PAGE COUNT
00C05F  1  E8           	INX
00C060  1  E0 80        	CPX	#$80
00C062  1  D0 F2        	BNE	FILLPAGESLOOP
00C064  1               
00C064  1               ; JUMP TO OK
00C064  1  4C 6F C0     	JMP	RAMOK
00C067  1               ; RAMFAIL
00C067  1               RAMFAIL:
00C067  1  A9 01        	LDA	#1
00C069  1  8D 00 C0     	STA LED
00C06C  1               RAMFAIL1:
00C06C  1  4C 6C C0     	JMP	RAMFAIL1
00C06F  1               
00C06F  1               RAMOK:
00C06F  1  A9 00        	LDA	#0
00C071  1  8D 00 C0     	STA LED
00C074  1               ; Setup ACIA
00C074  1  20 83 C2     	JSR INITACIA
00C077  1  48 98 48 A9  	CALLPASS16 PRINTSTR, CRLFMsg
00C07B  1  C3 A0 29 20  
00C07F  1  16 C2 68 A8  
00C084  1               ; SETUP INPUT BUFFER POINTER
00C084  1  A9 04        	LDA	#INSTRBUFFER/256		; A IS THE UPPER 8-BITS OF THE ADDRESS
00C086  1  85 13        	STA INSTRH
00C088  1  A9 00        	LDA	#INSTRBUFFER&255		; Y IS THE LOWER 8-BITS OF THE ADDRESS
00C08A  1  85 12        	STA	INSTRL
00C08C  1               ; Display startup message
00C08C  1  48 98 48 A9  	CALLPASS16 PRINTSTR, StartupMsg
00C090  1  C2 A0 AA 20  
00C094  1  16 C2 68 A8  
00C099  1               ; INTERPRETER LOOP
00C099  1  AD 01 A0     	LDA	ACIAData			; flush input
00C09C  1               LOOP1:
00C09C  1  20 FC C1     	JSR INPUTSTR
00C09F  1  AD 00 04     	LDA	INSTRBUFFER			; GET FIRST LOCATION IN INPUT LINE
00C0A2  1               CHKA:
00C0A2  1  C9 49        	CMP	#'I'
00C0A4  1  D0 06        	BNE	SKIPA
00C0A6  1  20 2C C2     	JSR INSTRTST
00C0A9  1  4C 1B C1     	JMP	ENDLOOP
00C0AC  1               SKIPA:
00C0AC  1  C9 44        	CMP #'D'
00C0AE  1  D0 06        	BNE SKIPC
00C0B0  1  20 1E C1     	JSR DUMPRTN
00C0B3  1  4C 1B C1     	JMP ENDLOOP
00C0B6  1               SKIPC:
00C0B6  1  C9 3F        	CMP #'?'
00C0B8  1  D0 37        	BNE SKIPD
00C0BA  1  48 98 48 A9  	CALLPASS16 PRINTSTR, StartupMsg
00C0BE  1  C2 A0 AA 20  
00C0C2  1  16 C2 68 A8  
00C0C7  1  48 98 48 A9  	CALLPASS16 PRINTSTR, TestInStrMsg
00C0CB  1  C3 A0 AF 20  
00C0CF  1  16 C2 68 A8  
00C0D4  1  48 98 48 A9  	CALLPASS16 PRINTSTR, TestDumpStrMsg
00C0D8  1  C3 A0 DD 20  
00C0DC  1  16 C2 68 A8  
00C0E1  1  48 98 48 A9  	CALLPASS16 PRINTSTR, SetClrLEDStrMsg
00C0E5  1  C4 A0 16 20  
00C0E9  1  16 C2 68 A8  
00C0EE  1  4C 1B C1     	JMP ENDLOOP
00C0F1  1               SKIPD:
00C0F1  1  C9 4C        	CMP	#'L'
00C0F3  1  D0 16        	BNE SKIPE
00C0F5  1  AD 01 04     	LDA INSTRBUFFER+1	; 2ND LOCATION IN INPUT LINE
00C0F8  1  8D 00 C0     	STA LED
00C0FB  1  48 98 48 A9  	CALLPASS16 PRINTSTR, SetClrLEDStrMsg
00C0FF  1  C4 A0 16 20  
00C103  1  16 C2 68 A8  
00C108  1  4C 1B C1     	JMP ENDLOOP
00C10B  1               SKIPE:
00C10B  1               ; UNKNOWN COMMAND
00C10B  1  48 98 48 A9  	CALLPASS16 PRINTSTR, HelpMsg
00C10F  1  C2 A0 C7 20  
00C113  1  16 C2 68 A8  
00C118  1  4C 1B C1     	JMP ENDLOOP
00C11B  1               ENDLOOP:
00C11B  1  4C 9C C0         JMP	LOOP1
00C11E  1               
00C11E  1               ; DUMPRTN - DUMP A PAGE OF MEMORY TO THE SCREEN
00C11E  1               ; EXAMPLE: D C0XX - DUMP BLOCK $C000-$C0FF
00C11E  1               ; CONVERT_HEX_STRING_TO_BYTE
00C11E  1               ;	The address of the string is in SCR16L/SCR16H.
00C11E  1               DUMPRTN:
00C11E  1  A9 02        	LDA	#$02		; Start of address part of input string
00C120  1  85 14        	STA	SCR16L
00C122  1  A9 04        	LDA	#$04
00C124  1  85 15        	STA	SCR16H
00C126  1  20 91 C1     	JSR	CONVERT_HEX_STRING_TO_BYTE
00C129  1  AD 42 04     	LDA	VAL8
00C12C  1  85 15        	STA	SCR16H
00C12E  1  A9 00        	LDA #0
00C130  1  85 14        	STA	SCR16L
00C132  1  48 98 48 A9  	CALLPASS16 PRINTSTR, HeaderDumpMsg
00C136  1  C3 A0 41 20  
00C13A  1  16 C2 68 A8  
00C13F  1  A0 00        	LDY #0			; Y COUNTS THE BUFFER OFFSET
00C141  1               LOOPB2:				; WRITE OUT THE ADDRESS
00C141  1  98           	TYA
00C142  1  48           	PHA
00C143  1  A5 15        	LDA	SCR16H
00C145  1  20 64 C2     	JSR PRHEXSTR
00C148  1  68           	PLA
00C149  1  A8           	TAY
00C14A  1  20 64 C2     	JSR PRHEXSTR
00C14D  1  A9 20        	LDA #' '
00C14F  1  20 9B C2     	JSR	PUTCHAR
00C152  1  A2 00        	LDX #0			; X IS CHARS PER LINE COUNTER
00C154  1               LPBRTN:
00C154  1  B1 14        	LDA	(SCR16L),Y
00C156  1  C8           	INY
00C157  1  C0 00        	CPY #00
00C159  1  F0 20        	BEQ	ENDRTNB
00C15B  1  20 64 C2     	JSR PRHEXSTR
00C15E  1  A9 20        	LDA #' '
00C160  1  20 9B C2     	JSR	PUTCHAR
00C163  1  E8           	INX
00C164  1  E0 10        	CPX	#16
00C166  1  D0 EC        	BNE	LPBRTN
00C168  1  48 98 48 A9  	CALLPASS16 PRINTSTR, CRLFMsg
00C16C  1  C3 A0 29 20  
00C170  1  16 C2 68 A8  
00C175  1  A9 00        	LDA	#0
00C177  1  F0 C8        	BEQ	LOOPB2
00C179  1  D0 D9        	BNE LPBRTN
00C17B  1               ENDRTNB:
00C17B  1  A9 FF        	LDA	#$FF
00C17D  1  A8           	TAY
00C17E  1  B1 14        	LDA	(SCR16L),Y
00C180  1  20 64 C2     	JSR PRHEXSTR
00C183  1  48 98 48 A9  	CALLPASS16 PRINTSTR, CRLFMsg
00C187  1  C3 A0 29 20  
00C18B  1  16 C2 68 A8  
00C190  1  60           	RTS
00C191  1               
00C191  1               ; CONVERT_HEX_STRING_TO_BYTE subroutine converts a null-terminated string of
00C191  1               ;	hexadecimal digits to an 8-bit value.
00C191  1               ; The address of the string is in SCR16L/SCR16H.
00C191  1               ; The subroutine processes each character, converts it from ASCII hex to binary,
00C191  1               ;	shifts the current result left by 4 bits (to make room for the next nibble),
00C191  1               ;	and combines it with the new digit.
00C191  1               ; If a non-hex character is encountered, the subroutine returns an error value ($99).
00C191  1               CONVERT_HEX_STRING_TO_BYTE:
00C191  1  A9 00        		LDA     #$00           ; Clear A to start with 0
00C193  1  8D 42 04             STA     VAL8           ; Clear the result variable
00C196  1  AD 02 04             LDA		INSTRBUFFER+2
00C199  1               ;		JSR		PUTCHAR
00C199  1  20 B0 C1             JSR     HEX_TO_BIN     ; Convert ASCII hex digit to binary
00C19C  1  0A                   ASL                    ; Shift left to make room for the next nibble
00C19D  1  0A                   ASL
00C19E  1  0A                   ASL
00C19F  1  0A                   ASL
00C1A0  1  8D 42 04             STA     VAL8           ; Store the new result
00C1A3  1  AD 03 04             LDA		INSTRBUFFER+3
00C1A6  1               ;		JSR		PUTCHAR
00C1A6  1  20 B0 C1             JSR     HEX_TO_BIN     ; Convert ASCII hex digit to binary
00C1A9  1  0D 42 04     		ORA		VAL8
00C1AC  1  8D 42 04     		STA		VAL8
00C1AF  1               ;		JSR		PRHEXSTR
00C1AF  1  60           		RTS
00C1B0  1               
00C1B0  1               HEX_TO_BIN:
00C1B0  1  C9 30                CMP     #'0'           ; Compare with '0'
00C1B2  1  90 18                BCC     HEX_ERROR1     ; If less than '0', it's an error
00C1B4  1  C9 3A                CMP     #'9'+1         ; Compare with '9'+1
00C1B6  1  90 0C                BCC     HEX_NUM		   ; If equal to or less then '9', it's a number
00C1B8  1  C9 41                CMP     #'A'           ; Compare with 'A'
00C1BA  1  90 20                BCC     HEX_ERROR2     ; If less than 'A', it's an error
00C1BC  1  C9 47                CMP     #'F'+1         ; Compare with 'F'+1
00C1BE  1  B0 2C                BCS     HEX_ERROR3     ; If greater than 'F', it's an error
00C1C0  1  38           		SEC
00C1C1  1  E9 37                SBC     #'A'-10        ; Convert 'A'-'F' to 10-15
00C1C3  1  60                   RTS
00C1C4  1               
00C1C4  1               HEX_NUM:
00C1C4  1  38                   SEC
00C1C5  1  E9 30        		SBC     #'0'           ; Convert '0'-'9' to 0-9
00C1C7  1  60                   RTS
00C1C8  1               
00C1C8  1               CONVERT_DONE:
00C1C8  1  AD 42 04             LDA     VAL8           ; Load the final result into A
00C1CB  1  60                   RTS                    ; Return from subroutine
00C1CC  1               
00C1CC  1               HEX_ERROR1:
00C1CC  1  48 98 48 A9  		CALLPASS16 PRINTSTR, HexErr1Msg
00C1D0  1  C3 A0 79 20  
00C1D4  1  16 C2 68 A8  
00C1D9  1  A9 99                LDA     #$99           ; Load error value into A
00C1DB  1  60                   RTS                    ; Return from subroutine
00C1DC  1               
00C1DC  1               HEX_ERROR2:
00C1DC  1  48 98 48 A9  		CALLPASS16 PRINTSTR, HexErr2Msg
00C1E0  1  C3 A0 8B 20  
00C1E4  1  16 C2 68 A8  
00C1E9  1  A9 99                LDA     #$99           ; Load error value into A
00C1EB  1  60                   RTS                    ; Return from subroutine
00C1EC  1               
00C1EC  1               HEX_ERROR3:
00C1EC  1  48 98 48 A9  		CALLPASS16 PRINTSTR, HexErr3Msg
00C1F0  1  C3 A0 9D 20  
00C1F4  1  16 C2 68 A8  
00C1F9  1  A9 99                LDA     #$99           ; Load error value into A
00C1FB  1  60                   RTS                    ; Return from subroutine
00C1FC  1               
00C1FC  1               ; READ STRING INTO BUFFER
00C1FC  1               ;
00C1FC  1               INPUTSTR:
00C1FC  1  A0 00        	LDY #0
00C1FE  1               LOOPISTR:
00C1FE  1  20 8E C2     	JSR GETCHAR			; READ THE CHARACTER
00C201  1  20 9B C2     	JSR	PUTCHAR			; ECHO OUT THE CHARACTER
00C204  1  C9 0D        	CMP	#CR
00C206  1  F0 09        	BEQ DONEIS
00C208  1  C9 0A        	CMP	#LF
00C20A  1  F0 05        	BEQ DONEIS
00C20C  1  91 12        	STA	(INSTRL),Y
00C20E  1  C8           	INY
00C20F  1  D0 ED        	BNE	LOOPISTR
00C211  1               DONEIS:
00C211  1  A9 00        	LDA	#0				; NULL TERMINATE STRING
00C213  1  91 12        	STA	(INSTRL),Y
00C215  1  60           	RTS
00C216  1               
00C216  1               ; PRINTSTR - PRINT STRING
00C216  1               ; INPUT POINTER TO STRING IN PAGE ZERO
00C216  1               ;	A IS UPPER 8-BITS OF ADDRESS
00C216  1               ;	Y IS LOWER 8-BITS OF ADDRESS
00C216  1               PRINTSTR:
00C216  1  48           	PHA
00C217  1  85 11        	STA PRSTRH
00C219  1  98           	TYA
00C21A  1  85 10        	STA PRSTRL
00C21C  1  A0 00        	LDY	#0
00C21E  1               LPPRSTR:
00C21E  1  B1 10        	LDA	(PRSTRL),Y
00C220  1  C9 00        	CMP #0
00C222  1  F0 06        	BEQ DONESTR		; If the character is null (end of string), exit
00C224  1  20 9B C2     	JSR	PUTCHAR		; Call subroutine to print the character
00C227  1  C8           	INY				; Increment X to point to the next character
00C228  1  D0 F4        	BNE	LPPRSTR		; Repeat the loop (always true since X is 8-bit)
00C22A  1               DONESTR:
00C22A  1  68           	PLA
00C22B  1  60           	RTS
00C22C  1               
00C22C  1               INSTRTST:
00C22C  1  48 98 48 A9  	CALLPASS16 PRINTSTR, InputStrMsg
00C230  1  C3 A0 07 20  
00C234  1  16 C2 68 A8  
00C239  1  20 FC C1     	JSR INPUTSTR	; READ IN THE STRING
00C23C  1  48 98 48 A9  	CALLPASS16 PRINTSTR, InputStrWasMsg
00C240  1  C3 A0 15 20  
00C244  1  16 C2 68 A8  
00C249  1  48 98 48 A9  	CALLPASS16 PRINTSTR, INSTRBUFFER
00C24D  1  04 A0 00 20  
00C251  1  16 C2 68 A8  
00C256  1  48 98 48 A9  	CALLPASS16 PRINTSTR, CRLFMsg
00C25A  1  C3 A0 29 20  
00C25E  1  16 C2 68 A8  
00C263  1  60           	RTS
00C264  1               
00C264  1               PRHEXSTR:
00C264  1  48                   PHA                    ; Push A onto the stack to save its value
00C265  1  48                   PHA                    ; Push A onto the stack to save its value
00C266  1  4A                   LSR                    ; Shift right to get the high nibble
00C267  1  4A                   LSR
00C268  1  4A                   LSR
00C269  1  4A                   LSR
00C26A  1  20 75 C2             JSR     PRINT_NIBBLE   ; Print the high nibble
00C26D  1  68                   PLA                    ; Pull A from the stack to restore its value
00C26E  1  29 0F                AND     #$0F           ; Mask out the high nibble
00C270  1  20 75 C2             JSR     PRINT_NIBBLE   ; Print the low nibble
00C273  1  68                   PLA                    ; Pull A from the stack to restore its value
00C274  1  60                   RTS                    ; Return from subroutine
00C275  1               
00C275  1               PRINT_NIBBLE:
00C275  1  48                   PHA                    ; Push A onto the stack to save its value
00C276  1  C9 0A                CMP     #$0A           ; Compare with 10
00C278  1  90 02                BCC     PRINT_DIGIT    ; If less than 10, it's a digit
00C27A  1  69 06                ADC     #$06           ; If 10 or more, convert to ASCII letter (A-F)
00C27C  1               PRINT_DIGIT:
00C27C  1  69 30                ADC     #$30           ; Convert to ASCII digit
00C27E  1  20 9B C2             JSR     PUTCHAR	       ; Print the character
00C281  1  68                   PLA                    ; Pull A from the stack to restore its value
00C282  1  60                   RTS                    ; Return from subroutine
00C283  1               
00C283  1               ; INITIALIZE THE ACIA
00C283  1               INITACIA:
00C283  1  A9 03        	LDA 	#$03		; Master Reset ACIA
00C285  1  8D 00 A0     	STA	ACIACtrl
00C288  1  A9 15        	LDA 	#$15		; Set ACIA baud rate, word size and Rx interrupt (to control RTS)
00C28A  1  8D 00 A0     	STA	ACIACtrl
00C28D  1  60           	RTS
00C28E  1               
00C28E  1               ; GET A CHARACTER FROM THE ACIA
00C28E  1               ; RETURN CHAR IN A REGISTER
00C28E  1               GETCHAR:
00C28E  1  AD 00 A0     	LDA	ACIAStat
00C291  1  29 01        	AND #1
00C293  1  C9 01        	CMP #1
00C295  1  D0 F7        	BNE GETCHAR
00C297  1  AD 01 A0     	LDA	ACIAData
00C29A  1  60           	RTS
00C29B  1               
00C29B  1               ; PUT A CHARACTER FROM THE A REGISTER OUT THE ACIA
00C29B  1               PUTCHAR:
00C29B  1  48           	PHA
00C29C  1               LPUTC:
00C29C  1  AD 00 A0     	LDA	ACIAStat
00C29F  1  29 02        	AND #2
00C2A1  1  C9 02        	CMP #2
00C2A3  1  D0 F7        	BNE LPUTC
00C2A5  1  68           	PLA
00C2A6  1  8D 01 A0     	STA ACIAData
00C2A9  1  60           	RTS
00C2AA  1               
00C2AA  1               ; Strings kept in ROM (constant values)
00C2AA  1               StartupMsg:
00C2AA  1  0D 0A 53 69  	.byte	$0D,$0A,"Simple Monitor 6502 v1.0",$0D,$0A,$00
00C2AE  1  6D 70 6C 65  
00C2B2  1  20 4D 6F 6E  
00C2C7  1               HelpMsg:
00C2C7  1  49 2D 54 45  	.byte	"I-TEST INPUT STRING, D-DUMP HEX, L-LED Write, ?-DETAILED HELP",$0D,$0A,$00
00C2CB  1  53 54 20 49  
00C2CF  1  4E 50 55 54  
00C307  1               InputStrMsg:
00C307  1  49 6E 70 75  	.byte	"Input string:",$00
00C30B  1  74 20 73 74  
00C30F  1  72 69 6E 67  
00C315  1               InputStrWasMsg:
00C315  1  0D 0A 49 6E  	.byte	$0D,$0A,"Input string was:",$00
00C319  1  70 75 74 20  
00C31D  1  73 74 72 69  
00C329  1               CRLFMsg:
00C329  1  0D 0A 00     	.byte	$0D,$0A,$00
00C32C  1               TestValu8:
00C32C  1  35 41 00     	.byte	"5A",$00
00C32F  1               FailMsg:
00C32F  1  0D 0A 46 41  	.byte	$0D,$0A,"FAIL",$0D,$0A,$00
00C333  1  49 4C 0D 0A  
00C337  1  00           
00C338  1               PassMsg:
00C338  1  0D 0A 50 41  	.byte	$0D,$0A,"PASS",$0D,$0A,$00
00C33C  1  53 53 0D 0A  
00C340  1  00           
00C341  1               HeaderDumpMsg:
00C341  1  0D 0A 41 44  	.byte	$0D,$0A,"ADDR 0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F",$0D,$0A,$00
00C345  1  44 52 20 30  
00C349  1  20 20 31 20  
00C379  1               HexErr1Msg:
00C379  1  0D 0A 48 65  	.byte	$0D,$0A,"Hex Error (1)",$0D,$0A,$00
00C37D  1  78 20 45 72  
00C381  1  72 6F 72 20  
00C38B  1               HexErr2Msg:
00C38B  1  0D 0A 48 65  	.byte	$0D,$0A,"Hex Error (2)",$0D,$0A,$00
00C38F  1  78 20 45 72  
00C393  1  72 6F 72 20  
00C39D  1               HexErr3Msg:
00C39D  1  0D 0A 48 65  	.byte	$0D,$0A,"Hex Error (3)",$0D,$0A,$00
00C3A1  1  78 20 45 72  
00C3A5  1  72 6F 72 20  
00C3AF  1               TestInStrMsg:
00C3AF  1  20 49 2D 54  	.byte " I-Test Input String (type and show string)",$0D,$0A,$00
00C3B3  1  65 73 74 20  
00C3B7  1  49 6E 70 75  
00C3DD  1               TestDumpStrMsg:
00C3DD  1  20 44 20 58  	.byte " D XX-Dump Memory Block (Ex: DA0 dumps block $DA-$DAFF",$0D,$0A,$00
00C3E1  1  58 2D 44 75  
00C3E5  1  6D 70 20 4D  
00C416  1               SetClrLEDStrMsg:
00C416  1  20 4C 23 2D  	.byte " L#-LED Write: 0= Off, 1=On",$0D,$0A,$00
00C41A  1  4C 45 44 20  
00C41E  1  57 72 69 74  
00C434  1               .segment "VECTS"
00C434  1               .org $FFFA
00FFFA  1  00 C0        	.word	Reset		; NMI
00FFFC  1  00 C0        	.word	Reset		; RESET
00FFFE  1  00 C0        	.word	Reset		; IRQ
00FFFE  1               
