= C Compiler for the 6800 (CC6303) =

A C compiler for the 6800 processor from [https://github.com/EtchedPixels/CC6303 EtchedPixels].

This is based upon [https://github.com/cc65/cc65 cc65] but involves doing some fairly brutal things to the original compiler. As such I currently have no plans to merge it back the other way.

In particular cc65 has a model where the code is generated into a big array which is parsed as it goes into all sorts of asm level info which drives optimizer logic. It also uses it to allow the compiler to re-order blocks and generate code then change its mind.

= Status =

The basic structure is now reasonably functional. You can "make" and "make install" to get a complete compiler/assembler/linker/tools that appear to generate actual binaries.

The assembler and linker should be reasonably reliable and complete. The compiler at this point should be reasonably solid on 6803 and 6303 except for 32bit types. The core compiler support for 32bit types is there and mostly tested but the library helpers for shifts, multiply and particularly division are not yet fully debugged.

On the 6800 processor the library routines are far from complete. Note that the 6800 target will generate much slower and larger code because the 6800 lacks 16bit operations and some other important features. 6800 code is about a third larger.

The bundled C library routines are initial code and not fully tested or reviewed. They are intended to provide native versions of key and time critical functions not a full C library.

= How to use =

For a simple test environment the easiest approach at this point is to compile the code with cc68 and then link with a suitable crt.o (entry code)
<pre>
cc68 -m6803 -c foo.c
ld68 -b -C startaddress crt.o mycode.o /opt/cc68/lib/lib6803.a
</pre>

= TODO =

* Strip out lots more unused cc65 code. There is a lot of unused code, and a load of dangling header references and so on left to resolve.
* Remove remaining '6502' references.
* Make embedding C source into asm as comments work for debugging
* The assembler uses 15 char names internally. The compiler does not. This leads to asm errors when the symbols clash.
* Maybe float: cc65 lacks float beyond the basic parsing support, so this   means extending the back end to handle all the fp cases (probably via stack) and using the long handling paths for the non maths ops.
* A proper optimizer

= BIG ISSUES =

* We can make much better use of X in some situations than the cc65 code based generator really understands. In particular we want to be able to tell the expression evaluation "try and evaluate this into X without using D". In practice that means simple constants and stack offsets. That will improve some handling of helpers. We can't do that much with it because we need to be in D for maths. Right now the worst of this is peepholed.
* Fetch pointers via X when we can, especially on 6803. In particular also deal with pre/post-inc of statics (but not alas pre/post inc locals) with

<pre>
ldx $foo
inx
stx $foo
dex
</pre>

* Make sure we can tell if the result of a function is being evaluated or if the function returns void. In those cases we can use D (mostly importantly  B) to use abx to fix the stack offsets.
* copt has no idea about register usage analysis, dead code elimination etc. We could do far better with a proper processor that understood 680x not just a pattern handler. We fudge it a bit with hints but it's not ideal.
* Floating point
** The cc65 front end has some float support although it is not supported by the back end, and I don't know how tested the frontend code is therefore. Adding float should not be hard, it's basically a long with no inlineable operators as far as the compiler code generator is concerned. It would however need someone to volunteer to write the basic IEEE floating point operations (add, negate, multiply, divide, maybe compare, plus conversion to and from float) for a 680x processor.

= Thoughts on 6800 Implementation =

The first problem is the lack of PSHX and PULX. The current code uses these to stack arguments more easily, because you can LDX, PSHX but have to LDD PSHA/B (or on 6800 LDAA LDAB PSHA/B).

Almost all of this code goes via CanLoadViaX/CanStoreViaX so you can tell the compiler tough it can't do that.

X is not preserved across function calls so pshx/pulx is only used internally for preserving stuf and that can use an extra  DP value instead (just remember to save/restore it on irqs like @tmp and friends).

Constant loads need optimizing because it's not only a win to use clra/clrb but also to do things like clra ldab #n and also to spot stuff like -1 with
<pre>
ldaa #-1 tab
</pre>

Probably all the ldd statements everywhere would want to become

<pre>
LoadDConst(value, preserve_carry)
LoadDViaX(value)
</pre>

and churn out the right per CPU code, ditto some other cases.

The second problem is adjusting the stack. On the 6803 we can use ABX to recover the stack frame (although we don't yet do it well as we don't usually know in the right place if we called a void function or don't need the arguments). On the 6800 you can't pull into X which also means that since A and B hold your arguments you've not got many options. For smaller values one option might be to have say 32 INS statements in a row with labels and just JMP to the right offset. Big stuff will have to std @tmp sts @tmp2 ldd #-n addd @tmp2 std @tmp2 lds @tmp2 etc

Similar problem building a stack frame but worse in that you can't just jsr/rts. Possibly something like

<pre>
 ldx #label
 jmp growstack
label:	.byte n
 code continues...
</pre>

but still not pretty...

Various other chunks of code need to move between X and D. These should already do the right thing because when you can't work via X the same mess is present on 6803, and only 6303 has xgdx. With some peephole rules a surprisingly large number of these go away.

The painful stuff is dealing with all the code that uses 16bit ops for add/sub/etc as each will need an alternative, or in some cases for size probably a helper jsr. A lot of it doesn't bloat much but becomes add/adc etc.

Stack offsets are uglier because there is no ABX. That means that if it's not within the ,X range you have to do it the hard way and can't use tsx abx patterns . The code is already there for this, it's just ugly and slow but the 6801/6303 almost never use it. Shouldn't be a big problem cc65 on the 6502 just barfs in this case and it handles most stuff!

(Another option for the D reg stuff in many cases might be to add a
<pre>
 .setcpu 6800auto
</pre>

and have the assembler turn the 16bit ops that are trivial into the  equivalent pairs - eg for load, store, rotate, shift, add, sub.)

= General Status =

The front end is little modified from cc65 so should be robust. The integer and character support has been fairly well tested and the compiler can build a mostly functional Fuzix kernel and userspace.

32bit maths is a lot less tested. The basics should be right and it appears to be working correctly for the Fuzix time handling code.

The assembler is reasonably well tested as is the linker. The linker is written from scratch so may well have a few glitches left to find.

The cc68 command supports a reasonable set of the usual cc options.

= General Limitations = 

The 680x processors have a single index register. In general this is not a big problem and the code generated is acceptable. Functions that copy data around can however generate quite horrible code. The library supports hand written implementations of key functions where this matters - memcpy for example.

The compiler works internally on 16bit values. It has some understanding of byte operations. Providing signed char is not used the extra code where it uses 16bit operations has a minimal cost (at least on 6803 and 6303) and the optimizer can already clean some of it up. Signed char is very expensive and should be avoided if possible.

The 6303 code generator will use xgdx. This makes 6303 code incompatible with the 68HC11. Use 6803 if 68HC11 compatibility is required.

Currently an argument cannot be a register variable. Declaring one register will ignore the hint.

As the compiler has direct page temporaries and register variables any re-entrant code for interrupts or signals will need to save these first.

= Calling Conventions =

cc68 uses cc65 like conventions for the 6800 processor. Arguments are stacked left to right, varargs are handled specially and the called function performs the stack clean up.

For the 6803/6303 processors the same basic rules apply but the caller performs stack clean up in a more conventional fashion. 6800 and 680x compiler output are not compatible.

The stack ordering may change if I find a good way to modify the compiler to stack the arguments in classic C style.

Function returns are in the D register (ie AB on 6800). A 16bit direct page register called sreg is used for 32bit maths and also to return the upper half of a 32bit result. All registers are assumed destroyed by the called function including direct page temporaries. Register variables in the direct page are saved and restored by the called function if used.

= Unimplemented Functionality =

Bitfields have not been tested at all. They may work but if they do it's by accident.

Floating point is not supported at all by the compiler backend as with cc65. The front end supports floating point types so this could in theory be added at least for 32bit float. Doing so would need someone to implement fpadd, fpsub, fpneg, fpmul, fpmod, fpdiv and maybe a couple of other basic operations between stack and D + dp registers.

You cannot insert source code as comments into the assembly output for debugging.

There is no provision to directly generate Fuzix relocatable binaries.

cc68 does not yet support sensible diagnostics for many command line errors but just reports 'usage...'. This will change once the arguments are a bit more stable.

The -l option on the front end does not yet resolve short names of libraries (eg -lc).

= Known Incomplete =

The 6800 code generator is still not completed and only minimally debugged.

Optimization is fairly basic at this point.

The Flex support code is just a sketch. Most of the library code is not heavily tested and some of it is unfinished.

= Install =

make; make install

It will by default place itself in /opt/cc68.

No special tools should be needed.

= Usage =

cc68 [options] [files]

The file types supported are '.c' - which will be preprocessed and compiled, '.S' which will be preprocessed and assembled, '.s' which will be assembled, and '.o' for object files.

Most of the standard C compiler options are supported. In addition the -M otion generates a map file, and -t name sets the target to this name. Currently the system supports fuzix, mc10 and flex targets.

When debugging the '-X' option keeps the temporary files. The .@ file is the compiler output, the '.s' file is the results of the optimizing pass.

= Additional Credits =

The cc68 compiler would not be possible without the work of Ullrich von Bassewitz and the many other contributors to the cc65 code.

The cc68 assembler is derived from the assembler by Mark Williams Co. released by Robert Swartz. Please see as68/COPYRIGHT.MWC.

The optimizer pass uses copt by Christopher W Fraser.
