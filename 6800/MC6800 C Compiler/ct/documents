*** Note- this document describes " newas09 ", not "as09".
*** We are in the middle of a conversion form as09 to newas09.
*** All new programs should use Newas09.

Relocatable/psect-able 6809 assembler manual.

Theory:
        The relocating assembler produces object files that
        can be placed anywhere in memory with minor modification.
        The object files have all the information in them for
        relocation to a specific area of memory by the linking loader,
        called 'll09'.  Also, the modules may refer to each other.
        This allows a library of subroutines that can be pointed
        to during relocation by a main program, linked into one
        program, and placed in a absolute address in memory.

                At this point, the 6809 assembler takes most
        number fields in any indirect instructions to be 16 bits
        long.  The exception to this is simple one-number offsets
        the magnitude of which can be known in pass 1.
        For an index of zero (and the corresponding byte
        savings) type (for example)     lda     ,x .  This would
        be the same as the old 6800 way of 'ldaa  0,x' .  This is a
        new assembler and may have some hidden bugs in it.
        The psydo-op
        code is the same as in the other 'mas' assemblers, and should
        be reliable.

Instruction format:

        Many type of the basic data definition psydo-ops are supported.
        Here is a list of the typicall "biggies":
        fcb     db      .byte   defines a byte.
        fdc     dw      .word   defines a word.
        fcc     ds      .ascii  defines a string in '"' (double-quotes)
        rmb     rs              reserves 'n' bytes.

Arithmetic:
        The arithmetic power of the assembler is that of the
        'C' language on the 11/70.  There is NO order of operations,
        so parenthesis () must be used to direct the assembler.
        The operators are:
        + - *   standard.
        /       divide, get the integer portion
        %       mod operator (i.e. 16%5 = 1)
        >>      arithmetic shift right
        <<      arithmetic shift left
        ^       XOR
        !       complement
        ~       two's complement
        &       and
        |       or

        The operators for the comparisons (used in if statement or
        anywhere else the result it true or false)
        ==      equal to
        !=      not equal to
        <=      less than or equal to
        >=      greater than or equal to
        >         "      "
        <       less     "
        ||      or
        &&      and


        . or *  are values for the Pc (start of the current
                instruction )

    Errors:
        Errors are preceded by the line number they occur in.
        They are preceded by a  '%%' so that files may be read
        in with the editor to search for errors (useful on long
        programs.)

    Table sizes:
        Max number of symbols = 800
        Max  "     "  macros  = 50
        Max  "     "  char. in a dup = 400
        Max  "  of local variables in a macro = 20

        Labels begin in the first column.  A colon after the label
        is not needed, but if one is there it is ignored.  The length
        of a label may be up to 20 characters.
        A double-colon ( :: ) after a label forces that label into
        the symbol table under all conditions, even in a macro.

        All arithmetic operators have the same priority
        (there is no order of operations)

    Files produced are:
        n.rel   6809 Relative binary
        n.sym   Symbol table dump

        The linking loader for as09 (ld09) produces the actual
        S 1  format binary, allong with maping and symbol table
        files.

        Many tables are not checked for overflow.
        Table overflow presents itself with a core dump.  If
        you should get a core dump, contact me (/a/wa1yyn) and
        I will try increase the offended table.

Radix Conventions:

         Numbers with no post or pre radix tags are initially decimal.
        Post radix tags are:
                q       octal
                h       hex
        Pre-radix tags are:
                0       octal
                00      hex
                000     binary
                $       hex
        Any number with a hex digit in it is considered hex
        irregardless of any radix flags.
        Note that these conventions allow compatibility with both
        the Intel and Motorola formats.
        Otherwise, post radix has priority.
        To change the default radix, use the 'base' psydo-op.
        the operand field of the base psydo-op  is always
        in base ten.  Usage is:

        base    16      ;to set default radix to base 16
                The operand field of the base psydo-op is
                always in base ten.

Indirection:
                Any instructions that can take indexing can use
        brackets around the operand field to denote indirection, i.e.
                lda     [4,x]
                ldd     [1234h]

Pushes, pulls and transfers:

                After a push or pull instruction,  a list of registers
        in any order may be given.  Valid registers are:
        a,b,d,dp,x,y,c,s/u.  Transfers format is:
                tfr     source,destination
        Exchanges use the same format.  Valid registers are:
        d,x,y,u,s,pc,a,b,cc and dp.  Extra letters may exist
        after any letter for a register, i.e. p and pc and pcr
        are equivalent.  The letter 'z' may also be used for base page
        addressing in place of 'dp'.


Pysdo Ops:

    org #
           A symbol on an org statement has the value
        of the org #. i.e.

        foo     org     10h

        'foo' will have a value of 10h.

label    equ  [expression]
            Assigns the value of the expression to the label.
        Expressions can contain any previously defined symbols.
        There is NO  'SET' psydo-op.  Use  'eval' instead (see below)


    db  # [,#,#...]     (also fcb and .byte)
           Define Byte.  Evaluates the number and stores it.
        Can stack arguments seperated by commas.  Only the lower eight
        bits are stored. Any high-order bits are truncated.

    ds  # or "string" [,...]    (also fcc and .ascii)
           Define storage.  Evaluates the number and reserves
        that much room.  If string, initializes storage area
        to string.      Special characters are preceded by a '\'.
        '\r' is 15q (carriage return)
        '\n' is 12q (line feed)
        '\t' is 11q (tab)
        '\b' is a 10q (backspace)
        '\0' is 0  (null byte)
        '\"' for the  "  character itself
        '\\' for a back-slash  (  \  )

    .asciiz or .asciz "string"
            Just like ds, fcc, and .ascii except that a zero
        byte is placed at the end of the string.

    dw  # [,...]        (also fdb and .word)
          Define word.  Evaluates the number and stores as a
        full word (2 bytes).

    repeat      n
           Repeats the line following the 'repeat' n times.
        Nested repeats produce funny but constant results.
        Labels in the line are passed on the first repetition,
        and deleted for subsequent repetitions.
        Do not try to repeat a dup.

    dup n
         .
        [dup field]
         .
        enddup
           Duplicates the series of lines between the dup and the
        enddup n times.
        Labels in the dup field are passed on the first dup, and
        deleted for subsequent dups.  Dups may be nested.

    defmacro    name
         .
        [macro body]
         .
        endmacro
           Defines the macro 'name' as the macro body.  Arguments
        in main are substituted whenever there is a &# , where
        1 <= # <= 9 .  The number of calling parameters is not
        specified.  To invoke the macro, type:

        name    arg1,arg2,...arg9

        Be sure the arguments match the call.  mas80 does not
        check for this.
        Local symbols may be used in the macros.  The symbols must
        not appear elsewhere in the program.
        To use a '&' in the text string or macro body, type
        a '\&' instead.
        Instructions may be used as macro names to replace
        or modify an instruction to your liking.  Generally
        speaking, macro names take precedence over everything.
        Maximum nesting level is at least 22 levels, and maybe
        more depending on various unexplicable conditions.
        There is (currently) no way to pass the character ';' to
        a macro as an argument.  The first ';' encountered starts
        the comment field for the macro.


    if  expression
    .
    (code here assembled if value of 'expression' is not-zero)
    .
    [else]
    .
    (code here assembled if value of 'expression' is zero.
        This code here is optional.)
    .
   endif
        Conditional assembly.  Done if expression is non-zero.
        'expression' is any valid 'c' expression.
        Can be nested.

    listoff
        Suppresses listing of source.  The statement itself is not
        listed.

    liston
        Enables listing of source.  The statement itself is not listed.

    binoff
        Suppresses generation of binary (m.out) file.

    binon
        Enables (turns on) generation of binary (m.out) file.


    include     "filename"
            Takes the file 'filename' and runs it through the assembler
        until it is ended, when it returns to the original source.
        The include file can include other include files.  All assembler
        psydo-ops are valid in the include file and code can be generated.
        Only one file name in the operand field is allowed.  To include
        a number of files, use a seperate include statement for each one.

    macon, macoff
            Disables or enables the inclusion in the listing of the
        source (m.lst) the expanded code produced during macro expansion.

    byteson and bytesoff
            These command allow supresion of the bytes of data
        normally printed with a db, dw, or ds type instruction
        in the listing.  Only the source code line is listed.


    end
            Last statement of assembler.  Signals end of source code.

    Internal Variables:

        Internal variables exist with certain useful information in
    them.  They may be used in expressions like any other variables.
        Valid internal variables are:

        _NARGS          Number of arguments passed in the most recent
                macro.  This is NOT a nested variable.

        _NEST           Number of levels of nesting in a macro, repeat,
                or dup.

  Psydo-ops used to help relocatability are :

        'external       prog1,prog2,...progn'
        Declares various programs as being external, so that they
        can be referenced within this module.

        'global   sym1,sym2,...    '
        Declares various symbols as being global.  Their value is passed
        to the linker and these symbols inside of this module can be
        referenced by other modules.

        'loadmod        mod1,mod2,....  '
        Forces the linker to load the modules (mod1,mod2, etc) whether
        they are referenced or not.  This is useful for big modules
        (like I.O. packages) that have multiple entry points defined as
        globals, where the user can't be sure that the correct global
        will be referenced to force the linker to load the module.

        '.text' ,  '.data' ,  '.bss' ,  '.abs' ,  '.stack'
        These commands are used to change psects (program sections).
        By changing program sections, one can force all information
        of a given type to be contiguous in the output file.  For
        example, all the program instructions (.text) will be together
        to allow easy entry into a rom.  All initialized data (.data)
        can also be contiguous.  '.bss' is for unitialized data (rmb
        type commands), and '.abs' allows the code to go into whatever
        location the user has specified without relocation, and any
        variables declared under abs do not get any relocation.
        There are no restrictions as to how often one can exit/enter
        different psects.

        '.psect n'              (n = 5, 6, 7)
        There are three other psects availible which the user can select
        and do as s/he pleases.

Sample Program:


*       sample relocatable module
        external        output,input
        global  data
        global  go
* this program gets input and echoes it to output putting the character
* in a variable.
        .data
data    db      0
        .text
go      jsr     input
        staa    data
        jsr     output
        staa    absadd
        rts
        .abs
absadd  equ     1234h
        end


Linking and relocating modules:
        Control of linking various subprograms together and specification
        of psect areas is left to the linker.  The linker also produces
        the ".out", ".sym" and ".map" files.  See 'ld09.manual".

To use:  type:  % x/as09 filename
***Note: the as09 assembler refered to here is really the "newas09"
*** until such time as newas09 is fully debugged and installed as
"as09".  -pdh

        'ld09' is the linking loader for the 'as09' assembler.  It will
read in a main program, and get any of the external programs it
references, and any externals referenced in them, etc, etc,
iteratively until all the externals are resolved.  Note that each
routine is loaded once regardless of how much it is called.
Impure routines recursively called could bungle things a might.
Format:
        ld09 filename [reloc addr] [library dir.] [more lib. dir]...

where 'filename' is the file name of the main program (stored as
                'filename.rel')

        'reloc addr' is the address the relocated module is to start
        (default is 100 hex).  This number is in hex.

        'library dir.'  is a pointer to a directories in which ld09 will
        look for  external files (except 'filename', the main
        program).  Default directory is the current directory.
        Note that the last '/' is missing from the path name.

Example:        ld09 myprog  1000 /usr2/wa1yyn/68lib

Output file is 'filename.out' in absolute 6809 format. ('S1' format)

        'ld09' also gives list of where each routine is in memory,
        and where the entry point for each routine is.  Note that
        the  options must be given in the order listed.

Another file produced is 'filename.sym' which is a symbol table
dump of the 1) symbols in filename 2) address of all modules
used and 3) all global variables.

To use: type % x/ld09 ...(as above)

Rom modules:
        To make a rom module, use 'rommod68'.  See the manual.
        This program makes a module for ld09 that generates no code
        and puts the address of a rom routine in wherever the program
        referenced it.

Relocatable/psectable 6809 format:

S0name          name of module

S2BCRRRRAAAAPP PPDD[PPDD...]CK          Relocatable code
                                        (space added for clarity)
        BC = bytecount
        RRRR = 16 bit relocation mask keyed to high-order bit
        AAAA = relative pc
        PP = psect for the data byte to follow
        DD = data bytes
        CK = checksum

S3name          Load the module 'name'.  Forces modules to be loaded,
                useful for libraries and the like.

S4AAAAPPname    Global symbol definition.  Enters 'name' as a global
                symbol with the (relocated) address of AAAA in that
                module.

S5AAAA          Rom module entry point. Can Not be used with record
                types S2,S6,S7, or S8.

S6AAAAPP        entry point- relative entry point for the module
                (soon to go away)

S7AAAAPPname    External reference module.

S8LLLLPP        Length of the module in bytes

SAAAAAPPname    Symbol table. AAAA is address, name is symbol name

SBAAAAPPname    Relocatable external reference (i.e. lbra extern)

S9              End of module
