
*
* Conversion type table
*

 data

cvruls fcb 7,0,1 30 FPP
 fcb 7,0,1 31 FMM
 fcb 7,0,1 32 BPP
 fcb 7,0,1 33 BMM
 fcb 4,0,1 34 NOT
 fcb 0,0,4 35 ADR
 fcb 5,0,3 36 IND
 fcb 1,0,1 37 UNM
 fcb 2,0,1 38 COM
 fcb 0,0,0 39 XXX

 fcb 1,1,1 40 ADD
 fcb 1,1,1 41 SUB
 fcb 1,1,1 42 MUL
 fcb 1,1,1 43 DIV
 fcb 2,1,1 44 MOD
 fcb 2,2,1 45 SHR
 fcb 2,2,1 46 SHL
 fcb 2,1,1 47 AND
 fcb 2,1,1 48 BOR
 fcb 2,1,1 49 XOR
 fcb 0,0,0 50 XXX
 fcb 0,0,0 51 XXX
 fcb 0,0,0 52 XXX

 fcb 4,0,2 53 LND
 fcb 4,0,2 54 LOR
 fcb 0,0,0 55 XXX
 fcb 0,0,0 56 XXX
 fcb 0,0,0 57 XXX
 fcb 0,0,0 58 XXX
 fcb 0,0,0 59 XXX

 fcb 4,1,2 60 EQU
 fcb 4,1,2 61 NEQ
 fcb 4,1,2 62 LEQ
 fcb 4,1,2 63 LES
 fcb 4,1,2 64 GEQ
 fcb 4,1,2 65 GRT
 fcb 0,0,0 66 XXX
 fcb 0,0,0 67 XXX
 fcb 0,0,0 68 XXX
 fcb 0,0,0 69 XXX

 fcb 4,3,1 70 ADA
 fcb 4,3,1 71 SUA
 fcb 4,3,1 72 MUA
 fcb 4,3,1 73 DIA
 fcb 4,3,1 74 MOA
 fcb 4,3,1 75 SRA
 fcb 4,3,1 76 SLA
 fcb 4,3,1 77 ANA
 fcb 4,3,1 78 BOA
 fcb 4,3,1 79 XOA
 fcb 4,3,1 80 ASN
 fcb 0,0,0 81 XXX
 fcb 0,0,0 82 XXX
 fcb 0,0,0 83 XXX
 fcb 0,0,0 84 XXX
 fcb 0,0,0 85 XXX
 fcb 0,0,0 86 XXX
 fcb 0,0,0 87 XXX
 fcb 0,0,0 88 XXX
 fcb 0,0,0 89 XXX

 fcb 0,0,1 90 CXB
 fcb 0,0,1 91 CBR
 fcb 0,0,1 92 CEN
 fcb 0,0,0 93 ORB
 fcb 0,0,0 94 ORE
 fcb 0,0,0 95 ANB
 fcb 0,0,0 96 ANE
 fcb 0,0,0 97 ORC
 fcb 0,0,0 98 ANC

 fcb 0,0,5 99 DOT

 fcb 6,0,3 100 CAL
 fcb 8,0,1 101 PRM
 fcb 8,0,1 102 LOD
 fcb 0,0,0 103 SPL
 fcb 0,0,0 104 SPR
 fcb 0,0,1 105 CMA

 text

*
* Set matrix entry type.  Do any necessary type
* conversions, making additional matrix entries
* if necessary.  X is pointing to last entry made.
*

prctyp jsr clsfy classify operands
 lda copr get operator
 bmi 4f
 ldy #cvruls point to rules table
 suba #30 remove bias
 bmi 4f
 ldb #3 set rule table size
 mul find rule
 leay d,y
 jsr chtyp check type
 jsr rslt set result
4 rts

*
* Classify operands
*

clsfy lda moprtr,x get operator
 sta copr save it
 ldu #cop1 point to op1 info field
 ldy mo1loc,x get op1 location
 bne 2f
 ldd #0 zero info fields
 sta cpt,u
 std ctp,u
 std clc,u
 bra 5f
2 cmpy #255 is it matrix level?
 bhi 4f
 bsr clset set level info
 bra 5f
4 bsr csett set type info
5 ldu #cop2 setup for op 2
 ldy mo2loc,x get location of op 2
 bne 6f
 ldd #0 zero info fields
 sta cpt,u
 std ctp,u
 std clc,u
 bra 9f
6 cmpy #255 is it matrix level?
 bhi 8f
 bsr clset set level info
 bra 9f
8 bsr csett set info
9 rts return

*
* set level type info
*

clset tfr y,d get level number
 std clc,u save location
 ldy #emat point to matrix
 decb adjust bias
 lda #MATSIZ setup size of element
 mul calculate position
 leay d,y
 ldd mttype,y get entry type
 std ctp,u
 andb #$3f
 stb cpt,u
 rts return

*
* Set type info for operand
*

csett ldd stype,y get type word
 std ctp,u set in table
 cmpb #CONST
 bne 4f
 tfr a,b
4 andb #$3f mask basic type
 stb cpt,u set in table
 sty clc,u save location
 rts return

*
* Set result type
*

rslt lda 2,y get result code
 beq 8f if null - exit
 cmpa #1 is it type 1?
 bne 1f
 lda copr check for subtract
 cmpa #SUB
 beq 9f
05 ldd cop1+ctp get type
 bsr fxcnst
 std mttype,x set type
 rts return
1 cmpa #2 is it type 2?
 bne 2f
 ldd #INT set integer type
 std mttype,x set in matrix
 rts return
2 cmpa #3 is it type 3?
 bne 3f
 ldd cop1+ctp get type
 bsr fxcnst
 jsr eathi get rid of high type
 std mttype,x
 rts return
3 cmpa #4 is it type 4?
 bne 4f
 ldd cop1+ctp get type
 bsr fxcnst
 jsr setptr make pointer
 std mttype,x set in matrix
 rts
4 cmpa #5
 bne 8f
 ldd cop2+ctp get type of right
 bsr fxcnst fix constant
 std mttype,x set type
8 rts return
9 ldd cop2+ctp get operand type
 bitb #$30 is it pointer type?
 beq 05b
 ldd #INT set result as integer
 std mttype,x
 rts return

*
* Eat highest type specifier
*

eathi pshs d save type
 lsra
 rorb
 lsra
 rorb
 andb #$f0 zero lo bits
 pshs b
 ldb 2,s get old low part
 andb #$0f
 orb 0,s+
 leas 2,s clean stack
 rts return

*
* Make pointer type
*

setptr pshs b
 andb #$f0
 lslb
 rora
 lslb
 rora
 orb 0,s+
 orb #PTR<<4
 rts return

*
* fixup constant type specifier
*

fxcnst cmpb #CONST is it const?
 bne 4f
 tfr a,b get type
 clra
4 rts return

*
* Check type of operands according to rules
*

chtyp pshs x save x
 ldu #chttab point to check table
 lda copr get operator
 cmpa #ADD is it unary?
 bhs 4f
 cmpa #FPP is it valid?
 blo 2f
 cmpa #BMM inc op?
 bls 12f
 cmpa #ADR is it address op?
 bne 15f
 ldb cop1+cpt get type of op1
 bitb #$30 is it complex?
 bne 1f
 cmpb #STRUCT is it structure?
 beq 11f
 cmpb #STRUCT+1 is it union?
 beq 11f
1 jsr chlval check lvalue
11 puls x,pc return
12 ldb cop1+cpt get type of op1
 bitb #$30 is it complex?
 beq 15f
 jsr chlval check lvalue
 jsr fxptrs fix up pointers
 puls x,pc return
15 lda 0,y get rule number
 beq 2f if no rule - exit
 deca remove bias
 asla
 ldb cop1+cpt get op1 type
 jsr [a,u] check type
2 puls x,pc return
4 cmpa #CXB any operands?
 blo 5f
 cmpa #DOT
 blo 2b
 beq 8f
 cmpa #LOD
 bls 15b
 bra 2b
5 cmpa #ADD is it add or subtract?
 beq 7f
 cmpa #SUB
 beq 7f
 cmpa #ADA is it add assign?
 beq 7f
 cmpa #SUA is it sub assign?
 beq 7f
55 lda 0,y get rule
 beq 6f if 0 - exit
 deca remove bias
 asla
 ldb cop1+cpt get primary type
 ldu #chttab point to check table
 jsr [a,u] check type
 lda 0,y get rule
 deca remove bias
 asla
 ldb cop2+cpt get primary type
 ldu #chttab point to check table
 jsr [a,u]
 lda copr get operator
 cmpa #ADA is it assignment op?
 blo 6f
 cmpa #ASN
 bhi 6f
 ldb cop1+cpt get op1 type
 jsr chlval check for lvalue
6 jsr cvsns do conversions
 stx 0,s reset x
 puls x,pc return
7 lda cop1+cpt get type of op 1
 ora cop2+cpt
 bita #$30 complex types?
 beq 55b
 jsr fxptrs fix up any pointers
 stx 0,s reset matrix pointer
 puls x,pc return
8 ldb cop1+cpt get op1 type
 cmpb #STRUCT is it structure or union?
 beq 85f
 cmpb #STRUCT+1 is it union?
 beq 85f
 jsr chlval check for lvalue
85 ldx 0,s point to matrix entry
 ldd mo2loc,x get op2 location
 tsta less than 255?
 beq 9f
 pshs y save y
 ldy mo2loc,x get location
 lda sclass,y get class of op
 puls y
 cmpa #MOS is it member of struct?
 blo 9f
 cmpa #MOU or of union?
 bls 6b
9 ldb #74 set error
 jsr rpterr
 bra 6b finish up checks

chttab fdb cht1,cht2,cht3,cht4,cht5,cht6,chlval,cht8

cht1 bitb #$f0 complex type?
 bne chte1
 bitb #$f check undefined
 beq chte4
 cmpb #DUBLE
 bhi chte2
 rts return

cht2 bitb #$f0 complex type?
 bne chte1
 tstb undefined?
 beq chte4
 cmpb #LONG
 bhi chte2
 rts return

cht3 andb #$0f mask high part
 beq chte4 undefined?
 cmpb #LONG
 bhi chte2
 rts return

cht4 bitb #$f0 check for complex
 bne 4f
 andb #$0f mask high part
 beq chte4 undefined?
 cmpb #DUBLE
 bhi chte2
 rts return
4 andb #$f0
 cmpb #FNCT<<4 is it function
 beq chte2
 rts return

cht5 bitb #$30
 beq 2f
 andb #$30 get complex type
 cmpb #FNCT<<4 is it function?
 beq chte2 if so - error
 rts return
2 ldd cop1+ctp get full type
 cmpb #CONST constant?
 bne chte2 if not - error
 rts return

cht6 andb #$30 check for function
 beq chte3
 cmpb #FNCT<<4 is it function?
 bne chte3
 rts return

cht8 bitb #$30
 bne 2f
 tst nochck
 bne 2f
 cmpb #STRUCT is it structure?
 beq chte5
 cmpb #STRUCT+1
 beq chte5
2 rts return

chte1 ldb #68 set error
 jmp rpterr
chte2 ldb #69 set error
 jmp rpterr
chte3 ldb #72 set error
 jmp rpterr
chte4 ldb #75 set error
 jmp rpterr
chte5 ldb #76 set error
 jmp rpterr

*
* Check for operand being an lvalue
*

chlval bitb #$30 complex type?
 bne 4f
 cmpb #CONST
 beq 6f
 ldd cop1+clc get location of op
 tsta is it node?
 beq 2f
 rts return
2 pshs x save x reg
 ldx #emat point to expr matrix
 decb
 lda #MATSIZ setup entry size
 mul calculate position
 leax d,x point to entry
 lda moprtr,x get operator
 puls x reset x reg
 cmpa #IND is it indirection op?
 beq 3f
 cmpa #DOT is it dot op?
 bne 6f
3 rts return
4 andb #$30 get complex type
 cmpb #PTR<<4 must be pointer or array
 bne 6f
 rts return
6 ldb #73 set error
 jmp rpterr

*
* Check for valid pointer operation
*

fxptrs pshs x,y save ptrs
 clrb set counter to 0
 lda cop1+cpt get op1 type
 anda #$30 complex type?
 beq 2f
 cmpa #FNCT<<4 is it function?
 lbeq fxper1 if so - error
 incb
2 lda cop2+cpt get op2 type
 anda #$30 is it complex type?
 beq 3f
 cmpa #FNCT<<4 is it function?
 lbeq fxper1
 incb bump counter
3 cmpb #2 1 or 2 pointers?
 lbeq 7f
 lda copr get operator
 cmpa #ADD is it add?
 beq 4f
 cmpa #ADA add assign?
 beq 4f
 cmpa #FPP is it inc or dec op?
 blo 35f
 cmpa #BMM
 lbls 8f
35 lda cop1+cpt check for op1 being the ptr
 bita #$30
 lbeq fxper2 if not - error
4 ldd cop1+ctp get op1 type
 jsr fxpchk check for valid type
 ldd cop2+ctp get op2 type
 jsr fxpchk check type
 lda moprtr,x get operator
 sta moprtr+MATSIZ,x move up in matrix
 ldd mo1loc,x get op1
 std mo1loc+MATSIZ,x move up
 cmpd #255 is it node number?
 bls 43f
 pshs a
 lda cop1+cpt check if array?
 bita #$30
 puls a
 beq 43f
 ldu nxtary set array pointer
 std 0,u++
 stu nxtary
43 ldd mo2loc,x get op2
 std mo2loc+MATSIZ,x move up
 lda cop1+cpt get op1 type
 bita #$30 is it pointer?
 bne 5f if not - rearrange ops
 ldd mo2loc+MATSIZ,x
 std mo1loc+MATSIZ,x
 cmpd #255 node number?
 bls 5f
 ldu nxtary get array pointer
 std 0,u++
 stu nxtary
5 ldy mo1loc+MATSIZ,x get op1
 ldd cop1+ctp get op type
 clr dosize
 jsr ptrsiz get size of pointed at object
 ldd 2,y get size of object
 cmpd #1 is it 1 byte?
 lbeq 65f if so - skip this junk
 ldd cop1+ctp get type
 cmpb #CONST is it constant?
 bne 54f
 cmpa #INT is it integer const?
 bne 56f
 pshs x save pointer
 ldx mo1loc,x get constant
 jsr mulcon get new size
 puls x
 jmp 65f ggo exit
54 ldd cop2+ctp get op2 type
 cmpb #CONST is it constant
 bne 56f
 cmpa #INT is it integer?
 bne 56f
 pshs x
 ldx mo2loc,x get constant
 jsr mulcon get new constant
 puls x
 jmp 65f exit
56 lda #MUL set for multiply
 sta moprtr,x
 ldd cop2+ctp get op2 type
 std mttype,x set result type
 lda cop1+cpt get type
 bita #$30 is it pointer?
 bne 57f
 ldd mo1loc,x
 std mo2loc,x
 ldd cop1+ctp get op1 type
 std mttype,x set result type
 ldd cop2+ctp fix up types
 std cop1+ctp
57 sty mo1loc,x save constant location
 ldb matlev get matrix level
 clra
 std mo2loc+MATSIZ,x set in matrix
58 incb bump level 1
 stb matlev
 ldy tos get top stack
 std -2,y adjust level there
 leax 2*MATSIZ,x adjust end of matrix ptr
 stx nxtmat
 clr 0,x set term
 cmpx #emat+EMLEN overflow table?
 blo 6f
 ldd #140 set error
 jmp error
6 puls x,y get pointers
 leax MATSIZ,x bump to new entry
 rts return
65 clr moprtr+MATSIZ,x zero operator
 puls x,y,pc return
7 lda copr check for subtract
 cmpa #SUB
 lbne fxper2 error?
 ldd #INT set result
 std mttype,x
 ldd cop1+ctp get op1 type
 ldy mo1loc,x get op1
 clr dosize
 jsr ptrsiz get size of object
 ldd 2,y get size
 pshs d save it
 ldd cop2+ctp get op2 type
 ldy mo2loc,x get op2
 clr dosize
 jsr ptrsiz get object size
 ldd 2,y
 cmpd 0,s++ same size?
 lbne fxper2
 cmpd #1 if 1 - we are done
 lbeq 65b
 lda #DIV set up divide operation
 sta MATSIZ+moprtr,x
 sty mo2loc+MATSIZ,x set up constant as op2
 ldb matlev set node number
 clra
 std mo1loc+MATSIZ,x
 jmp 58b go finish
8 ldd cop1+ctp get op1 type
 ldy mo1loc,x get location
 clr dosize
 jsr ptrsiz get size of object
 sty mo2loc,x save constant
 puls x,y,pc return

fxper1 ldb #70 set error
 jsr rpterr
 puls x,y,pc return
fxper2 ldb #71 set error
 jsr rpterr
 puls x,y,pc return

*
* Check for valid type
*

fxpchk bitb #$30 is it ptr?
 bne 2f
 cmpb #FLOAT
 blo 2f
 cmpb #CONST is it constant?
 bne 4f
 cmpa #FLOAT is type ok?
 bhs 4f
2 rts
4 ldb #71 set error
 jmp rpterr

*
* Fix pointer addition constant
*

mulcon ldd 2,y xfr numbers
 std conop1 for multiply
 ldd 2,x
 std conop2
 pshs x,y
 jsr imul do multiply
 puls x,y
 std 2,x save new constant
 rts return

*
* Calculate pointed to object size
*

ptrsiz pshs d,x,y save regs
 andb #$30 get type
 cmpb #ARAY<<4 array?
 beq 3f
 cmpb #FNCT<<4 function?
 beq 05f
 ldd 0,s get type
 andb #$c0
 beq 1f
 cmpb #ARAY<<6
 beq 3f
05 ldd #2 set size to 2
 std basize
 lbra 7f
1 ldb 1,s get type
 andb #$0f
 cmpb #DUBLE is it structure
 bls 2f
 cmpy #255 is it node number?
 bhi 2f
 ldy rcntpt get recent pointer
2 tfr y,x point to variable
 ldb 1,s get type
 andb #$0f
 jsr esizit get size
 lbra 7f
3 ldd #1 set base size to 1
 std basize
 ldu nxtary get array ref
 ldu -2,u
 ldu ssubs,u get subscript pointer
 beq 55f
 ldd 0,u++ get 1st value
 tst dosize doing sizeof?
 beq 4f
 std basize save new base size
4 cmpd #$ffff look for end of list
 beq 5f
 ldd 0,u++ get next entry
 bra 4b
5 leau -4,u point to last entry
55 ldd 0,s get type
 andb #$f0 mask basic type
 cmpb #ARAY<<4 simple array?
 bne 58f
 pshs u
 ldu nxtary fix array stack
 leau -2,u
 stu nxtary
 puls u
58 lsra remove one type part
 rorb
 lsra
 rorb
 andb #$f0 get rid of low 4 bits
 pshs b
 andb #$30 check if array anymore
 cmpb #ARAY<<4
 puls b
 bne 6f
 pshs d
 ldd 0,u get dim value
 std conop1 set up for multiply
 ldd basize
 std conop2
 leau -2,u
 pshs u,x,y
 jsr imul
 puls u,x,y
 std basize save result
 puls d get type back
 bra 58b
6 tstb all done?
 beq 62f
 ldd #2 set base to 2
 bra 65f
62 cmpy #255 node pointer?
 bhi 63f
 ldy rcntpt get pointer
63 tfr y,x point to var
 ldd basize save base
 pshs d
 ldb 3,s get type
 andb #$0f
 jsr esizit get size
 puls d get base
65 std conop1 set up for mul
 ldd basize
 std conop2
 jsr imul multiply
 std basize save base
7 ldd basize get size
 pshs d
 lda #INT set integer type
 ldx nxtcon get next constant storage
 tfr x,y save entry
 sta 0,x+
 lda #CONST set constant type
 sta 0,x+
 puls d get value
 std 0,x++ set in buffer
 stx nxtcon mark new end
 cmpx #contab+CTLEN buffer overflow?
 blo 9f
 ldd #139 set error
 jmp error
9 puls d,x get regs
 leas 2,s clean stack
 rts return

*
* Setup any necessary conversions
*

cvsns lda 1,y get conversion rule
 bne 2f if null - exit
 rts
2 pshs a
 jsr tcvtcn test constants
 puls a
 bne 25f
 rts return
25 cmpa #2 check for 1 or 2
 lbeq 7f
 ldd cop1+ctp get op1 type
 jsr fxcnst fix if constant
 andb #$3f get basic type
 pshs b save type
 ldd cop2+ctp get op2 type
 jsr fxcnst fix if constant
 andb #$3f get basic type
 cmpb 0,s types the same?
 bne 3f
 puls a,pc return
3 pshs b save op2 type
 lda moprtr,x move matrix entry up one level
 sta moprtr+MATSIZ,x
 ldd mo1loc,x
 std mo1loc+MATSIZ,x
 ldd mo2loc,x
 std mo2loc+MATSIZ,x
 ldb 1,y get conversion rule
 cmpb #3
 beq 35f
 ldb 0,s get op2 type
 cmpb 1,s higher than op1?
 bhi 4f
35 ldb matlev get matrix level
 clra
 std mo2loc+MATSIZ,x set new op2
 ldd cop1+ctp get op1 type
 std cop2+ctp set new op2 type
 ldu #cop2 point to op2
 bra 5f
4 ldb matlev get matrix level
 clra
 std mo1loc+MATSIZ,x set new op1
 ldd cop2+ctp get op2 type
 std cop1+ctp set new op1 type
 ldu #cop1 point to op1
5 jsr fxcnst fix if constant
 std mttype,x set new type
 pshs u
 ldu #cvntab point to conversion table
 bitb #$30 is it pointer?
 beq 55f
 lda 1,y check rules
 cmpa #3
 bne 52f
 pshs b save type
 andb #$30 get complex type
 cmpb #ARAY<<4 is it an array?
 puls b reset type
 bne 52f
 pshs b
 ldb 3,s get types
 lda 4,s
 andb #$0f get basic types
 anda #$0f
 pshs b
 cmpa 0,s+ are they the same?
 puls b
 bne 55f
 puls u fix stack
 clr MATSIZ,x set term
 puls d,pc return
52 lda #CVC set pointer operator
 bra 6f
55 andb #$0f get basic type
 decb remove bias
 lda b,u get operator
 lda #CVC *** new 3-17-82 (one cvt op now!)
6 puls u reset op pointer
 sta moprtr,x set new operator
 ldd clc,u get op location
 std mo1loc,x set in matrix
 ldd #0 set op2 to null
 std mo2loc,x
 ldb matlev get level counter
 clra
 incb bump one level
 stb matlev save new
 ldu tos get stack pointer
 std -2,u set new tos value
 leax 2*MATSIZ,x set new matrix end
 stx nxtmat
 clr 0,x set term
 cmpx #emat+EMLEN overflow?
 blo 65f
 ldd #140 set error
 jmp error
65 leax -MATSIZ,x
 puls d,pc return
7 ldd cop2+ctp get op2 type
 jsr fxcnst fix if constant
 pshs b
 andb #$0f get basic type
 cmpb #INT is it integer?
 bne 8f
 puls b,pc return
8 lda moprtr,x move matrix entry up one level
 sta moprtr+MATSIZ,x
 ldd mo1loc,x
 std mo1loc+MATSIZ,x
 ldd mo2loc,x
 std mo2loc+MATSIZ,x
 ldb matlev set matrix level for op2
 clra
 std mo2loc+MATSIZ,x
 ldd #INT set integer type
 ldu #cop2 point to op2
 pshs b
 lbra 5b finish up

* conversion table

cvntab fcb CVC,CVI,CVI,CVU,CVL,CVF,CVF

 pag

*
* optimize expression matrix
*

optmat ldx #emat point to exp matrix
1 cmpx nxtmat end of matrix?
 bne 2f
 rts return
2 pshs x,y,u
 jsr clsfy classify ops
 puls x,y,u
 jsr optcom check commutes
 lda moprtr,x get operator
 cmpa #ADR check for address type op
 blo 3f
 cmpa #IND
 bhi 25f
 jsr optadr optimize address op
 bra 3f
25 suba #ADD remove bias
 bmi 3f
 cmpa #4
 bhi 3f is it add,sub,mul,mod, or div?
 ldy #opttab point to routine table
 asla
 jsr [a,y] exec opt code
3 leax MATSIZ,x move to next entry
 bra 1b

 data

opttab fdb optadd,optsub,optmul,optdiv,optmod

 text

*
* optimize add operator
*

optadd jsr tstocn test for constant
 beq 5f
 ldd 2,u get constant
 bne 5f is it zero?
 ldd mo1loc,x check operand1
 cmpd #255 is it node?
 bls 2f
 lda #LOD set up load op
 bra 3f
2 lda #NOP set nop
3 sta moprtr,x set in entry
 ldd #0 zero op2
 std mo2loc,x
5 rts return

*
* optimizr subtract
*

optsub equ optadd same as add

*
* optimize multiply
*

optmul jsr tstocn test for constant
 beq 35f
 ldd 2,u get constant
 bne 2f is it 0?
optmu2 lda #LOD set up load 0 op
 sta moprtr,x
 ldd #0 zero op2
 std mo2loc,x
 ldd #zrocon set constant
 std mo1loc,x
 rts return
2 cmpd #1 is it by 1?
 bne 4f
 ldd mo1loc,x check op1 type
 cmpd #255 is it node?
 bls 3f
 lda #LOD set load op
 bra 32f
3 lda #NOP set nop
32 sta moprtr,x set in entry
 ldd #0 zero op2
 std mo2loc,x
 sez set true
35 rts return
4 cmpd #-1 is it -1?
 bne 5f
 lda #UNM set up unary minus
 bra 32b
5 jsr shftst test for shift condition
 beq 35b
 std mo2loc,x set shift count
 lda #SHL set shift op
 sta moprtr,x
 rts return

*
* optimize divide
*

optdiv jsr optmul same as multiply
 beq 2f any mods done?
 lda moprtr,x check for change to shift
 cmpa #SHL
 bne 1f
 lda #SHR change to right shift
 sta moprtr,x
1 rts return
2 ldu mo1loc,x check op1
 jsr tstoc2
 beq 1b constant?
 ldd 2,u get value
 bne 1b is it 0?
 jmp optmu2

*
* test for operand 2 being a constant
*

tstocn ldu mo2loc,x get op
tstoc2 cmpu #255 is it node?
 bls 2f
 ldd stype,u get type
 cmpb #CONST is it constant?
 bne 2f
 cmpa #UNSND in range?
 bhi 2f
 cmpa #CHR is it char?
 beq 2f
 rts return
2 sez set false
 rts return

*
* test for shift condition
*

shftst ldu #shftab point to table
1 ldy 0,u end of list?
 beq 3f
 cmpd 0,u does it match
 beq 2f
 leau 4,u go to next entry
 bra 1b
2 ldd 2,u get constant
3 rts return

* optimize mod

optmod jsr tstocn test for constant
 beq 35f
 ldd 2,u get constant
 bne 2f is it 0?
optmo2 lda #LOD set up load 0 op
 sta moprtr,x
 ldd #0 zero op2
 std mo2loc,x
 ldd #zrocon set constant
 std mo1loc,x
 rts return
2 cmpd #1 is it by 1?
 beq optmo2
 bra 4f
35 rts return
4 cmpd #-1 is it -1?
 beq optmo2
5 jsr shftst test for shift condition
 beq 35b
 ldu mo2loc,x
 ldd 2,u get constant
 subd #1 dec by one
 std 2,u reset it
 lda #AND set and op
 sta moprtr,x
 rts return

 data
* shift table

shftab fdb 2,onecon,4,twocon,8,thrcon,16,forcon
 fdb 256,atecon,512,nincon,0

 text

*
* Optimize operators which commute
*

optcom lda moprtr,x get operator
 suba #ADD remove bias
 bmi 1f
 cmpa #25 in range?
 bhi 1f
 ldy #comtab point to commute table
 lda a,y get value
 bne 2f
1 rts return
2 pshs a save com type
 ldu mo1loc,x get op1
 cmpu #255 is it a node?
 bls 3f if so - exit
 ldu mo2loc,x check op2
 cmpu #255 is it a node?
 bls 42f if so - reverse
 ldu mo1loc,x get op1
 ldd stype,u get type
 cmpb #CONST is it a constant?
 beq 42f if so - reverse
25 puls a,pc return
3 ldd mo2loc,x check op2
 cmpd #255 is it node?
 bhi 25b if not - exit
 pshs u
 cmpd 0,s++
 blo 25b
4 ldu #emat find op2 in emat
 decb
 lda #MATSIZ
 mul
 leau d,u point to it
 lda moprtr,u get operator
 cmpa #IND is it ind op?
 bne 42f
 ldd mo1loc,x get op1 again
 ldu #emat find entry
 lda #MATSIZ
 decb
 mul
 leau d,u point to it
 lda moprtr,u get operator
 cmpa #IND
 bne 25b
42 ldd mo1loc,x get op1
 ldu mo2loc,x get op2
 std mo2loc,x reverse them
 stu mo1loc,x
 puls a get com type
 cmpa #3 is it a compare?
 bne 7f
 lda moprtr,x get operator
 suba #LEQ remove bias
 ldu #equtab point to table
 lda a,u get new op
 sta moprtr,x
7 rts return

 data

* commute op table

comtab fcb 1,0,1,0,0,0,0,1,1,1
 fcb 0,0,0,0,0,0,0,0,0,0
 fcb 1,1,3,3,3,3

equtab fcb GEQ,GRT,LEQ,LES

 text

*
* Optimize IND and ADR ops
*

optadr leay -MATSIZ,x move to previous entry
 cmpx #emat first entry?
 beq 2f
 ldb moprtr,y get operator
 cmpb #ADR is it address op?
 blo 2f
 cmpb #IND
 bhi 2f
 pshs b
 cmpa 0,s+ is it same operator?
 beq 2f
 lda #NOP set up nop code
 sta moprtr,y
 sta moprtr,x
 rts return
2 cmpa #IND is it ind op?
 bne 4f
 ldd mttype,x get result type
 andb #$30
 cmpb #ARAY<<4 is it array?
 bne 4f
 ldd cop1+ctp get op type
 andb #$30
 cmpb #ARAY<<4 is it array?
 bne 4f
 lda #NOP set nop
 sta moprtr,x
4 rts return

*
* Try to reduce constants for conversions
*

tcvtcn ldd cop1+ctp get type of op1
 cmpb #CONST constant?
 beq 2f
 ldd cop2+ctp get type of op2
 cmpb #CONST is it constant?
 beq 3f
1 rts return
2 cmpa #UNSND unsigned?
 bhi 1b
 ldb cop2+ctp+1 get op2 type
 ldu mo1loc,x get op1
 bra 4f
3 cmpa #UNSND integral?
 bhi 1b
 ldb cop1+ctp+1 get op1 type
 ldu mo2loc,x get op2
4 bitb #$30 pointer type?
 bne 6f
 cmpb #UNSND integral type?
 bhi 1b
 cmpb #CHR character?
 bne 5f
 lda copr get operator
 cmpa #ASN is it assign?
 beq 45f
 cmpa #EQU equality op?
 blo 1b
 cmpa #GRT
 bhi 1b
45 clr 2,u zero hi part
5 stb 0,u change type
 sez set status
 rts return
6 cmpa #CHR character?
 bne 7f
 clr 2,u 0 hi part
7 lda #INT set integer type
 sta 0,u
 sez set status
 rts return

