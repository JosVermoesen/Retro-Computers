/*
     Routines defined in this module:

     fseek()   Seek within a stream
     ftell()   Return current offset from beginning of the
               stream
     rewind()  Rewind the stream
*/


/*
     Definitions used in this module
*/
#include  "machine.h"
#include  <stdio.h>
#include  <errno.h>


/*
     Routines used in this module
*/

long      lseek();
int       isatty();

/*----------------------------------------------------------------*/

/*
     int fseek(stream, offset, type)
          FILE     *stream;
          long      offset;
          int       type;

          This function performs a seek of type <type>
          within the stream referenced by <stream> for
          <offset> bytes.

     Arguments:
          stream    The stream to perform the seek on
          offset    The number of bytes to seek
          type      The type of seek to preform

     Valid <type> values
          0         Offset is an absolute offset from the
                    beginning of the file.
          1         Offset is relative to the current position
                    in the stream.
          2         Offset is an absolute offset from the
                    end of the file.

     Returns:
          0 if successful, -1 otherwise

     Errors:
        - May not perform fseek() on a stream that is a terminal.
        - Others generated by UniFLEX.

     Revision History:
          06/12/84 kpm - New.
          05/13/85 ljn - Added support for "r+", "w+" and "a+" open modes.
          07/18/85 ljn - Corrected by checking for "ungotten" character.

*/


int fseek(stream, offset, type)
     register  FILE     *stream;
     REGISTER  long      offset;
     REGISTER  int       type;
{
     REGISTER  int       rtnval;
     REGISTER  int       flag;


     stream->_flag &= ~_EOF;            /* Clear EOF flag */

     if (((stream->_flag & _READ) && (!(stream->_flag & _UPDATE))) ||
         ((stream->_flag & _UPDATE) && (stream->_flag & _LASTREAD)) ||
         ((stream->_flag & _UPDATE) && (!(stream->_flag & (_LASTREAD|_LASTWRITE)))))
     {
       if (stream->_flag & _UNBUF)
       {
         /* Unbuffered I/O */
         if ((type == 1) && (stream->_save != EOF)) /* remember ungotten characters */
            offset--;
         if (lseek(stream->_fd, offset, type) != -1L)
           rtnval = 0;
         else
           rtnval = -1;            /* Error seeking */
       }
       else
       {
         /* Buffered I/O */
         if (isatty(stream->_fd))
         {
           errno = ESEEK;
           rtnval = -1;
         }
         else
         {
           if (type == 1)
             {
             /*
                Relative seek.  Try to do the
                seek within the current buffer
             */
                if (stream->_save != EOF) /* ungotten character */
                   offset--;
                if (!(stream->_flag & _UPDATE) &&
                   (((offset < 0L) &&
                     (stream->_base - stream->_ptr <= offset)) ||
                    ((offset >= 0L) && (stream->_cnt >= offset))))
                {
                  /*
                     Seek is within current buffer.  Just adjust
                     pointers and counts
                  */
                  flag = FALSE;
                  stream->_cnt -= offset;
                  stream->_ptr += offset;
                  rtnval = 0;
                }
                else
                {
                  /*
                     Unable to seek within the buffer.  Adjust the
                     requested offset to reflect buffering
                  */
                  flag = TRUE;
                  offset -= stream->_cnt;
                }
             }
           else
             flag = TRUE;

           /*
              If we couldn't do the seek within the buffer,
              must seek within the file
           */
           if (flag)
           {
             stream->_cnt = 0;
             if (lseek(stream->_fd, offset, type) == -1L)
               rtnval = -1;
             else
               rtnval = 0;
           }
         }
       }
     }
     else
       if (((stream->_flag & _WRITE) && (!(stream->_flag & _UPDATE))) ||
           ((stream->_flag & _UPDATE) && (stream->_flag & _LASTWRITE)))
         if (!isatty(stream->_fd))
           if (fflush(stream) != EOF)
             if (lseek(stream->_fd, offset, type) != -1L)
                {
                 stream->_cnt = 0;
                 rtnval = 0;
                }
             else
               rtnval = -1;          /* Error seeking */
           else
             rtnval = -1;          /* Error flushing buffer */
         else
         {
           errno = ESEEK;        /* Seek error */
           rtnval = -1;          /* Can't fflush a terminal */
         }
       else
       {
         errno = EBADF;
         rtnval = -1;      /* Stream is not open */
       }

     stream->_flag &= ~(_LASTWRITE|_LASTREAD);
     stream->_save = EOF;               /* Undo "ungetc" effects */

     /*
          Returning.  Set the stream's error flag if we've had
          some type of problem doing a fseek() on the stream
     */
     if (rtnval == -1)
          stream->_flag |= _ERR;
     return(rtnval);
}

/*-----------------------------------------------------------------*/


/*
     long ftell(stream)
          FILE     *stream;

          This function returns the current offset into
          the stream <stream>, relative to the beginning
          of the stream.  This offset may differ from
          the system's file pointer of the associated file
          because of standard I/O buffering.

     Arguments:
          stream    Stream to get offset from

     Returns:  long
          Offset into the stream or -1 if error

     Routine History:
          06/12/84 kpm - New
          05/13/85 ljn - Added support for "r+", "w+" and "a+" open modes.
          07/18/85 ljn - Corrected by checking for "ungotten" character.

*/


long ftell(stream)
     register  FILE     *stream;
{
     REGISTER  long      rtnval;


     if (((stream->_flag & _READ) && (!(stream->_flag & _UPDATE))) ||
         ((stream->_flag & _UPDATE) && (stream->_flag & _LASTREAD)) ||
         ((stream->_flag & _UPDATE) && (!(stream->_flag & (_LASTREAD|_LASTWRITE)))))
     {
          /*
               Stream open for reading.
               Use system pointer less the count of unconsumed
               characters in the buffer (buffered I/O only)
          */
          if ((rtnval = lseek(stream->_fd, 0L, 1)) != -1L)
             {
              if (stream->_save != EOF)
                 rtnval--;
              if (!(stream->_flag & _UNBUF))
                 rtnval -= (long) stream->_cnt;
             }
     }
     else if (((stream->_flag & _WRITE) && (!(stream->_flag & _UPDATE))) ||
              ((stream->_flag & _UPDATE) && (stream->_flag & _LASTWRITE)))
     {
          /*
               Stream open for writing
               Use system pointer plus the count of unwritten
               characters in the buffer (buffered I/O only)
          */
          if ((rtnval = lseek(stream->_fd, 0L, 1)) != -1L)
             if (!(stream->_flag & _UNBUF))
                rtnval += (long)(stream->_ptr-stream->_base);
     }
     else
     {
      /*
            Stream is not open
             Report "bad file" error
       */
       errno = EBADF;
       rtnval = -1L;
     }

   /*
        Finished
   */
   return(rtnval);
}



/*-----------------------------------------------------------------*/

/*
     void rewind(stream)
          FILE *stream;

          This function positions the stream <stream> to
          its beginning (beginning of the file)

          It may not be a macro since it returns no result.

     Arguments:
          stream    The stream to rewind

     Returns:  Nothing

     Routine History:
          06/12/84 kpm - New.

*/

void rewind(stream)
     FILE     *stream;
{
     fseek(stream, 0L, 0);    /* Position to beginning */
}
