    1:   /*
    2:   * This file contains all external symbol definitions, the basic i/o
    3:   * routines, and the main calling loop.
    4:   */
    5:   
    6:   #include "putchar.c"
    1:   
    2:   /*
    3:    *      V1.24 80/08/05 16:25    (C) Copyright MCMLXXIX tgi
    4:    *
    5:    * putchar(char), flush()
    6:    *
    7:    *      Putchar places the argument character onto the output
    8:    *      stream from file descriptor *fout* (default is 1).
    9:    *      If a write error occurs, ERROR is returned.
   10:    *      The argument character is returned without
   11:    *      sign extension, so ERROR is a distinct value.
   12:    *
   13:    *      Flush writes out any data remaining in the buffer.
   14:    *
   15:    *      _cleanup is called by the library exit routine,
   16:    *      hence a flush is guaranteed on a normal exit.
   17:    *
   18:    *      The output is managed via a one-block (512 byte)
   19:    *      buffer, and write system calls are issued as necessary.
   20:    *
   21:    *      In addition, a putchar(c) MACRO is defined to further
   22:    *      aid efficiency.
   23:    *
   24:    *      Calls: write
   25:    */
   26:   
   27:   #ifndef ERROR
   28:   #define ERROR   -1
   29:   #endif
   30:   
 14-int 15-fout 80 16-1 1   31:   int     fout    = 1;
 14-char 15-_obuf 4 16-512 5 1   32:   char    _obuf[512];
 14-char 42 15-_opos 80 15-_obuf 1   33:   char    *_opos  = _obuf;
   34:   
 15-flush 6 7 2   35:   flush() {
 14-int 15-n 1   36:           int n;
   37:   
 15-n 80 6 14-int 7 15-_opos 41 6 14-int 7 47 15-_obuf 4 16-0 5 1   38:           n = (int)_opos - (int)&_obuf[0];
 15-_opos 80 15-_obuf 1   39:           _opos = _obuf;
 14-if 6 15-n 65 16-0 7   40:           if (n > 0)
 14-if 6 15-write 6 15-fout 105 15-_obuf 105 15-n 7 61 15-n 7   41:                   if (write(fout, _obuf, n) != n)
 14-return 6 41 16-1 7 1   42:                           return(ERROR);
 14-return 6 16-0 7 1   43:           return(0);
 3   44:   }
   45:   
 15-_flsbuf 6 15-c 7 2   46:   _flsbuf(c) {
 14-if 6 15-flush 6 7 60 41 16-1 7   47:           if (flush() == ERROR)
 14-return 6 41 16-1 7 1   48:                   return(ERROR);
 42 15-_opos 30 80 15-c 1   49:           *_opos++ = c;
 14-return 6 15-c 7 1   50:           return(c);
 3   51:   }
   52:   
   53:   #ifndef CLEANUP
 15-_cleanup 6 7 2   54:   _cleanup() {
 15-flush 6 7 1   55:           flush();
 3   56:   }
   57:   #endif
   58:   
 15-putchar 6 15-c 7 2   59:   putchar(c) {
   60:   #define putchar(x) (_opos<&_obuf[sizeof _obuf]?((*_opos++=(x))&0377):_flsbuf((x)))
 14-return 6 6 15-_opos 63 47 15-_obuf 4 14-sizeof 15-_obuf 5 12 6 6 42 15-_opos 30 80 6 15-c 7 7 47 16-255 7 8 15-_flsbuf 6 6 15-c 7 7 7 7 1   61:           return(putchar(c));
 3   62:   }
    7:   #include "il.h"
    1:   /*
    2:   * C intermediate language definitions
    3:   */
    4:   
    5:   #define CVC 5
    6:   #define NOP 29
    7:   #define FPP 30
    8:   #define FMM 31
    9:   #define BPP 32
   10:   #define BMM 33
   11:   #define NOT 34
   12:   #define ADR 35
   13:   #define IND 36
   14:   #define UNM 37
   15:   #define COM 38
   16:   #define ADD 40
   17:   #define SUB 41
   18:   #define MUL 42
   19:   #define DIV 43
   20:   #define MOD 44
   21:   #define SHR 45
   22:   #define SHL 46
   23:   #define AND 47
   24:   #define BOR 48
   25:   #define XOR 49
   26:   #define LND 53
   27:   #define LOR 54
   28:   #define EQU 60
   29:   #define NEQ 61
   30:   #define LEQ 62
   31:   #define LES 63
   32:   #define GEQ 64
   33:   #define GRT 65
   34:   #define ADA 70
   35:   #define SUA 71
   36:   #define MUA 72
   37:   #define DIA 73
   38:   #define MOA 74
   39:   #define SRA 75
   40:   #define SLA 76
   41:   #define ANA 77
   42:   #define BOA 78
   43:   #define XOA 79
   44:   #define ASN 80
   45:   #define CXB 90
   46:   #define CBR 91
   47:   #define CEN 92
   48:   #define ORB 93
   49:   #define ORE 94
   50:   #define ANB 95
   51:   #define ANE 96
   52:   #define ORC 97
   53:   #define ANC 98
   54:   #define DOT 99
   55:   #define CAL 100
   56:   #define PRM 101
   57:   #define LOD 102
   58:   #define SPL 103
   59:   #define SPR 104
   60:   #define CMA 105
   61:   #define ENDITM 128
   62:   #define BEGEXP 129
   63:   #define ENDEXP 130
   64:   #define NNAME 131
   65:   #define NCON 132
   66:   #define NNODE 133
   67:   #define LABEL 134
   68:   #define BRANCH 135
   69:   #define CBRNCH 136
   70:   #define BEGFNT 137
   71:   #define ENDFNT 138
   72:   #define SWIT 139
   73:   #define STVAR 140
   74:   #define AUTVAR 141
   75:   #define REGVAR 142
   76:   #define PROFIL 143
   77:   #define TEXT 144
   78:   #define DATA 145
   79:   #define BSS 146
   80:   #define SSPACE 147
   81:   #define BYTES 148
   82:   #define WORDS 149
   83:   #define DNAME 150
   84:   #define EXTERS 151
   85:   #define COMDAT 152
   86:   #define CMNT 153
   87:   #define STRNG 154
   88:   #define BEGBLK 155
   89:   #define ENDBLK 156
   90:   #define BEGMOD 157
   91:   #define ENDMOD 158
   92:   #define CLNSTK 159
   93:   #define GLOBAL 160
   94:   #define LABELS 161
   95:   
    8:   #include "pass1.h"
    1:   /*
    2:   * This file contains the definitions for tokens.
    3:   */
    4:   
    5:   #include "machine.h"
    1:   /*
    2:   * This file contains the machine dependent definitions.
    3:   */
    4:   
    5:   #define ONEWORD INT
    6:   #define TWOWORDS LONG
    7:   #define FSTARG 4
    8:   #define FSTAUT -4
    9:   #define NUMDREG 0
   10:   #define NUMAREG 1
   11:   
   12:   /* if alignment - define
   13:   
   14:   #define ALIGN
   15:   */
   16:   
    6:   
    7:   #define SMC 1   /* ; */
    8:   #define LCB 2   /* { */
    9:   #define RCB 3   /* } */
   10:   #define LSB 4   /* [ */
   11:   #define RSB 5   /* ] */
   12:   #define LPR 6   /* ( */
   13:   #define RPR 7   /* ) */
   14:   #define COL 8   /* : */
   15:   #define SQU 9   /* ' */
   16:   #define DQU 10  /* " */
   17:   #define BKS 11  /* \ */
   18:   #define QUM 12  /* ? */
   19:   #define ARO 13  /* -> */
   20:   #define KEY 14  /* keyword */
   21:   #define VAR 15  /* variable */
   22:   #define CON 16  /* constant */
   23:   #define CHC 17  /* character constant */
   24:   #define STC 18  /* string constant */
   25:   #define BAD 127 /* no token */
   26:   
   27:   /* adjustable quantity definitions */
   28:   
   29:   #define MAXSTRNG 128
   30:   #define NUMSTRNG  24
   31:   
   32:   /* structure definitions */
   33:   
   34:   /* token table structure */
   35:   
 14-struct 15-toktab 2   36:   struct toktab {
 14-char 15-ch 1   37:     char ch;
 14-char 15-tok 1   38:     char tok;
 3 1   39:   };
   40:   
   41:   /* string stack structure definition */
   42:   
 14-struct 15-sstack 2   43:   struct sstack {
 14-int 15-stlbl 1   44:     int stlbl;
 14-char 42 15-stptr 1   45:     char *stptr;
 3 1   46:   };
   47:   
   48:   /* misc defines */
   49:   
   50:   #define EOF (-1)
   51:   
   52:   /* type defines */
   53:   
   54:   #define CHR 1
   55:   #define INT 2
   56:   #define SHORT 3
   57:   #define UNSND 4
   58:   #define LONG 5
   59:   #define FLOAT 6
   60:   #define DUBLE 7
   61:   #define STRUCT 12
   62:   #define CONST 14
   63:   
   64:   #define PTR 1
   65:   #define FNCT 2
   66:   #define ARAY 3
   67:   
   68:   /* macro definitions */
   69:   
   70:   #define getnch() (curchar ? curchar : (curchar = nxtchr()))
   71:   
    9:   #include "nxtchr.h"
    1:   /*******************************************************************/
    2:   /*                                                                 */
    3:   /*        Values Returned by the Routine "nxtchr"                  */
    4:   /*                                                                 */
    5:   /*******************************************************************/
    6:   
    7:   #define   FILE_END  -1   /* end-of-file response */
    8:   #define   IDENT     -2   /* identifier found response */
    9:   #define   KEYWORD   -3   /* keyword encountered */
   10:   #define   END_IF    -4   /* end of "if" expression */
   10:   
   11:   #define ERROR (-1)
   12:   #define F_Z     01      /* leading zeroes */
   13:   #define F_S     02      /* signed */
   14:   #define F_L     04      /* left-justify */
   15:   
   16:   /* global variable definitions */
   17:   
 14-int 15-lstflg 1   18:   int lstflg;
 14-int 15-pp_if_re 1   19:   int pp_if_result;
 14-int 15-errcnt 1   20:   int errcnt;
 14-int 15-curchar 1   21:   int curchar;
 14-int 15-curtok 1   22:   int curtok;
 14-int 15-label 1   23:   int label;
 14-int 15-strindx 1   24:   int strindx;
 14-int 15-contyp 1   25:   int contyp;
 14-long 15-convalu 1   26:   long convalu;
 14-char 42 15-nxtstr 1   27:   char *nxtstr;
 14-char 15-strngbf 4 16-128 5 1   28:   char strngbf[MAXSTRNG];
 14-struct 15-sstack 42 15-strngloc 1   29:   struct sstack *strngloc;
 14-struct 15-sstack 15-strstck 4 16-24 5 1   30:   struct sstack strstck[NUMSTRNG];
 14-char 15-esctab 4 5 80 2 17-n 105 17-
 105 17-t 105 17-	 105 17-b 105 17- 105 17-r 105 17-
 105 17-f 105 17- 105 17-  3 1   31:   char esctab[] = {'n','\n','t','\t','b','\b','r','\r','f','\f','\0'};
   32:   
   33:   /* token arrays */
   34:   
 14-struct 15-toktab 15-dchtab 4 5 80 2   35:   struct toktab dchtab[] = {
 17-= 105 16-60 105   36:     '=', EQU,
 17-+ 105 16-30 105   37:     '+', FPP,
 17-- 105 16-31 105   38:     '-', FMM,
 17-& 105 16-53 105   39:     '&', LND,
 17-| 105 16-54 105   40:     '|', LOR,
 17-< 105 16-46 105   41:     '<', SHL,
 17-> 105 16-45 105   42:     '>', SHR,
 17-  105 16-0 3 1   43:     '\0', 0 };
   44:   
 14-struct 15-toktab 15-eqctab 4 5 80 2   45:   struct toktab eqctab[] = {
 17-< 105 16-62 105   46:     '<', LEQ,
 17-> 105 16-64 105   47:     '>', GEQ,
 17-! 105 16-61 105   48:     '!', NEQ,
 17-  105 16-0 3 1   49:     '\0', 0 };
   50:   
 14-struct 15-toktab 15-chrtab 4 5 80 2   51:   struct toktab chrtab[] = {
 17-; 105 16-1 105   52:     ';', SMC,
 17-{ 105 16-2 105   53:     '{', LCB,
 17-} 105 16-3 105   54:     '}', RCB,
 17-[ 105 16-4 105   55:     '[', LSB,
 17-] 105 16-5 105   56:     ']', RSB,
 17-( 105 16-6 105   57:     '(', LPR,
 17-) 105 16-7 105   58:     ')', RPR,
 17-+ 105 16-40 105   59:     '+', ADD,
 17-- 105 16-41 105   60:     '-', SUB,
 17-* 105 16-42 105   61:     '*', MUL,
 17-/ 105 16-43 105   62:     '/', DIV,
 17-% 105 16-44 105   63:     '%', MOD,
 17-= 105 16-80 105   64:     '=', ASN,
 17-> 105 16-65 105   65:     '>', GRT,
 17-< 105 16-63 105   66:     '<', LES,
 17-! 105 16-34 105   67:     '!', NOT,
 17-' 105 16-9 105   68:     '\'', SQU,
 17-" 105 16-10 105   69:     '"', DQU,
 17-, 105 16-105 105   70:     ',', CMA,
 17-. 105 16-99 105   71:     '.', DOT,
 17-& 105 16-47 105   72:     '&', AND,
 17-| 105 16-48 105   73:     '|', BOR,
 17-^ 105 16-49 105   74:     '^', XOR,
 17-~ 105 16-38 105   75:     '~', COM,
 17-? 105 16-12 105   76:     '?', QUM,
 17-\ 105 16-11 105   77:     '\\', BKS,
 17-: 105 16-8 105   78:     ':', COL,
 17-  105 16-0 3 1   79:     '\0', 0 };
   80:   
   81:   /* Main pass1 loop */
   82:   
 15-main 6 15-argc 105 15-argv 7   83:   main(argc, argv)
 14-int 15-argc 1   84:   int argc;
 14-char 42 15-argv 4 5 1   85:   char *argv[];
 2   86:   {
   87:   
 14-if 6 15-prs 6 15-argc 105 15-argv 7 61 16-0 7 2   88:     if (prs(argc, argv) != 0) {
 15-perror 6 18-1Can't preset!
 7 1   89:       perror("Can't preset!\n");
 15-exit 6 16-255 7 1   90:       exit(255);
 3   91:     }
 15-initial 6 7 1   92:     initial();
 15-loop 6 7 1   93:     loop();
 15-errrpt 6 7 1   94:     errrpt();
 3   95:   }
   96:   
   97:   /* Initialize all variables and open files */
   98:   
 15-initial 6 7 2   99:   initial() {
 14-extern 15-fout 1  100:     extern fout;
  101:   
 14-if 6 6 15-fout 80 15-creat 6 18-2cc_temp 105 16-63 7 7 63 16-0 7 2  102:     if ((fout = creat("cc_temp", 0x3f)) < 0) {
 15-perror 6 18-3Can't create IL file.
 7 1  103:       perror("Can't create IL file.\n");
 15-exit 6 16-255 7 1  104:       exit(255);
 3  105:     }
 15-errcnt 80 16-0 1  106:     errcnt = 0;
 3  107:   }
  108:   
  109:   /* Main pass1 loop */
  110:   
 15-loop 6 7 2  111:   loop() {
 14-char 42 15-name 1  112:     char *name;
 14-char 42 15-nxtfil 6 7 1  113:     char *nxtfil();
  114:   
  115:   
  116:   /*lstflg = 1;  */
 14-while 6 15-name 80 15-nxtfil 6 7 7 2  117:     while (name = nxtfil()) {
 15-finit 6 7 1  118:       finit();
 15-reset 6 7 1  119:       reset();
 15-domodule 6 15-name 7 1  120:       domodule(name);
 3  121:     }
 15-flush 6 7 1  122:     flush();
 3  123:   }
  124:   
  125:   /* initialize pass1 for new file */
  126:   
 15-finit 6 7 2  127:   finit() {
 15-curtok 80 16-0 1  128:     curtok = 0;
 15-curchar 80 16-0 1  129:     curchar = 0;
 15-strindx 80 16-0 1  130:     strindx = 0;
 15-nxtstr 80 15-strngbf 1  131:     nxtstr = strngbf;
 15-label 80 16-0 1  132:     label = 0;
 3  133:   }
  134:   
  135:   /* Give final error report */
  136:   
 15-errrpt 6 7 2  137:   errrpt() {
 14-if 6 15-errcnt 7 2  138:     if (errcnt) {
 15-outil 6 16-1 105 18-4%u errors detected.
 105 15-errcnt 7 1  139:       outil(1, "%u errors detected.\n", errcnt);
 15-flush 6 7 1  140:       flush();
 15-exit 6 16-255 7 1  141:       exit(255);
 3  142:     }
 3  143:   }
  144:   
  145:   /* Print error message to std error. */
  146:   
 15-perror 6 15-msg 7  147:   perror(msg)
 14-char 42 15-msg 1  148:   char *msg;
 2  149:   {
 15-outil 6 16-2 105 15-msg 7 1  150:     outil(2, msg);
 3  151:   }
  152:   
  153:   /* fatal error processor */
  154:   
 15-error 6 15-n 7  155:   error(n)
 14-int 15-n 1  156:   int n;
 2  157:   {
 15-outil 6 16-2 105 18-5Fatal error #%d.
 105 15-n 7 1  158:     outil(2, "Fatal error #%d.\n", n);
 15-flush 6 7 1  159:     flush();
 15-exit 6 16-255 7 1  160:     exit(255);
 3  161:   }
  162:   
  163:   /* standard error handler */
  164:   
 15-rpterr 6 15-msg 7  165:   rpterr(msg)
 14-char 42 15-msg 1  166:   char *msg;
 2  167:   {
 15-outil 6 16-1 105 18-6%s
 105 15-msg 7 1  168:     outil(1,"%s\n", msg);
 3  169:   }
  170:   
  171:   /* print string */
  172:   
 15-pstrng 6 15-str 7  173:   pstrng(str)
 14-char 42 15-str 1  174:   char *str;
 2  175:   {
 15-outil 6 16-1 105 18-7%s 105 15-str 7 1  176:     outil(1,"%s",str);
 3  177:   }
  178:   
  179:   /* temp ppcexp */
  180:   
 15-ppcexp 6 7 2  181:   ppcexp() {
 15-pp_if_re 80 16-0 1  182:     pp_if_result = 0;
 3  183:   }
  184:   
  185:   /* Output code to il file - essentially a "printf". */
  186:   
 15-outil 6 15-args 7 2  187:   outil(args) {
 14-extern 15-fout 1  188:     extern fout;
 14-register 42 15-ap 105 15-c 1  189:     register *ap, c;
 14-register 14-char 42 15-s 105 42 15-af 1  190:     register char *s, *af;
 14-int 15-p 105 15-f 105 15-sfout 1  191:     int p, f, sfout;
  192:   
 15-ap 80 47 15-args 1  193:     ap = &args;
 15-f 80 42 15-ap 1  194:     f = *ap;
 15-sfout 80 41 16-1 1  195:     sfout = -1;
 14-if 6 6 14-unsigned 7 15-f 63 16-20 7 2  196:     if ((unsigned) f < 20) {
 30 15-ap 1  197:       ++ap;
 14-if 6 15-f 61 15-fout 7 2  198:       if (f != fout) {
 15-flush 6 7 1  199:         flush();
 15-sfout 80 15-fout 1  200:         sfout = fout;
 15-fout 80 15-f 1  201:         fout = f;
 3  202:       }
 3  203:     }
 15-af 80 6 14-char 42 7 42 15-ap 30 1  204:     af = (char *) *ap++;
 14-for 6 1 1 7 2  205:     for (;;) {
 14-while 6 6 15-c 80 42 15-af 30 7 61 17-% 7 2  206:       while ((c = *af++) != '%') {
 14-if 6 34 15-c 7  207:         if (!c)
 14-break 1  208:           break;
 6 15-_opos 63 47 15-_obuf 4 14-sizeof 15-_obuf 5 12 6 6 42 15-_opos 30 80 6 15-c 7 7 47 16-255 7 8 15-_flsbuf 6 6 15-c 7 7 7 1  209:         putchar(c);
 3  210:       }
 14-if 6 15-c 60 17-  7  211:       if (c == '\0')
 14-break 1  212:         break;
 15-c 80 42 15-af 30 1  213:       c = *af++;
 15-p 80 16-0 1  214:       p = 0;
 15-f 80 16-0 1  215:       f = 0;
 14-if 6 15-c 60 17-- 7 2  216:       if (c == '-') {
 15-f 78 15-F_L 1  217:         f |= F_L;
 15-c 80 42 15-af 30 1  218:         c = *af++;
 3  219:       }
 14-if 6 15-c 60 17-0 7 2  220:       if (c == '0') {
 15-f 78 15-F_Z 1  221:         f |= F_Z;
 15-c 80 42 15-af 30 1  222:         c = *af++;
 3  223:       }
 14-while 6 17-0 62 15-c 53 15-c 62 17-9 7 2  224:       while ('0' <= c && c <= '9') {
 15-p 80 15-p 42 16-10 40 15-c 41 17-0 1  225:         p = p * 10 + c - '0';
 15-c 80 42 15-af 30 1  226:         c = *af++;
 3  227:       }
 14-if 6 15-c 60 17-. 7 2  228:       if (c == '.') {
 15-c 80 42 15-af 30 1  229:         c = *af++;
 14-while 6 17-0 62 15-c 53 15-c 62 17-9 7  230:         while ('0' <= c && c <= '9')
 15-c 80 42 15-af 30 1  231:           c = *af++;
 3  232:       }
 14-if 6 15-c 60 17-  7  233:       if (c == '\0')
 14-break 1  234:         break;
 14-switch 6 15-c 7 2  235:       switch (c) {
 14-case 17-d 8  236:       case 'd':
 15-f 78 15-F_S 1  237:         f |= F_S;
 14-case 17-l 8  238:       case 'l':
 14-case 17-u 8  239:       case 'u':
 15-c 80 16-10 1  240:         c = 10;
 14-goto 15-num 1  241:         goto num;
 14-case 17-o 8  242:       case 'o':
 15-c 80 16-8 1  243:         c = 8;
 14-goto 15-num 1  244:         goto num;
 14-case 17-b 8  245:       case 'b':
 15-c 80 16-2 1  246:         c = 2;
 14-goto 15-num 1  247:         goto num;
 14-case 17-h 8  248:       case 'h':
 14-case 17-x 8  249:       case 'x':
 15-c 80 16-16 1  250:         c = 16;
 15-num 8 15-_num 6 42 15-ap 30 105 15-c 105 15-p 105 15-f 7 1  251:         num:  _num(*ap++, c, p, f);
 14-continue 1  252:         continue;
 14-case 17-c 8  253:       case 'c':
 15-c 80 42 15-ap 30 47 16-255 1  254:         c = *ap++ & 0377;
 6 15-_opos 63 47 15-_obuf 4 14-sizeof 15-_obuf 5 12 6 6 42 15-_opos 30 80 6 15-c 7 7 47 16-255 7 8 15-_flsbuf 6 6 15-c 7 7 7 1  255:         putchar(c);
 31 15-p 1  256:         --p;
 14-while 6 31 15-p 64 16-0 7  257:         while (--p >= 0)
 6 15-_opos 63 47 15-_obuf 4 14-sizeof 15-_obuf 5 12 6 6 42 15-_opos 30 80 6 17-  7 7 47 16-255 7 8 15-_flsbuf 6 6 17-  7 7 7 1  258:           putchar(' ');
 14-continue 1  259:         continue;
 14-case 17-s 8  260:       case 's':
 15-s 80 6 14-char 42 7 42 15-ap 30 1  261:         s = (char *) *ap++;
 14-while 6 42 15-s 7 2  262:         while (*s) {
 15-c 80 42 15-s 30 47 16-255 1  263:           c = *s++ & 0377;
 6 15-_opos 63 47 15-_obuf 4 14-sizeof 15-_obuf 5 12 6 6 42 15-_opos 30 80 6 15-c 7 7 47 16-255 7 8 15-_flsbuf 6 6 15-c 7 7 7 1  264:           putchar(c);
 14-if 6 15-p 53 31 15-p 62 16-0 7  265:           if (p && --p <= 0)
 14-break 1  266:             break;
 3  267:         }
 14-while 6 31 15-p 64 16-0 7  268:         while (--p >= 0)
 6 15-_opos 63 47 15-_obuf 4 14-sizeof 15-_obuf 5 12 6 6 42 15-_opos 30 80 6 17-  7 7 47 16-255 7 8 15-_flsbuf 6 6 17-  7 7 7 1  269:           putchar(' ');
 14-if 6 15-f 47 15-F_Z 7  270:         if (f & F_Z)
 6 15-_opos 63 47 15-_obuf 4 14-sizeof 15-_obuf 5 12 6 6 42 15-_opos 30 80 6 17-7566-2828 11 16-0 7 7 7 1  271:           putchar('\0');
 14-continue 1  272:         continue;
 3  273:       }
 6 15-_opos 63 47 15-_obuf 4 14-sizeof 15-_obuf 5 12 6 6 42 15-_opos 30 80 6 15-c 7 7 47 16-255 7 8 15-_flsbuf 6 6 15-c 7 7 7 1  274:       putchar(c);
 3  275:     }
 14-if 6 15-sfout 64 16-0 7 2  276:     if (sfout >= 0) {
 15-flush 6 7 1  277:       flush();
 15-fout 80 15-sfout 1  278:       fout = sfout;
 3  279:     }
 3  280:   }
  281:   
 14-static 15-_num 6 15-an 105 15-ab 105 15-ap 105 15-af 7 2  282:   static _num(an, ab, ap, af) {
 14-register 14-unsigned 15-n 105 15-b 1  283:     register unsigned n, b;
 14-register 14-char 42 15-p 1  284:     register char *p;
 14-int 15-neg 1  285:     int neg;
 14-char 15-buf 4 16-17 5 1  286:     char buf[17];
  287:   
 15-p 80 47 15-buf 4 16-17 5 1  288:     p = &buf[17];
 15-n 80 15-an 1  289:     n = an;
 15-b 80 15-ab 1  290:     b = ab;
 15-neg 80 16-0 1  291:     neg = 0;
 14-if 6 6 15-af 47 15-F_S 7 53 15-an 63 16-0 7 2  292:     if ((af & F_S) && an < 0) {
 15-neg 30 1  293:       neg++;
 15-n 80 41 15-n 1  294:       n = -n;
 31 15-ap 1  295:       --ap;
 3  296:     }
 42 31 15-p 80 17-  1  297:     *--p = '\0';
 14-do 2  298:     do {
 42 31 15-p 80 18-80123456789ABCDEF 4 15-n 44 15-b 5 1  299:       *--p = "0123456789ABCDEF"[n % b];
 31 15-ap 1  300:       --ap;
 3 14-while 6 15-n 73 15-b 7 1  301:     } while (n /= b);
 15-n 80 17-  1  302:     n = ' ';
 14-if 6 6 15-af 47 6 15-F_Z 48 15-F_L 7 7 60 15-F_Z 7  303:     if ((af & (F_Z | F_L)) == F_Z)
 15-n 80 17-0 1  304:       n = '0';
 14-else 14-if 6 15-neg 7 2  305:     else if (neg) {
 42 31 15-p 80 17-- 1  306:       *--p = '-';
 15-neg 80 16-0 1  307:       neg = 0;
 3  308:     }
 14-if 6 6 15-af 47 15-F_L 7 60 16-0 7  309:     if ((af & F_L) == 0)
 14-while 6 31 15-ap 64 16-0 7  310:       while (--ap >= 0)
 42 31 15-p 80 15-n 1  311:         *--p = n;
 14-if 6 15-neg 7  312:     if (neg)
 42 31 15-p 80 17-- 1  313:       *--p = '-';
 14-while 6 42 15-p 7  314:     while (*p)
 6 15-_opos 63 47 15-_obuf 4 14-sizeof 15-_obuf 5 12 6 6 42 15-_opos 30 80 6 42 15-p 30 7 7 47 16-255 7 8 15-_flsbuf 6 6 42 15-p 30 7 7 7 1  315:       putchar(*p++);
 14-while 6 31 15-ap 64 16-0 7  316:     while (--ap >= 0)
 6 15-_opos 63 47 15-_obuf 4 14-sizeof 15-_obuf 5 12 6 6 42 15-_opos 30 80 6 15-n 7 7 47 16-255 7 8 15-_flsbuf 6 6 15-n 7 7 7 1  317:       putchar(n);
 3  318:   }
  319:   
Elapsed real time - 1:25.6
User CPU time - 0:27.1
System CPU time - 0:15.6
