 text
* /*
* 
* #include "il.h"
* /*
* 
* #define CVC 5
* #define NOP 29
* #define FPP 30
* #define FMM 31
* #define BPP 32
* #define BMM 33
* #define NOT 34
* #define ADR 35
* #define IND 36
* #define UNM 37
* #define COM 38
* #define ADD 40
* #define SUB 41
* #define MUL 42
* #define DIV 43
* #define MOD 44
* #define SHR 45
* #define SHL 46
* #define AND 47
* #define BOR 48
* #define XOR 49
* #define LND 53
* #define LOR 54
* #define EQU 60
* #define NEQ 61
* #define LEQ 62
* #define LES 63
* #define GEQ 64
* #define GRT 65
* #define ADA 70
* #define SUA 71
* #define MUA 72
* #define DIA 73
* #define MOA 74
* #define SRA 75
* #define SLA 76
* #define ANA 77
* #define BOA 78
* #define XOA 79
* #define ASN 80
* #define CXB 90
* #define CBR 91
* #define CEN 92
* #define ORB 93
* #define ORE 94
* #define ANB 95
* #define ANE 96
* #define ORC 97
* #define ANC 98
* #define DOT 99
* #define CAL 100
* #define PRM 101
* #define LOD 102
* #define SPL 103
* #define SPR 104
* #define CMA 105
* #define ENDITM 128
* #define BEGEXP 129
* #define ENDEXP 130
* #define NNAME 131
* #define NCON 132
* #define NNODE 133
* #define LABEL 134
* #define BRANCH 135
* #define CBRNCH 136
* #define BEGFNT 137
* #define ENDFNT 138
* #define SWIT 139
* #define STVAR 140
* #define AUTVAR 141
* #define REGVAR 142
* #define PROFIL 143
* #define TEXT 144
* #define DATA 145
* #define BSS 146
* #define SSPACE 147
* #define BYTES 148
* #define WORDS 149
* #define DNAME 150
* #define EXTERS 151
* #define COMDAT 152
* #define CMNT 153
* #define STRNG 154
* #define BEGBLK 155
* #define ENDBLK 156
* #define BEGMOD 157
* #define ENDMOD 158
* #define CLNSTK 159
* #define GLOBAL 160
* #define LABELS 161
* 
* #include "pass1.h"
* /*
* 
* #include "machine.h"
* /*
* 
* #define ONEWORD INT
* #define TWOWORDS LONG
* #define FSTARG 4
* #define FSTAUT -4
* #define NUMDREG 0
* #define NUMAREG 1
* 
* /* if alignment - define
* 
* 
* #include "symbol.h"
* 
* /* symbol table structure */
* 
* struct symtab {
*   int stype;
*   char sclass;
*   char sflags;
*   char sname[8];
*   int sstore;
*   char sblklv;
*   char sitype;
*   int *ssubs;
*   int sstrct;
*   int spoint;
*   char sstrnum;
*   char smemnum;
* };
* 
* /* type defines */
* 
* #define CHR 1
* #define INT 2
* #define SHORT 3
* #define UNSND 4
* #define LONG 5
* #define FLOAT 6
* #define DUBLE 7
* #define STRUCT 11
* #define UNION 12
* #define ENUM 13
* #define CONST 14
* #define VOID 15
* 
* /* class definitions */
* 
* #define AUTO 1
* #define STAT 2
* #define REG 3
* #define EXTN 4
* #define TYPDF 5
* #define STRTAG 8
* #define UNNTAG 9
* #define ENMTAG 10
* #define MOS 11
* #define MOU 12
* #define MOE 13
* 
* /* type specifiers */
* 
* #define PTR 1
* #define FNCT 2
* #define ARAY 3
* 
* /* flag definitions */
* 
* #define FLAB 1
* #define FUNION 2
* #define FUND 4
* #define FINIT 8
* #define FFIELD 16
* #define FPRM 32
* #define FPSHD 64
* #define FEXT 128
* 
* /* itype definitions */
* 
* #define SIDENT 1
* #define STAG 2
* #define SMEMBER 3
* #define SLABEL 4
* 
* #include "tbdef.h"
* /*******************************************************************/
* /*                                                                 */
* /*             Managed Table Structure Definitions.                */
* /*                                                                 */
* /*******************************************************************/
* 
* struct table {   /* Managed Table control block */
*    char *fwad;
*    char *lwad;
*    char *ptr1;
*    char *ptr2;
*    char *lwas;
*    unsigned  incr;
*    struct table *prev;
*    struct table *next;
* };
* 
* typedef struct table *TABLE;
* 
* #define SMC 1   /* ; */
* #define LCB 2   /* { */
* #define RCB 3   /* } */
* #define LSB 4   /* [ */
* #define RSB 5   /* ] */
* #define LPR 6   /* ( */
* #define RPR 7   /* ) */
* #define COL 8   /* : */
* #define SQU 9   /* ' */
* #define DQU 10  /* " */
* #define BKS 11  /* \ */
* #define QUM 12  /* ? */
* #define ARO 13  /* -> */
* #define KEY 14  /* keyword */
* #define VAR 15  /* variable */
* #define CON 16  /* constant */
* #define CHC 17  /* character constant */
* #define STC 18  /* string constant */
* #define BAD 127 /* no token */
* 
* /* adjustable quantity definitions */
* 
* #define MAXSTRNG 128
* #define NUMSTRNG  24
* #define DMLEN 64
* #define SWLEN 256
* #define FORNUM 50
* #define FORCON 32
* #define SSLEN 16
* #define MATLEN 130
* #define ASLEN 2*MATLEN
* #define NUMCON 128
* 
* /* structure definitions */
* 
* /* token table structure */
* 
* struct toktab {
*   char ch;
*   char tok;
* };
* 
* /* string stack structure definition */
* 
* struct sstack {
*   int stlbl;
*   char *stptr;
* };
* 
* /* structure info stack structure */
* 
* struct infost {
*   int header;
*   int number;
* };
* 
* /* expression matrix structure definition */
* 
* struct express {
*   char moprtr;
*   int mttype;
*   struct symtab *mo1loc;
*   struct symtab *mo2loc;
* };
* 
* #define STNEST 10
* 
* /* misc defines */
* 
* #define EOF (-1)
* #define NULL 0
* 
* /* macro definitions */
* 
* #define getnch() (curchar ? curchar : (curchar = nxtchr()))
* 
* /* miscellaneous definitions */
* 
* #define FALSE 0
* #define TRUE 1
* 
* #define STEXT 0
* #define SDATA 1
* #define SBSS 2
* 
* 
* extern int curtok, *cursubs, contab[];
* extern struct symtab strings[], *nxtsst, *astack[];
* extern struct symtab **tos;
* extern struct symtab *symloc;
* extern int token;
* extern int contyp;
* extern long convalu;
* extern int *nxtdim, *nxtcon, dimstk[];
* extern char strnum;
* extern struct sstack *strngloc;
* extern int onecon[];
* 
* /* priority level 15 - comma operator */
* 
* exp15() {
 global exp15
exp15
 pshs y,u
 jmp 1f
2
*   if (!exp14())
*     return(FALSE);
 jsr exp14
 subd #0
 lbne _2
_1
 clra
 clrb
 puls y,u,pc

*   if (getok() != CMA)
_2
*     return(TRUE);
 jsr getok
 cmpd #105
 lbeq _4
_3
 ldd #1
 puls y,u,pc

*   curtok = 0;
_4
 clra
 clrb
 std curtok
*   entera(CMA);
 ldd #105
 pshs d
 jsr entera
 leas 2,s
*   return(exp15());
 jsr exp15
 puls y,u,pc

* }
1 ldd #-136
 jsr _stkcheck
 jmp 2b


* 
* /* priority level 14 - assignment operators */
* 
* exp14() {
 global exp14
exp14
 pshs y,u
 jmp 1f
2
*   int tok;
* 
*   if (!exp13())
 leas -2,s
*     return(FALSE);
 jsr exp13
 subd #0
 lbne _6
_5
 clra
 clrb
 leas 2,s
 puls y,u,pc

*   while (getok()>=ADA && curtok<=ASN) {
_6
_8
 jsr getok
 cmpd #70
 lblt _7
_10
 ldd curtok
 cmpd #80
 lbgt _7
_9
*     tok = curtok;
 ldd curtok
 std ,s
*     curtok = 0;
 clra
 clrb
 std curtok
*     if (!exp14())
*       return(FALSE);
 jsr exp14
 subd #0
 lbne _12
_11
 clra
 clrb
 leas 2,s
 puls y,u,pc

*     enterb(tok);
_12
 ldd ,s
 pshs d
 jsr enterb
 leas 2,s
*   }
*   return(TRUE);
 jmp _8
_7
 ldd #1
 leas 2,s
 puls y,u,pc

* }
1 ldd #-138
 jsr _stkcheck
 jmp 2b


* 
* /* priority level 13 - conditional operator */
* 
* exp13() {
 global exp13
exp13
 pshs y,u
 jmp 1f
2
*   if (!exp12())
*     return(FALSE);
 jsr exp12
 subd #0
 lbne _14
_13
 clra
 clrb
 puls y,u,pc

*   while (getok() == QUM) {
_14
_16
 jsr getok
 cmpd #12
 lbne _15
_17
*     curtok = 0;
 clra
 clrb
 std curtok
*     makeload();
 jsr makeload
*     entera(CXB);
 ldd #90
 pshs d
 jsr entera
 leas 2,s
*     if (!exp14())
*       return(FALSE);
 jsr exp14
 subd #0
 lbne _19
_18
 clra
 clrb
 puls y,u,pc

*     if (getok() != COL)
_19
*       return(FALSE);
 jsr getok
 cmpd #8
 lbeq _21
_20
 clra
 clrb
 puls y,u,pc

*     curtok = 0;
_21
 clra
 clrb
 std curtok
*     makeload();
 jsr makeload
*     entera(CBR);
 ldd #91
 pshs d
 jsr entera
 leas 2,s
*     if (!exp14())
*       return(FALSE);
 jsr exp14
 subd #0
 lbne _23
_22
 clra
 clrb
 puls y,u,pc

*     makeload();
_23
 jsr makeload
*     enteru(CEN);
 ldd #92
 pshs d
 jsr enteru
 leas 2,s
*   }
*   return(TRUE);
 jmp _16
_15
 ldd #1
 puls y,u,pc

* }
1 ldd #-136
 jsr _stkcheck
 jmp 2b


* 
* /* priority level 12 - logical or operator */
* 
* exp12() {
 global exp12
exp12
 pshs y,u
 jmp 1f
2
*   if (!exp11())
*     return(FALSE);
 jsr exp11
 subd #0
 lbne _25
_24
 clra
 clrb
 puls y,u,pc

*   while (getok() == LOR) {
_25
_27
 jsr getok
 cmpd #54
 lbne _26
_28
*     curtok = 0;
 clra
 clrb
 std curtok
*     putorb();
 jsr putorb
*     if (!exp11())
*       return(FALSE);
 jsr exp11
 subd #0
 lbne _30
_29
 clra
 clrb
 puls y,u,pc

*     putore();
_30
 jsr putore
*   }
*   return(TRUE);
 jmp _27
_26
 ldd #1
 puls y,u,pc

* }
1 ldd #-134
 jsr _stkcheck
 jmp 2b


* 
* /* priority level 11 - logical and operator */
* 
* exp11() {
 global exp11
exp11
 pshs y,u
 jmp 1f
2
*   if (!exp10())
*     return(FALSE);
 jsr exp10
 subd #0
 lbne _32
_31
 clra
 clrb
 puls y,u,pc

*   while (getok() == LND) {
_32
_34
 jsr getok
 cmpd #53
 lbne _33
_35
*     curtok = 0;
 clra
 clrb
 std curtok
*     putanb();
 jsr putanb
*     if (!exp10())
*       return(FALSE);
 jsr exp10
 subd #0
 lbne _37
_36
 clra
 clrb
 puls y,u,pc

*     putane();
_37
 jsr putane
*   }
*   return(TRUE);
 jmp _34
_33
 ldd #1
 puls y,u,pc

* }
1 ldd #-134
 jsr _stkcheck
 jmp 2b


* 
* /* priority level 10 - bitwise or operator */
* 
* exp10() {
 global exp10
exp10
 pshs y,u
 jmp 1f
2
*   if (!exp9())
*     return(FALSE);
 jsr exp9
 subd #0
 lbne _39
_38
 clra
 clrb
 puls y,u,pc

*   while (getok() == BOR) {
_39
_41
 jsr getok
 cmpd #48
 lbne _40
_42
*     curtok = 0;
 clra
 clrb
 std curtok
*     if (!exp9())
*       return(FALSE);
 jsr exp9
 subd #0
 lbne _44
_43
 clra
 clrb
 puls y,u,pc

*     enterb(BOR);
_44
 ldd #48
 pshs d
 jsr enterb
 leas 2,s
*   }
*   return(TRUE);
 jmp _41
_40
 ldd #1
 puls y,u,pc

* }
1 ldd #-136
 jsr _stkcheck
 jmp 2b


* 
* /* priority level 9 - exclusive or operator */
* 
* exp9() {
 global exp9
exp9
 pshs y,u
 jmp 1f
2
*   if (!exp8())
*     return(FALSE);
 jsr exp8
 subd #0
 lbne _46
_45
 clra
 clrb
 puls y,u,pc

*   while (getok() == XOR) {
_46
_48
 jsr getok
 cmpd #49
 lbne _47
_49
*     curtok = 0;
 clra
 clrb
 std curtok
*     if (!exp8())
*       return(FALSE);
 jsr exp8
 subd #0
 lbne _51
_50
 clra
 clrb
 puls y,u,pc

*     enterb(XOR);
_51
 ldd #49
 pshs d
 jsr enterb
 leas 2,s
*   }
*   return(TRUE);
 jmp _48
_47
 ldd #1
 puls y,u,pc

* }
1 ldd #-136
 jsr _stkcheck
 jmp 2b


* 
* /* priority level 8 - bitwise and operator */
* 
* exp8() {
 global exp8
exp8
 pshs y,u
 jmp 1f
2
*   if (!exp7())
*     return(FALSE);
 jsr exp7
 subd #0
 lbne _53
_52
 clra
 clrb
 puls y,u,pc

*   while (getok() == AND) {
_53
_55
 jsr getok
 cmpd #47
 lbne _54
_56
*     curtok = 0;
 clra
 clrb
 std curtok
*     if (!exp7())
*       return(FALSE);
 jsr exp7
 subd #0
 lbne _58
_57
 clra
 clrb
 puls y,u,pc

*     enterb(AND);
_58
 ldd #47
 pshs d
 jsr enterb
 leas 2,s
*   }
*   return(TRUE);
 jmp _55
_54
 ldd #1
 puls y,u,pc

* }
1 ldd #-136
 jsr _stkcheck
 jmp 2b


* 
* /* priority level 7 - equality operators */
* 
* exp7() {
 global exp7
exp7
 pshs y,u
 jmp 1f
2
*   int tok;
* 
*   if (!exp6())
 leas -2,s
*     return(FALSE);
 jsr exp6
 subd #0
 lbne _60
_59
 clra
 clrb
 leas 2,s
 puls y,u,pc

*   while (getok()==EQU || curtok==NEQ) {
_60
_62
 jsr getok
 cmpd #60
 lbeq _63
_64
 ldd curtok
 cmpd #61
 lbne _61
_63
*     tok = curtok;
 ldd curtok
 std ,s
*     curtok = 0;
 clra
 clrb
 std curtok
*     if (!exp6())
*       return(FALSE);
 jsr exp6
 subd #0
 lbne _66
_65
 clra
 clrb
 leas 2,s
 puls y,u,pc

*     enterb(tok);
_66
 ldd ,s
 pshs d
 jsr enterb
 leas 2,s
*   }
*   return(TRUE);
 jmp _62
_61
 ldd #1
 leas 2,s
 puls y,u,pc

* }
1 ldd #-138
 jsr _stkcheck
 jmp 2b


* 
* /* priority level 6 - relational operators */
* 
* exp6() {
 global exp6
exp6
 pshs y,u
 jmp 1f
2
*   int tok;
* 
*   if (!exp5())
 leas -2,s
*     return(FALSE);
 jsr exp5
 subd #0
 lbne _68
_67
 clra
 clrb
 leas 2,s
 puls y,u,pc

*   while (getok()>=LEQ && curtok<=GRT) {
_68
_70
 jsr getok
 cmpd #62
 lblt _69
_72
 ldd curtok
 cmpd #65
 lbgt _69
_71
*     tok = curtok;
 ldd curtok
 std ,s
*     curtok = 0;
 clra
 clrb
 std curtok
*     if (!exp5())
*       return(FALSE);
 jsr exp5
 subd #0
 lbne _74
_73
 clra
 clrb
 leas 2,s
 puls y,u,pc

*     enterb(tok);
_74
 ldd ,s
 pshs d
 jsr enterb
 leas 2,s
*   }
*   return(TRUE);
 jmp _70
_69
 ldd #1
 leas 2,s
 puls y,u,pc

* }
1 ldd #-138
 jsr _stkcheck
 jmp 2b


* 
* /* priority level 5 - shift operators */
* 
* exp5() {
 global exp5
exp5
 pshs y,u
 jmp 1f
2
*   int tok;
* 
*   if (!exp4())
 leas -2,s
*     return(FALSE);
 jsr exp4
 subd #0
 lbne _76
_75
 clra
 clrb
 leas 2,s
 puls y,u,pc

*   while (getok()==SHL || curtok==SHR) {
_76
_78
 jsr getok
 cmpd #46
 lbeq _79
_80
 ldd curtok
 cmpd #45
 lbne _77
_79
*     tok = curtok;
 ldd curtok
 std ,s
*     curtok = 0;
 clra
 clrb
 std curtok
*     if (!exp4())
*       return(FALSE);
 jsr exp4
 subd #0
 lbne _82
_81
 clra
 clrb
 leas 2,s
 puls y,u,pc

*     enterb(tok);
_82
 ldd ,s
 pshs d
 jsr enterb
 leas 2,s
*   }
*   return(TRUE);
 jmp _78
_77
 ldd #1
 leas 2,s
 puls y,u,pc

* }
1 ldd #-138
 jsr _stkcheck
 jmp 2b


* 
* /* priority level 4 - add and subtract operators */
* 
* exp4() {
 global exp4
exp4
 pshs y,u
 jmp 1f
2
*   int tok;
* 
*   if (!exp3())
 leas -2,s
*     return(FALSE);
 jsr exp3
 subd #0
 lbne _84
_83
 clra
 clrb
 leas 2,s
 puls y,u,pc

*   while (getok()==ADD || curtok==SUB) {
_84
_86
 jsr getok
 cmpd #40
 lbeq _87
_88
 ldd curtok
 cmpd #41
 lbne _85
_87
*     tok = curtok;
 ldd curtok
 std ,s
*     curtok = 0;
 clra
 clrb
 std curtok
*     if (!exp3())
*       return(FALSE);
 jsr exp3
 subd #0
 lbne _90
_89
 clra
 clrb
 leas 2,s
 puls y,u,pc

*     enterb(tok);
_90
 ldd ,s
 pshs d
 jsr enterb
 leas 2,s
*   }
*   return(TRUE);
 jmp _86
_85
 ldd #1
 leas 2,s
 puls y,u,pc

* }
1 ldd #-138
 jsr _stkcheck
 jmp 2b


* 
* /* priority level 3 - multiplicative operators */
* 
* exp3() {
 global exp3
exp3
 pshs y,u
 jmp 1f
2
*   int tok;
* 
*   if (!exp2())
 leas -2,s
*     return(FALSE);
 jsr exp2
 subd #0
 lbne _92
_91
 clra
 clrb
 leas 2,s
 puls y,u,pc

*   while (getok()==MUL || curtok==DIV || curtok==MOD) {
_92
_94
 jsr getok
 cmpd #42
 lbeq _95
_97
 ldd curtok
 cmpd #43
 lbeq _95
_96
 ldd curtok
 cmpd #44
 lbne _93
_95
*     tok = curtok;
 ldd curtok
 std ,s
*     curtok = 0;
 clra
 clrb
 std curtok
*     if (!exp2())
*       return(FALSE);
 jsr exp2
 subd #0
 lbne _99
_98
 clra
 clrb
 leas 2,s
 puls y,u,pc

*     enterb(tok);
_99
 ldd ,s
 pshs d
 jsr enterb
 leas 2,s
*   }
*   return(FALSE);
 jmp _94
_93
 clra
 clrb
 leas 2,s
 puls y,u,pc

* }
1 ldd #-138
 jsr _stkcheck
 jmp 2b


* 
* /* priority level 2 - unary operators */
* 
* exp2() {
 global exp2
exp2
 pshs y,u
 jmp 1f
2
*   int tok;
* 
*   switch (getok()) {
 leas -2,s
 jsr getok
 tfr d,x
 jmp _101
*     case FPP:
*     case FMM:
_102
*       tok = curtok;
_103
 ldd curtok
 std ,s
*       curtok = 0;
 clra
 clrb
 std curtok
*       if (!exp2())
*         return(FALSE);
 jsr exp2
 subd #0
 lbne _105
_104
 clra
 clrb
 leas 2,s
 puls y,u,pc

*       *tos++ = onecon;
_105
 ldd #onecon
 ldx tos
 leax 2,x
 stx tos
 std -2,x
*       enterb(tok);
 ldd ,s
 pshs d
 jsr enterb
 leas 2,s
*       tok = 0;
 clra
 clrb
 std ,s
*       break;
 jmp _100
*     case MUL:
*       tok = IND;
_106
 ldd #36
 std ,s
*       break;
 jmp _100
*     case AND:
*       tok = ADR;
_107
 ldd #35
 std ,s
*       break;
 jmp _100
*     case NOT:
*       tok = NOT;
_108
 ldd #34
 std ,s
*       break;
 jmp _100
*     case SUB:
*       tok = UNM;
_109
 ldd #37
 std ,s
*       break;
 jmp _100
*     case COM:
*       tok = COM;
_110
 ldd #38
 std ,s
*       break;
 jmp _100
*     case KEY:
*       if (token == 22) /* is it sizeof? */
_111
*         return(psizeof());
 ldd token
 cmpd #22
 lbne _113
_112
 jsr psizeof
 leas 2,s
 puls y,u,pc

*     default:
_113
_114
*       if (!exp1())
*         return(FALSE);
 jsr exp1
 subd #0
 lbne _116
_115
 clra
 clrb
 leas 2,s
 puls y,u,pc

*       tok = 0;
_116
 clra
 clrb
 std ,s
*   }
*   if (tok) {
 jmp _100
_101
 cmpx #30
 lbeq _102
 cmpx #31
 lbeq _103
 cmpx #42
 lbeq _106
 cmpx #47
 lbeq _107
 cmpx #34
 lbeq _108
 cmpx #41
 lbeq _109
 cmpx #38
 lbeq _110
 cmpx #14
 lbeq _111
 jmp _114
_100
 ldd ,s
 lbeq _118
_117
*     curtok = 0;
 clra
 clrb
 std curtok
*     if (!exp2())
*       return(FALSE);
 jsr exp2
 subd #0
 lbne _120
_119
 clra
 clrb
 leas 2,s
 puls y,u,pc

*     enteru(tok);
_120
 ldd ,s
 pshs d
 jsr enteru
 leas 2,s
*   }
*   if (getok()==FPP || curtok==FMM) {
_118
 jsr getok
 cmpd #30
 lbeq _121
_123
 ldd curtok
 cmpd #31
 lbne _122
_121
*     *tos++ = onecon;
 ldd #onecon
 ldx tos
 leax 2,x
 stx tos
 std -2,x
*     enterb(curtok + 2);
 ldd curtok
 addd #2
 pshs d
 jsr enterb
 leas 2,s
*     curtok = 0;
 clra
 clrb
 std curtok
*   }
*   return(TRUE);
_122
 ldd #1
 leas 2,s
 puls y,u,pc

* }
1 ldd #-138
 jsr _stkcheck
 jmp 2b


* 
* /* priority level 1 - operands */
* 
* exp1() {
 global exp1
exp1
 pshs y,u
 jmp 1f
2
*   switch (getok()) {
 jsr getok
 tfr d,x
 jmp _125
*     case VAR:
*       return(xvar());
_126
 jsr xvar
 puls y,u,pc

*     case CON:
*       return(xcon());
_127
 jsr xcon
 puls y,u,pc

*     case STC:
*       return(xstr());
_128
 jsr xstr
 puls y,u,pc

*     case LPR:
*       return(xsub());
_129
 jsr xsub
 puls y,u,pc

*     default:
_130
*       return(rptern(44));
 ldd #44
 pshs d
 jsr rptern
 leas 2,s
 puls y,u,pc

*   }
* }
_125
 cmpx #15
 lbeq _126
 cmpx #16
 lbeq _127
 cmpx #18
 lbeq _128
 cmpx #6
 lbeq _129
 jmp _130
_124
 puls y,u,pc

1 ldd #-136
 jsr _stkcheck
 jmp 2b


* 
* /* process a variable operand */
* 
* xvar() {
 global xvar
xvar
 pshs y,u
 jmp 1f
2
*   int *savesub;
* 
*   curtok = 0;
 leas -2,s
 clra
 clrb
 std curtok
*   if (!(symloc = looksym(SIDENT)))
*     symloc = addsym(SIDENT);
 ldd #1
 pshs d
 jsr looksym
 leas 2,s
 std symloc
 lbne _132
_131
 ldd #1
 pshs d
 jsr addsym
 leas 2,s
 std symloc
*   *tos++ = symloc;
_132
 ldd symloc
 ldx tos
 leax 2,x
 stx tos
 std -2,x
*   if (tos > &astack[ASLEN])
*     error(138);
 ldd #astack+520
 cmpd tos
 lbhs _134
_133
 ldd #138
 pshs d
 jsr error
 leas 2,s
*   if (symloc->sstrct)
_134
*     strnum = symloc->sstrnum;
 ldx symloc
 ldd 18,x
 lbeq _136
_135
 ldx symloc
 ldb 22,x
 stb strnum
*   else
*     strnum = 0;
 jmp _137
_136
 clra
 clrb
 stb strnum
*   savesub = cursubs;
_137
 ldd cursubs
 std ,s
*   if (symloc->ssubs)
*     cursubs = symloc->ssubs;
 ldx symloc
 ldd 16,x
 lbeq _139
_138
 ldx symloc
 ldd 16,x
 std cursubs
*   if (!primexp())
_139
*     return(FALSE);
 jsr primexp
 subd #0
 lbne _141
_140
 clra
 clrb
 leas 2,s
 puls y,u,pc

*   if (savesub)
_141
*     cursubs = savesub;
 ldd ,s
 lbeq _143
_142
 ldd ,s
 std cursubs
*   return(TRUE);
_143
 ldd #1
 leas 2,s
 puls y,u,pc

* }
1 ldd #-138
 jsr _stkcheck
 jmp 2b


* 
* /* process a constant operand */
* 
* xcon() {
 global xcon
xcon
 pshs y,u
 jmp 1f
2
*   int *p;
* 
*   curtok = 0;
 leas -2,s
 clra
 clrb
 std curtok
*   p = nxtcon;
 ldd nxtcon
 std ,s
*   *p++ = (contyp << 8) | CONST;
 ldd contyp
 pshs d
 ldd #8
 jsr ccasl
 orb #14
 ldx ,s
 leax 2,x
 stx ,s
 std -2,x
*   switch (contyp) {
 ldx contyp
 jmp _145
*     case CHR:
*     case SHORT:
_146
*     case INT:
_147
*     case UNSND:
_148
*       *p++ = (int) convalu;
_149
 ldd convalu+2
 ldx ,s
 leax 2,x
 stx ,s
 std -2,x
*       break;
 jmp _144
*     case LONG:
*     case FLOAT:
_150
*     case DUBLE:
_151
*       *p++ = (int) (convalu>>16);
_152
 ldx #convalu
 pshs x
 ldd #16
 jsr _lshr
 ldd _flacc+2
 ldx ,s
 leax 2,x
 stx ,s
 std -2,x
*       *p++ = (int) convalu;
 ldd convalu+2
 ldx ,s
 leax 2,x
 stx ,s
 std -2,x
*       break;
 jmp _144
*   }
*   if (p >= &contab[NUMCON])
_145
 cmpx #1
 lbeq _146
 cmpx #3
 lbeq _147
 cmpx #2
 lbeq _148
 cmpx #4
 lbeq _149
 cmpx #5
 lbeq _150
 cmpx #6
 lbeq _151
 cmpx #7
 lbeq _152
_144
*     error(139);
 ldd #contab+256
 cmpd ,s
 lbhi _154
_153
 ldd #139
 pshs d
 jsr error
 leas 2,s
*   *tos++ = nxtcon;
_154
 ldd nxtcon
 ldx tos
 leax 2,x
 stx tos
 std -2,x
*   nxtcon = p;
 ldd ,s
 std nxtcon
*   if (tos > &astack[ASLEN]);
*     error(138);
 ldd #astack+520
 cmpd tos
 lblo _155
_156
_155
 ldd #138
 pshs d
 jsr error
 leas 2,s
*   return(primexp());
 jsr primexp
 leas 2,s
 puls y,u,pc

* }
1 ldd #-138
 jsr _stkcheck
 jmp 2b


* 
* /* process string constant operand */
* 
* xstr() {
 global xstr
xstr
 pshs y,u
 jmp 1f
2
*   int size;
*   char *p;
* 
*   if (nxtsst >= &strings[SSLEN])
 leas -4,s
*     error(133);
 ldd #strings+384
 cmpd nxtsst
 lbhi _158
_157
 ldd #133
 pshs d
 jsr error
 leas 2,s
*   symloc = nxtsst++;
_158
 ldd nxtsst
 addd #24
 std nxtsst
 subd #24
 std symloc
*   symloc->sclass = STAT;
 ldd #2
 ldx symloc
 stb 2,x
*   symloc->stype = (ARAY<<4) | CHR;
 ldd #49
 std [symloc]
*   symloc->sstore = strngloc->stlbl;
 ldd [strngloc]
 ldx symloc
 std 12,x
*   symloc->ssubs = nxtdim;
 ldd nxtdim
 ldx symloc
 std 16,x
*   p = strngloc->stptr;
 ldx strngloc
 ldd 2,x
 std ,s
*   for (size = 1; *p; p++, size++);
 ldd #1
 std 2,s
_161
 ldb [,s]
 lbeq _160
_159
*   *nxtdim++ = size;
_162
 ldd ,s
 addd #1
 std ,s
 subd #1
 ldd 2,s
 addd #1
 std 2,s
 subd #1
 jmp _161
_160
 ldd 2,s
 ldx nxtdim
 leax 2,x
 stx nxtdim
 std -2,x
*   *nxtdim++ = (-1);
 ldd #-1
 ldx nxtdim
 leax 2,x
 stx nxtdim
 std -2,x
*   if (nxtdim >= &dimstk[DMLEN])
*     error(135);
 ldd #dimstk+128
 cmpd nxtdim
 lbhi _164
_163
 ldd #135
 pshs d
 jsr error
 leas 2,s
*   return(xvar());
_164
 jsr xvar
 leas 4,s
 puls y,u,pc

* }
1 ldd #-140
 jsr _stkcheck
 jmp 2b


* 
* /* process sub expression */
* 
* xsub() {
 global xsub
xsub
 pshs y,u
 jmp 1f
2
*   curtok = 0;
 clra
 clrb
 std curtok
*   exp15();
 jsr exp15
*   if (getok() != RPR)
*     rptern(45);
 jsr getok
 cmpd #7
 lbeq _166
_165
 ldd #45
 pshs d
 jsr rptern
 leas 2,s
*   else
*     curtok = 0;
 jmp _167
_166
 clra
 clrb
 std curtok
*   return(primexp());
_167
 jsr primexp
 puls y,u,pc

* }
1 ldd #-136
 jsr _stkcheck
 jmp 2b


* 
* /* process primary expression */
* 
* primexp() {
 global primexp
primexp
 pshs y,u
 jmp 1f
2
*   int savenum;
* 
*   switch(getok()) {
 leas -2,s
 jsr getok
 tfr d,x
 jmp _169
*     case LSB:
*       curtok = 0;
_170
 clra
 clrb
 std curtok
*       savenum = strnum;
 ldb strnum
 sex
 std ,s
*       strnum = 0;
 clra
 clrb
 stb strnum
*       exp15();
 jsr exp15
*       strnum = savenum;
 ldd ,s
 stb strnum
*       if (getok() != RSB)
*         rptern(46);
 jsr getok
 cmpd #5
 lbeq _172
_171
 ldd #46
 pshs d
 jsr rptern
 leas 2,s
*       else
*         curtok = 0;
 jmp _173
_172
 clra
 clrb
 std curtok
*       if (*cursubs != (-1))
_173
*         cursubs++;
 ldd [cursubs]
 cmpd #-1
 lbeq _175
_174
 ldd cursubs
 addd #2
 std cursubs
*       enterb(ADD);
_175
 ldd #40
 pshs d
 jsr enterb
 leas 2,s
*       enteru(IND);
 ldd #36
 pshs d
 jsr enteru
 leas 2,s
*       return(primexp());
 jsr primexp
 leas 2,s
 puls y,u,pc

*     case LPR:
*       curtok = 0;
_176
 clra
 clrb
 std curtok
*       if (symloc && !symloc->sclass) {
 ldd symloc
 lbeq _178
_179
 ldx symloc
 ldb 2,x
 lbne _178
_177
*         symloc->sclass = EXTN;
 ldd #4
 ldx symloc
 stb 2,x
*         symloc->stype = (FNCT<<4) | INT;
 ldd #34
 std [symloc]
*       }
*       entern(SPL);
_178
 ldd #103
 pshs d
 jsr entern
 leas 2,s
*       explst();
 jsr explst
*       if (getok() != RPR)
*         rptern(47);
 jsr getok
 cmpd #7
 lbeq _181
_180
 ldd #47
 pshs d
 jsr rptern
 leas 2,s
*       else
*         curtok = 0;
 jmp _182
_181
 clra
 clrb
 std curtok
*       enteru(CAL);
_182
 ldd #100
 pshs d
 jsr enteru
 leas 2,s
*       return(primexp());
 jsr primexp
 leas 2,s
 puls y,u,pc

*     case ARO:
*       curtok = 0;
_183
 clra
 clrb
 std curtok
*       enteru(IND);
 ldd #36
 pshs d
 jsr enteru
 leas 2,s
*     case DOT:
*       curtok = 0;
_184
 clra
 clrb
 std curtok
*       return(strident());
 jsr strident
 leas 2,s
 puls y,u,pc

*     default:
_185
*       return(TRUE);
 ldd #1
 leas 2,s
 puls y,u,pc

*   }
* }
_169
 cmpx #4
 lbeq _170
 cmpx #6
 lbeq _176
 cmpx #13
 lbeq _183
 cmpx #99
 lbeq _184
 jmp _185
_168
 leas 2,s
 puls y,u,pc

1 ldd #-138
 jsr _stkcheck
 jmp 2b


* 
* /* parse expression list */
* 
* explst() {
 global explst
explst
 pshs y,u
 jmp 1f
2
*   if (getok() == RPR)
*     return(TRUE);
 jsr getok
 cmpd #7
 lbne _187
_186
 ldd #1
 puls y,u,pc

*   while (TRUE) {
_187
_189
_190
*     entern(SPR);
 ldd #104
 pshs d
 jsr entern
 leas 2,s
*     exp14();
 jsr exp14
*     entera(PRM);
 ldd #101
 pshs d
 jsr entera
 leas 2,s
*     if (getok() != CMA)
*       return(TRUE);
 jsr getok
 cmpd #105
 lbeq _192
_191
 ldd #1
 puls y,u,pc

*     curtok = 0;
_192
 clra
 clrb
 std curtok
*   }
* }
 jmp _189
_188
 puls y,u,pc

1 ldd #-136
 jsr _stkcheck
 jmp 2b


* 
* /* process a structure member identifier */
* 
* strident() {
 global strident
strident
 pshs y,u
 jmp 1f
2
*   int *savesub;
* 
*   savesub = cursubs;
 leas -2,s
 ldd cursubs
 std ,s
*   if (getok() != VAR)
*     return(rptern(49));
 jsr getok
 cmpd #15
 lbeq _194
_193
 ldd #49
 pshs d
 jsr rptern
 leas 2,s
 leas 2,s
 puls y,u,pc

*   if (!(symloc = looksym(SMEMBER)))
_194
*     return(rptern(49));
 ldd #3
 pshs d
 jsr looksym
 leas 2,s
 std symloc
 lbne _196
_195
 ldd #49
 pshs d
 jsr rptern
 leas 2,s
 leas 2,s
 puls y,u,pc

*   curtok = 0;
_196
 clra
 clrb
 std curtok
*   if (symloc->ssubs)
*     cursubs = symloc->ssubs;
 ldx symloc
 ldd 16,x
 lbeq _198
_197
 ldx symloc
 ldd 16,x
 std cursubs
*   if (symloc->sstrct)
_198
*     strnum = symloc->sstrnum;
 ldx symloc
 ldd 18,x
 lbeq _200
_199
 ldx symloc
 ldb 22,x
 stb strnum
*   else
*     strnum = 0;
 jmp _201
_200
 clra
 clrb
 stb strnum
*   enterb(DOT);
_201
 ldd #99
 pshs d
 jsr enterb
 leas 2,s
*   if (!primexp())
*     return(FALSE);
 jsr primexp
 subd #0
 lbne _203
_202
 clra
 clrb
 leas 2,s
 puls y,u,pc

*   if (savesub)
_203
*     cursubs = savesub;
 ldd ,s
 lbeq _205
_204
 ldd ,s
 std cursubs
*   return(TRUE);
_205
 ldd #1
 leas 2,s
 puls y,u,pc

* }
1 ldd #-138
 jsr _stkcheck
 jmp 2b


* 
 bss
 name p1_exp_c
