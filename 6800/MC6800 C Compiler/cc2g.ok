 opt lis

* code generation for unary ops

* nop

noop ldd -EXPSIZ+rslt,x get result
 std rslt,x set new result
nop leax EXPSIZ,x skip entry
 stx codptr save new pointer
 rts return

* cvt code generation

cvt ldu op1ptr get op
 ldb enbtyp save the type
 pshs b
 jsr gettyp get operand type
 bitb #$30 complex type?
 beq 2f
 andb #$30
 cmpb #$10 is it ptr?
 bne 1f
 ldb #8
 bra 2f
1 ldb #9 set ptr type
2 andb #$f
 ldy #typcnv
 decb
 ldb b,y get basic type
 stb enbtyp set new type
 ldu op1ptr get op1
 lda 0,u get type
 cmpa #NNODE is it node?
 beq 6f
 cmpb #8 pointer type?
 blo 4f
 lda 0,s get basic type
 cmpa #2 integral type?
 bls 5f
 bra 6f
4 lda 0,s get basic type
 cmpa #8 pointer type?
 blo 6f
 cmpb #2 op1 type integral?
 bhi 6f
5 puls b
 stb enbtyp reset type
 jmp lod go do load
6 jsr load do load
 puls b reset type
 stb enbtyp
 ldu op1ptr
 ldy #cvttab point to routine list
 jmp [b,y] do it

cvttab fdb chcvt,intcvt,lncvt,fpcvt,ptcvt,arcvt

chcvt jsr gettyp get operand type
 cmpb #UNSND is it unsigned?
 lbls rsltb if integral - nop
 swi
intcvt jsr gettyp get operand type
 cmpb #CHR is it character?
 beq 2f
 cmpb #UNSND integral?
 bhi 4f
 jmp rsltd nop
2 ldd entype get type of result
 cmpb #UNSND
 beq 3f
 jsr osex output 'sex'
 clr ccok
 bra 35f
3 jsr oclra output 'clra'
 clr ccok
35 jmp rsltd
4 bitb #$30 complex type?
 beq 6f
 ldy curadr get ar
 jsr cmplar complete ar
 jsr chkdb check if d busy
5 jsr otfrxd output 'tfr x,d'
 ldd #0
 std xcont
 bra 35b
6 swi
lncvt swi
fpcvt swi
ptcvt
arcvt jsr gettyp get type of op
 bitb #$30 complex?
 beq 2f
 jmp nop
2 cmpb #CHR is it character?
 beq 4f
 cmpb #UNSND integral?
 bhi 5f
3 jsr chkxb check if x busy
 jsr otfrdx output 'tfr d,x'
 jsr gtareg get ar
 lda #XREF set xref
 sta ar_ref,y
 sty curadr
 sty xcont set x contents
 ldd #0
 std dcont
 jmp ptrfin go finish
4 jsr osex output 'sex'
 bra 3b
5 swi

* fpp code generation

fpp ldu op1ptr get op1
 ldb enbtyp get basic type
 ldy #fpptab point to routines
 jmp [b,y] go do it

fpptab fdb chfpp,intfpp,lnfpp,fpfpp

chfpp jsr oinc output 'inc'
 jsr giadr gen address
 inc ccok
 jsr tstfol end of exp?
 beq 1f
 ldu op1ptr get op1
 jsr load do load
1 jmp rsltb set result
intfpp jsr tstfol end of exp?
 beq infpp2
 jsr load do load
 jsr oaddd1 output 'addd #1'
 ldu op1ptr get op1
 jmp intasn do store code
infpp2 jsr oinc output 'inc'
 ldd #1 set offset
 std offval
 clr spctos
 jsr giadro gen address
 jsr obne1f output 'bne 1f'
 jsr oinc output 'inc'
 ldu op1ptr get op1
 jsr giadr gen address
 jsr o1lab output '1'
 clr ccok
 jmp rsltd set result
lnfpp swi
fpfpp swi

* fmm code generation

fmm ldu op1ptr get op1
 ldb enbtyp get basic type
 ldy #fmmtab point to routines
 jmp [b,y] go do it

fmmtab fdb chfmm,intfmm,lnfmm,fpfmm

chfmm jsr odec output 'dec'
 jsr giadr gen address
 inc ccok
 jsr tstfol end of exp
 beq 1f
 ldu op1ptr get op1
 jsr load do load
1 jmp rsltb set result
intfmm jsr load do load
 jsr osubd1 output 'subd #1'
 ldu op1ptr get op1
 jmp intasn do store code
lnfmm swi
fpfmm swi

* bpp code generation

bpp ldu op1ptr get op1
 jsr tstfol
 beq 1f
 jsr load do load
 ldu op1ptr get op1
1 ldb enbtyp get type
 ldy #bpptab point to routines
 jmp [b,y] do it

bpptab fdb chbpp,intbpp,lnbpp,fpbpp

chbpp jsr oinc output 'inc'
 jsr giadr gen address
 clr ccok
 jmp rsltb set result
intbpp jmp infpp2 same as above
lnbpp swi
fpbpp swi

* bmm code generation

bmm ldu op1ptr get op1
 jsr tstfol end of exp?
 beq 1f
 jsr load do load
 ldu op1ptr get op1
1 ldb enbtyp get type
 ldy #bmmtab point to routines
 jmp [b,y] go do it

bmmtab fdb chbmm,intbmm,lnbmm,fpbmm

chbmm jsr odec output 'dec'
 jsr giadr gen address
 jmp rsltb set result
intbmm jsr otst output 'tst'
 ldd #1 set offset
 std offval
 clr spctos
 jsr giadro gen address
 jsr obne1f output 'bne 1f'
 jsr odec output 'dec'
 ldu op1ptr get op1
 jsr giadr gen address
 jsr o1dec output '1 dec'
 ldd #1 set offset
 std offval
 clr spctos
 ldu op1ptr get op1
 jsr giadro
 clr ccok
 jmp rsltd set result
lnbmm swi
fpbmm swi

* not code generation

not ldu op1ptr get op1
 jsr load do load
 com revcon reverse compare
 jmp cndfin

* adr code generation

adr ldu op1ptr get op1
 jsr ptld do pointer load
 ldy curadr get address reg
 inc ar_adr,y set address mode
 bra ptrfin go finish

* ind code generation

ino ldu op1ptr get operand
 jsr ptld do pointer load
 clr doind clear flag
 pshs y
 jsr tstfol
 puls y
 bne 2f
 inc doind set ind flag
2 ldy curadr get address reg
 ldb enbtyp get basic type
 cmpb #10 is it array?
 bne 33f
 ldu op1ptr get op1
 jsr gettyp get its type
 ldy curadr get ar
 andb #$30 check for array
 cmpb #ARAY<<4
 beq 34f
33 inc ar_ind,y bump indirect count
34 ldb enbtyp check for structure
 cmpb #12
 bne 35f
 jsr cmplar reduce ar
 ldy curadr get ar
35 lda ar_ind,y get count
 beq ptrfin
 cmpa #1
 beq ptrfin
 ldb ar_ref,y get reference
 cmpb #XREF is it x ref?
 bne 4f
 cmpa #2 double indirection?
 beq ptrfin
4 ldy curadr get ar
 jsr ldx do load x
 ldy curadr get ar
* lda #1 set ind count
 inc ar_ind,y
 tst doind do it?
 bne 45f
 rts return
45 ldx codptr reset code pointer
 leax -EXPSIZ,x
 stx codptr
 bra 47f
ptrfin ldx codptr get code pointer
 stx ar_con,y set contents of ar reg
 sty rslt,x save result location
 leax EXPSIZ,x next entry
 stx codptr
 tst doind do ind now?
 bne 45b
 rts return
47 ldu #faknod set up fake node
 lda #NNODE set node type
 sta 0,u
 ldd #1 set exp count
 ldx #exptbl point to exp
5 cmpx codptr this guy?
 beq 6f
 leax EXPSIZ,x next entry
 incb bump count
 bra 5b
6 std 1,u set node number
 stu op1ptr set op1
 jmp lod do load op

* unm code generation

unm ldu op1ptr get operand
 jsr load do load
 ldb enbtyp get type
 ldy #unmtab point to routines
 jmp [b,y]

unmtab fdb chunm,intunm,lnunm,fpunm

chunm jsr onegb output 'negb'
 inc ccok
 jmp rsltb set result
intunm jsr onegd output 'negd'
 clr ccok
 jmp rsltd set result
lnunm swi
fpunm swi

* com code generation

com ldu op1ptr get operand
 jsr load do load
 ldb enbtyp get type
 ldy #comtab point to routines
 jmp [b,y]

comtab fdb chcom,intcom,lncom,fpcom

chcom jsr ocomb output 'comb'
 inc ccok
 jmp rsltb
intcom jsr ocomb output 'comb'
 jsr ocoma output 'coma'
 clr ccok
 jmp rsltd set restult
lncom swi
fpcom swi

* get operand type for cvt routines

gettyp ldb 0,u what is this entry?
 cmpb #NNODE
 bne 2f
 ldb 2,u get node number
 jsr fndnod find the node
 ldd rtype,y get type
 rts return
2 cmpb #NNAME is it name?
 bne 3f
 ldd 2,u get type
 rts return
3 ldb 1,u get constant type
 clra
 rts return

* test if end of expression

tstfol ldy codptr get code pointer
1 leay EXPSIZ,y get next entry
 cmpy expptr end of exp?
 beq 4f
 lda oprtr,y get operator
 bmi 2f branch type?
 cmpa #NOP is it nop?
 beq 1b
 bra 4f
2 cmpa #LBL is it label
 beq 1b
 sez set false
4 rts return

