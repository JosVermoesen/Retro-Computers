 text
* #include <stdio.h>
* #define   BUFSIZ 512
* #define   _NFILE   16
* struct _iobuf {
*        char *_ptr;     /* pointer into buffer */
*        int _cnt;       /* count of unused buffer */
*        char *_base;    /* buffer base address */
*        int _flag;      /* file status */
*        int _fd;        /* file descriptor */
*        char _save;     /* for 'ungetc' when unbuffered */
*        char _spare;
* } ;
* 
* typedef struct _iobuf FILE ;
* 
* extern FILE _iob[_NFILE];
* 
* #define _READ 1
* #define _WRITE 2
* #define _UNBUF 4
* #define _BIGBUF 010
* #define _EOF 020
* #define _ERR 040
* 
* #define EOF (-1)
* #define EOL 13
* #define NULL 0
* 
* #define stdin _iob
* #define stdout (&_iob[1])
* #define stderr (&_iob[2])
* 
* #define PMODE  0xb   /* r/w for owner, r for others */
* 
* #define fgetc      getc
* #define putchar(c) putc(c,stdout)
* #define getchar()  getc(stdin)
* #define ferror(p)  ((p)->_flag&_ERR)
* #define feof(p)    ((p)->_flag&_EOF)
* #define clearerr(p) ((p)->_flag&=~_ERR)
* #define fileno(p)   ((p)->_fd)
* 
* long ftell();
* 
* #include <sgtty.h>
* struct sgttyb { /* structure for 'stty' and 'gtty' */
*     char sg_flag,      /* mode flag - see below */
*          sg_delay,     /* delay type - see below */
*          sg_kill,      /* line cancel character - default cntrl X */
*          sg_erase,     /* backspace/rubout char.- default cntrl H */
*          sg_speed,     /* terminal speed - unused */
*          sg_spare;
* };
* 
* /* terminal modes */
* #define      RAW        01   /* raw - single char,no mapping,no echo etc. */
* #define      ECHO       02   /* input character echo */
* #define      XTABS      04   /* expand tabs on output */
* #define      LCASE      010  /* map upper-case to lower-case on input */
* #define      CRMOD      020  /* output cr-lf for cr */
* #define      SCOPE      040  /* echo backspace echo char */
* #define      CBREAK     0100 /* single char i/o */
* #define      CNTRL      0200 /* ignore control characters */
* 
* /* delay types */
* #define      DELNL      03   /* new line */
* #define      DELCR      014  /* carriage-return */
* #define      DELTB      020  /* tab */
* #define      DELVT      040  /* vertical tab */
* #define      DELFF      040  /* form-feed (as DELVT) */
* #include <ctype.h>
* extern  char    _chcodes[];      /* in chcodes.a */
* 
* #define _CONTROL       0x01
* #define _UPPER         0x02
* #define _LOWER         0x04
* #define _DIGIT         0x08
* #define _WHITE         0x10
* #define _PUNCT         0x20
* #define _HEXDIG        0x40
* 
* #define isascii(c)      ((unsigned)(c)<=0xff)
* #define isalpha(c)      (_chcodes[c]&(_UPPER|_LOWER))
* #define isupper(c)      (_chcodes[c]&_UPPER)
* #define islower(c)      (_chcodes[c]&_LOWER)
* #define isdigit(c)      (_chcodes[c]&_DIGIT)
* #define isxdigit(c)     (_chcodes[c]&_HEXDIG)
* #define isspace(c)      (_chcodes[c]&_WHITE)
* #define ispunct(c)      (_chcodes[c]&_PUNCT)
* #define isalnum(c)      (_chcodes[c]&(_UPPER|_LOWER|_DIGIT))
* #define isprint(c)      (_chcodes[c]&(_PUNCT|_UPPER|_LOWER|_DIGIT))
* #define iscntrl(c)      (_chcodes[c]&_CONTROL)
* #define toupper(c)      ((c)-('a'+'A'))
* #define tolower(c)      ((c)-('A'+'a'))
* #define toascii(c)      ((c)&0177)
* #include "boolean.h"
* typedef int BOOLEAN;
* #define TRUE 1
* #define FALSE 0
* #include "termcap.h"
* 
* /*  Terminal Capability Structure Definition */
* 
* #define STRSIZE 192 /* Size of string area */
* 
* struct ttycap {
*    char    c_rows;     /* Number of rows */
*    char    c_cols;     /* Number of columns */
*    char    c_inxy;     /* Invert x and y when positioning */
*    char    c_wait;     /* Screen settling time */
*    char    *c_home;    /* Home up */
*    char    *c_up;      /* Cursor up */
*    char    *c_down;    /* Cursor down */
*    char    *c_left;    /* Cursor left */
*    char    *c_right;   /* Cursor right */
*    char    *c_clear;   /* Clear screen */
*    char    *c_pos;     /* Position to x y */
*    char    *c_init;    /* Initialize terminal */
*    char    *c_blank;   /* Blank to end of current line */
*    char    *c_backg;   /* Set background mode */
*    char    *c_foreg;   /* Set foreground mode */
*    char    *c_darrow;  /* Down arrow key */
*    char    *c_uarrow;  /* Up arrow key */
*    char    *c_larrow;  /* Left arrow key */
*    char    *c_rarrow;  /* Right arrow key */
*    char    *c_hmkey;   /* Home key */
*    char    *c_fn0;     /* Function key 0 */
*    char    *c_fn1;     /* Function key 1 */
*    char    *c_fn2;     /* Function key 2 */
*    char    *c_fn3;     /* Function key 3 */
*    char    *c_fn4;     /* Function key 4 */
*    char    *c_fn5;     /* Function key 5 */
*    char    *c_fn6;     /* Function key 6 */
*    char    *c_fn7;     /* Function key 7 */
*    char    *c_fn8;     /* Function key 8 */
*    char    *c_fn9;     /* Function key 9 */
*    char    *unused[4]; /* Spares */
*    char    c_caps[STRSIZE];/* Capability strings */
* } ;
* 
* #define HOME_KEY -1
* #define UP_KEY -2
* #define DOWN_KEY -3
* #define LEFT_KEY -4
* #define RIGHT_KEY -5
* #define KEY(WHICH) (-10-WHICH)
* #define NO_DATA -100
* 
* #define NIL 0          /* Null pointer */
* #define DIRSIZE 16     /* Terminal Directory Size */
* #define NUMCAP 30      /* Number of capabilities */
* #define DATABYTES 4        /* Number of bytes before pointers */
* #define STDOUT 1       /* Standard output descriptor */
* #define STDIN 0        /* Standard input descriptor */
* #define DATA_READY 0x80    /* ttyget "data ready" bit */
* #define QUEUE_SIZE 10      /* Input queue size */
* 
* struct ttycap cap;  /* Terminal capabilities */
* int nrows;      /* Number of rows on screen */
* int ncols;      /* Number of columns on screen */
* int p_l_row;        /* Physical last row */
* int p_l_column;     /* Physical last column */
* int last_row;         /* Last row number (0 origin) */
* int last_column;      /* Last column number (0 origin) */
* int delay;      /* Screen settle time in seconds */
* int cu_size;        /* Size of cursor up string */
* int cd_size;        /* Size of cursor down string */
* int cl_size;        /* Size of cursor left string */
* int cr_size;        /* Size of cursor right string */
* int hm_size;        /* Size of home up string */
* int row;           /* Current row number (0 origin) */
* int column;            /* Current column number (0 origin) */
* static char ique[QUEUE_SIZE];  /* Input character queue */
 bss
ique rmb 10
 text
* static int  q_in;      /* queue "in" pointer */
 bss
q_in rmb 2
 text
* static int  q_out;     /* queue "out" pointer */
 bss
q_out rmb 2
 text
* BOOLEAN margin;        /* True if right margin hit */
* 
* blank_line()       /* Blank from current position */
* 
* {
 global blank_li
blank_li
 pshs y,u
 jmp 1f
2
*    int i;
* 
*    if (cap.c_blank != NULL) fputs(cap.c_blank,stdout);
 leas -2,s
 ldx #cap
 ldd 20,x
 lbeq _1
_2
 ldd #_iob
 addd #12
 pshs d
 ldx #cap
 ldd 20,x
 pshs d
 jsr fputs
 leas 4,s
*    else {
 jmp _3
_1
*        i = column;
 ldd column
 std ,s
*        while (column <= last_column && !margin) c_output(' ');
_5
 ldd column
 cmpd last_col
 lbgt _4
_7
 ldd margin
 lbne _4
_6
 ldd #32
 pshs d
 jsr c_output
 leas 2,s
*        if (row == p_l_row) command_line(i);
 jmp _5
_4
 ldd row
 cmpd p_l_row
 lbne _8
_9
 ldd ,s
 pshs d
 jsr command_
 leas 2,s
*        else move_to(i,row);
 jmp _10
_8
 ldd row
 pshs d
 ldd 2,s
 pshs d
 jsr move_to
 leas 4,s
*    }
_10
* }
_3
 leas 2,s
 puls y,u,pc

1 ldd #-140
 jsr _stkcheck
 jmp 2b


* 
* static int check_cursor(s,v)   /* Check for cursor string */
* char *s;   /* Cursor string */
* int v;     /* Value (< 0) to be returned if match
* {
check_cu
 pshs y,u
 jmp 1f
2
*    int value;
* 
*    if (s==NULL) return 0;
 leas -2,s
 ldd 8,s
 lbne _11
_12
 ldd #0
 leas 2,s
 puls y,u,pc

*    if ( (value=comp_str(s))==0 ) return 0;
_11
 ldd 8,s
 pshs d
 jsr comp_str
 leas 2,s
 std ,s
 lbne _13
_14
 ldd #0
 leas 2,s
 puls y,u,pc

*    if ( value < 0 ) return 1;
_13
 ldd ,s
 lbge _15
_16
 ldd #1
 leas 2,s
 puls y,u,pc

*    q_out = (q_out+value >= QUEUE_SIZE) ?
_15
*            q_out+value-QUEUE_SIZE: q_out+value;
 ldd q_out
 addd ,s
 cmpd #10
 lblt _17
_18
 ldd q_out
 addd ,s
 subd #10
 jmp _19
_17
 ldd q_out
 addd ,s
_19
 std q_out
*    return v;
 ldd 10,s
 leas 2,s
 puls y,u,pc

* }
1 ldd #-138
 jsr _stkcheck
 jmp 2b


* 
* clear_screen()     /* Clear screen */
* 
* {
 global clear_sc
clear_sc
 pshs y,u
 jmp 1f
2
*    fputs(cap.c_clear,stdout);
 ldd #_iob
 addd #12
 pshs d
 ldx #cap
 ldd 14,x
 pshs d
 jsr fputs
 leas 4,s
*    if (delay != 0) sleep(delay);
 ldd delay
 lbeq _20
_21
 ldd delay
 pshs d
 jsr sleep
 leas 2,s
*    row = column = 0;
_20
 ldd #0
 std column
 std row
*    margin = FALSE;
 ldd #0
 std margin
* }
 puls y,u,pc

1 ldd #-138
 jsr _stkcheck
 jmp 2b


* 
* command_line(n)    /* Move to column n in command line */
* int n;
* 
* {
 global command_
command_
 pshs y,u
 jmp 1f
2
*    int save_row;
* 
*    save_row = last_row;
 leas -2,s
 ldd last_row
 std ,s
*    last_row = p_l_row;
 ldd p_l_row
 std last_row
*    move_to(n,p_l_row);
 ldd p_l_row
 pshs d
 ldd 10,s
 pshs d
 jsr move_to
 leas 4,s
*    last_row = save_row;
 ldd ,s
 std last_row
* }
 leas 2,s
 puls y,u,pc

1 ldd #-140
 jsr _stkcheck
 jmp 2b


* 
* static int comp_str(s)     /* Compare queue to string */
* char *s;   /* Object string */
* 
* /* Returns:
* 
* {
comp_str
 pshs y,u
 jmp 1f
2
*    int i, j;   /* string pointers */
* 
*    if ( s==NULL || (j=q_out)==q_in ) return 0;
 leas -4,s
 ldd 10,s
 lbeq _23
_24
 ldd q_out
 std ,s
 cmpd q_in
 lbne _22
_23
 ldd #0
 leas 4,s
 puls y,u,pc

*    i = 0;
_22
 ldd #0
 std 2,s
*    while (*(s+i)==ique[j]) {
_26
 ldx 10,s
 ldd 2,s
 leax d,x
 ldb ,x
 sex
 pshs d
 ldd 2,s
 ldx #ique
 leax d,x
 ldb ,x
 sex
 cmpd ,s++
 lbne _25
_27
*        i++;
 ldd 2,s
 addd #1
 std 2,s
*        if (*(s+i) == NULL) return i;
 ldx 10,s
 ldd 2,s
 leax d,x
 ldb ,x
 lbne _28
_29
 ldd 2,s
 leas 4,s
 puls y,u,pc

*        j = (j<(QUEUE_SIZE-1))? j+1 : 0;
_28
 ldd ,s
 cmpd #9
 lbge _30
_31
 ldd ,s
 addd #1
 jmp _32
_30
 ldd #0
_32
 std ,s
*        if (j==q_in) return -1;
 ldd ,s
 cmpd q_in
 lbne _33
_34
 ldd #-1
 leas 4,s
 puls y,u,pc

*    }
_33
*    return 0;
 jmp _26
_25
 ldd #0
 leas 4,s
 puls y,u,pc

* }
1 ldd #-134
 jsr _stkcheck
 jmp 2b


* 
* cursor(v)  /* move cursor according to special value */
* int v;
* 
* {
 global cursor
cursor
 pshs y,u
 jmp 1f
2
*    switch (v) {
 ldd 6,s
 jmp _36
*    case HOME_KEY:
*        home_up();
_37
 jsr home_up
*        break;
 jmp _35
*    case UP_KEY:
*        move_up(1);
_38
 ldd #1
 pshs d
 jsr move_up
 leas 2,s
*        break;
 jmp _35
*    case DOWN_KEY:
*        move_down(1);
_39
 ldd #1
 pshs d
 jsr move_dow
 leas 2,s
*        break;
 jmp _35
*    case LEFT_KEY:
*        move_left(1);
_40
 ldd #1
 pshs d
 jsr move_lef
 leas 2,s
*        break;
 jmp _35
*    case RIGHT_KEY:
*        move_right(1);
_41
 ldd #1
 pshs d
 jsr move_rig
 leas 2,s
*        break;
 jmp _35
*    }
* }
_36
 cmpd #-1
 lbeq _37
 cmpd #-2
 lbeq _38
 cmpd #-3
 lbeq _39
 cmpd #-4
 lbeq _40
 cmpd #-5
 lbeq _41
_35
 puls y,u,pc

1 ldd #-136
 jsr _stkcheck
 jmp 2b


* 
* c_output(c)        /* Output character at current position */
* char c;
* 
* {
 global c_output
c_output
 pshs y,u
 jmp 1f
2
*    if (!margin) {
 ldd margin
 lbne _42
_43
*        putchar(c);
 ldd #_iob
 addd #12
 pshs d
 ldb 9,s
 sex
 pshs d
 jsr putc
 leas 4,s
*        if (column != last_column) column++;
 ldd column
 cmpd last_col
 lbeq _44
_45
 ldd column
 addd #1
 std column
*        else margin = TRUE;
 jmp _46
_44
 ldd #1
 std margin
*    }
_46
* }
_42
 puls y,u,pc

1 ldd #-138
 jsr _stkcheck
 jmp 2b


* 
* home_up()      /* Home cursor */
* 
* {
 global home_up
home_up
 pshs y,u
 jmp 1f
2
*    fputs(cap.c_home,stdout);
 ldd #_iob
 addd #12
 pshs d
 ldx #cap
 ldd 4,x
 pshs d
 jsr fputs
 leas 4,s
*    row = column = 0;
 ldd #0
 std column
 std row
*    margin = FALSE;
 ldd #0
 std margin
* }
 puls y,u,pc

1 ldd #-138
 jsr _stkcheck
 jmp 2b


* 
* int input(wait,echo)       /* Input character */
* BOOLEAN wait;      /* True if should wait for character */
* BOOLEAN echo;      /* True if should echo character */
* 
* /* Value is the integer cast of the character.
* 
* {
 global input
input
 pshs y,u
 jmp 1f
2
*    struct sgttyb ttbuf;
*    char ch;
*    int possible();         /* Check for cursor sequence */
*    int special;
* 
*    while (TRUE) {
 leas -9,s
_48
_49
*        special = (q_in!=q_out)? possible(): 0;
 ldd q_in
 cmpd q_out
 lbeq _50
_51
 jsr possible
 jmp _52
_50
 ldd #0
_52
 std ,s
*        if (special < 0) {
 ldd ,s
 lbge _53
_54
*            if (echo) cursor(special);
 ldd 17,s
 lbeq _55
_56
 ldd ,s
 pshs d
 jsr cursor
 leas 2,s
*            return special;
_55
 ldd ,s
 leas 9,s
 puls y,u,pc

*        }
*        if ( special==0 && q_in!=q_out ) {
_53
 ldd ,s
 lbne _57
_59
 ldd q_in
 cmpd q_out
 lbeq _57
_58
*            ch = ique[q_out++];
 ldd q_out
 addd #1
 std q_out
 subd #1
 ldx #ique
 leax d,x
 ldb ,x
 stb 2,s
*            if (q_out == QUEUE_SIZE) q_out=0;
 ldd q_out
 cmpd #10
 lbne _60
_61
 ldd #0
 std q_out
*            if (echo && isprint(ch)) {
_60
 ldd 17,s
 lbeq _62
_64
 ldb 2,s
 sex
 ldx #_chcodes
 leax d,x
 ldb ,x
 sex
 andb #46
 clra
 cmpd #0
 lbeq _62
_63
*                putchar(ch);
 ldd #_iob
 addd #12
 pshs d
 ldb 4,s
 sex
 pshs d
 jsr putc
 leas 4,s
*                if (column<last_column) column++;
 ldd column
 cmpd last_col
 lbge _65
_66
 ldd column
 addd #1
 std column
*            }
_65
*            return (int)ch;
_62
 ldb 2,s
 sex
 leas 9,s
 puls y,u,pc

*        } else if (!wait) {
 jmp _67
_57
 ldd 15,s
 lbne _68
_69
*            gtty(STDIN,&ttbuf);
 leax 3,s
 pshs x
 ldd #0
 pshs d
 jsr gtty
 leas 4,s
*            if ((ttbuf.sg_speed & DATA_READY) == 0)
 leax 3,s
 ldb 4,x
 sex
 andb #128
 clra
 cmpd #0
 lbne _70
*                return NO_DATA;
_71
 ldd #-100
 leas 9,s
 puls y,u,pc

*            else {
 jmp _72
_70
*                ique[q_in++] = getchar() & 0x7f;
 ldd q_in
 addd #1
 std q_in
 subd #1
 ldx #ique
 leax d,x
 pshs x
 ldd #_iob
 pshs d
 jsr getc
 leas 2,s
 andb #127
 clra
 stb [,s++]
*                if (q_in == QUEUE_SIZE) q_in = 0;
 ldd q_in
 cmpd #10
 lbne _73
_74
 ldd #0
 std q_in
*            }
_73
*        } else {
_72
 jmp _75
_68
*            ique[q_in++] = getchar() & 0x7f;
 ldd q_in
 addd #1
 std q_in
 subd #1
 ldx #ique
 leax d,x
 pshs x
 ldd #_iob
 pshs d
 jsr getc
 leas 2,s
 andb #127
 clra
 stb [,s++]
*            if (q_in == QUEUE_SIZE) q_in = 0;
 ldd q_in
 cmpd #10
 lbne _76
_77
 ldd #0
 std q_in
*        }
_76
*    }
_75
_67
* }
 jmp _48
_47
 leas 9,s
 puls y,u,pc

1 ldd #-147
 jsr _stkcheck
 jmp 2b


* 
* static int possible()      /* Return possible cursor sequence */
* 
* /* Response:
* 
* {
possible
 pshs y,u
 jmp 1f
2
*    int value;
* 
*    if((value=check_cursor(cap.c_hmkey,HOME_KEY))!=0 ||
 leas -2,s
*       (value=check_cursor(cap.c_uarrow,UP_KEY))!=0 ||
*       (value=check_cursor(cap.c_darrow,DOWN_KEY))!=0 ||
*       (value=check_cursor(cap.c_larrow,LEFT_KEY))!=0 ||
*       (value=check_cursor(cap.c_rarrow,RIGHT_KEY))!=0 ||
*       (value=check_cursor(cap.c_fn0,KEY(0)))!=0 ||
*       (value=check_cursor(cap.c_fn1,KEY(1)))!=0) return value;
 ldd #-1
 pshs d
 ldx #cap
 ldd 34,x
 pshs d
 jsr check_cu
 leas 4,s
 std ,s
 lbne _79
_85
 ldd #-2
 pshs d
 ldx #cap
 ldd 28,x
 pshs d
 jsr check_cu
 leas 4,s
 std ,s
 lbne _79
_84
 ldd #-3
 pshs d
 ldx #cap
 ldd 26,x
 pshs d
 jsr check_cu
 leas 4,s
 std ,s
 lbne _79
_83
 ldd #-4
 pshs d
 ldx #cap
 ldd 30,x
 pshs d
 jsr check_cu
 leas 4,s
 std ,s
 lbne _79
_82
 ldd #-5
 pshs d
 ldx #cap
 ldd 32,x
 pshs d
 jsr check_cu
 leas 4,s
 std ,s
 lbne _79
_81
 ldd #-10
 pshs d
 ldx #cap
 ldd 36,x
 pshs d
 jsr check_cu
 leas 4,s
 std ,s
 lbne _79
_80
 ldd #-11
 pshs d
 ldx #cap
 ldd 38,x
 pshs d
 jsr check_cu
 leas 4,s
 std ,s
 lbeq _78
_79
 ldd ,s
 leas 2,s
 puls y,u,pc

*    if((value=check_cursor(cap.c_fn2,KEY(2)))!=0 ||
_78
*       (value=check_cursor(cap.c_fn3,KEY(3)))!=0 ||
*       (value=check_cursor(cap.c_fn4,KEY(4)))!=0 ||
*       (value=check_cursor(cap.c_fn5,KEY(5)))!=0 ||
*       (value=check_cursor(cap.c_fn6,KEY(6)))!=0 ||
*       (value=check_cursor(cap.c_fn7,KEY(7)))!=0 ||
*       (value=check_cursor(cap.c_fn8,KEY(8)))!=0 ||
*       (value=check_cursor(cap.c_fn9,KEY(9)))!=0) return value;
 ldd #-12
 pshs d
 ldx #cap
 ldd 40,x
 pshs d
 jsr check_cu
 leas 4,s
 std ,s
 lbne _87
_94
 ldd #-13
 pshs d
 ldx #cap
 ldd 42,x
 pshs d
 jsr check_cu
 leas 4,s
 std ,s
 lbne _87
_93
 ldd #-14
 pshs d
 ldx #cap
 ldd 44,x
 pshs d
 jsr check_cu
 leas 4,s
 std ,s
 lbne _87
_92
 ldd #-15
 pshs d
 ldx #cap
 ldd 46,x
 pshs d
 jsr check_cu
 leas 4,s
 std ,s
 lbne _87
_91
 ldd #-16
 pshs d
 ldx #cap
 ldd 48,x
 pshs d
 jsr check_cu
 leas 4,s
 std ,s
 lbne _87
_90
 ldd #-17
 pshs d
 ldx #cap
 ldd 50,x
 pshs d
 jsr check_cu
 leas 4,s
 std ,s
 lbne _87
_89
 ldd #-18
 pshs d
 ldx #cap
 ldd 52,x
 pshs d
 jsr check_cu
 leas 4,s
 std ,s
 lbne _87
_88
 ldd #-19
 pshs d
 ldx #cap
 ldd 54,x
 pshs d
 jsr check_cu
 leas 4,s
 std ,s
 lbeq _86
_87
 ldd ,s
 leas 2,s
 puls y,u,pc

*    return 0;
_86
 ldd #0
 leas 2,s
 puls y,u,pc

* }
1 ldd #-140
 jsr _stkcheck
 jmp 2b


* 
* s_output(s)        /* Output string at current position */
* char *s;
* 
* {
 global s_output
s_output
 pshs y,u
 jmp 1f
2
*    for (; *s != NULL; s++) c_output(*s);
_97
 ldb [6,s]
 lbeq _96
_95
 ldb [6,s]
 sex
 pshs d
 jsr c_output
 leas 2,s
* }
_98
 ldd 6,s
 addd #1
 std 6,s
 jmp _97
_96
 puls y,u,pc

1 ldd #-136
 jsr _stkcheck
 jmp 2b


* 
* BOOLEAN termcap(cp)    /* Get terminal capabilities */
* struct ttycap *cp;
* 
* {
 global termcap
termcap
 pshs y,u
 jmp 1f
2
*    char    **cap_ptr;
*    int i;
*    long    j;
*    int fd;
*    int direct[DIRSIZE];
*    long    lseek();
*    int open(), read();
* 
*    if ( (fd=open("/etc/termcap",0)) == -1) return FALSE;
 leas -42,s
 data
_101 fcb 47,101,116,99,47,116,101,114,109,99,97,112,0
 text
 ldd #0
 pshs d
 ldd #_101
 pshs d
 jsr open
 leas 4,s
 std 32,s
 cmpd #-1
 lbne _99
_100
 ldd #0
 leas 42,s
 puls y,u,pc

*    if (
_99
*     (i=read(fd,(char *)direct,sizeof(int)*DIRSIZE)) == -1 ||
*     i != sizeof(int)*DIRSIZE ||
*     (i=direct[termnumb(0)]) == 0 ||
*     (j=lseek(fd, (long)i, 0)) == -1L ||
*     (i=read(fd,(char *)cp,sizeof(struct ttycap))) == -1 ||
*     i != sizeof(struct ttycap)
*    ) {
 ldd #32
 pshs d
 leax 2,s
 pshs x
 ldd 36,s
 pshs d
 jsr read
 leas 6,s
 std 38,s
 cmpd #-1
 lbeq _103
_108
 ldd 38,s
 cmpd #32
 lbne _103
_107
 ldd #0
 pshs d
 jsr termnumb
 leas 2,s
 aslb
 rola
 leax ,s
 leax d,x
 ldd ,x
 std 38,s
 cmpd #0
 lbeq _103
_106
 leax 34,s
 pshs x
 ldd #0
 pshs d
 ldd 42,s
 jsr _litol
 ldd 2,x
 pshs d
 ldd ,x
 pshs d
 ldd 40,s
 pshs d
 jsr lseek
 leas 8,s
 jsr _lmove
 ldd 2,x
 pshs d
 ldd ,x
 pshs d
 data
_109 fdb 0,1
 text
 ldx #_109
 jsr _lneg
 jsr _lcmpr
 lbeq _103
_105
 ldd #256
 pshs d
 ldd 50,s
 pshs d
 ldd 36,s
 pshs d
 jsr read
 leas 6,s
 std 38,s
 cmpd #-1
 lbeq _103
_104
 ldd 38,s
 cmpd #256
 lbeq _102
_103
*        close(fd);
 ldd 32,s
 pshs d
 jsr close
 leas 2,s
*        return FALSE;
 ldd #0
 leas 42,s
 puls y,u,pc

*    }
*    close(fd);
_102
 ldd 32,s
 pshs d
 jsr close
 leas 2,s
*    cap_ptr = (char **)( (char *)cp+DATABYTES );
 ldd 48,s
 addd #4
 std 40,s
*    for (i=NUMCAP; i--; cap_ptr++)
 ldd #30
 std 38,s
_112
 ldd 38,s
 addd #-1
 std 38,s
 subd #-1
 lbeq _111
*        if (*cap_ptr != NIL) *cap_ptr += (unsigned)cp;
_110
 ldd [40,s]
 lbeq _114
_115
 ldd [40,s]
 addd 48,s
 std [40,s]
*    return TRUE;
_114
_113
 ldd 40,s
 addd #2
 std 40,s
 jmp _112
_111
 ldd #1
 leas 42,s
 puls y,u,pc

* }
1 ldd #-186
 jsr _stkcheck
 jmp 2b


* 
* BOOLEAN terminit() /* Initialize terminal */
* 
* {
 global terminit
terminit
 pshs y,u
 jmp 1f
2
*    if ( ! termcap(&cap) ) return FALSE;
 ldd #cap
 pshs d
 jsr termcap
 leas 2,s
 cmpd #0
 lbne _116
_117
 ldd #0
 puls y,u,pc

*    nrows = (int)cap.c_rows;
_116
 ldb cap
 sex
 std nrows
*    ncols = (int)cap.c_cols;
 ldx #cap
 ldb 1,x
 sex
 std ncols
*    p_l_row = nrows-1;
 ldd nrows
 subd #1
 std p_l_row
*    last_row = nrows-2;
 ldd nrows
 subd #2
 std last_row
*    p_l_column = last_column = ncols-1;
 ldd ncols
 subd #1
 std last_col
 std p_l_colu
*    delay = (int)cap.c_wait;
 ldx #cap
 ldb 3,x
 sex
 std delay
*    cu_size = strlen(cap.c_up);
 ldx #cap
 ldd 6,x
 pshs d
 jsr strlen
 leas 2,s
 std cu_size
*    cd_size = strlen(cap.c_down);
 ldx #cap
 ldd 8,x
 pshs d
 jsr strlen
 leas 2,s
 std cd_size
*    cl_size = strlen(cap.c_left);
 ldx #cap
 ldd 10,x
 pshs d
 jsr strlen
 leas 2,s
 std cl_size
*    cr_size = strlen(cap.c_right);
 ldx #cap
 ldd 12,x
 pshs d
 jsr strlen
 leas 2,s
 std cr_size
*    hm_size = strlen(cap.c_home);
 ldx #cap
 ldd 4,x
 pshs d
 jsr strlen
 leas 2,s
 std hm_size
*    setbuf(stdout,0);
 ldd #0
 pshs d
 ldd #_iob
 addd #12
 pshs d
 jsr setbuf
 leas 4,s
*    set_raw(stdout->_fd);
 ldx #_iob
 ldd 20,x
 pshs d
 jsr set_raw
 leas 2,s
*    if (cap.c_init != NIL) fputs(cap.c_init,stdout);
 ldx #cap
 ldd 18,x
 lbeq _118
_119
 ldd #_iob
 addd #12
 pshs d
 ldx #cap
 ldd 18,x
 pshs d
 jsr fputs
 leas 4,s
*    clear_screen();
_118
 jsr clear_sc
*    return TRUE;
 ldd #1
 puls y,u,pc

* }
1 ldd #-138
 jsr _stkcheck
 jmp 2b


 bss
 name termcap_c
 define
margin rmb 2
column rmb 2
row rmb 2
hm_size rmb 2
cr_size rmb 2
cl_size rmb 2
cd_size rmb 2
cu_size rmb 2
delay rmb 2
last_col rmb 2
last_row rmb 2
p_l_colu rmb 2
p_l_row rmb 2
ncols rmb 2
nrows rmb 2
cap rmb 256
 enddef
