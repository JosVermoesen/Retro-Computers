 text
* #include "pass1.h"
* /*
* 
* #include "machine.h"
* /*
* 
* #define ONEWORD INT
* #define TWOWORDS LONG
* #define FSTARG 4
* #define FSTAUT -2
* #define NUMDREG 0
* #define NUMAREG 1
* #define SIZINT 2
* #define MAXCON LONG
* 
* /* if alignment - define
* 
* 
* #include "symbol.h"
* #include "machine.h"
* /*
* 
* #define ONEWORD INT
* #define TWOWORDS LONG
* #define FSTARG 4
* #define FSTAUT -2
* #define NUMDREG 0
* #define NUMAREG 1
* #define SIZINT 2
* #define MAXCON LONG
* 
* /* if alignment - define
* 
* 
* /* symbol table structure */
* 
* struct symtab {
*   short stype;
*   char sclass;
*   char sflags;
* #ifdef ALIGN
*   char sname[8];
* #endif
*   short sstore;
*   char sblklv;
*   char sitype;
*   int *ssubs;
*   short sstrct;
*   short spoint;
*   char sstrnum;
*   char smemnum;
* };
* 
* /* type defines */
* 
* #define VOID 0
* #define UNS 1
* #define CHR 2
* #define SHORT 4
* #define INT 6
* #define LONG 8
* #define UNSND (INT|UNS)
* #define FLOAT 10
* #define DUBLE 11
* #define STRUCT 12
* #define UNION 13
* #define ENUM 14
* #define CONST 15
* 
* /* class definitions */
* 
* #define AUTO 1
* #define STAT 2
* #define REG 3
* #define EXTN 4
* #define TYPDF 5
* #define STRTAG 8
* #define UNNTAG 9
* #define ENMTAG 10
* #define MOS 12
* #define MOU 13
* #define MOE 14
* 
* /* type specifiers */
* 
* #define PTR 1
* #define FNCT 2
* #define ARAY 3
* 
* /* flag definitions */
* 
* #define FLAB 1
* #define FSTATIC 2
* #define FUND 4
* #define FINIT 8
* #define FFIELD 16
* #define FPRM 32
* #define FALND 64
* #define FEXT 128
* 
* /* itype definitions */
* 
* #define SIDENT 1
* #define STAG 2
* #define SMEMBER 3
* #define SLABEL 4
* 
* #include "tbdef.h"
* /*******************************************************************/
* /*                                                                 */
* /*             Managed Table Structure Definitions.                */
* /*                                                                 */
* /*******************************************************************/
* 
* struct table {   /* Managed Table control block */
*    char *fwad;
*    char *lwad;
*    char *ptr1;
*    char *ptr2;
*    char *lwas;
*    unsigned  incr;
*    struct table *prev;
*    struct table *next;
* };
* 
* typedef struct table *TABLE;
* 
* #define SMC 1   /* ; */
* #define LCB 2   /* { */
* #define RCB 3   /* } */
* #define LSB 4   /* [ */
* #define RSB 5   /* ] */
* #define LPR 6   /* ( */
* #define RPR 7   /* ) */
* #define COL 8   /* : */
* #define SQU 9   /* ' */
* #define DQU 10  /* " */
* #define BKS 11  /* \ */
* #define QUM 12  /* ? */
* #define ARO 13  /* -> */
* #define KEY 14  /* keyword */
* #define VAR 15  /* variable */
* #define CON 16  /* constant */
* #define CHC 17  /* character constant */
* #define STC 18  /* string constant */
* #define BAD 127 /* no token */
* 
* /* adjustable quantity definitions */
* 
* #define MAXSTRNG 512
* #define NUMSTRNG  10
* #ifdef ALIGN
* #define DMLEN 128
* #define SWLEN 256
* #define FORNUM 32
* #define FORCON 20
* #define NUMCON 64
* #endif
* #define SSLEN 16
* #define MATLEN 127
* #define ASLEN 2*MATLEN
* 
* /* structure definitions */
* 
* /* token table structure */
* 
* struct toktab {
*   char ch;
*   char tok;
* };
* 
* /* string stack structure definition */
* 
* struct sstack {
*   short stlbl;
*   char *stptr;
* };
* 
* /* structure info stack structure */
* 
* struct infost {
*   short header;
*   char number;
* };
* 
* /* expression matrix structure definition */
* 
* struct express {
*   char moprtr;
*   short mttype;
*   struct symtab *mo1loc;
*   struct symtab *mo2loc;
* };
* 
* /* classified operand structure */
* 
* struct classo {
*   short otype;
*   union {
*     struct express *exp;
*     struct symtab *sym;
*   } oloc;
*   char onode;
*   char ocflag;
* };
* 
* #define STNEST 10
* 
* struct ilab {
*   char ityp;
*   int iofset;
*   int ilabn;
* };
* 
* /* misc defines */
* 
* #define EOF (-1)
* #define NULL 0
* 
* /* macro definitions */
* 
* #define getnch() (curchar ? curchar : (curchar = nxtchr()))
* 
* /* miscellaneous definitions */
* 
* #define FALSE 0
* #define TRUE 1
* 
* #define STEXT 0
* #define SDATA 1
* #define SBSS 2
* 
* #include "il.h"
* /*
* 
* #define CVC 5
* #define NOP 29
* #define FPP 30
* #define FMM 31
* #define BPP 32
* #define BMM 33
* #define NOT 34
* #define ADR 35
* #define IND 36
* #define UNM 37
* #define COM 38
* #define ADD 40
* #define SUB 41
* #define MUL 42
* #define DIV 43
* #define MOD 44
* #define SHR 45
* #define SHL 46
* #define AND 47
* #define BOR 48
* #define XOR 49
* #define LND 53
* #define LOR 54
* #define EQU 60
* #define NEQ 61
* #define LEQ 62
* #define LES 63
* #define GEQ 64
* #define GRT 65
* #define ADA 70
* #define SUA 71
* #define MUA 72
* #define DIA 73
* #define MOA 74
* #define SRA 75
* #define SLA 76
* #define ANA 77
* #define BOA 78
* #define XOA 79
* #define ASN 80
* #define OZF 87
* #define OZR 88
* #define OZT 89
* #define CXB 90
* #define CBR 91
* #define CEN 92
* #define ORB 93
* #define ORE 94
* #define ANB 95
* #define ANE 96
* #define ORC 97
* #define ANC 98
* #define DOT 99
* #define CAL 100
* #define PRM 101
* #define LOD 102
* #define SPL 103
* #define SPR 104
* #define CMA 105
* #define RET 106
* #define SWT 107
* #define ENC 108
* #define SIZ 109
* #define BEX 110
* #define BCL 111
* #define BXC 112
* #define SAV 113
* #define ENDITM 128
* #define BEGEXP 129
* #define ENDEXP 130
* #define NNAME 131
* #define NCON 132
* #define NNODE 133
* #define LABEL 134
* #define BRANCH 135
* #define CBRNCH 136
* #define BEGFNT 137
* #define ENDFNT 138
* #define SWIT 139
* #define STVAR 140
* #define AUTVAR 141
* #define REGVAR 142
* #define PROFIL 143
* #define TEXT 144
* #define DATA 145
* #define BSS 146
* #define SSPACE 147
* #define BYTES 148
* #define WORDS 149
* #define DNAME 150
* #define EXTERS 151
* #define FPV 152
* #define CMNT 153
* #define STRNG 154
* #define BEGBLK 155
* #define ENDBLK 156
* #define BEGMOD 157
* #define ENDMOD 158
* #define EVEN 159
* #define GLOBAL 160
* #define LABELS 161
* #define LONGS 162
* 
* #include "nxtchr.h"
* /*******************************************************************/
* /*                                                                 */
* /*        Values Returned by the Routine "nxtchr"                  */
* /*                                                                 */
* /*******************************************************************/
* 
* #define   FILE_END  -1   /* end-of-file response */
* #define   IDENT     -2   /* identifier found response */
* #define   KEYWORD   -3   /* keyword encountered */
* #define   END_IF    -4   /* end of "if" expression */
* 
* /* external definitions */
* 
* extern short curtok;
* extern char ident[];
* extern long convalu;
* extern short contyp;
* extern char lstflg;
* extern short hdrlab;
* extern char dclass;
* extern char deftyp;
* extern char nokey;
* extern char strnum, funnum;
* extern char swexp, rtexp;
* extern short dtype;
* extern short fpvars;
* extern short funtype;
* extern short addrreg, datareg;
* extern short argoff, retlab;
* extern short nxtaut, label;
* extern char blklev, fndcf, pmlsf;
* extern char strngbf[];
* extern struct infost *ptinfo, stinfo[];
* extern TABLE sym_table, lab_table;
* extern struct symtab *symloc, *funnam, *argptr;
* extern struct symtab *endprms, *typdfsym;
* extern int *nxtfrc, frctab[];
* extern struct express *nxtfor, fortab[];
* 
* domodule(name)
* char *name;
* {
 global domodule
domodule
 pshs y,u
 jmp 1f
2
*   nokey = fpvars = 0;
 clra
 clrb
 std fpvars
 stb nokey
*   outil("%c%0s%c", BEGMOD, name, TEXT);
 data
_1 fcb 37,99,37,48,115,37,99,0
 text
 ldd #144
 pshs d
 ldd 8,s
 pshs d
 ldd #157
 pshs d
 ldd #_1
 pshs d
 jsr outil
 leas 8,s
*   program();
 jsr program
*   if (fpvars)
*     outil("%c", FPV);
 ldd fpvars
 lbeq _3
_2
 data
_4 fcb 37,99,0
 text
 ldd #152
 pshs d
 ldd #_4
 pshs d
 jsr outil
 leas 4,s
*   outinfo();
_3
 jsr outinfo
*   flstr();
 jsr flstr
*   outil("%c", ENDMOD);
 data
_5 fcb 37,99,0
 text
 ldd #158
 pshs d
 ldd #_5
 pshs d
 jsr outil
 leas 4,s
* }
 puls y,u,pc

1 ldd #-142
 jsr _stkcheck
 jmp 2b


* 
* /* parse a program */
* 
* program()
* {
 global program
program
 pshs y,u
 jmp 1f
2
*   swexp = rtexp = 0;
 clra
 clrb
 stb rtexp
 stb swexp
*   while (getok() != FILE_END) {
_7
 jsr getok
 cmpd #-1
 lbeq _6
_8
*     if (!extdef())
*       curtok = 0;
 jsr extdef
 subd #0
 lbne _10
_9
 clra
 clrb
 std curtok
*   }
_10
* /*abort(sym_table->fwad);*/
* }
 jmp _7
_6
 puls y,u,pc

1 ldd #-134
 jsr _stkcheck
 jmp 2b


* 
* /* parse an external definition */
* 
* extdef() {
 global extdef
extdef
 pshs y,u
 jmp 1f
2
*   blklev = 0;
 clra
 clrb
 stb blklev
*   ptinfo = stinfo;
 ldx #stinfo
 stx ptinfo
*   dclass = dtype = deftyp = 0;
 clra
 clrb
 stb deftyp
 sex
 std dtype
 stb dclass
*   typdfsym = NULL;
 clra
 clrb
 std typdfsym
*   if (tstcls())
*     if (!(dclass==EXTN || dclass==STAT || dclass==TYPDF))
 jsr tstcls
 subd #0
 lbeq _12
_11
*       rpters(1);
 ldb dclass
 sex
 cmpd #4
 lbeq _14
_16
 ldb dclass
 sex
 cmpd #2
 lbeq _14
_15
 ldb dclass
 sex
 cmpd #5
 lbeq _14
_13
 ldd #1
 pshs d
 jsr rpters
 leas 2,s
*   if (tsttyp())
_14
_12
*     if (!type())
 jsr tsttyp
 subd #0
 lbeq _18
_17
*       return(FALSE);
 jsr type
 subd #0
 lbne _20
_19
 clra
 clrb
 puls y,u,pc

*   if (getok() != SMC) {
_20
_18
 jsr getok
 cmpd #1
 lbeq _22
_21
*     if (!dodec())
*       return(FALSE);
 jsr dodec
 subd #0
 lbne _24
_23
 clra
 clrb
 puls y,u,pc

*     if (getok() == ASN) {
_24
 jsr getok
 cmpd #80
 lbne _26
_25
*       if (dclass == EXTN)
*         return(rptern(68));
 ldb dclass
 sex
 cmpd #4
 lbne _28
_27
 ldd #68
 pshs d
 jsr rptern
 leas 2,s
 puls y,u,pc

*       if (!doinit())
_28
*         return(FALSE);
 jsr doinit
 subd #0
 lbne _30
_29
 clra
 clrb
 puls y,u,pc

*     }
_30
*     if (getok() != SMC) {
_26
 jsr getok
 cmpd #1
 lbeq _32
_31
*       if (curtok != CMA)
*         if (!fndcf)
 ldd curtok
 cmpd #105
 lbeq _34
_33
*           return(rptern(8));
 ldb fndcf
 lbne _36
_35
 ldd #8
 pshs d
 jsr rptern
 leas 2,s
 puls y,u,pc

*         else
*          return(funbod());
 jmp _37
_36
 jsr funbod
 puls y,u,pc

*       else {
_37
 jmp _38
_34
*         curtok = 0;
 clra
 clrb
 std curtok
*         if (pmlsf)
*           return(rptern(9));
 ldb pmlsf
 lbeq _40
_39
 ldd #9
 pshs d
 jsr rptern
 leas 2,s
 puls y,u,pc

*         if (!dctlst())
_40
*           return(FALSE);
 jsr dctlst
 subd #0
 lbne _42
_41
 clra
 clrb
 puls y,u,pc

*         if (getok() != SMC)
_42
*           return(rptern(10));
 jsr getok
 cmpd #1
 lbeq _44
_43
 ldd #10
 pshs d
 jsr rptern
 leas 2,s
 puls y,u,pc

*         curtok = 0;
_44
 clra
 clrb
 std curtok
*         return(TRUE);
 ldd #1
 puls y,u,pc

*       }
*     }
_38
*   }
_32
*   else {
 jmp _45
_22
*     if (dclass == TYPDF)
*       rptern(4);
 ldb dclass
 sex
 cmpd #5
 lbne _47
_46
 ldd #4
 pshs d
 jsr rptern
 leas 2,s
*   }
_47
*   curtok = 0;
_45
 clra
 clrb
 std curtok
*   if (pmlsf)
*     return(rptern(9));
 ldb pmlsf
 lbeq _49
_48
 ldd #9
 pshs d
 jsr rptern
 leas 2,s
 puls y,u,pc

*   else
*     return(TRUE);
 jmp _50
_49
 ldd #1
 puls y,u,pc

* }
_50
 puls y,u,pc

1 ldd #-136
 jsr _stkcheck
 jmp 2b


* 
* /* process function body */
* 
* funbod() {
 global funbod
funbod
 pshs y,u
 jmp 1f
2
*   short fsize;
* 
*   retlab = ++label;
 leas -2,s
 ldd label
 addd #1
 std label
 std retlab
*   hdrlab = ++label;
 ldd label
 addd #1
 std label
 std hdrlab
*   nxtaut = FSTAUT;
 ldd #-2
 std nxtaut
*   blklev = 1;
 ldd #1
 stb blklev
*   nxtfrc = frctab;
 ldx #frctab
 stx nxtfrc
*   nxtfor = fortab;
 ldx #fortab
 stx nxtfor
*   outtext();
 jsr outtext
*   if (dclass == TYPDF)
*     rptern(59);
 ldb dclass
 sex
 cmpd #5
 lbne _52
_51
 ldd #59
 pshs d
 jsr rptern
 leas 2,s
*   if (!(funnam->sflags & FSTATIC))
_52
*     outglob(funnam->sname);
 ldx funnam
 ldb 3,x
 sex
 clra
 andb #2
 lbne _54
_53
 ldd funnam
 addd #4
 pshs d
 jsr outglob
 leas 2,s
*   else
*     funnam->sclass = EXTN;
 jmp _55
_54
 ldd #4
 ldx funnam
 stb 2,x
*   funtype = remvlev(funnam->stype);
_55
 ldd [funnam]
 pshs d
 jsr remvlev
 leas 2,s
 std funtype
*   funnum = strnum;
 ldb strnum
 stb funnum
*   if (funtype==DUBLE || funtype==STRUCT || funtype==UNION)
*     fsize = patsize(funtype);
 ldd funtype
 cmpd #11
 lbeq _56
_59
 ldd funtype
 cmpd #12
 lbeq _56
_58
 ldd funtype
 cmpd #13
 lbne _57
_56
 ldd funtype
 pshs d
 jsr patsize
 leas 2,s
 std ,s
*   else
*     fsize = 0;
 jmp _60
_57
 clra
 clrb
 std ,s
*   outil("%c_%n%r", BEGFNT, funnam->sname, fsize);
_60
 data
_61 fcb 37,99,95,37,110,37,114,0
 text
 ldd ,s
 pshs d
 ldd funnam
 addd #4
 pshs d
 ldd #137
 pshs d
 ldd #_61
 pshs d
 jsr outil
 leas 8,s
*   outil("%c%r", BEGBLK, hdrlab);
 data
_62 fcb 37,99,37,114,0
 text
 ldd hdrlab
 pshs d
 ldd #155
 pshs d
 ldd #_62
 pshs d
 jsr outil
 leas 6,s
*   if (!argdec())
*     eatsc();
 jsr argdec
 subd #0
 lbne _64
_63
 jsr eatsc
*   outprms();
_64
 jsr outprms
*   if (!cmpstm()) {
 jsr cmpstm
 subd #0
 lbne _66
_65
*     lab_table->lwad = lab_table->fwad;
 ldd [lab_tabl]
 ldx lab_tabl
 std 2,x
*     exitblck(argoff);
 ldd argoff
 pshs d
 jsr exitblck
 leas 2,s
*     return(FALSE);
 clra
 clrb
 leas 2,s
 puls y,u,pc

*   }
*   if (getok() == SMC)
_66
*     curtok = 0;
 jsr getok
 cmpd #1
 lbne _68
_67
 clra
 clrb
 std curtok
*   outtext();
_68
 jsr outtext
*   outil("%c%r%r", ENDFNT, funtype, (addrreg<<8)|datareg);
 data
_69 fcb 37,99,37,114,37,114,0
 text
 ldd addrreg
 pshs d
 ldd #8
 jsr ccasl
 ora datareg
 orb datareg+1
 pshs d
 ldd funtype
 pshs d
 ldd #138
 pshs d
 ldd #_69
 pshs d
 jsr outil
 leas 8,s
*   chklbls();
 jsr chklbls
*   exitblck(argoff);
 ldd argoff
 pshs d
 jsr exitblck
 leas 2,s
*   return(TRUE);
 ldd #1
 leas 2,s
 puls y,u,pc

* }
1 ldd #-144
 jsr _stkcheck
 jmp 2b


* 
* /* output parameter definitions */
* 
* outprms() {
 global outprms
outprms
 pshs y,u
 jmp 1f
2
*   while (argptr != endprms) {
_71
 ldd argptr
 cmpd endprms
 lbeq _70
_72
*     symloc = argptr++;
 ldd argptr
 addd #24
 std argptr
 subd #24
 std symloc
*     if (symloc->sclass == AUTO)
*       outautdf();
 ldx symloc
 ldb 2,x
 sex
 cmpd #1
 lbne _74
_73
 jsr outautdf
*     else
*       if (symloc->sclass == REG) {
 jmp _75
_74
 ldx symloc
 ldb 2,x
 sex
 cmpd #3
 lbne _77
_76
*         gnldreg(symloc);
 ldd symloc
 pshs d
 jsr gnldreg
 leas 2,s
*         outregdf(symloc);
 ldd symloc
 pshs d
 jsr outregdf
 leas 2,s
*       }
*   }
_77
_75
* }
 jmp _71
_70
 puls y,u,pc

1 ldd #-136
 jsr _stkcheck
 jmp 2b


* 
* /* check for undefined line labels */
* 
* chklbls() {
 global chklbls
chklbls
 pshs y,u
 jmp 1f
2
*   register struct symtab *p;
* 
*   for (p=lab_table->fwad; p<lab_table->lwad; p++) {
 ldu [lab_tabl]
_80
 ldx lab_tabl
 cmpu 2,x
 lbhs _79
_78
*     if (!(p->sflags & FLAB)) {
 ldb 3,u
 sex
 clra
 andb #1
 lbne _83
_82
*       symloc = p;
 stu symloc
*       rpters(106);
 ldd #106
 pshs d
 jsr rpters
 leas 2,s
*     }
*   }
_83
*   lab_table->lwad = lab_table->fwad;
_81
 leau 24,u
 jmp _80
_79
 ldd [lab_tabl]
 ldx lab_tabl
 std 2,x
* }
 puls y,u,pc

1 ldd #-136
 jsr _stkcheck
 jmp 2b


* 
* /* output info data collected by preprocessor */
* 
* outinfo() {
 global outinfo
outinfo
 pshs y,u
 jmp 1f
2
*   char *get_info();
*   char *p;
* 
*   if (p = get_info())
 leas -2,s
*     outil("%c%0s", CMNT, p);
 jsr get_info
 std ,s
 lbeq _85
_84
 data
_86 fcb 37,99,37,48,115,0
 text
 ldd ,s
 pshs d
 ldd #153
 pshs d
 ldd #_86
 pshs d
 jsr outil
 leas 6,s
* }
_85
 leas 2,s
 puls y,u,pc

1 ldd #-142
 jsr _stkcheck
 jmp 2b


* 
 bss
 name p1_mod_c
